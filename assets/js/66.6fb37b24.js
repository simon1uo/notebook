(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{396:function(s,a,t){"use strict";t.r(a);var n=t(3),e=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("blockquote",[a("p",[s._v("在 JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数…… 这一切都会占用内存。当不需要某个东西， JavaScript 该如何发现并清理？")]),s._v(" "),a("ul",[a("li",[s._v("垃圾：没有任何对象需要（没有任何变量引用它们的对象数据）")])])]),s._v(" "),a("p",[s._v("了解 JavaScript 的垃圾回收机制之前先来了解可达性：")]),s._v(" "),a("h2",{attrs:{id:"可达性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可达性"}},[s._v("#")]),s._v(" 可达性")]),s._v(" "),a("p",[s._v("JavaScript 中主要的内存管理概念是 "),a("strong",[s._v("可达性")]),s._v("。「可达」意思是以某种方式可访问或可用的值，它们一定是存储在内存中的。")]),s._v(" "),a("blockquote",[a("ul",[a("li",[a("p",[s._v("固有的可达值基本集合（这些值显然不能被释放），这些值被称为"),a("strong",[s._v("根")]),s._v("（Root）。：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("当前执行的函数，它的局部变量和参数。")])]),s._v(" "),a("li",[a("p",[s._v("当前嵌套调用链上的其他函数、它们的局部变量和参数。")])]),s._v(" "),a("li",[a("p",[s._v("全局变量。")])]),s._v(" "),a("li",[a("p",[s._v("（还有一些内部的）")])])])]),s._v(" "),a("li",[a("p",[s._v("还有可以"),a("strong",[s._v("通过引用或引用链从根访问任何其他值")]),s._v("，也是可达的。")])])])]),s._v(" "),a("p",[s._v("在 JavaScript 引擎中有一个被称作 "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)",target:"_blank",rel:"noopener noreferrer"}},[s._v("垃圾回收器"),a("OutboundLink")],1),s._v(" 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。")]),s._v(" "),a("h2",{attrs:{id:"结合可达性与垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结合可达性与垃圾回收"}},[s._v("#")]),s._v(" 结合可达性与垃圾回收")]),s._v(" "),a("p",[s._v("🌰 例子：一个对象的引用")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// user 具有对这个对象的引用")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" user "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"John"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("全局变量  "),a("code",[s._v('"user"')]),s._v("  引用了对象  "),a("code",[s._v('{name："John"}')]),s._v(" 。John 的  "),a("code",[s._v('"name"')]),s._v("  属性存储一个原始值，所以它被写在对象内部。")]),s._v(" "),a("p",[s._v("当  "),a("code",[s._v("user = null")]),s._v(" ， "),a("code",[s._v("user")]),s._v("  的值被重写了，这个引用就没了。现在  "),a("code",[s._v("John")]),s._v("  变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。")]),s._v(" "),a("p",[s._v("🌰 例子： 两个对象的引用：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// user 具有对这个对象的引用")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" user "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"John"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" admin "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("再执行  "),a("code",[s._v("user = null")]),s._v("  。此时，对象仍然可以被通过  "),a("code",[s._v("admin")]),s._v("  这个全局变量访问到（ "),a("code",[s._v("admin")]),s._v("  仍然保留对 John 的引用），所以对象还在内存中。如果又重写了  "),a("code",[s._v("admin")]),s._v(" （ "),a("code",[s._v("admin = null")]),s._v(" ），对象才会被删除。")]),s._v(" "),a("p",[s._v("🌰 例子：相互关联的对象：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("marry")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("man"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" woman")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  woman"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("husband "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" man"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  man"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("wife "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" woman"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("father")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" man"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("mother")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" woman\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" family "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("marry")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"John"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Ann"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[a("code",[s._v("marry")]),s._v("  函数通过让两个对象相互引用使它们 “结婚” 了，并返回了一个包含这两个对象的新对象。如下图，所有对象都是「可达的」。")]),s._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/Gdo63V.png",alt:"image-20220504175728585"}}),s._v(" "),a("ul",[a("li",[a("p",[s._v("此时移除两个引用：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("delete")]),s._v(" family"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("father\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("delete")]),s._v(" family"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("mother"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("husband\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("可以看到「到达 John 的两条途径」显然都被移除了，所以此时 John 是不可达的。这是 John 将被从内存中移除，同时 John 的所有数据都将变得不可达。")])]),s._v(" "),a("li",[a("p",[s._v("「无法到达的岛屿」：如果此时重写  "),a("code",[s._v("family")]),s._v("  ，即")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("family "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("此时虽然内部几个对象相互引用，但外部没有对其任意对象的引用，"),a("strong",[s._v("这些对象也可能是「不可达」的")]),s._v("，并被从内存中删除。")])])]),s._v(" "),a("h2",{attrs:{id:"内部算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部算法"}},[s._v("#")]),s._v(" 内部算法")]),s._v(" "),a("p",[s._v("垃圾回收的基本算法被称为 「mark-and-sweep」。")]),s._v(" "),a("blockquote",[a("p",[s._v("定期执行以下「垃圾回收」步骤：")]),s._v(" "),a("ul",[a("li",[s._v("垃圾收集器找到所有的根，并「"),a("strong",[s._v("标记")]),s._v("」（记住）它们。")]),s._v(" "),a("li",[s._v("然后它遍历并「"),a("strong",[s._v("标记")]),s._v("」来自它们的所有引用。")]),s._v(" "),a("li",[s._v("然后它遍历标记的对象并标记 "),a("strong",[s._v("它们的")]),s._v(" 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。")]),s._v(" "),a("li",[s._v("…… 如此操作，直到所有可达的（从根部）引用都被访问到。")]),s._v(" "),a("li",[a("strong",[s._v("没有被标记的对象都会被删除")]),s._v("。")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);