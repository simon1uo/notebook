(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var o,s,i=e[0],l=e[1],c=e[2],u=0,p=[];u<i.length;u++)s=i[u],Object.prototype.hasOwnProperty.call(r,s)&&r[s]&&p.push(r[s][0]),r[s]=0;for(o in l)Object.prototype.hasOwnProperty.call(l,o)&&(n[o]=l[o]);for(d&&d(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],o=!0,i=1;i<t.length;i++){var l=t[i];0!==r[l]&&(o=!1)}o&&(a.splice(e--,1),n=s(s.s=t[0]))}return n}var o={},r={1:0},a=[];function s(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var o=new Promise((function(e,o){t=r[n]=[e,o]}));e.push(t[2]=o);var a,i=document.createElement("script");i.charset="utf-8",i.timeout=120,s.nc&&i.setAttribute("nonce",s.nc),i.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"f4898154",3:"c3838318",4:"2154b193",5:"3e12280c",6:"f9e2e59e",7:"2605c331",8:"f531fa54",9:"aa95344e",10:"f4956d94",11:"3af04ad8",12:"f79c9441",13:"fadf75b1",14:"cec8d8df",15:"7185794d",16:"112bf3f4",17:"312a89d9",18:"9167c962",19:"ba8086d2",20:"cf5e5e04",21:"5a1cb35a",22:"31489614",23:"e12c4282",24:"bb663886",25:"d8796088",26:"b99c22e0",27:"1ffbfb5f",28:"7d60dd38",29:"4b5294cf",30:"724723ec",31:"623965a8",32:"6df472c6",33:"ea40803b",34:"6a90c024",35:"861b1967",36:"88979d54",37:"a4c4b993",38:"0413403f",39:"655288ba",40:"7c24398a",41:"d1a772c3",42:"b023e055",43:"cdb9d72f",44:"96f8d1b2",45:"f9b1a4d5",46:"6109fe06",47:"d9aa2a49",48:"dc0d1bc8",49:"76ff7918",50:"2ffde3f9",51:"1cf84f64",52:"101bf1b4",53:"dee95f49",54:"fdc8538c",55:"63ea5564",56:"61b601f7",57:"83ff38a2",58:"58f322fb",59:"a3057f33",60:"29a455a8",61:"419d3f4f",62:"737221ad",63:"3cfc6321",64:"805396ad",65:"295f3ca7",66:"ea6a7b17",67:"1e45e13d",68:"e47c0e7b",69:"f1830d96",70:"4cb9324d",71:"d5db79fb",72:"1960795b",73:"34cc852c",74:"b724f370",75:"e181c33d",76:"351a1010",77:"21075f79",78:"c68bf338",79:"39f73d8a",80:"c6aebe88",81:"6ebb7b22",82:"e971358e",83:"65c85cb8",84:"9f05023d",85:"fe3d38ec",86:"0f958488",87:"386a6d3e",88:"455ba6c7",89:"16bf0c14",90:"0750114c",91:"9933d5d0",92:"db8b611a",93:"7183459e",94:"abbdcdff",95:"fa17638b",96:"9a699eb7",97:"14ca7778",98:"c2e461e1",99:"9385ccf4",100:"a588bdc3",101:"39714883",102:"a9f1754c",103:"c66ae759",104:"f7508aea",105:"c700f308",106:"d6d51702",107:"a6177324",108:"788c4c9c",109:"1507dbb4",110:"deafa6ef",111:"5f0ec393",112:"aeb33ef7",113:"e1fd1dd6",114:"4c9f2891",115:"cc73046c",116:"a89d65fa",117:"1a7050fe",118:"e5dbf35a",119:"80484f5a",120:"648bceb5",121:"121983dd",122:"58c13251",123:"dba2e543",124:"b511087d",125:"bfd96b8b",126:"18aa8df7",127:"70b5ca7e",128:"4b856bd4",129:"862f1c77",130:"798920e6",131:"886952d7",132:"a0c6c02a",133:"969cecf9",134:"e9be1a8e",135:"f9a9ff16",136:"c8002cca",137:"af6dee58",138:"b0b0c2d1",139:"2fb3ff44",140:"ed518b88",141:"40fca265",142:"569fc738",143:"896f2f3d",144:"3cf68cf0",145:"377ac706",146:"132c0ca7",147:"d457262f",148:"b9b78ddf",149:"05282ff0",150:"b32f91c4",151:"e3992c5f",152:"1bb5f227",153:"507ac576",154:"de9fec2b",155:"977bc2be",156:"29bc9326",157:"5df73ff7",158:"d7f5cf9a",159:"80602843",160:"b57b0cd5",161:"ce275f9f",162:"062c7930",163:"3badc844",164:"bd559c64",165:"8ab721be",166:"1eeef7ce",167:"03af183f",168:"7de51d82",169:"5bd13515",170:"7b54175d",171:"a4ba4a3b",172:"3cb7eec6",173:"54541147",174:"c57466be",175:"6d2ac1da",176:"3b26413c",177:"81898220",178:"e3f27b47",179:"c1f75379",180:"e8ec1450",181:"8ac7712d",182:"1c0b67e0",183:"4df6c062",184:"764ebf6c",185:"3f6d43bc",186:"f94989dd",187:"778d9f22",188:"2149eed9",189:"7a4dda0d",190:"f14ac633",191:"ab16a741",192:"71f025f1",193:"b762a554",194:"370283b2",195:"6bd42c7d",196:"90c85916",197:"6c1ef2fa",198:"e455849c",199:"cbf24014",200:"b0c9845f",201:"4e40cc30",202:"0a73f3e0",203:"9dde6f95",204:"e7bbc1eb",205:"8556e38d",206:"9fc0fee4",207:"646485bf",208:"15338cbb",209:"865e293f",210:"67e96cf1",211:"621dd3d4",212:"0410e0cb",213:"7ea165aa",214:"fbe96fa5",215:"eee95dc8",216:"4d832f1e",217:"8f5b69c0",218:"47c1102a",219:"370b70ec",220:"22cd81f3",221:"08f3a528",222:"76c8428d",223:"69ec49ee",224:"34da6f6a",225:"22595741",226:"38991266",227:"fffa5e67",228:"1c52649b",229:"15be4eb5",230:"48f574aa",231:"51fe9cec",232:"16c57fdc",233:"27a6576b",234:"22928851",235:"9d2fe95a",236:"9d57a174",237:"95975166",238:"1317d369",239:"c345dfee",240:"ee86a12e",241:"650b1d1a",242:"dcd65c40",243:"0b8a677e",244:"7e1c0d3a",245:"e7486ab0",246:"3e9a422a",247:"41ce505c",248:"bafd64aa",249:"0f52446f",250:"c98b3878",251:"ee184feb",252:"314d77ad",253:"42ad7be0",254:"f0b14c48",255:"cbe26b6e",256:"36622958",257:"85887912",258:"302c0036",259:"332082a1",260:"c34b61c0",261:"41e4dc90",262:"0e5fd70a",263:"801f79cf",264:"4ddb5306",265:"dd7cf1b4",266:"cf07fe0e",267:"de182ce1",268:"aa8024ed",269:"5cfede6c",270:"a1807f5e",271:"650cf426",272:"73d16685",273:"b19fb62e",274:"7932a065",275:"dba4f280",276:"58e7777c",277:"28748b67",278:"a808f032",279:"3eeffc26",280:"d49a0af8",281:"7c0f57d2",282:"217a628d",283:"cb15d832",284:"7fab1c92",285:"bc345be3",286:"f481b5ed",287:"377fbca2",288:"6894faa4",289:"681e00d1",290:"564cc5da",291:"52356308",292:"91cefa20"}[n]+".js"}(n);var l=new Error;a=function(e){i.onerror=i.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var o=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+o+": "+a+")",l.name="ChunkLoadError",l.type=o,l.request=a,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:i})}),12e4);i.onerror=i.onload=a,document.head.appendChild(i)}return Promise.all(e)},s.m=n,s.c=o,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)s.d(t,o,function(e){return n[e]}.bind(null,o));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/notebook/",s.oe=function(n){throw console.error(n),n};var i=window.webpackJsonp=window.webpackJsonp||[],l=i.push.bind(i);i.push=e,i=i.slice();for(var c=0;c<i.length;c++)e(i[c]);var d=l;a.push([102,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var o=t(28),r=Function.prototype,a=r.bind,s=r.call,i=o&&a.bind(s,s);n.exports=o?function(n){return n&&i(n)}:function(n){return n&&function(){return s.apply(n,arguments)}}},function(n,e,t){"use strict";function o(n,e,t,o,r,a,s,i){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),o&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):r&&(l=i?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return o}))},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var o=t(2),r=t(46),a=o({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(r(n),e)}},function(n,e,t){var o=t(68),r="object"==typeof self&&self&&self.Object===Object&&self,a=o||r||Function("return this")();n.exports=a},function(n,e,t){var o=t(4);n.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var o=t(0);n.exports=function(n){return"object"==typeof n?null!==n:o(n)}},function(n,e,t){var o=t(157),r=t(160);n.exports=function(n,e){var t=r(n,e);return o(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return o})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));const o=/#.*$/,r=/\.(md|html)$/,a=/\/$/,s=/^[a-z]+:/i;function i(n){return decodeURI(n).replace(o,"").replace(r,"")}function l(n){return s.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(o),t=e?e[0]:"",r=i(n);return a.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(o);if(e)return e[0]}(e);if(r&&t!==r)return!1;return i(n.path)===i(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const o=i(e);for(let e=0;e<n.length;e++)if(i(n[e].regularPath)===o)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,o){const{pages:r,themeConfig:a}=t,s=o&&a.locales&&a.locales[o]||a;if("auto"===(n.frontmatter.sidebar||s.sidebar||a.sidebar))return f(n);const i=s.sidebar||a.sidebar;if(i){const{base:t,config:o}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const o in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(o)))return{base:o,config:e[o]};var t;return{}}(e,i);return"auto"===o?f(n):o?o.map(n=>function n(e,t,o,r=1){if("string"==typeof e)return m(t,e,o);if(Array.isArray(e))return Object.assign(m(t,e[0],o),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,o),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,o,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var o=t(8),r=t(62),a=t(98),s=t(26),i=t(53),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=o?a?function(n,e,t){if(s(n),e=i(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var o=d(n,e);o&&o.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:o.configurable,enumerable:"enumerable"in t?t.enumerable:o.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=i(e),s(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var o=t(15),r=t(142),a=t(143),s=o?o.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?r(n):a(n)}},function(n,e,t){var o=t(7).Symbol;n.exports=o},function(n,e,t){var o=t(1),r=t(0),a=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(o[n]):o[n]&&o[n][e]}},function(n,e,t){var o=t(1),r=t(59),a=t(6),s=t(61),i=t(57),l=t(56),c=r("wks"),d=o.Symbol,u=d&&d.for,p=l?d:d&&d.withoutSetter||s;n.exports=function(n){if(!a(c,n)||!i&&"string"!=typeof c[n]){var e="Symbol."+n;i&&a(d,n)?c[n]=d[n]:c[n]=l&&u?u(e):p(e)}return c[n]}},function(n,e,t){var o=t(8),r=t(13),a=t(31);n.exports=o?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var o=t(147),r=t(148),a=t(149),s=t(150),i=t(151);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var o=t(70);n.exports=function(n,e){for(var t=n.length;t--;)if(o(n[t][0],e))return t;return-1}},function(n,e,t){var o=t(10)(Object,"create");n.exports=o},function(n,e,t){var o=t(169);n.exports=function(n,e){var t=n.__data__;return o(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var o=t(42);n.exports=function(n){if("string"==typeof n||o(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var o,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(o=function(){var n,e,t={version:"0.2.0"},o=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(o[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,o.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(o.barSelector),d=o.speed,u=o.easing;return l.offsetWidth,s((function(e){""===o.positionUsing&&(o.positionUsing=t.getPositioningCSS()),i(c,function(n,e,t){var r;return(r="translate3d"===o.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===o.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,r}(n,d,u)),1===n?(i(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){i(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),o.trickleSpeed)};return o.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*o.trickleRate)},n=0,e=0,t.promise=function(o){return o&&"resolved"!==o.state()?(0===e&&t.start(),n++,e++,o.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=o.template;var r,s=e.querySelector(o.barSelector),l=n?"-100":a(t.status||0),d=document.querySelector(o.parent);return i(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),o.showSpinner||(r=e.querySelector(o.spinnerSelector))&&p(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(o.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),i=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var o,r=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((o=n[r]+a)in t)return o;return e}(t))}function o(n,e,o){e=t(e),n.style[e]=o}return function(n,e){var t,r,a=arguments;if(2==a.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&o(n,t,r);else o(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),o=t+e;l(t,e)||(n.className=o.substring(1))}function d(n,e){var t,o=u(n);l(n,e)&&(t=o.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?o.call(e,t,e,n):o)||(n.exports=r)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment-plus","version":"1.1.0","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/SivanLaai/vuepress-plugin-comment-plus.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine","waline"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/SivanLaai/vuepress-plugin-comment-plus/issues"},"homepage":"https://github.com/SivanLaai/vuepress-plugin-comment-plus#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9","@waline/client":"^1.3.3"}}')},function(n,e,t){var o=t(9),r=String,a=TypeError;n.exports=function(n){if(o(n))return n;throw a(r(n)+" is not an object")}},function(n,e,t){var o=t(1),r=t(51).f,a=t(18),s=t(110),i=t(34),l=t(64),c=t(122);n.exports=function(n,e){var t,d,u,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?o:g?o[h]||i(h,{}):(o[h]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=r(t,d))&&m.value:t[d],!c(f?d:h+(g?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&a(p,"sham",!0),s(t,d,p,n)}}},function(n,e,t){var o=t(4);n.exports=!o((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var o=t(44),r=t(52);n.exports=function(n){return o(r(n))}},function(n,e,t){var o=t(28),r=Function.prototype.call;n.exports=o?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var o=t(2),r=o({}.toString),a=o("".slice);n.exports=function(n){return a(r(n),8,-1)}},function(n,e,t){var o=t(1),r=t(34),a=o["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=a},function(n,e,t){var o=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(o,n,{value:e,configurable:!0,writable:!0})}catch(t){o[n]=e}return e}},function(n,e,t){var o=t(141),r=t(12),a=Object.prototype,s=a.hasOwnProperty,i=a.propertyIsEnumerable,l=o(function(){return arguments}())?o:function(n){return r(n)&&s.call(n,"callee")&&!i.call(n,"callee")};n.exports=l},function(n,e,t){var o=t(10)(t(7),"Map");n.exports=o},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var o=t(161),r=t(168),a=t(170),s=t(171),i=t(172);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var o=t(5),r=t(42),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(o(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(s.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var o=t(14),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==o(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var o=t(2),r=t(4),a=t(32),s=Object,i=o("".split);n.exports=r((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?i(n,""):s(n)}:s},function(n,e,t){var o=t(0),r=t(108),a=TypeError;n.exports=function(n){if(o(n))return n;throw a(r(n)+" is not a function")}},function(n,e,t){var o=t(52),r=Object;n.exports=function(n){return r(o(n))}},function(n,e){n.exports={}},function(n,e,t){var o=t(120);n.exports=function(n){return o(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,o=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,a=/^0o[0-7]+$/i,s=parseInt,i="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=i||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var i=r.test(n);return i||a.test(n)?s(n.slice(2),i?2:8):o.test(n)?NaN:+n}n.exports=function(n,e,t){var o,r,a,s,i,l,c=0,d=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=o,a=r;return o=r=void 0,c=e,s=n.apply(a,t)}function y(n){return c=n,i=setTimeout(w,e),d?b(n):s}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function w(){var n=m();if(x(n))return E(n);i=setTimeout(w,function(n){var t=e-(n-l);return g?p(t,a-(n-c)):t}(n))}function E(n){return i=void 0,v&&o?b(n):(o=r=void 0,s)}function S(){var n=m(),t=x(n);if(o=arguments,r=this,l=n,t){if(void 0===i)return y(l);if(g)return i=setTimeout(w,e),b(l)}return void 0===i&&(i=setTimeout(w,e)),s}return e=f(e)||0,h(t)&&(d=!!t.leading,a=(g="maxWait"in t)?u(f(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),S.cancel=function(){void 0!==i&&clearTimeout(i),c=0,o=l=r=i=void 0},S.flush=function(){return void 0===i?s:E(m())},S}},function(n,e,t){var o=t(8),r=t(30),a=t(104),s=t(31),i=t(29),l=t(53),c=t(6),d=t(62),u=Object.getOwnPropertyDescriptor;e.f=o?u:function(n,e){if(n=i(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return s(!r(a.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var o=t(105),r=t(54);n.exports=function(n){var e=o(n,"string");return r(e)?e:e+""}},function(n,e,t){var o=t(16),r=t(0),a=t(55),s=t(56),i=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=o("Symbol");return r(e)&&a(e.prototype,i(n))}},function(n,e,t){var o=t(2);n.exports=o({}.isPrototypeOf)},function(n,e,t){var o=t(57);n.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var o=t(58),r=t(4);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},function(n,e,t){var o,r,a=t(1),s=t(106),i=a.process,l=a.Deno,c=i&&i.versions||l&&l.version,d=c&&c.v8;d&&(r=(o=d.split("."))[0]>0&&o[0]<4?1:+(o[0]+o[1])),!r&&s&&(!(o=s.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=s.match(/Chrome\/(\d+)/))&&(r=+o[1]),n.exports=r},function(n,e,t){var o=t(60),r=t(33);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.23.3",mode:o?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var o=t(2),r=0,a=Math.random(),s=o(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++r+a,36)}},function(n,e,t){var o=t(8),r=t(4),a=t(97);n.exports=!o&&!r((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var o=t(2),r=t(0),a=t(33),s=o(Function.toString);r(a.inspectSource)||(a.inspectSource=function(n){return s(n)}),n.exports=a.inspectSource},function(n,e,t){var o=t(6),r=t(115),a=t(51),s=t(13);n.exports=function(n,e,t){for(var i=r(e),l=s.f,c=a.f,d=0;d<i.length;d++){var u=i[d];o(n,u)||t&&o(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var o=t(119);n.exports=function(n){var e=+n;return e!=e||0===e?0:o(e)}},function(n,e,t){var o=t(2),r=t(26),a=t(129);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=o(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),a(o),e?n(t,o):t.__proto__=o,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,o=e.length,r=n.length;++t<o;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var o=t(19),r=t(152),a=t(153),s=t(154),i=t(155),l=t(156);function c(n){var e=this.__data__=new o(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=a,c.prototype.get=s,c.prototype.has=i,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var o=t(14),r=t(37);n.exports=function(n){if(!r(n))return!1;var e=o(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var o=t(173),r=t(12);n.exports=function n(e,t,a,s,i){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:o(e,t,a,s,n,i))}},function(n,e,t){var o=t(75),r=t(176),a=t(76);n.exports=function(n,e,t,s,i,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new o:void 0;for(l.set(n,e),l.set(e,n);++h<d;){var v=n[h],b=e[h];if(s)var y=c?s(b,v,h,e,n,l):s(v,b,h,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!a(g,e)&&(v===n||i(v,n,t,s,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!i(v,b,t,s,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var o=t(38),r=t(174),a=t(175);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new o;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=r,s.prototype.has=a,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var o=t(186),r=t(192),a=t(81);n.exports=function(n){return a(n)?o(n):r(n)}},function(n,e,t){(function(n){var o=t(7),r=t(188),a=e&&!e.nodeType&&e,s=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=s&&s.exports===a?o.Buffer:void 0,l=(i?i.isBuffer:void 0)||r;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var o=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==o||"symbol"!=o&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var o=t(189),r=t(190),a=t(191),s=a&&a.isTypedArray,i=s?r(s):o;n.exports=i},function(n,e,t){var o=t(71),r=t(40);n.exports=function(n){return null!=n&&r(n.length)&&!o(n)}},function(n,e,t){var o=t(10)(t(7),"Set");n.exports=o},function(n,e,t){var o=t(37);n.exports=function(n){return n==n&&!o(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var o=t(86),r=t(23);n.exports=function(n,e){for(var t=0,a=(e=o(e,n)).length;null!=n&&t<a;)n=n[r(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var o=t(5),r=t(41),a=t(203),s=t(206);n.exports=function(n,e){return o(n)?n:r(n,e)?[n]:a(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(139),r=t(144),a=t(215),s=t(223),i=t(232),l=t(101),c=a((function(n){var e=l(n);return i(e)&&(e=void 0),s(o(n,1,i,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var o=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=o.exec(t);if(!r)return t;var a="",s=0,i=0;for(s=r.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}i!==s&&(a+=t.substring(i,s)),i=s+1,a+=e}return i!==s?a+t.substring(i,s):a}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var o=t(241),r=t(242),a=t(243),s=!1,i=t(244).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),d=/^\uFEFF/;function u(n,t){var r,a,s=t.views,i=/^[A-Za-z]+:\\|^\//.exec(n);if(i&&i.length)r=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),o.existsSync(a)&&(r=a)),r||Array.isArray(s)&&s.some((function(t){return a=e.resolveInclude(n,t,!0),o.existsSync(a)}))&&(r=a),!r)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return r}function p(n,t){var o,r=n.filename,a=arguments.length>1;if(n.cache){if(!r)throw new Error("cache option requires a filename");if(o=e.cache.get(r))return o;a||(t=h(r).toString().replace(d,""))}else if(!a){if(!r)throw new Error("Internal EJS error: no file name or template provided");t=h(r).toString().replace(d,"")}return o=e.compile(t,n),n.cache&&e.cache.set(r,o),o}function m(n,t,o){var r;if(!o){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,o){try{e(r=p(n)(t))}catch(n){o(n)}}));throw new Error("Please provide a callback function")}try{r=p(n)(t)}catch(n){return o(n)}o(null,r)}function h(n){return e.fileLoader(n)}function f(n,e,t,o,r){var a=e.split("\n"),s=Math.max(o-3,0),i=Math.min(a.length,o+3),l=r(t),c=a.slice(s,i).map((function(n,e){var t=e+s+1;return(t==o?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+o+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var o={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],o.client=t.client||!1,o.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,o.compileDebug=!1!==t.compileDebug,o.debug=!!t.debug,o.filename=t.filename,o.openDelimiter=t.openDelimiter||e.openDelimiter||"<",o.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",o.delimiter=t.delimiter||e.delimiter||"%",o.strict=t.strict||!1,o.context=t.context,o.cache=t.cache||!1,o.rmWhitespace=t.rmWhitespace,o.root=t.root,o.outputFunctionName=t.outputFunctionName,o.localsName=t.localsName||e.localsName||"locals",o.views=t.views,o.async=t.async,o.destructuredLocals=t.destructuredLocals,o.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,o.strict?o._with=!1:o._with=void 0===t._with||t._with,this.opts=o,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=o.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var o=r.dirname,a=r.extname,s=(0,r.resolve)(t?e:o(e),n);return a(n)||(s+=".ejs"),s},e.compile=function(n,e){return e&&e.scope&&(s||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),s=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var o=e||{},r=t||{};return 2==arguments.length&&a.shallowCopyFromList(r,o,l),p(r,n)(o)},e.renderFile=function(){var n,e,t,o=Array.prototype.slice.call(arguments),r=o.shift(),s={filename:r};return"function"==typeof arguments[arguments.length-1]&&(n=o.pop()),o.length?(e=o.shift(),o.length?a.shallowCopy(s,o.pop()):(e.settings&&(e.settings.views&&(s.views=e.settings.views),e.settings["view cache"]&&(s.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(s,t)),a.shallowCopyFromList(s,e,c)),s.filename=r):e={},m(s,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),o=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,o),new RegExp(n)},compile:function(){var n,e,t,o=this.opts,s="",i="",l=o.escapeFunction;if(!this.source){if(this.generateSource(),s+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',o.outputFunctionName&&(s+="  var "+o.outputFunctionName+" = __append;\n"),o.destructuredLocals&&o.destructuredLocals.length){for(var c="  var __locals = ("+o.localsName+" || {}),\n",d=0;d<o.destructuredLocals.length;d++){var m=o.destructuredLocals[d];d>0&&(c+=",\n  "),c+=m+" = __locals."+m}s+=c+";\n"}!1!==o._with&&(s+="  with ("+o.localsName+" || {}) {\n",i+="  }\n"),i+="  return __output;\n",this.source=s+this.source+i}n=o.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(o.filename?JSON.stringify(o.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,o.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,o.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),o.strict&&(n='"use strict";\n'+n),o.debug&&console.log(n),o.compileDebug&&o.filename&&(n=n+"\n//# sourceURL="+o.filename+"\n");try{if(o.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(o.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(o.filename&&(n.message+=" in "+o.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",o.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=o.client?e:function(n){return e.apply(o.context,[n||{},l,function(e,t){var r=a.shallowCopy({},n);return t&&(r=a.shallowCopy(r,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,o)(r)},f])};if(h.dependencies=this.dependencies,o.filename&&"function"==typeof Object.defineProperty){var g=o.filename,v=r.basename(g,r.extname(g));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,o=this.parseTemplateText(),r=this.opts.delimiter,s=this.opts.openDelimiter,i=this.opts.closeDelimiter;o&&o.length&&o.forEach((function(l,c){var p,m,f,g,b,y;if(0===l.indexOf(s+r)&&0!==l.indexOf(s+r+r)&&(m=o[c+2])!=r+i&&m!="-"+r+i&&m!="_"+r+i)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(p=o[c-1])&&(p==s+r||p==s+r+"-"||p==s+r+"_"))return g=a.shallowCopy({},t.opts),b=function(n,e){var t,o,r=a.shallowCopy({},e);o=h(t=u(n,r)).toString().replace(d,""),r.filename=t;var s=new v(o,r);return s.generateSource(),{source:s.source,filename:t,template:o}}(f[1],g),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(f[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,o=t.exec(e),r=[];o;)0!==(n=o.index)&&(r.push(e.substring(0,n)),e=e.slice(n)),r.push(o[0]),e=e.slice(o[0].length),o=t.exec(e);return e&&r.push(e),r},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,o=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case o+t:case o+t+"_":this.mode=v.modes.EVAL;break;case o+t+"=":this.mode=v.modes.ESCAPED;break;case o+t+"-":this.mode=v.modes.RAW;break;case o+t+"#":this.mode=v.modes.COMMENT;break;case o+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(o+t+t,o+t)+'")\n';break;case t+t+r:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+r,t+r)+'")\n';break;case t+r:case"-"+t+r:case"_"+t+r:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=i,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var o={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(235),t(3)),a=Object(r.a)(o,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"a7f6ff22",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var o={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(236),t(3)),a=Object(r.a)(o,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,o){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":o===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(o)}}},[n._v("\n                        "+n._s(t.title)+"\n                    ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"cd29b590",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var o=t(1),r=t(9),a=o.document,s=r(a)&&r(a.createElement);n.exports=function(n){return s?a.createElement(n):{}}},function(n,e,t){var o=t(8),r=t(4);n.exports=o&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var o=t(59),r=t(61),a=o("keys");n.exports=function(n){return a[n]||(a[n]=r(n))}},function(n,e,t){var o=t(2),r=t(6),a=t(29),s=t(117).indexOf,i=t(47),l=o([].push);n.exports=function(n,e){var t,o=a(n),c=0,d=[];for(t in o)!r(i,t)&&r(o,t)&&l(d,t);for(;e.length>c;)r(o,t=e[c++])&&(~s(d,t)||l(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var o=t(27),r=t(123).left,a=t(124),s=t(58),i=t(125);o({target:"Array",proto:!0,forced:!a("reduce")||!i&&s>79&&s<83},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!o.call({1:2},1);e.f=a?function(n){var e=r(this,n);return!!e&&e.enumerable}:o},function(n,e,t){var o=t(30),r=t(9),a=t(54),s=t(107),i=t(109),l=t(17),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!r(n)||a(n))return n;var t,l=s(n,d);if(l){if(void 0===e&&(e="default"),t=o(l,n,e),!r(t)||a(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),i(n,e)}},function(n,e,t){var o=t(16);n.exports=o("navigator","userAgent")||""},function(n,e,t){var o=t(45);n.exports=function(n,e){var t=n[e];return null==t?void 0:o(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var o=t(30),r=t(0),a=t(9),s=TypeError;n.exports=function(n,e){var t,i;if("string"===e&&r(t=n.toString)&&!a(i=o(t,n)))return i;if(r(t=n.valueOf)&&!a(i=o(t,n)))return i;if("string"!==e&&r(t=n.toString)&&!a(i=o(t,n)))return i;throw s("Can't convert object to primitive value")}},function(n,e,t){var o=t(0),r=t(13),a=t(111),s=t(34);n.exports=function(n,e,t,i){i||(i={});var l=i.enumerable,c=void 0!==i.name?i.name:e;if(o(t)&&a(t,c,i),i.global)l?n[e]=t:s(e,t);else{try{i.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!i.nonConfigurable,writable:!i.nonWritable})}return n}},function(n,e,t){var o=t(4),r=t(0),a=t(6),s=t(8),i=t(112).CONFIGURABLE,l=t(63),c=t(113),d=c.enforce,u=c.get,p=Object.defineProperty,m=s&&!o((function(){return 8!==p((function(){}),"length",{value:8}).length})),h=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||i&&n.name!==e)&&(s?p(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&a(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?s&&p(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var o=d(n);return a(o,"source")||(o.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return r(this)&&u(this).source||l(this)}),"toString")},function(n,e,t){var o=t(8),r=t(6),a=Function.prototype,s=o&&Object.getOwnPropertyDescriptor,i=r(a,"name"),l=i&&"something"===function(){}.name,c=i&&(!o||o&&s(a,"name").configurable);n.exports={EXISTS:i,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var o,r,a,s=t(114),i=t(1),l=t(2),c=t(9),d=t(18),u=t(6),p=t(33),m=t(99),h=t(47),f=i.TypeError,g=i.WeakMap;if(s||p.state){var v=p.state||(p.state=new g),b=l(v.get),y=l(v.has),x=l(v.set);o=function(n,e){if(y(v,n))throw new f("Object already initialized");return e.facade=n,x(v,n,e),e},r=function(n){return b(v,n)||{}},a=function(n){return y(v,n)}}else{var w=m("state");h[w]=!0,o=function(n,e){if(u(n,w))throw new f("Object already initialized");return e.facade=n,d(n,w,e),e},r=function(n){return u(n,w)?n[w]:{}},a=function(n){return u(n,w)}}n.exports={set:o,get:r,has:a,enforce:function(n){return a(n)?r(n):o(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=r(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var o=t(1),r=t(0),a=t(63),s=o.WeakMap;n.exports=r(s)&&/native code/.test(a(s))},function(n,e,t){var o=t(16),r=t(2),a=t(116),s=t(121),i=t(26),l=r([].concat);n.exports=o("Reflect","ownKeys")||function(n){var e=a.f(i(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){var o=t(100),r=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return o(n,r)}},function(n,e,t){var o=t(29),r=t(118),a=t(48),s=function(n){return function(e,t,s){var i,l=o(e),c=a(l),d=r(s,c);if(n&&t!=t){for(;c>d;)if((i=l[d++])!=i)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){var o=t(65),r=Math.max,a=Math.min;n.exports=function(n,e){var t=o(n);return t<0?r(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,o=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?o:t)(e)}},function(n,e,t){var o=t(65),r=Math.min;n.exports=function(n){return n>0?r(o(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var o=t(4),r=t(0),a=/#|\.prototype\./,s=function(n,e){var t=l[i(n)];return t==d||t!=c&&(r(e)?o(e):!!e)},i=s.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=s.data={},c=s.NATIVE="N",d=s.POLYFILL="P";n.exports=s},function(n,e,t){var o=t(45),r=t(46),a=t(44),s=t(48),i=TypeError,l=function(n){return function(e,t,l,c){o(t);var d=r(e),u=a(d),p=s(d),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw i("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var o=t(4);n.exports=function(n,e){var t=[][n];return!!t&&o((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var o=t(32),r=t(1);n.exports="process"==o(r.process)},function(n,e,t){var o=t(27),r=t(1),a=t(127),s=t(128),i=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,l),o({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(i&&i[n]){var t={};t[n]=s("WebAssembly."+n,e,l),o({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var o=t(28),r=Function.prototype,a=r.apply,s=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(o?s.bind(a):function(){return s.apply(a,arguments)})},function(n,e,t){"use strict";var o=t(16),r=t(6),a=t(18),s=t(55),i=t(66),l=t(64),c=t(130),d=t(131),u=t(132),p=t(136),m=t(137),h=t(138),f=t(8),g=t(60);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),x=y[y.length-1],w=o.apply(null,y);if(w){var E=w.prototype;if(!g&&r(E,"cause")&&delete E.cause,!t)return w;var S=o("Error"),k=e((function(n,e){var t=u(v?e:n,void 0),o=v?new w(n):new w;return void 0!==t&&a(o,"message",t),h&&a(o,"stack",m(o.stack,2)),this&&s(E,this)&&d(o,this,k),arguments.length>b&&p(o,arguments[b]),o}));if(k.prototype=E,"Error"!==x?i?i(k,S):l(k,S,{name:!0}):f&&"stackTraceLimit"in w&&(c(k,w,"stackTraceLimit"),c(k,w,"prepareStackTrace")),l(k,w),!g)try{E.name!==x&&a(E,"name",x),E.constructor=k}catch(n){}return k}}},function(n,e,t){var o=t(0),r=String,a=TypeError;n.exports=function(n){if("object"==typeof n||o(n))return n;throw a("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var o=t(13).f;n.exports=function(n,e,t){t in n||o(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var o=t(0),r=t(9),a=t(66);n.exports=function(n,e,t){var s,i;return a&&o(s=e.constructor)&&s!==t&&r(i=s.prototype)&&i!==t.prototype&&a(n,i),n}},function(n,e,t){var o=t(133);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:o(n)}},function(n,e,t){var o=t(134),r=String;n.exports=function(n){if("Symbol"===o(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var o=t(135),r=t(0),a=t(32),s=t(17)("toStringTag"),i=Object,l="Arguments"==a(function(){return arguments}());n.exports=o?a:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=i(n),s))?t:l?a(e):"Object"==(o=a(e))&&r(e.callee)?"Arguments":o}},function(n,e,t){var o={};o[t(17)("toStringTag")]="z",n.exports="[object z]"===String(o)},function(n,e,t){var o=t(9),r=t(18);n.exports=function(n,e){o(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var o=t(2),r=Error,a=o("".replace),s=String(r("zxcasd").stack),i=/\n\s*at [^:]*:[^\n]*/,l=i.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=a(n,i,"");return n}},function(n,e,t){var o=t(4),r=t(31);n.exports=!o((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var o=t(67),r=t(140);n.exports=function n(e,t,a,s,i){var l=-1,c=e.length;for(a||(a=r),i||(i=[]);++l<c;){var d=e[l];t>0&&a(d)?t>1?n(d,t-1,a,s,i):o(i,d):s||(i[i.length]=d)}return i}},function(n,e,t){var o=t(15),r=t(35),a=t(5),s=o?o.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||r(n)||!!(s&&n&&n[s])}},function(n,e,t){var o=t(14),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==o(n)}},function(n,e,t){var o=t(15),r=Object.prototype,a=r.hasOwnProperty,s=r.toString,i=o?o.toStringTag:void 0;n.exports=function(n){var e=a.call(n,i),t=n[i];try{n[i]=void 0;var o=!0}catch(n){}var r=s.call(n);return o&&(e?n[i]=t:delete n[i]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var o=t(145),r=t(201),a=t(43),s=t(5),i=t(212);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?s(n)?r(n[0],n[1]):o(n):i(n)}},function(n,e,t){var o=t(146),r=t(200),a=t(84);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||o(t,n,e)}}},function(n,e,t){var o=t(69),r=t(73);n.exports=function(n,e,t,a){var s=t.length,i=s,l=!a;if(null==n)return!i;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<i;){var d=(c=t[s])[0],u=n[d],p=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new o;if(a)var h=a(u,p,d,n,e,m);if(!(void 0===h?r(p,u,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var o=t(20),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=o(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var o=t(20);n.exports=function(n){var e=this.__data__,t=o(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var o=t(20);n.exports=function(n){return o(this.__data__,n)>-1}},function(n,e,t){var o=t(20);n.exports=function(n,e){var t=this.__data__,r=o(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var o=t(19);n.exports=function(){this.__data__=new o,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var o=t(19),r=t(36),a=t(38);n.exports=function(n,e){var t=this.__data__;if(t instanceof o){var s=t.__data__;if(!r||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var o=t(71),r=t(158),a=t(37),s=t(72),i=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||r(n))&&(o(n)?p:i).test(s(n))}},function(n,e,t){var o,r=t(159),a=(o=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+o:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var o=t(7)["__core-js_shared__"];n.exports=o},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var o=t(162),r=t(19),a=t(36);n.exports=function(){this.size=0,this.__data__={hash:new o,map:new(a||r),string:new o}}},function(n,e,t){var o=t(163),r=t(164),a=t(165),s=t(166),i=t(167);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var o=t(21);n.exports=function(){this.__data__=o?o(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var o=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(o){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var o=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return o?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var o=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=o&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var o=t(22);n.exports=function(n){var e=o(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var o=t(22);n.exports=function(n){return o(this,n).get(n)}},function(n,e,t){var o=t(22);n.exports=function(n){return o(this,n).has(n)}},function(n,e,t){var o=t(22);n.exports=function(n,e){var t=o(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var o=t(69),r=t(74),a=t(177),s=t(180),i=t(196),l=t(5),c=t(78),d=t(80),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),v=l(e),b=g?"[object Array]":i(n),y=v?"[object Array]":i(e),x=(b="[object Arguments]"==b?u:b)==u,w=(y="[object Arguments]"==y?u:y)==u,E=b==y;if(E&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(E&&!x)return f||(f=new o),g||d(n)?r(n,e,t,m,h,f):a(n,e,b,t,m,h,f);if(!(1&t)){var S=x&&p.call(n,"__wrapped__"),k=w&&p.call(e,"__wrapped__");if(S||k){var j=S?n.value():n,T=k?e.value():e;return f||(f=new o),h(j,T,t,m,f)}}return!!E&&(f||(f=new o),s(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length;++t<o;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var o=t(15),r=t(178),a=t(70),s=t(74),i=t(179),l=t(39),c=o?o.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,o,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=i;case"[object Set]":var h=1&o;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;o|=2,p.set(n,e);var g=s(m(n),m(e),o,c,u,p);return p.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var o=t(7).Uint8Array;n.exports=o},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,o){t[++e]=[o,n]})),t}},function(n,e,t){var o=t(181),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,s,i){var l=1&t,c=o(n),d=c.length;if(d!=o(e).length&&!l)return!1;for(var u=d;u--;){var p=c[u];if(!(l?p in e:r.call(e,p)))return!1}var m=i.get(n),h=i.get(e);if(m&&h)return m==e&&h==n;var f=!0;i.set(n,e),i.set(e,n);for(var g=l;++u<d;){var v=n[p=c[u]],b=e[p];if(a)var y=l?a(b,v,p,e,n,i):a(v,b,p,n,e,i);if(!(void 0===y?v===b||s(v,b,t,a,i):y)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(f=!1)}return i.delete(n),i.delete(e),f}},function(n,e,t){var o=t(182),r=t(183),a=t(77);n.exports=function(n){return o(n,a,r)}},function(n,e,t){var o=t(67),r=t(5);n.exports=function(n,e,t){var a=e(n);return r(n)?a:o(a,t(n))}},function(n,e,t){var o=t(184),r=t(185),a=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,i=s?function(n){return null==n?[]:(n=Object(n),o(s(n),(function(e){return a.call(n,e)})))}:r;n.exports=i},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,r=0,a=[];++t<o;){var s=n[t];e(s,t,n)&&(a[r++]=s)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var o=t(187),r=t(35),a=t(5),s=t(78),i=t(79),l=t(80),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),d=!t&&r(n),u=!t&&!d&&s(n),p=!t&&!d&&!u&&l(n),m=t||d||u||p,h=m?o(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||i(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,o=Array(n);++t<n;)o[t]=e(t);return o}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var o=t(14),r=t(40),a=t(12),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&r(n.length)&&!!s[o(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var o=t(68),r=e&&!e.nodeType&&e,a=r&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===r&&o.process,i=function(){try{var n=a&&a.require&&a.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=i}).call(this,t(49)(n))},function(n,e,t){var o=t(193),r=t(194),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!o(n))return r(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var o=t(195)(Object.keys,Object);n.exports=o},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var o=t(197),r=t(36),a=t(198),s=t(82),i=t(199),l=t(14),c=t(72),d=c(o),u=c(r),p=c(a),m=c(s),h=c(i),f=l;(o&&"[object DataView]"!=f(new o(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||a&&"[object Promise]"!=f(a.resolve())||s&&"[object Set]"!=f(new s)||i&&"[object WeakMap]"!=f(new i))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,o=t?c(t):"";if(o)switch(o){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var o=t(10)(t(7),"DataView");n.exports=o},function(n,e,t){var o=t(10)(t(7),"Promise");n.exports=o},function(n,e,t){var o=t(10)(t(7),"WeakMap");n.exports=o},function(n,e,t){var o=t(83),r=t(77);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var a=e[t],s=n[a];e[t]=[a,s,o(s)]}return e}},function(n,e,t){var o=t(73),r=t(202),a=t(209),s=t(41),i=t(83),l=t(84),c=t(23);n.exports=function(n,e){return s(n)&&i(e)?l(c(n),e):function(t){var s=r(t,n);return void 0===s&&s===e?a(t,n):o(e,s,3)}}},function(n,e,t){var o=t(85);n.exports=function(n,e,t){var r=null==n?void 0:o(n,e);return void 0===r?t:r}},function(n,e,t){var o=t(204),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,s=o((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,o,r){e.push(o?r.replace(a,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var o=t(205);n.exports=function(n){var e=o(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var o=t(38);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var o=arguments,r=e?e.apply(this,o):o[0],a=t.cache;if(a.has(r))return a.get(r);var s=n.apply(this,o);return t.cache=a.set(r,s)||a,s};return t.cache=new(r.Cache||o),t}r.Cache=o,n.exports=r},function(n,e,t){var o=t(207);n.exports=function(n){return null==n?"":o(n)}},function(n,e,t){var o=t(15),r=t(208),a=t(5),s=t(42),i=o?o.prototype:void 0,l=i?i.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return r(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,r=Array(o);++t<o;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var o=t(210),r=t(211);n.exports=function(n,e){return null!=n&&r(n,e,o)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var o=t(86),r=t(35),a=t(5),s=t(79),i=t(40),l=t(23);n.exports=function(n,e,t){for(var c=-1,d=(e=o(e,n)).length,u=!1;++c<d;){var p=l(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&i(d)&&s(p,d)&&(a(n)||r(n))}},function(n,e,t){var o=t(213),r=t(214),a=t(41),s=t(23);n.exports=function(n){return a(n)?o(s(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var o=t(85);n.exports=function(n){return function(e){return o(e,n)}}},function(n,e,t){var o=t(43),r=t(216),a=t(218);n.exports=function(n,e){return a(r(n,e,o),n+"")}},function(n,e,t){var o=t(217),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var a=arguments,s=-1,i=r(a.length-e,0),l=Array(i);++s<i;)l[s]=a[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=a[s];return c[e]=t(l),o(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var o=t(219),r=t(222)(o);n.exports=r},function(n,e,t){var o=t(220),r=t(221),a=t(43),s=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:o(e),writable:!0})}:a;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var o=t(10),r=function(){try{var n=o(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,o=0;return function(){var r=t(),a=16-(r-o);if(o=r,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var o=t(75),r=t(224),a=t(229),s=t(76),i=t(230),l=t(39);n.exports=function(n,e,t){var c=-1,d=r,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=a;else if(u>=200){var f=e?null:i(n);if(f)return l(f);p=!1,d=s,h=new o}else h=e?[]:m;n:for(;++c<u;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(g)}else d(h,v,t)||(h!==m&&h.push(v),m.push(g))}return m}},function(n,e,t){var o=t(225);n.exports=function(n,e){return!!(null==n?0:n.length)&&o(n,e,0)>-1}},function(n,e,t){var o=t(226),r=t(227),a=t(228);n.exports=function(n,e,t){return e==e?a(n,e,t):o(n,r,t)}},function(n,e){n.exports=function(n,e,t,o){for(var r=n.length,a=t+(o?1:-1);o?a--:++a<r;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var o=t-1,r=n.length;++o<r;)if(n[o]===e)return o;return-1}},function(n,e){n.exports=function(n,e,t){for(var o=-1,r=null==n?0:n.length;++o<r;)if(t(e,n[o]))return!0;return!1}},function(n,e,t){var o=t(82),r=t(231),a=t(39),s=o&&1/a(new o([,-0]))[1]==1/0?function(n){return new o(n)}:r;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var o=t(81),r=t(12);n.exports=function(n){return r(n)&&o(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(87)},function(n,e,t){"use strict";t(88)},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(27),r=t(1),a=t(240);o({global:!0},{Reflect:{}}),a(r.Reflect,"Reflect",!0)},function(n,e,t){var o=t(13).f,r=t(6),a=t(17)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,a)&&o(n,a,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,o=n.length-1;o>=0;o--){var r=n[o];"."===r?n.splice(o,1):".."===r?(n.splice(o,1),t++):t&&(n.splice(o,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function o(n,e){if(n.filter)return n.filter(e);for(var t=[],o=0;o<n.length;o++)e(n[o],o,n)&&t.push(n[o]);return t}e.resolve=function(){for(var n="",e=!1,r=arguments.length-1;r>=-1&&!e;r--){var a=r>=0?arguments[r]:process.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(n=a+"/"+n,e="/"===a.charAt(0))}return(e?"/":"")+(n=t(o(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),s="/"===r(n,-1);return(n=t(o(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&s&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(o(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function o(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var r=o(n.split("/")),a=o(t.split("/")),s=Math.min(r.length,a.length),i=s,l=0;l<s;l++)if(r[l]!==a[l]){i=l;break}var c=[];for(l=i;l<r.length;l++)c.push("..");return(c=c.concat(a.slice(i))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,o=-1,r=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!r){o=a;break}}else r=!1;return-1===o?t?"/":".":t&&1===o?"/":n.slice(0,o)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,o=-1,r=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!r){t=e+1;break}}else-1===o&&(r=!1,o=e+1);return-1===o?"":n.slice(t,o)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,o=-1,r=!0,a=0,s=n.length-1;s>=0;--s){var i=n.charCodeAt(s);if(47!==i)-1===o&&(r=!1,o=s+1),46===i?-1===e?e=s:1!==a&&(a=1):-1!==e&&(a=-1);else if(!r){t=s+1;break}}return-1===e||-1===o||0===a||1===a&&e===o-1&&e===t+1?"":n.slice(e,o)};var r="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var o=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(o,"\\$&"):""};var r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function s(n){return r[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,s)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var o=0;o<t.length;o++){var r=t[o];void 0!==e[r]&&(n[r]=e[r])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.0
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var o=Object.freeze({}),r=Array.isArray;function a(n){return null==n}function s(n){return null!=n}function i(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),o=n.split(","),r=0;r<o.length;r++)t[o[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var w=Object.prototype.hasOwnProperty;function E(n,e){return w.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var k=/-(\w)/g,j=S((function(n){return n.replace(k,(function(n,e){return e?e.toUpperCase():""}))})),T=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),A=/\B([A-Z])/g,B=S((function(n){return n.replace(A,"-$1").toLowerCase()}));var F=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var o=arguments.length;return o?o>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function C(n,e){e=e||0;for(var t=n.length-e,o=new Array(t);t--;)o[t]=n[t+e];return o}function P(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function I(n,e,t){}var J=function(n,e,t){return!1},q=function(n){return n};function D(n,e){if(n===e)return!0;var t=d(n),o=d(e);if(!t||!o)return!t&&!o&&String(n)===String(e);try{var r=Array.isArray(n),a=Array.isArray(e);if(r&&a)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||a)return!1;var s=Object.keys(n),i=Object.keys(e);return s.length===i.length&&s.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function M(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function _(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function O(n,e){return n===e?0===n&&1/n!=1/e:n==n&&e==e}var L=["component","directive","filter"],H=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],R={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:J,isReservedAttr:J,isUnknownElement:J,getTagNamespace:I,parsePlatformTagName:q,mustUseProp:J,async:!0,_lifecycleHooks:H},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,o){Object.defineProperty(n,e,{value:t,enumerable:!!o,writable:!0,configurable:!0})}var N=new RegExp("[^".concat(U.source,".$_\\d]"));var W="__proto__"in{},G="undefined"!=typeof window,Z=G&&window.navigator.userAgent.toLowerCase(),X=Z&&/msie|trident/.test(Z),Y=Z&&Z.indexOf("msie 9.0")>0,K=Z&&Z.indexOf("edge/")>0;Z&&Z.indexOf("android");var Q=Z&&/iphone|ipad|ipod|ios/.test(Z);Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z);var nn,en=Z&&Z.match(/firefox\/(\d+)/),tn={}.watch,on=!1;if(G)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var an=function(){return void 0===nn&&(nn=!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=I,hn=0,fn=function(){function n(){this.id=hn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){x(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,o=e.length;t<o;t++){e[t].update()}},n}();fn.target=null;var gn=[];function vn(n){gn.push(n),fn.target=n}function bn(){gn.pop(),fn.target=gn[gn.length-1]}var yn=function(){function n(n,e,t,o,r,a,s,i){this.tag=n,this.data=e,this.children=t,this.text=o,this.elm=r,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=i,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),xn=function(n){void 0===n&&(n="");var e=new yn;return e.text=n,e.isComment=!0,e};function wn(n){return new yn(void 0,void 0,void 0,String(n))}function En(n){var e=new yn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var Sn=Array.prototype,kn=Object.create(Sn);function jn(n){return Tn(n,!0),V(n,"__v_isShallow",!0),n}function Tn(n,e){if(!An(n)){ht(n,e);0}}function An(n){return!(!n||!n.__v_isReadonly)}["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Sn[n];V(kn,n,(function(){for(var t=[],o=0;o<arguments.length;o++)t[o]=arguments[o];var r,a=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&s.observeArray(r),s.dep.notify(),a}))}));function Bn(n){return!(!n||!0!==n.__v_isRef)}var Fn=new cn;function Cn(n){return function n(e,t){var o,a,s=r(e);if(!s&&!d(e)||Object.isFrozen(e)||e instanceof yn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(s)for(o=e.length;o--;)n(e[o],t);else for(a=Object.keys(e),o=a.length;o--;)n(e[a[o]],t)}(n,Fn),Fn.clear(),n}var Pn=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),o="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=o?n.slice(1):n,once:t,capture:o,passive:e}}));function zn(n,e){function t(){var n=t.fns;if(!r(n))return Ze(n,null,arguments,e,"v-on handler");for(var o=n.slice(),a=0;a<o.length;a++)Ze(o[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function In(n,e,t,o,r,s){var l,c,d,u;for(l in n)c=n[l],d=e[l],u=Pn(l),a(c)||(a(d)?(a(c.fns)&&(c=n[l]=zn(c,s)),i(u.once)&&(c=n[l]=r(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)a(n[l])&&o((u=Pn(l)).name,e[l],u.capture)}function Jn(n,e,t){var o;n instanceof yn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),x(o.fns,l)}a(r)?o=zn([l]):s(r.fns)&&i(r.merged)?(o=r).fns.push(l):o=zn([r,l]),o.merged=!0,n[e]=o}function qn(n,e,t,o,r){if(s(e)){if(E(e,t))return n[t]=e[t],r||delete e[t],!0;if(E(e,o))return n[t]=e[o],r||delete e[o],!0}return!1}function Dn(n){return l(n)?[wn(n)]:r(n)?function n(e,t){var o,c,d,u,p=[];for(o=0;o<e.length;o++)a(c=e[o])||"boolean"==typeof c||(d=p.length-1,u=p[d],r(c)?c.length>0&&(Mn((c=n(c,"".concat(t||"","_").concat(o)))[0])&&Mn(u)&&(p[d]=wn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Mn(u)?p[d]=wn(u.text+c):""!==c&&p.push(wn(c)):Mn(c)&&Mn(u)?p[d]=wn(u.text+c.text):(i(e._isVList)&&s(c.tag)&&a(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(o,"__")),p.push(c)));return p}(n):void 0}function Mn(n){return s(n)&&s(n.text)&&!1===n.isComment}function _n(n,e){if(un){var t=un._provided,o=un.$parent&&un.$parent._provided;o===t&&(t=un._provided=Object.create(o)),t[n]=e}else 0}function On(n,e){if(n){for(var t=Object.create(null),o=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<o.length;r++){var a=o[r];if("__ob__"!==a){var s=n[a].from;if(s in e._provided)t[a]=e._provided[s];else if("default"in n[a]){var i=n[a].default;t[a]=c(i)?i.call(e):i}else 0}}return t}}function Ln(n,e){if(!n||!n.length)return{};for(var t={},o=0,r=n.length;o<r;o++){var a=n[o],s=a.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,a.context!==e&&a.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(a);else{var i=s.slot,l=t[i]||(t[i]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(Hn)&&delete t[c];return t}function Hn(n){return n.isComment&&!n.asyncFactory||" "===n.text}function Rn(n){return n.isComment&&n.asyncFactory}function Un(n,e,t,r){var a,s=Object.keys(t).length>0,i=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(i&&r&&r!==o&&l===r.$key&&!s&&!r.$hasNormal)return r;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=$n(n,t,c,e[c]))}else a={};for(var d in t)d in a||(a[d]=Vn(t,d));return e&&Object.isExtensible(e)&&(e._normalized=a),V(a,"$stable",i),V(a,"$key",l),V(a,"$hasNormal",s),a}function $n(n,e,t,o){var a=function(){var e=un;pn(n);var t=arguments.length?o.apply(null,arguments):o({}),a=(t=t&&"object"==typeof t&&!r(t)?[t]:Dn(t))&&t[0];return pn(e),t&&(!a||1===t.length&&a.isComment&&!Rn(a))?void 0:t};return o.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function Vn(n,e){return function(){return n[e]}}function Nn(n,e){var t,o,a,i,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,o=n.length;t<o;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,o=a.length;t<o;t++)i=a[t],l[t]=e(n[i],i,t);return s(l)||(l=[]),l._isVList=!0,l}function Wn(n,e,t,o){var r,a=this.$scopedSlots[n];a?(t=t||{},o&&(t=P(P({},o),t)),r=a(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},r):r}function Gn(n){return Tt(this.$options,"filters",n,!0)||q}function Zn(n,e){return r(n)?-1===n.indexOf(e):n!==e}function Xn(n,e,t,o,r){var a=R.keyCodes[e]||t;return r&&o&&!R.keyCodes[e]?Zn(r,o):a?Zn(a,n):o?B(o)!==e:void 0===n}function Yn(n,e,t,o,a){if(t)if(d(t)){r(t)&&(t=z(t));var s=void 0,i=function(r){if("class"===r||"style"===r||y(r))s=n;else{var i=n.attrs&&n.attrs.type;s=o||R.mustUseProp(e,i,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(r),c=B(r);l in s||c in s||(s[r]=t[r],a&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)i(l)}else;return n}function Kn(n,e){var t=this._staticTrees||(this._staticTrees=[]),o=t[n];return o&&!e||ne(o=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__".concat(n),!1),o}function Qn(n,e,t){return ne(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ne(n,e,t){if(r(n))for(var o=0;o<n.length;o++)n[o]&&"string"!=typeof n[o]&&ee(n[o],"".concat(e,"_").concat(o),t);else ee(n,e,t)}function ee(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function te(n,e){if(e)if(p(e)){var t=n.on=n.on?P({},n.on):{};for(var o in e){var r=t[o],a=e[o];t[o]=r?[].concat(r,a):a}}else;return n}function oe(n,e,t,o){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var s=n[a];r(s)?oe(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return o&&(e.$key=o),e}function re(n,e){for(var t=0;t<e.length;t+=2){var o=e[t];"string"==typeof o&&o&&(n[e[t]]=e[t+1])}return n}function ae(n,e){return"string"==typeof n?e+n:n}function se(n){n._o=Qn,n._n=v,n._s=g,n._l=Nn,n._t=Wn,n._q=D,n._i=M,n._m=Kn,n._f=Gn,n._k=Xn,n._b=Yn,n._v=wn,n._e=xn,n._u=oe,n._g=te,n._d=re,n._p=ae}function ie(n,e,t,a,s){var l,c=this,d=s.options;E(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var u=i(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||o,this.injections=On(d.inject,a),this.slots=function(){return c.$slots||Un(a,n.scopedSlots,c.$slots=Ln(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return Un(a,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=Un(a,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,o){var s=he(l,n,e,t,o,p);return s&&!r(s)&&(s.fnScopeId=d._scopeId,s.fnContext=a),s}:this._c=function(n,e,t,o){return he(l,n,e,t,o,p)}}function le(n,e,t,o,r){var a=En(n);return a.fnContext=t,a.fnOptions=o,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function ce(n,e){for(var t in e)n[j(t)]=e[t]}se(ie.prototype);var de={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;de.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},o=n.data.inlineTemplate;s(o)&&(t.render=o.render,t.staticRenderFns=o.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Be)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){0;var s=r.data.scopedSlots,i=n.$scopedSlots,l=!!(s&&!s.$stable||i!==o&&!i.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);n.$options._renderChildren=a;var u=r.data.attrs||o;n._attrsProxy&&ve(n._attrsProxy,u,d.data&&d.data.attrs||o,n)&&(c=!0);if(n.$attrs=u,n.$listeners=t||o,e&&n.$options.props){pt(!1);for(var p=n._props,m=n.$options._propKeys||[],h=0;h<m.length;h++){var f=m[h],g=n.$options.props;p[f]=At(f,g,e,n)}pt(!0),n.$options.propsData=e}t=t||o;var v=n.$options._parentListeners;n.$options._parentListeners=t,Ae(n,t,v),c&&(n.$slots=Ln(a,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,o=n.componentInstance;o._isMounted||(o._isMounted=!0,ze(o,"mounted")),n.data.keepAlive&&(t._isMounted?((e=o)._inactive=!1,Je.push(e)):Pe(o,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ce(e)))return;if(!e._inactive){e._inactive=!0;for(var o=0;o<e.$children.length;o++)n(e.$children[o]);ze(e,"deactivated")}}(e,!0):e.$destroy())}},ue=Object.keys(de);function pe(n,e,t,l,c){if(!a(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(i(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=we;t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(i(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var o=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(o,t)}));var u=function(n){for(var e=0,t=o.length;e<t;e++)o[e].$forceUpdate();n&&(o.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=_((function(t){n.resolved=Ee(t,e),r?o.length=0:u(!0)})),m=_((function(e){s(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(f(h)?a(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),s(h.error)&&(n.errorComp=Ee(h.error,e)),s(h.loading)&&(n.loadingComp=Ee(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),s(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,o,r){var a=xn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:o,tag:r},a}(p,e,t,l,c);e=e||{},Ht(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",o=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),i=a[o],l=e.model.callback;s(i)?(r(i)?-1===i.indexOf(l):i!==l)&&(a[o]=[l].concat(i)):a[o]=l}(n.options,e);var m=function(n,e,t){var o=e.options.props;if(!a(o)){var r={},i=n.attrs,l=n.props;if(s(i)||s(l))for(var c in o){var d=B(c);qn(r,l,c,d,!0)||qn(r,i,c,d,!1)}return r}}(e,n);if(i(n.options.functional))return function(n,e,t,a,i){var l=n.options,c={},d=l.props;if(s(d))for(var u in d)c[u]=At(u,d,e||o);else s(t.attrs)&&ce(c,t.attrs),s(t.props)&&ce(c,t.props);var p=new ie(t,c,i,a,n),m=l.render.call(null,p._c,p);if(m instanceof yn)return le(m,t,p.parent,l,p);if(r(m)){for(var h=Dn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=le(h[g],t,p.parent,l,p);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,i(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<ue.length;t++){var o=ue[t],r=e[o],a=de[o];r===a||r&&r._merged||(e[o]=r?me(a,r):a)}}(e);var v=n.options.name||c;return new yn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function me(n,e){var t=function(t,o){n(t,o),e(t,o)};return t._merged=!0,t}function he(n,e,t,o,u,p){return(r(t)||l(t))&&(u=o,o=t,t=void 0),i(p)&&(u=2),function(n,e,t,o,l){if(s(t)&&s(t.__ob__))return xn();s(t)&&s(t.is)&&(e=t.is);if(!e)return xn();0;r(o)&&c(o[0])&&((t=t||{}).scopedSlots={default:o[0]},o.length=0);2===l?o=Dn(o):1===l&&(o=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(o));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||R.getTagNamespace(e),u=R.isReservedTag(e)?new yn(R.parsePlatformTagName(e),t,o,void 0,void 0,n):t&&t.pre||!s(m=Tt(n.$options,"components",e))?new yn(e,t,o,void 0,void 0,n):pe(m,t,n,o,e)}else u=pe(e,t,n,o);return r(u)?u:s(u)?(s(p)&&function n(e,t,o){e.ns=t,"foreignObject"===e.tag&&(t=void 0,o=!0);if(s(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];s(c.tag)&&(a(c.ns)||i(o)&&"svg"!==c.tag)&&n(c,t,o)}}(u,p),s(t)&&function(n){d(n.style)&&Cn(n.style);d(n.class)&&Cn(n.class)}(t),u):xn()}(n,e,t,o,u)}function fe(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];return Bn(n)?n.value:n},set:function(n){var o=e[t];Bn(o)?o.value=n:e[t]=n}})}function ge(n){return{get attrs(){return function(n){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),ve(e,n.$attrs,o,n)}return n._attrsProxy}(n)},get slots(){return function(n){n._slotsProxy||ye(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:F(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return fe(n,e,t)}))}}}function ve(n,e,t,o){var r=!1;for(var a in e)a in n?e[a]!==t[a]&&(r=!0):(r=!0,be(n,a,o));for(var a in n)a in e||(r=!0,delete n[a]);return r}function be(n,e,t){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t.$attrs[e]}})}function ye(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var xe,we=null;function Ee(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Se(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||Rn(t)))return t}}function ke(n,e){xe.$on(n,e)}function je(n,e){xe.$off(n,e)}function Te(n,e){var t=xe;return function o(){var r=e.apply(null,arguments);null!==r&&t.$off(n,o)}}function Ae(n,e,t){xe=n,In(e,t||{},ke,je,Te,n),xe=void 0}var Be=null;function Fe(n){var e=Be;return Be=n,function(){Be=e}}function Ce(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Pe(n,e){if(e){if(n._directInactive=!1,Ce(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Pe(n.$children[t]);ze(n,"activated")}}function ze(n,e,t){vn();var o=un;pn(n);var r=n.$options[e],a="".concat(e," hook");if(r)for(var s=0,i=r.length;s<i;s++)Ze(r[s],n,t||null,n,a);n._hasHookEvent&&n.$emit("hook:"+e),pn(o),bn()}var Ie=[],Je=[],qe={},De=!1,Me=!1,_e=0;var Oe,Le=0,He=Date.now;if(G&&!X){var Re=window.performance;Re&&"function"==typeof Re.now&&He()>document.createEvent("Event").timeStamp&&(He=function(){return Re.now()})}function Ue(){var n,e;for(Le=He(),Me=!0,Ie.sort((function(n,e){return n.id-e.id})),_e=0;_e<Ie.length;_e++)(n=Ie[_e]).before&&n.before(),e=n.id,qe[e]=null,n.run();var t=Je.slice(),o=Ie.slice();_e=Ie.length=Je.length=0,qe={},De=Me=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Pe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],o=t.vm;o&&o._watcher===t&&o._isMounted&&!o._isDestroyed&&ze(o,"updated")}}(o),sn&&R.devtools&&sn.emit("flush")}function $e(n){var e=n.id;if(null==qe[e]&&(n!==fn.target||!n.noRecurse)){if(qe[e]=!0,Me){for(var t=Ie.length-1;t>_e&&Ie[t].id>n.id;)t--;Ie.splice(t+1,0,n)}else Ie.push(n);De||(De=!0,it(Ue))}}var Ve=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Oe&&(this.parent=Oe,this.index=(Oe.scopes||(Oe.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Oe;try{return Oe=this,n()}finally{Oe=e}}else 0},n.prototype.on=function(){Oe=this},n.prototype.off=function(){Oe=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.active=!1}},n}();var Ne=0,We=function(){function n(n,e,t,o,r){var a,s;a=this,void 0===(s=Oe||(n?n._scope:void 0))&&(s=Oe),s&&s.active&&s.effects.push(a),(this.vm=n)&&r&&(n._watcher=this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ne,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!N.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=I)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;vn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ge(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Cn(n),bn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():$e(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ze(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");function Ge(n,e,t){vn();try{if(e)for(var o=e;o=o.$parent;){var r=o.$options.errorCaptured;if(r)for(var a=0;a<r.length;a++)try{if(!1===r[a].call(o,n,e,t))return}catch(n){Xe(n,o,"errorCaptured hook")}}Xe(n,e,t)}finally{bn()}}function Ze(n,e,t,o,r){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return Ge(n,o,r+" (Promise/async)")})),a._handled=!0)}catch(n){Ge(n,o,r)}return a}function Xe(n,e,t){if(R.errorHandler)try{return R.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ye(e,null,"config.errorHandler")}Ye(n,e,t)}function Ye(n,e,t){if(!G||"undefined"==typeof console)throw n;console.error(n)}var Ke,Qe=!1,nt=[],et=!1;function tt(){et=!1;var n=nt.slice(0);nt.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ot=Promise.resolve();Ke=function(){ot.then(tt),Q&&setTimeout(I)},Qe=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ke="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(tt)}:function(){setTimeout(tt,0)};else{var rt=1,at=new MutationObserver(tt),st=document.createTextNode(String(rt));at.observe(st,{characterData:!0}),Ke=function(){rt=(rt+1)%2,st.data=String(rt)},Qe=!0}function it(n,e){var t;if(nt.push((function(){if(n)try{n.call(e)}catch(n){Ge(n,e,"nextTick")}else t&&t(e)})),et||(et=!0,Ke()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function lt(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var o=n.$options;o[e]=Et(o[e],t)}(t,n,e)}}lt("beforeMount"),lt("mounted"),lt("beforeUpdate"),lt("updated"),lt("beforeDestroy"),lt("destroyed"),lt("errorCaptured"),lt("activated"),lt("deactivated"),lt("serverPrefetch"),lt("renderTracked"),lt("renderTriggered");var ct=Object.getOwnPropertyNames(kn),dt={},ut=!0;function pt(n){ut=n}var mt=function(){function n(n,e){void 0===e&&(e=!1),this.value=n,this.shallow=e,this.dep=new fn,this.vmCount=0,V(n,"__ob__",this),r(n)?(W?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var o=0,r=t.length;o<r;o++){var a=t[o];V(n,a,e[a])}}(n,kn,ct),e||this.observeArray(n)):this.walk(n,e)}return n.prototype.walk=function(n,e){for(var t=Object.keys(n),o=0;o<t.length;o++){ft(n,t[o],dt,void 0,e)}},n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)ht(n[e])},n}();function ht(n,e){var t;if(!(!d(n)||Bn(n)||n instanceof yn))return E(n,"__ob__")&&n.__ob__ instanceof mt?t=n.__ob__:ut&&!an()&&(r(n)||p(n))&&Object.isExtensible(n)&&!n.__v_skip&&(t=new mt(n,e)),t}function ft(n,e,t,o,a){var s=new fn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var l=i&&i.get,c=i&&i.set;l&&!c||t!==dt&&2!==arguments.length||(t=n[e]);var d=!a&&ht(t);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return fn.target&&(s.depend(),d&&(d.dep.depend(),r(e)&&bt(e))),Bn(e)?e.value:e},set:function(e){var o=l?l.call(n):t;if(O(o,e)){if(c)c.call(n,e);else{if(l)return;if(Bn(o)&&!Bn(e))return void(o.value=e);t=e}d=!a&&ht(e),s.notify()}}}),s}}function gt(n,e,t){if(!An(n)){if(r(n)&&h(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var o=n.__ob__;return n._isVue||o&&o.vmCount?t:o?(ft(o.value,e,t),o.dep.notify(),t):(n[e]=t,t)}}function vt(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||An(n)||E(n,e)&&(delete n[e],t&&t.dep.notify())}}function bt(n){for(var e=void 0,t=0,o=n.length;t<o;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&bt(e)}var yt=R.optionMergeStrategies;function xt(n,e){if(!e)return n;for(var t,o,r,a=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<a.length;s++)"__ob__"!==(t=a[s])&&(o=n[t],r=e[t],E(n,t)?o!==r&&p(o)&&p(r)&&xt(o,r):gt(n,t,r));return n}function wt(n,e,t){return t?function(){var o=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return o?xt(o,r):r}:e?n?function(){return xt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Et(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function St(n,e,t,o){var r=Object.create(n||null);return e?P(r,e):r}yt.data=function(n,e,t){return t?wt(n,e,t):e&&"function"!=typeof e?n:wt(n,e)},H.forEach((function(n){yt[n]=Et})),L.forEach((function(n){yt[n+"s"]=St})),yt.watch=function(n,e,t,o){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var s in P(a,n),e){var i=a[s],l=e[s];i&&!r(i)&&(i=[i]),a[s]=i?i.concat(l):r(l)?l:[l]}return a},yt.props=yt.methods=yt.inject=yt.computed=function(n,e,t,o){if(!n)return e;var r=Object.create(null);return P(r,n),e&&P(r,e),r},yt.provide=wt;var kt=function(n,e){return void 0===e?n:e};function jt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var o,a,s={};if(r(t))for(o=t.length;o--;)"string"==typeof(a=t[o])&&(s[j(a)]={type:null});else if(p(t))for(var i in t)a=t[i],s[j(i)]=p(a)?a:{type:a};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var o=n.inject={};if(r(t))for(var a=0;a<t.length;a++)o[t[a]]={from:t[a]};else if(p(t))for(var s in t){var i=t[s];o[s]=p(i)?P({from:s},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var o=e[t];c(o)&&(e[t]={bind:o,update:o})}}(e),!e._base&&(e.extends&&(n=jt(n,e.extends,t)),e.mixins))for(var o=0,a=e.mixins.length;o<a;o++)n=jt(n,e.mixins[o],t);var s,i={};for(s in n)l(s);for(s in e)E(n,s)||l(s);function l(o){var r=yt[o]||kt;i[o]=r(n[o],e[o],t,o)}return i}function Tt(n,e,t,o){if("string"==typeof t){var r=n[e];if(E(r,t))return r[t];var a=j(t);if(E(r,a))return r[a];var s=T(a);return E(r,s)?r[s]:r[t]||r[a]||r[s]}}function At(n,e,t,o){var r=e[n],a=!E(t,n),s=t[n],i=Pt(Boolean,r.type);if(i>-1)if(a&&!E(r,"default"))s=!1;else if(""===s||s===B(n)){var l=Pt(String,r.type);(l<0||i<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!E(e,"default"))return;var o=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(o)&&"Function"!==Ft(e.type)?o.call(n):o}(o,r,n);var d=ut;pt(!0),ht(s),pt(d)}return s}var Bt=/^\s*function (\w+)/;function Ft(n){var e=n&&n.toString().match(Bt);return e?e[1]:""}function Ct(n,e){return Ft(n)===Ft(e)}function Pt(n,e){if(!r(e))return Ct(e,n)?0:-1;for(var t=0,o=e.length;t<o;t++)if(Ct(e[t],n))return t;return-1}var zt={enumerable:!0,configurable:!0,get:I,set:I};function It(n,e,t){zt.get=function(){return this[e][t]},zt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,zt)}function Jt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},o=n._props=jn({}),r=n.$options._propKeys=[];n.$parent&&pt(!1);var a=function(a){r.push(a);var s=At(a,e,t,n);ft(o,a,s),a in n||It(n,"_props",a)};for(var s in e)a(s);pt(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var o=n._setupContext=ge(n);pn(n),vn();var r=Ze(t,null,[n._props||jn({}),o],n,"setup");if(bn(),pn(),c(r))e.render=r;else if(d(r))if(n._setupState=r,r.__sfc){var a=n._setupProxy={};for(var s in r)fe(a,r,s)}else for(var s in r)$(s)||fe(n,r,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?I:F(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){vn();try{return n.call(e,e)}catch(n){return Ge(n,e,"data()"),{}}finally{bn()}}(e,n):e||{})||(e={});var t=Object.keys(e),o=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var a=t[r];0,o&&E(o,a)||$(a)||It(n,"_data",a)}var s=ht(e);s&&s.vmCount++}(n);else{var t=ht(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),o=an();for(var r in e){var a=e[r],s=c(a)?a:a.get;0,o||(t[r]=new We(n,s||I,I,qt)),r in n||Dt(n,r,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var o=e[t];if(r(o))for(var a=0;a<o.length;a++)Ot(n,t,o[a]);else Ot(n,t,o)}}(n,e.watch)}var qt={lazy:!0};function Dt(n,e,t){var o=!an();c(t)?(zt.get=o?Mt(e):_t(t),zt.set=I):(zt.get=t.get?o&&!1!==t.cache?Mt(e):_t(t.get):I,zt.set=t.set||I),Object.defineProperty(n,e,zt)}function Mt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),fn.target&&e.depend(),e.value}}function _t(n){return function(){return n.call(this,this)}}function Ot(n,e,t,o){return p(t)&&(o=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,o)}var Lt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var o=function(n){var e,t=n.options,o=n.sealedOptions;for(var r in t)t[r]!==o[r]&&(e||(e={}),e[r]=t[r]);return e}(n);o&&P(n.extendOptions,o),(e=n.options=jt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Rt(n){this._init(n)}function Ut(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,o=t.cid,r=n._Ctor||(n._Ctor={});if(r[o])return r[o];var a=n.name||t.options.name;var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=jt(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)It(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)Dt(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,L.forEach((function(n){s[n]=t[n]})),a&&(s.options.components[a]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=P({},s.options),r[o]=s,s}}function $t(n){return n&&(n.Ctor.options.name||n.tag)}function Vt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Nt(n,e){var t=n.cache,o=n.keys,r=n._vnode;for(var a in t){var s=t[a];if(s){var i=s.name;i&&!e(i)&&Wt(t,a,o,r)}}}function Wt(n,e,t,o){var r=n[e];!r||o&&r.tag===o.tag||r.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Lt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Ve(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),o=e._parentVnode;t.parent=e.parent,t._parentVnode=o;var r=o.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=jt(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ae(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=Ln(e._renderChildren,r),n.$scopedSlots=o,n._c=function(e,t,o,r){return he(n,e,t,o,r,!1)},n.$createElement=function(e,t,o,r){return he(n,e,t,o,r,!0)};var a=t&&t.data;ft(n,"$attrs",a&&a.attrs||o,null,!0),ft(n,"$listeners",e._parentListeners||o,null,!0)}(e),ze(e,"beforeCreate"),function(n){var e=On(n.$options.inject,n);e&&(pt(!1),Object.keys(e).forEach((function(t){ft(n,t,e[t])})),pt(!0))}(e),Jt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;var o=dn?Reflect.ownKeys(t):Object.keys(t);pn(n);for(var r=0;r<o.length;r++)_n(o[r],t[o[r]]);pn()}}(e),ze(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Rt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=gt,n.prototype.$delete=vt,n.prototype.$watch=function(n,e,t){if(p(e))return Ot(this,n,e,t);(t=t||{}).user=!0;var o=new We(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(o.expression,'"');vn(),Ze(e,this,[o.value],this,r),bn()}return function(){o.teardown()}}}(Rt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var o=this;if(r(n))for(var a=0,s=n.length;a<s;a++)o.$on(n[a],t);else(o._events[n]||(o._events[n]=[])).push(t),e.test(n)&&(o._hasHookEvent=!0);return o},n.prototype.$once=function(n,e){var t=this;function o(){t.$off(n,o),e.apply(t,arguments)}return o.fn=e,t.$on(n,o),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var o=0,a=n.length;o<a;o++)t.$off(n[o],e);return t}var s,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var l=i.length;l--;)if((s=i[l])===e||s.fn===e){i.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?C(t):t;for(var o=C(arguments,1),r='event handler for "'.concat(n,'"'),a=0,s=t.length;a<s;a++)Ze(t[a],e,o,e,r)}return e}}(Rt),function(n){n.prototype._update=function(n,e){var t=this,o=t.$el,r=t._vnode,a=Fe(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),a(),o&&(o.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){ze(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),ze(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Rt),function(n){se(n.prototype),n.prototype.$nextTick=function(n){return it(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,o=t.render,a=t._parentVnode;a&&(e.$scopedSlots=Un(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&ye(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{pn(e),we=e,n=o.call(e._renderProxy,e.$createElement)}catch(t){Ge(t,e,"render"),n=e._vnode}finally{we=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof yn||(n=xn()),n.parent=a,n}}(Rt);var Gt=[String,RegExp,Array],Zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Gt,exclude:Gt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,o=this.keyToCache;if(t){var r=t.tag,a=t.componentInstance,s=t.componentOptions;n[o]={name:$t(s),tag:r,componentInstance:a},e.push(o),this.max&&e.length>parseInt(this.max)&&Wt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Wt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Nt(n,(function(n){return Vt(e,n)}))})),this.$watch("exclude",(function(e){Nt(n,(function(n){return!Vt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var o=$t(t),r=this.include,a=this.exclude;if(r&&(!o||!Vt(r,o))||a&&o&&Vt(a,o))return e;var s=this.cache,i=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,x(i,l),i.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return R}};Object.defineProperty(n,"config",e),n.util={warn:mn,extend:P,mergeOptions:jt,defineReactive:ft},n.set=gt,n.delete=vt,n.nextTick=it,n.observable=function(n){return ht(n),n},n.options=Object.create(null),L.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=C(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=jt(this.options,n),this}}(n),Ut(n),function(n){L.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Rt),Object.defineProperty(Rt.prototype,"$isServer",{get:an}),Object.defineProperty(Rt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Rt,"FunctionalRenderContext",{value:ie}),Rt.version="2.7.0";var Xt=b("style,class"),Yt=b("input,textarea,option,select,progress"),Kt=b("contenteditable,draggable,spellcheck"),Qt=b("events,caret,typing,plaintext-only"),no=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),eo="http://www.w3.org/1999/xlink",to=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},oo=function(n){return to(n)?n.slice(6,n.length):""},ro=function(n){return null==n||!1===n};function ao(n){for(var e=n.data,t=n,o=n;s(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=so(o.data,e));for(;s(t=t.parent);)t&&t.data&&(e=so(e,t.data));return function(n,e){if(s(n)||s(e))return io(n,lo(e));return""}(e.staticClass,e.class)}function so(n,e){return{staticClass:io(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function io(n,e){return n?e?n+" "+e:n:e||""}function lo(n){return Array.isArray(n)?function(n){for(var e,t="",o=0,r=n.length;o<r;o++)s(e=lo(n[o]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var co={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},uo=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),po=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),mo=function(n){return uo(n)||po(n)};var ho=Object.create(null);var fo=b("text,number,password,search,email,tel,url");var go=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(co[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),vo={create:function(n,e){bo(e)},update:function(n,e){n.data.ref!==e.data.ref&&(bo(n,!0),bo(e))},destroy:function(n){bo(n,!0)}};function bo(n,e){var t=n.data.ref;if(s(t)){var o=n.context,a=n.componentInstance||n.elm,i=e?null:a,l=e?void 0:a;if(c(t))Ze(t,o,[i],o,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Bn(t),m=o.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?r(h)&&x(h,a):r(h)?h.includes(a)||h.push(a):u?(m[t]=[a],yo(o,t,m[t])):t.value=[a]}else if(u){if(e&&m[t]!==a)return;m[t]=l,yo(o,t,i)}else if(p){if(e&&t.value!==a)return;t.value=i}else 0}}}function yo(n,e,t){var o=n._setupState;o&&E(o,e)&&(Bn(o[e])?o[e].value=t:o[e]=t)}var xo=new yn("",{},[]),wo=["create","activate","update","remove","destroy"];function Eo(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,o=s(t=n.data)&&s(t=t.attrs)&&t.type,r=s(t=e.data)&&s(t=t.attrs)&&t.type;return o===r||fo(o)&&fo(r)}(n,e)||i(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function So(n,e,t){var o,r,a={};for(o=e;o<=t;++o)s(r=n[o].key)&&(a[r]=o);return a}var ko={create:jo,update:jo,destroy:function(n){jo(n,xo)}};function jo(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,o,r,a=n===xo,s=e===xo,i=Ao(n.data.directives,n.context),l=Ao(e.data.directives,e.context),c=[],d=[];for(t in l)o=i[t],r=l[t],o?(r.oldValue=o.value,r.oldArg=o.arg,Fo(r,"update",e,n),r.def&&r.def.componentUpdated&&d.push(r)):(Fo(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Fo(c[t],"inserted",e,n)};a?Jn(e,"insert",u):u()}d.length&&Jn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Fo(d[t],"componentUpdated",e,n)}));if(!a)for(t in i)l[t]||Fo(i[t],"unbind",n,n,s)}(n,e)}var To=Object.create(null);function Ao(n,e){var t,o,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++)(o=n[t]).modifiers||(o.modifiers=To),r[Bo(o)]=o,e._setupState&&e._setupState.__sfc&&(o.def=Tt(e,"_setupState","v-"+o.name)),o.def=o.def||Tt(e.$options,"directives",o.name);return r}function Bo(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Fo(n,e,t,o,r){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,o,r)}catch(o){Ge(o,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Co=[vo,ko];function Po(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var o,r,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(o in(s(d.__ob__)||i(d._v_attr_proxy))&&(d=e.data.attrs=P({},d)),d)r=d[o],c[o]!==r&&zo(l,o,r,e.data.pre);for(o in(X||K)&&d.value!==c.value&&zo(l,"value",d.value),c)a(d[o])&&(to(o)?l.removeAttributeNS(eo,oo(o)):Kt(o)||l.removeAttribute(o))}}function zo(n,e,t,o){o||n.tagName.indexOf("-")>-1?Io(n,e,t):no(e)?ro(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Kt(e)?n.setAttribute(e,function(n,e){return ro(e)||"false"===e?"false":"contenteditable"===n&&Qt(e)?e:"true"}(e,t)):to(e)?ro(t)?n.removeAttributeNS(eo,oo(e)):n.setAttributeNS(eo,e,t):Io(n,e,t)}function Io(n,e,t){if(ro(t))n.removeAttribute(e);else{if(X&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var o=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",o)};n.addEventListener("input",o),n.__ieph=!0}n.setAttribute(e,t)}}var Jo={create:Po,update:Po};function qo(n,e){var t=e.elm,o=e.data,r=n.data;if(!(a(o.staticClass)&&a(o.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var i=ao(e),l=t._transitionClasses;s(l)&&(i=io(i,lo(l))),i!==t._prevClass&&(t.setAttribute("class",i),t._prevClass=i)}}var Do,Mo={create:qo,update:qo};function _o(n,e,t){var o=Do;return function r(){var a=e.apply(null,arguments);null!==a&&Ho(n,r,t,o)}}var Oo=Qe&&!(en&&Number(en[1])<=53);function Lo(n,e,t,o){if(Oo){var r=Le,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Do.addEventListener(n,e,on?{capture:t,passive:o}:t)}function Ho(n,e,t,o){(o||Do).removeEventListener(n,e._wrapper||e,t)}function Ro(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},o=n.data.on||{};Do=e.elm||n.elm,function(n){if(s(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),In(t,o,Lo,Ho,_o,e.context),Do=void 0}}var Uo,$o={create:Ro,update:Ro,destroy:function(n){return Ro(n,xo)}};function Vo(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,o,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||i(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),l)t in c||(r[t]="");for(t in c){if(o=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),o===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=o;var d=a(o)?"":String(o);No(r,d)&&(r.value=d)}else if("innerHTML"===t&&po(r.tagName)&&a(r.innerHTML)){(Uo=Uo||document.createElement("div")).innerHTML="<svg>".concat(o,"</svg>");for(var u=Uo.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(o!==l[t])try{r[t]=o}catch(n){}}}}function No(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,o=n._vModifiers;if(s(o)){if(o.number)return v(t)!==v(e);if(o.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Wo={create:Vo,update:Vo},Go=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var o=n.split(t);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function Zo(n){var e=Xo(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Xo(n){return Array.isArray(n)?z(n):"string"==typeof n?Go(n):n}var Yo,Ko=/^--/,Qo=/\s*!important$/,nr=function(n,e,t){if(Ko.test(e))n.style.setProperty(e,t);else if(Qo.test(t))n.style.setProperty(B(e),t.replace(Qo,""),"important");else{var o=tr(e);if(Array.isArray(t))for(var r=0,a=t.length;r<a;r++)n.style[o]=t[r];else n.style[o]=t}},er=["Webkit","Moz","ms"],tr=S((function(n){if(Yo=Yo||document.createElement("div").style,"filter"!==(n=j(n))&&n in Yo)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<er.length;t++){var o=er[t]+e;if(o in Yo)return o}}));function or(n,e){var t=e.data,o=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(o.staticStyle)&&a(o.style))){var r,i,l=e.elm,c=o.staticStyle,d=o.normalizedStyle||o.style||{},u=c||d,p=Xo(e.data.style)||{};e.data.normalizedStyle=s(p.__ob__)?P({},p):p;var m=function(n,e){var t,o={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Zo(r.data))&&P(o,t);(t=Zo(n.data))&&P(o,t);for(var a=n;a=a.parent;)a.data&&(t=Zo(a.data))&&P(o,t);return o}(e,!0);for(i in u)a(m[i])&&nr(l,i,"");for(i in m)(r=m[i])!==u[i]&&nr(l,i,null==r?"":r)}}var rr={create:or,update:or},ar=/\s+/;function sr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ar).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ir(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ar).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),o=" "+e+" ";t.indexOf(o)>=0;)t=t.replace(o," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function lr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,cr(n.name||"v")),P(e,n),e}return"string"==typeof n?cr(n):void 0}}var cr=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),dr=G&&!Y,ur="transition",pr="transitionend",mr="animation",hr="animationend";dr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ur="WebkitTransition",pr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(mr="WebkitAnimation",hr="webkitAnimationEnd"));var fr=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function gr(n){fr((function(){fr(n)}))}function vr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),sr(n,e))}function br(n,e){n._transitionClasses&&x(n._transitionClasses,e),ir(n,e)}function yr(n,e,t){var o=wr(n,e),r=o.type,a=o.timeout,s=o.propCount;if(!r)return t();var i="transition"===r?pr:hr,l=0,c=function(){n.removeEventListener(i,d),t()},d=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),a+1),n.addEventListener(i,d)}var xr=/\b(transform|all)(,|$)/;function wr(n,e){var t,o=window.getComputedStyle(n),r=(o[ur+"Delay"]||"").split(", "),a=(o[ur+"Duration"]||"").split(", "),s=Er(r,a),i=(o[mr+"Delay"]||"").split(", "),l=(o[mr+"Duration"]||"").split(", "),c=Er(i,l),d=0,u=0;return"transition"===e?s>0&&(t="transition",d=s,u=a.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&xr.test(o[ur+"Property"])}}function Er(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Sr(e)+Sr(n[t])})))}function Sr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function kr(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var o=lr(n.data.transition);if(!a(o)&&!s(t._enterCb)&&1===t.nodeType){for(var r=o.css,i=o.type,l=o.enterClass,u=o.enterToClass,p=o.enterActiveClass,m=o.appearClass,h=o.appearToClass,f=o.appearActiveClass,g=o.beforeEnter,b=o.enter,y=o.afterEnter,x=o.enterCancelled,w=o.beforeAppear,E=o.appear,S=o.afterAppear,k=o.appearCancelled,j=o.duration,T=Be,A=Be.$vnode;A&&A.parent;)T=A.context,A=A.parent;var B=!T._isMounted||!n.isRootInsert;if(!B||E||""===E){var F=B&&m?m:l,C=B&&f?f:p,P=B&&h?h:u,z=B&&w||g,I=B&&c(E)?E:b,J=B&&S||y,q=B&&k||x,D=v(d(j)?j.enter:j);0;var M=!1!==r&&!Y,O=Ar(I),L=t._enterCb=_((function(){M&&(br(t,P),br(t,C)),L.cancelled?(M&&br(t,F),q&&q(t)):J&&J(t),t._enterCb=null}));n.data.show||Jn(n,"insert",(function(){var e=t.parentNode,o=e&&e._pending&&e._pending[n.key];o&&o.tag===n.tag&&o.elm._leaveCb&&o.elm._leaveCb(),I&&I(t,L)})),z&&z(t),M&&(vr(t,F),vr(t,C),gr((function(){br(t,F),L.cancelled||(vr(t,P),O||(Tr(D)?setTimeout(L,D):yr(t,i,L)))}))),n.data.show&&(e&&e(),I&&I(t,L)),M||O||L()}}}function jr(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var o=lr(n.data.transition);if(a(o)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var r=o.css,i=o.type,l=o.leaveClass,c=o.leaveToClass,u=o.leaveActiveClass,p=o.beforeLeave,m=o.leave,h=o.afterLeave,f=o.leaveCancelled,g=o.delayLeave,b=o.duration,y=!1!==r&&!Y,x=Ar(m),w=v(d(b)?b.leave:b);0;var E=t._leaveCb=_((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(br(t,c),br(t,u)),E.cancelled?(y&&br(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(S):S()}function S(){E.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(vr(t,l),vr(t,u),gr((function(){br(t,l),E.cancelled||(vr(t,c),x||(Tr(w)?setTimeout(E,w):yr(t,i,E)))}))),m&&m(t,E),y||x||E())}}function Tr(n){return"number"==typeof n&&!isNaN(n)}function Ar(n){if(a(n))return!1;var e=n.fns;return s(e)?Ar(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Br(n,e){!0!==e.data.show&&kr(e)}var Fr=function(n){var e,t,o={},c=n.modules,d=n.nodeOps;for(e=0;e<wo.length;++e)for(o[wo[e]]=[],t=0;t<c.length;++t)s(c[t][wo[e]])&&o[wo[e]].push(c[t][wo[e]]);function u(n){var e=d.parentNode(n);s(e)&&d.removeChild(e,n)}function p(n,e,t,r,a,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=En(n)),n.isRootInsert=!a,!function(n,e,t,r){var a=n.data;if(s(a)){var l=s(n.componentInstance)&&a.keepAlive;if(s(a=a.hook)&&s(a=a.init)&&a(n,!1),s(n.componentInstance))return m(n,e),h(t,n.elm,r),i(l)&&function(n,e,t,r){var a,i=n;for(;i.componentInstance;)if(i=i.componentInstance._vnode,s(a=i.data)&&s(a=a.transition)){for(a=0;a<o.activate.length;++a)o.activate[a](xo,i);e.push(i);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var u=n.data,p=n.children,g=n.tag;s(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),y(n),f(n,p,e),s(u)&&v(n,e),h(t,n.elm,r)):i(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,r)):(n.elm=d.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),y(n)):(bo(n),e.push(n))}function h(n,e,t){s(n)&&(s(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var o=0;o<e.length;++o)p(e[o],t,n.elm,null,!0,e,o)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function v(n,t){for(var r=0;r<o.create.length;++r)o.create[r](xo,n);s(e=n.data.hook)&&(s(e.create)&&e.create(xo,n),s(e.insert)&&t.push(n))}function y(n){var e;if(s(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;s(e=Be)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function x(n,e,t,o,r,a){for(;o<=r;++o)p(t[o],a,n,e,!1,t,o)}function w(n){var e,t,r=n.data;if(s(r))for(s(e=r.hook)&&s(e=e.destroy)&&e(n),e=0;e<o.destroy.length;++e)o.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function E(n,e,t){for(;e<=t;++e){var o=n[e];s(o)&&(s(o.tag)?(S(o),w(o)):u(o.elm))}}function S(n,e){if(s(e)||s(n.data)){var t,r=o.remove.length+1;for(s(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&S(t,e),t=0;t<o.remove.length;++t)o.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else u(n.elm)}function k(n,e,t,o){for(var r=t;r<o;r++){var a=e[r];if(s(a)&&Eo(n,a))return r}}function j(n,e,t,r,l,c){if(n!==e){s(e.elm)&&s(r)&&(e=r[l]=En(e));var u=e.elm=n.elm;if(i(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?B(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(i(e.isStatic)&&i(n.isStatic)&&e.key===n.key&&(i(e.isCloned)||i(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;s(h)&&s(m=h.hook)&&s(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(s(h)&&g(e)){for(m=0;m<o.update.length;++m)o.update[m](n,e);s(m=h.hook)&&s(m=m.update)&&m(n,e)}a(e.text)?s(f)&&s(v)?f!==v&&function(n,e,t,o,r){var i,l,c,u=0,m=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,b=t[0],y=t[v],w=!r;for(0;u<=h&&m<=v;)a(f)?f=e[++u]:a(g)?g=e[--h]:Eo(f,b)?(j(f,b,o,t,m),f=e[++u],b=t[++m]):Eo(g,y)?(j(g,y,o,t,v),g=e[--h],y=t[--v]):Eo(f,y)?(j(f,y,o,t,v),w&&d.insertBefore(n,f.elm,d.nextSibling(g.elm)),f=e[++u],y=t[--v]):Eo(g,b)?(j(g,b,o,t,m),w&&d.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(a(i)&&(i=So(e,u,h)),a(l=s(b.key)?i[b.key]:k(b,e,u,h))?p(b,o,n,f.elm,!1,t,m):Eo(c=e[l],b)?(j(c,b,o,t,m),e[l]=void 0,w&&d.insertBefore(n,c.elm,f.elm)):p(b,o,n,f.elm,!1,t,m),b=t[++m]);u>h?x(n,a(t[v+1])?null:t[v+1].elm,t,m,v,o):m>v&&E(e,u,h)}(u,f,v,t,c):s(v)?(s(n.text)&&d.setTextContent(u,""),x(u,null,v,0,v.length-1,t)):s(f)?E(f,0,f.length-1):s(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),s(h)&&s(m=h.hook)&&s(m=m.postpatch)&&m(n,e)}}}function T(n,e,t){if(i(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var o=0;o<e.length;++o)e[o].data.hook.insert(e[o])}var A=b("attrs,class,staticClass,staticStyle,key");function B(n,e,t,o){var r,a=e.tag,l=e.data,c=e.children;if(o=o||l&&l.pre,e.elm=n,i(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(r=l.hook)&&s(r=r.init)&&r(e,!0),s(r=e.componentInstance)))return m(e,t),!0;if(s(a)){if(s(c))if(n.hasChildNodes())if(s(r=l)&&s(r=r.domProps)&&s(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!B(u,c[p],t,o)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else f(e,c,t);if(s(l)){var h=!1;for(var g in l)if(!A(g)){h=!0,v(e,t);break}!h&&l.class&&Cn(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!a(e)){var l,c=!1,u=[];if(a(n))c=!0,p(e,u);else{var m=s(n.nodeType);if(!m&&Eo(n,e))j(n,e,u,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),i(t)&&B(n,e,u))return T(e,u,!0),n;l=n,n=new yn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=d.parentNode(h);if(p(e,u,h._leaveCb?null:f,d.nextSibling(h)),s(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<o.destroy.length;++y)o.destroy[y](v);if(v.elm=e.elm,b){for(var x=0;x<o.create.length;++x)o.create[x](xo,v);var S=v.data.hook.insert;if(S.merged)for(var k=1;k<S.fns.length;k++)S.fns[k]()}else bo(v);v=v.parent}s(f)?E([n],0,0):s(n.tag)&&w(n)}}return T(e,u,c),e.elm}s(n)&&w(n)}}({nodeOps:go,modules:[Jo,Mo,$o,Wo,rr,G?{create:Br,activate:Br,remove:function(n,e){!0!==n.data.show?jr(n,e):e()}}:{}].concat(Co)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Mr(n,"input")}));var Cr={inserted:function(n,e,t,o){"select"===t.tag?(o.elm&&!o.elm._vOptions?Jn(t,"postpatch",(function(){Cr.componentUpdated(n,e,t)})):Pr(n,e,t.context),n._vOptions=[].map.call(n.options,Jr)):("textarea"===t.tag||fo(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",qr),n.addEventListener("compositionend",Dr),n.addEventListener("change",Dr),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Pr(n,e,t.context);var o=n._vOptions,r=n._vOptions=[].map.call(n.options,Jr);if(r.some((function(n,e){return!D(n,o[e])})))(n.multiple?e.value.some((function(n){return Ir(n,r)})):e.value!==e.oldValue&&Ir(e.value,r))&&Mr(n,"change")}}};function Pr(n,e,t){zr(n,e,t),(X||K)&&setTimeout((function(){zr(n,e,t)}),0)}function zr(n,e,t){var o=e.value,r=n.multiple;if(!r||Array.isArray(o)){for(var a,s,i=0,l=n.options.length;i<l;i++)if(s=n.options[i],r)a=M(o,Jr(s))>-1,s.selected!==a&&(s.selected=a);else if(D(Jr(s),o))return void(n.selectedIndex!==i&&(n.selectedIndex=i));r||(n.selectedIndex=-1)}}function Ir(n,e){return e.every((function(e){return!D(e,n)}))}function Jr(n){return"_value"in n?n._value:n.value}function qr(n){n.target.composing=!0}function Dr(n){n.target.composing&&(n.target.composing=!1,Mr(n.target,"input"))}function Mr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function _r(n){return!n.componentInstance||n.data&&n.data.transition?n:_r(n.componentInstance._vnode)}var Or={model:Cr,show:{bind:function(n,e,t){var o=e.value,r=(t=_r(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;o&&r?(t.data.show=!0,kr(t,(function(){n.style.display=a}))):n.style.display=o?a:"none"},update:function(n,e,t){var o=e.value;!o!=!e.oldValue&&((t=_r(t)).data&&t.data.transition?(t.data.show=!0,o?kr(t,(function(){n.style.display=n.__vOriginalDisplay})):jr(t,(function(){n.style.display="none"}))):n.style.display=o?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,o,r){r||(n.style.display=n.__vOriginalDisplay)}}},Lr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Hr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Hr(Se(e.children)):n}function Rr(n){var e={},t=n.$options;for(var o in t.propsData)e[o]=n[o];var r=t._parentListeners;for(var o in r)e[j(o)]=r[o];return e}function Ur(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var $r=function(n){return n.tag||Rn(n)},Vr=function(n){return"show"===n.name},Nr={name:"transition",props:Lr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter($r)).length){0;var o=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var a=Hr(r);if(!a)return r;if(this._leaving)return Ur(n,r);var s="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?s+"comment":s+a.tag:l(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var i=(a.data||(a.data={})).transition=Rr(this),c=this._vnode,d=Hr(c);if(a.data.directives&&a.data.directives.some(Vr)&&(a.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,d)&&!Rn(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=P({},i);if("out-in"===o)return this._leaving=!0,Jn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ur(n,r);if("in-out"===o){if(Rn(a))return c;var p,m=function(){p()};Jn(i,"afterEnter",m),Jn(i,"enterCancelled",m),Jn(u,"delayLeave",(function(n){p=n}))}}return r}}},Wr=P({tag:String,moveClass:String},Lr);function Gr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Zr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Xr(n){var e=n.data.pos,t=n.data.newPos,o=e.left-t.left,r=e.top-t.top;if(o||r){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(o,"px,").concat(r,"px)"),a.transitionDuration="0s"}}delete Wr.mode;var Yr={Transition:Nr,TransitionGroup:{props:Wr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,o){var r=Fe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,o)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),o=this.prevChildren=this.children,r=this.$slots.default||[],a=this.children=[],s=Rr(this),i=0;i<r.length;i++){if((d=r[i]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))a.push(d),t[d.key]=d,(d.data||(d.data={})).transition=s;else;}if(o){var l=[],c=[];for(i=0;i<o.length;i++){var d;(d=o[i]).data.transition=s,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Gr),n.forEach(Zr),n.forEach(Xr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,o=t.style;vr(t,e),o.transform=o.WebkitTransform=o.transitionDuration="",t.addEventListener(pr,t._moveCb=function n(o){o&&o.target!==t||o&&!/transform$/.test(o.propertyName)||(t.removeEventListener(pr,n),t._moveCb=null,br(t,e))})}})))},methods:{hasMove:function(n,e){if(!dr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ir(t,n)})),sr(t,e),t.style.display="none",this.$el.appendChild(t);var o=wr(t);return this.$el.removeChild(t),this._hasMove=o.hasTransform}}}};function Kr(n,e){for(var t in e)n[t]=e[t];return n}Rt.config.mustUseProp=function(n,e,t){return"value"===t&&Yt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Rt.config.isReservedTag=mo,Rt.config.isReservedAttr=Xt,Rt.config.getTagNamespace=function(n){return po(n)?"svg":"math"===n?"math":void 0},Rt.config.isUnknownElement=function(n){if(!G)return!0;if(mo(n))return!1;if(n=n.toLowerCase(),null!=ho[n])return ho[n];var e=document.createElement(n);return n.indexOf("-")>-1?ho[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ho[n]=/HTMLUnknownElement/.test(e.toString())},P(Rt.options.directives,Or),P(Rt.options.components,Yr),Rt.prototype.__patch__=G?Fr:I,Rt.prototype.$mount=function(n,e){return function(n,e,t){var o;n.$el=e,n.$options.render||(n.$options.render=xn),ze(n,"beforeMount"),o=function(){n._update(n._render(),t)},new We(n,o,I,{before:function(){n._isMounted&&!n._isDestroyed&&ze(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var a=0;a<r.length;a++)r[a].run();return null==n.$vnode&&(n._isMounted=!0,ze(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){R.devtools&&sn&&sn.emit("init",Rt)}),0);var Qr=/[!'()*]/g,na=function(n){return"%"+n.charCodeAt(0).toString(16)},ea=/%2C/g,ta=function(n){return encodeURIComponent(n).replace(Qr,na).replace(ea,",")};function oa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var ra=function(n){return null==n||"object"==typeof n?n:String(n)};function aa(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),o=oa(t.shift()),r=t.length>0?oa(t.join("=")):null;void 0===e[o]?e[o]=r:Array.isArray(e[o])?e[o].push(r):e[o]=[e[o],r]})),e):e}function sa(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ta(e);if(Array.isArray(t)){var o=[];return t.forEach((function(n){void 0!==n&&(null===n?o.push(ta(e)):o.push(ta(e)+"="+ta(n)))})),o.join("&")}return ta(e)+"="+ta(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ia=/\/?$/;function la(n,e,t,o){var r=o&&o.options.stringifyQuery,a=e.query||{};try{a=ca(a)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:pa(e,r),matched:n?ua(n):[]};return t&&(s.redirectedFrom=pa(t,r)),Object.freeze(s)}function ca(n){if(Array.isArray(n))return n.map(ca);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ca(n[t]);return e}return n}var da=la(null,{path:"/"});function ua(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function pa(n,e){var t=n.path,o=n.query;void 0===o&&(o={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||sa)(o)+r}function ma(n,e,t){return e===da?n===e:!!e&&(n.path&&e.path?n.path.replace(ia,"")===e.path.replace(ia,"")&&(t||n.hash===e.hash&&ha(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&ha(n.query,e.query)&&ha(n.params,e.params))))}function ha(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),o=Object.keys(e).sort();return t.length===o.length&&t.every((function(t,r){var a=n[t];if(o[r]!==t)return!1;var s=e[t];return null==a||null==s?a===s:"object"==typeof a&&"object"==typeof s?ha(a,s):String(a)===String(s)}))}function fa(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var o in t.instances){var r=t.instances[o],a=t.enteredCbs[o];if(r&&a){delete t.enteredCbs[o];for(var s=0;s<a.length;s++)r._isBeingDestroyed||a[s](r)}}}}var ga={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,o=e.children,r=e.parent,a=e.data;a.routerView=!0;for(var s=r.$createElement,i=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&d++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(a.routerViewDepth=d,u){var m=c[i],h=m&&m.component;return h?(m.configProps&&va(h,a,m.route,m.configProps),s(h,a,o)):s()}var f=l.matched[d],g=f&&f.components[i];if(!f||!g)return c[i]=null,s();c[i]={component:g},a.registerRouteInstance=function(n,e){var t=f.instances[i];(e&&t!==n||!e&&t===n)&&(f.instances[i]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){f.instances[i]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[i]&&(f.instances[i]=n.componentInstance),fa(l)};var v=f.props&&f.props[i];return v&&(Kr(c[i],{route:l,configProps:v}),va(g,a,l,v)),s(g,a,o)}};function va(n,e,t,o){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,o);if(r){r=e.props=Kr({},r);var a=e.attrs=e.attrs||{};for(var s in r)n.props&&s in n.props||(a[s]=r[s],delete r[s])}}function ba(n,e,t){var o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var a=n.replace(/^\//,"").split("/"),s=0;s<a.length;s++){var i=a[s];".."===i?r.pop():"."!==i&&r.push(i)}return""!==r[0]&&r.unshift(""),r.join("/")}function ya(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var xa=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},wa=qa,Ea=Aa,Sa=function(n,e){return Fa(Aa(n,e),e)},ka=Fa,ja=Ja,Ta=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Aa(n,e){for(var t,o=[],r=0,a=0,s="",i=e&&e.delimiter||"/";null!=(t=Ta.exec(n));){var l=t[0],c=t[1],d=t.index;if(s+=n.slice(a,d),a=d+l.length,c)s+=c[1];else{var u=n[a],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],v=t[7];s&&(o.push(s),s="");var b=null!=p&&null!=u&&u!==p,y="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||i,E=h||f;o.push({name:m||r++,prefix:p||"",delimiter:w,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:E?Pa(E):v?".*":"[^"+Ca(w)+"]+?"})}}return a<n.length&&(s+=n.substr(a)),s&&o.push(s),o}function Ba(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Fa(n,e){for(var t=new Array(n.length),o=0;o<n.length;o++)"object"==typeof n[o]&&(t[o]=new RegExp("^(?:"+n[o].pattern+")$",Ia(e)));return function(e,o){for(var r="",a=e||{},s=(o||{}).pretty?Ba:encodeURIComponent,i=0;i<n.length;i++){var l=n[i];if("string"!=typeof l){var c,d=a[l.name];if(null==d){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(xa(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=s(d[u]),!t[i].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(d),!t[i].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Ca(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Pa(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function za(n,e){return n.keys=e,n}function Ia(n){return n&&n.sensitive?"":"i"}function Ja(n,e,t){xa(e)||(t=e||t,e=[]);for(var o=(t=t||{}).strict,r=!1!==t.end,a="",s=0;s<n.length;s++){var i=n[s];if("string"==typeof i)a+=Ca(i);else{var l=Ca(i.prefix),c="(?:"+i.pattern+")";e.push(i),i.repeat&&(c+="(?:"+l+c+")*"),a+=c=i.optional?i.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Ca(t.delimiter||"/"),u=a.slice(-d.length)===d;return o||(a=(u?a.slice(0,-d.length):a)+"(?:"+d+"(?=$))?"),a+=r?"$":o&&u?"":"(?="+d+"|$)",za(new RegExp("^"+a,Ia(t)),e)}function qa(n,e,t){return xa(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var o=0;o<t.length;o++)e.push({name:o,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return za(n,e)}(n,e):xa(n)?function(n,e,t){for(var o=[],r=0;r<n.length;r++)o.push(qa(n[r],e,t).source);return za(new RegExp("(?:"+o.join("|")+")",Ia(t)),e)}(n,e,t):function(n,e,t){return Ja(Aa(n,t),e,t)}(n,e,t)}wa.parse=Ea,wa.compile=Sa,wa.tokensToFunction=ka,wa.tokensToRegExp=ja;var Da=Object.create(null);function Ma(n,e,t){e=e||{};try{var o=Da[n]||(Da[n]=wa.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),o(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function _a(n,e,t,o){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var a=(r=Kr({},n)).params;return a&&"object"==typeof a&&(r.params=Kr({},a)),r}if(!r.path&&r.params&&e){(r=Kr({},r))._normalized=!0;var s=Kr(Kr({},e.params),r.params);if(e.name)r.name=e.name,r.params=s;else if(e.matched.length){var i=e.matched[e.matched.length-1].path;r.path=Ma(i,s,e.path)}else 0;return r}var l=function(n){var e="",t="",o=n.indexOf("#");o>=0&&(e=n.slice(o),n=n.slice(0,o));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",d=l.path?ba(l.path,c,t||r.append):c,u=function(n,e,t){void 0===e&&(e={});var o,r=t||aa;try{o=r(n||"")}catch(n){o={}}for(var a in e){var s=e[a];o[a]=Array.isArray(s)?s.map(ra):ra(s)}return o}(l.query,r.query,o&&o.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Oa,La=function(){},Ha={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,o=this.$route,r=t.resolve(this.to,o,this.append),a=r.location,s=r.route,i=r.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=s.redirectedFrom?la(null,_a(s.redirectedFrom),null,t):s;l[h]=ma(o,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ia,"/").indexOf(e.path.replace(ia,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(o,f);var g=l[h]?this.ariaCurrentValue:null,v=function(n){Ra(n)&&(e.replace?t.replace(a,La):t.push(a,La))},b={click:Ra};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:i,route:s,navigate:v,isActive:l[m],isExactActive:l[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:i,"aria-current":g};else{var w=function n(e){var t;if(e)for(var o=0;o<e.length;o++){if("a"===(t=e[o]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var E=w.data=Kr({},w.data);for(var S in E.on=E.on||{},E.on){var k=E.on[S];S in b&&(E.on[S]=Array.isArray(k)?k:[k])}for(var j in b)j in E.on?E.on[j].push(b[j]):E.on[j]=v;var T=w.data.attrs=Kr({},w.data.attrs);T.href=i,T["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ra(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ua="undefined"!=typeof window;function $a(n,e,t,o,r){var a=e||[],s=t||Object.create(null),i=o||Object.create(null);n.forEach((function(n){!function n(e,t,o,r,a,s){var i=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ya(e.path+"/"+n)}(i,a,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var u={path:d,regex:Va(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:s,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var a=s?ya(s+"/"+r.path):void 0;n(e,t,o,r,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,o,h,a,u.path||"/")}l&&(o[l]||(o[l]=u))}(a,s,i,n,r)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:s,nameMap:i}}function Va(n,e){return wa(n,[],e)}function Na(n,e){var t=$a(n),o=t.pathList,r=t.pathMap,a=t.nameMap;function s(n,t,s){var i=_a(n,t,!1,e),c=i.name;if(c){var d=a[c];if(!d)return l(null,i);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof i.params&&(i.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in i.params)&&u.indexOf(p)>-1&&(i.params[p]=t.params[p]);return i.path=Ma(d.path,i.params),l(d,i,s)}if(i.path){i.params={};for(var m=0;m<o.length;m++){var h=o[m],f=r[h];if(Wa(f.regex,i.path,i.params))return l(f,i,s)}}return l(null,i)}function i(n,t){var o=n.redirect,r="function"==typeof o?o(la(n,t,null,e)):o;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var i=r,c=i.name,d=i.path,u=t.query,p=t.hash,m=t.params;if(u=i.hasOwnProperty("query")?i.query:u,p=i.hasOwnProperty("hash")?i.hash:p,m=i.hasOwnProperty("params")?i.params:m,c){a[c];return s({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return ba(n,e.parent?e.parent.path:"/",!0)}(d,n);return s({_normalized:!0,path:Ma(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,o){return n&&n.redirect?i(n,o||t):n&&n.matchAs?function(n,e,t){var o=s({_normalized:!0,path:Ma(t,e.params)});if(o){var r=o.matched,a=r[r.length-1];return e.params=o.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):la(n,t,o,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;$a([e||n],o,r,a,t),t&&t.alias.length&&$a(t.alias.map((function(n){return{path:n,children:[e]}})),o,r,a,t)},getRoutes:function(){return o.map((function(n){return r[n]}))},addRoutes:function(n){$a(n,o,r,a)}}}function Wa(n,e,t){var o=e.match(n);if(!o)return!1;if(!t)return!0;for(var r=1,a=o.length;r<a;++r){var s=n.keys[r-1];s&&(t[s.name||"pathMatch"]="string"==typeof o[r]?oa(o[r]):o[r])}return!0}var Ga=Ua&&window.performance&&window.performance.now?window.performance:Date;function Za(){return Ga.now().toFixed(3)}var Xa=Za();function Ya(){return Xa}function Ka(n){return Xa=n}var Qa=Object.create(null);function ns(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Kr({},window.history.state);return t.key=Ya(),window.history.replaceState(t,"",e),window.addEventListener("popstate",os),function(){window.removeEventListener("popstate",os)}}function es(n,e,t,o){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var a=function(){var n=Ya();if(n)return Qa[n]}(),s=r.call(n,e,t,o?a:null);s&&("function"==typeof s.then?s.then((function(n){ls(n,a)})).catch((function(n){0})):ls(s,a))}))}}function ts(){var n=Ya();n&&(Qa[n]={x:window.pageXOffset,y:window.pageYOffset})}function os(n){ts(),n.state&&n.state.key&&Ka(n.state.key)}function rs(n){return ss(n.x)||ss(n.y)}function as(n){return{x:ss(n.x)?n.x:window.pageXOffset,y:ss(n.y)?n.y:window.pageYOffset}}function ss(n){return"number"==typeof n}var is=/^#\d/;function ls(n,e){var t,o="object"==typeof n;if(o&&"string"==typeof n.selector){var r=is.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),o=n.getBoundingClientRect();return{x:o.left-t.left-e.x,y:o.top-t.top-e.y}}(r,a={x:ss((t=a).x)?t.x:0,y:ss(t.y)?t.y:0})}else rs(n)&&(e=as(n))}else o&&rs(n)&&(e=as(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var cs,ds=Ua&&((-1===(cs=window.navigator.userAgent).indexOf("Android 2.")&&-1===cs.indexOf("Android 4.0")||-1===cs.indexOf("Mobile Safari")||-1!==cs.indexOf("Chrome")||-1!==cs.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function us(n,e){ts();var t=window.history;try{if(e){var o=Kr({},t.state);o.key=Ya(),t.replaceState(o,"",n)}else t.pushState({key:Ka(Za())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function ps(n){us(n,!0)}function ms(n,e,t){var o=function(r){r>=n.length?t():n[r]?e(n[r],(function(){o(r+1)})):o(r+1)};o(0)}var hs={redirected:2,aborted:4,cancelled:8,duplicated:16};function fs(n,e){return vs(n,e,hs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return bs.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function gs(n,e){return vs(n,e,hs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function vs(n,e,t,o){var r=new Error(o);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var bs=["params","query","hash"];function ys(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function xs(n,e){return ys(n)&&n._isRouter&&(null==e||n.type===e)}function ws(n){return function(e,t,o){var r=!1,a=0,s=null;Es(n,(function(n,e,t,i){if("function"==typeof n&&void 0===n.cid){r=!0,a++;var l,c=js((function(e){var r;((r=e).__esModule||ks&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Oa.extend(e),t.components[i]=e,--a<=0&&o()})),d=js((function(n){var e="Failed to resolve async component "+i+": "+n;s||(s=ys(n)?n:new Error(e),o(s))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),r||o()}}function Es(n,e){return Ss(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ss(n){return Array.prototype.concat.apply([],n)}var ks="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function js(n){var e=!1;return function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];if(!e)return e=!0,n.apply(this,t)}}var Ts=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ua){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=da,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function As(n,e,t,o){var r=Es(n,(function(n,o,r,a){var s=function(n,e){"function"!=typeof n&&(n=Oa.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,o,r,a)})):t(s,o,r,a)}));return Ss(o?r.reverse():r)}function Bs(n,e){if(e)return function(){return n.apply(e,arguments)}}Ts.prototype.listen=function(n){this.cb=n},Ts.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ts.prototype.onError=function(n){this.errorCbs.push(n)},Ts.prototype.transitionTo=function(n,e,t){var o,r=this;try{o=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(o,(function(){r.updateRoute(o),e&&e(o),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(o,a)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(o)})))}),(function(n){t&&t(n),n&&!r.ready&&(xs(n,hs.redirected)&&a===da||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ts.prototype.confirmTransition=function(n,e,t){var o=this,r=this.current;this.pending=n;var a,s,i=function(n){!xs(n)&&ys(n)&&(o.errorCbs.length?o.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(ma(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&es(this.router,r,n,!1),i(((s=vs(a=r,n,hs.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",s));var d=function(n,e){var t,o=Math.max(n.length,e.length);for(t=0;t<o&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return As(n,"beforeRouteLeave",Bs,!0)}(p),this.router.beforeHooks,function(n){return As(n,"beforeRouteUpdate",Bs)}(u),m.map((function(n){return n.beforeEnter})),ws(m)),f=function(e,t){if(o.pending!==n)return i(gs(r,n));try{e(n,r,(function(e){!1===e?(o.ensureURL(!0),i(function(n,e){return vs(n,e,hs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):ys(e)?(o.ensureURL(!0),i(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(i(fs(r,n)),"object"==typeof e&&e.replace?o.replace(e):o.push(e)):t(e)}))}catch(n){i(n)}};ms(h,f,(function(){ms(function(n){return As(n,"beforeRouteEnter",(function(n,e,t,o){return function(n,e,t){return function(o,r,a){return n(o,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,o)}))}(m).concat(o.router.resolveHooks),f,(function(){if(o.pending!==n)return i(gs(r,n));o.pending=null,e(n),o.router.app&&o.router.app.$nextTick((function(){fa(n)}))}))}))},Ts.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ts.prototype.setupListeners=function(){},Ts.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=da,this.pending=null};var Fs=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Cs(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,o=ds&&t;o&&this.listeners.push(ns());var r=function(){var t=n.current,r=Cs(n.base);n.current===da&&r===n._startLocation||n.transitionTo(r,(function(n){o&&es(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){us(ya(o.base+n.fullPath)),es(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){ps(ya(o.base+n.fullPath)),es(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Cs(this.base)!==this.current.fullPath){var e=ya(this.base+this.current.fullPath);n?us(e):ps(e)}},e.prototype.getCurrentLocation=function(){return Cs(this.base)},e}(Ts);function Cs(n){var e=window.location.pathname,t=e.toLowerCase(),o=n.toLowerCase();return!n||t!==o&&0!==t.indexOf(ya(o+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ps=function(n){function e(e,t,o){n.call(this,e,t),o&&function(n){var e=Cs(n);if(!/^\/#/.test(e))return window.location.replace(ya(n+"/#"+e)),!0}(this.base)||zs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ds&&e;t&&this.listeners.push(ns());var o=function(){var e=n.current;zs()&&n.transitionTo(Is(),(function(o){t&&es(n.router,o,e,!0),ds||Ds(o.fullPath)}))},r=ds?"popstate":"hashchange";window.addEventListener(r,o),this.listeners.push((function(){window.removeEventListener(r,o)}))}},e.prototype.push=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){qs(n.fullPath),es(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){Ds(n.fullPath),es(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Is()!==e&&(n?qs(e):Ds(e))},e.prototype.getCurrentLocation=function(){return Is()},e}(Ts);function zs(){var n=Is();return"/"===n.charAt(0)||(Ds("/"+n),!1)}function Is(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Js(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function qs(n){ds?us(Js(n)):window.location.hash=n}function Ds(n){ds?ps(Js(n)):window.location.replace(Js(n))}var Ms=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index+1).concat(n),o.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var o=this.stack[t];this.confirmTransition(o,(function(){var n=e.current;e.index=t,e.updateRoute(o),e.router.afterHooks.forEach((function(e){e&&e(o,n)}))}),(function(n){xs(n,hs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ts),_s=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Na(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ds&&!1!==n.fallback,this.fallback&&(e="hash"),Ua||(e="abstract"),this.mode=e,e){case"history":this.history=new Fs(this,n.base);break;case"hash":this.history=new Ps(this,n.base,this.fallback);break;case"abstract":this.history=new Ms(this,n.base);break;default:0}},Os={currentRoute:{configurable:!0}};function Ls(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}_s.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Os.currentRoute.get=function(){return this.history&&this.history.current},_s.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Fs||t instanceof Ps){var o=function(n){t.setupListeners(),function(n){var o=t.current,r=e.options.scrollBehavior;ds&&r&&"fullPath"in n&&es(e,n,o,!1)}(n)};t.transitionTo(t.getCurrentLocation(),o,o)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},_s.prototype.beforeEach=function(n){return Ls(this.beforeHooks,n)},_s.prototype.beforeResolve=function(n){return Ls(this.resolveHooks,n)},_s.prototype.afterEach=function(n){return Ls(this.afterHooks,n)},_s.prototype.onReady=function(n,e){this.history.onReady(n,e)},_s.prototype.onError=function(n){this.history.onError(n)},_s.prototype.push=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.push(n,e,t)}));this.history.push(n,e,t)},_s.prototype.replace=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.replace(n,e,t)}));this.history.replace(n,e,t)},_s.prototype.go=function(n){this.history.go(n)},_s.prototype.back=function(){this.go(-1)},_s.prototype.forward=function(){this.go(1)},_s.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},_s.prototype.resolve=function(n,e,t){var o=_a(n,e=e||this.history.current,t,this),r=this.match(o,e),a=r.redirectedFrom||r.fullPath;return{location:o,route:r,href:function(n,e,t){var o="hash"===t?"#"+e:e;return n?ya(n+"/"+o):o}(this.history.base,a,this.mode),normalizedTo:o,resolved:r}},_s.prototype.getRoutes=function(){return this.matcher.getRoutes()},_s.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==da&&this.history.transitionTo(this.history.getCurrentLocation())},_s.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==da&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(_s.prototype,Os),_s.install=function n(e){if(!n.installed||Oa!==e){n.installed=!0,Oa=e;var t=function(n){return void 0!==n},o=function(n,e){var o=n.$options._parentVnode;t(o)&&t(o=o.data)&&t(o=o.registerRouteInstance)&&o(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,o(this,this)},destroyed:function(){o(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",ga),e.component("RouterLink",Ha);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},_s.version="3.5.4",_s.isNavigationFailure=xs,_s.NavigationFailureType=hs,_s.START_LOCATION=da,Ua&&window.Vue&&window.Vue.use(_s);var Hs=_s;t(103);t(126);var Rs={NotFound:()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,336)),Layout:()=>Promise.all([t.e(0),t.e(3),t.e(2)]).then(t.bind(null,335))},Us={"v-ccb821ec":()=>t.e(7).then(t.bind(null,337)),"v-696b0a49":()=>t.e(8).then(t.bind(null,338)),"v-23ff1010":()=>t.e(9).then(t.bind(null,339)),"v-5e9f586b":()=>t.e(10).then(t.bind(null,340)),"v-636b316c":()=>t.e(11).then(t.bind(null,341)),"v-34e195e9":()=>t.e(12).then(t.bind(null,342)),"v-8e2f20b6":()=>t.e(13).then(t.bind(null,343)),"v-71a62a83":()=>t.e(14).then(t.bind(null,344)),"v-5a8ed19a":()=>t.e(15).then(t.bind(null,345)),"v-64d5b56e":()=>t.e(16).then(t.bind(null,346)),"v-6c5d0ea6":()=>t.e(17).then(t.bind(null,347)),"v-c5dd7ffa":()=>t.e(18).then(t.bind(null,348)),"v-27e10230":()=>t.e(19).then(t.bind(null,349)),"v-489164fc":()=>t.e(20).then(t.bind(null,350)),"v-157bc241":()=>t.e(21).then(t.bind(null,351)),"v-36daa0e9":()=>t.e(22).then(t.bind(null,352)),"v-fb81fc8a":()=>t.e(23).then(t.bind(null,353)),"v-4f5c3eb5":()=>t.e(24).then(t.bind(null,354)),"v-fecb5b10":()=>t.e(25).then(t.bind(null,355)),"v-47839f38":()=>t.e(26).then(t.bind(null,356)),"v-55ad45a1":()=>t.e(27).then(t.bind(null,357)),"v-2321eb02":()=>t.e(28).then(t.bind(null,358)),"v-4bfbfc8f":()=>t.e(29).then(t.bind(null,359)),"v-f1fc15c0":()=>t.e(30).then(t.bind(null,360)),"v-18f501c4":()=>t.e(31).then(t.bind(null,361)),"v-eaa28632":()=>t.e(32).then(t.bind(null,362)),"v-6e674884":()=>t.e(33).then(t.bind(null,363)),"v-bb016a66":()=>t.e(34).then(t.bind(null,364)),"v-2b3ae24e":()=>t.e(35).then(t.bind(null,365)),"v-cccab4ca":()=>t.e(36).then(t.bind(null,366)),"v-b48c1564":()=>t.e(37).then(t.bind(null,367)),"v-e8174f44":()=>t.e(38).then(t.bind(null,368)),"v-e993351a":()=>t.e(39).then(t.bind(null,369)),"v-4adbdfdc":()=>t.e(40).then(t.bind(null,370)),"v-586acead":()=>t.e(41).then(t.bind(null,371)),"v-2bfb06ae":()=>t.e(42).then(t.bind(null,372)),"v-65651d2c":()=>t.e(43).then(t.bind(null,373)),"v-7d17d9c4":()=>t.e(44).then(t.bind(null,374)),"v-8458d62a":()=>t.e(45).then(t.bind(null,375)),"v-5c2e274a":()=>t.e(46).then(t.bind(null,376)),"v-f3a6bcd4":()=>t.e(47).then(t.bind(null,377)),"v-f80fbb16":()=>t.e(48).then(t.bind(null,378)),"v-943d629a":()=>t.e(49).then(t.bind(null,379)),"v-7aced672":()=>t.e(50).then(t.bind(null,380)),"v-6e17c6b9":()=>t.e(51).then(t.bind(null,381)),"v-2a227a05":()=>t.e(52).then(t.bind(null,382)),"v-ac317b20":()=>t.e(53).then(t.bind(null,383)),"v-1d792e48":()=>t.e(54).then(t.bind(null,384)),"v-49aa8c49":()=>t.e(55).then(t.bind(null,385)),"v-1572ebde":()=>t.e(56).then(t.bind(null,386)),"v-13f3c2ee":()=>t.e(58).then(t.bind(null,387)),"v-c3cc3544":()=>t.e(57).then(t.bind(null,388)),"v-49546196":()=>t.e(59).then(t.bind(null,389)),"v-5bff9ca2":()=>t.e(60).then(t.bind(null,390)),"v-3baa6731":()=>t.e(61).then(t.bind(null,391)),"v-43c073c8":()=>t.e(62).then(t.bind(null,392)),"v-19c0f996":()=>t.e(63).then(t.bind(null,393)),"v-5aec749e":()=>t.e(64).then(t.bind(null,394)),"v-bdb3a544":()=>t.e(65).then(t.bind(null,395)),"v-44f445c1":()=>t.e(66).then(t.bind(null,396)),"v-9cb66582":()=>t.e(67).then(t.bind(null,397)),"v-586b2e40":()=>t.e(68).then(t.bind(null,398)),"v-e275eb9c":()=>t.e(69).then(t.bind(null,399)),"v-c5c30270":()=>t.e(70).then(t.bind(null,400)),"v-3ef35fa2":()=>t.e(71).then(t.bind(null,401)),"v-2ed9553b":()=>t.e(72).then(t.bind(null,402)),"v-2cb1cf16":()=>t.e(73).then(t.bind(null,403)),"v-f88617ea":()=>t.e(74).then(t.bind(null,404)),"v-7d208927":()=>t.e(75).then(t.bind(null,405)),"v-5ceaba30":()=>t.e(77).then(t.bind(null,406)),"v-9d907de4":()=>t.e(78).then(t.bind(null,407)),"v-3b15d3d5":()=>t.e(76).then(t.bind(null,408)),"v-3e61f4a4":()=>t.e(79).then(t.bind(null,409)),"v-1be9ae19":()=>t.e(80).then(t.bind(null,410)),"v-1cd573e8":()=>t.e(81).then(t.bind(null,411)),"v-04bd74da":()=>t.e(82).then(t.bind(null,412)),"v-57dee333":()=>t.e(83).then(t.bind(null,413)),"v-1c37d794":()=>t.e(84).then(t.bind(null,414)),"v-11fc5ceb":()=>t.e(85).then(t.bind(null,415)),"v-0a26fed9":()=>t.e(86).then(t.bind(null,416)),"v-4768b646":()=>t.e(87).then(t.bind(null,417)),"v-cc0ff3e4":()=>t.e(88).then(t.bind(null,418)),"v-5fdcd749":()=>t.e(89).then(t.bind(null,419)),"v-358d30aa":()=>t.e(90).then(t.bind(null,420)),"v-af0f602e":()=>t.e(91).then(t.bind(null,421)),"v-5f9ee188":()=>t.e(92).then(t.bind(null,422)),"v-145b3250":()=>t.e(93).then(t.bind(null,423)),"v-3fcbcc4a":()=>t.e(94).then(t.bind(null,424)),"v-25736eb0":()=>t.e(95).then(t.bind(null,425)),"v-50873160":()=>t.e(96).then(t.bind(null,426)),"v-ddbd9348":()=>t.e(97).then(t.bind(null,427)),"v-8eb7b8b2":()=>t.e(98).then(t.bind(null,428)),"v-621fc681":()=>t.e(99).then(t.bind(null,429)),"v-52852f48":()=>t.e(100).then(t.bind(null,430)),"v-9f196f3c":()=>t.e(101).then(t.bind(null,431)),"v-4e6c610e":()=>t.e(102).then(t.bind(null,432)),"v-6d6cd2d3":()=>t.e(103).then(t.bind(null,433)),"v-6a714abe":()=>t.e(104).then(t.bind(null,434)),"v-3e4b87bc":()=>t.e(105).then(t.bind(null,435)),"v-7e3a34cb":()=>t.e(106).then(t.bind(null,436)),"v-0ba73a86":()=>t.e(107).then(t.bind(null,437)),"v-4828f3e8":()=>t.e(108).then(t.bind(null,438)),"v-08213124":()=>t.e(109).then(t.bind(null,439)),"v-0aa835c0":()=>t.e(110).then(t.bind(null,440)),"v-c96a83c6":()=>t.e(111).then(t.bind(null,441)),"v-48513a41":()=>t.e(112).then(t.bind(null,442)),"v-33781e61":()=>t.e(113).then(t.bind(null,443)),"v-34aea119":()=>t.e(116).then(t.bind(null,444)),"v-371f7877":()=>t.e(117).then(t.bind(null,445)),"v-7bbab4e8":()=>t.e(119).then(t.bind(null,446)),"v-3e2ba5ca":()=>t.e(118).then(t.bind(null,447)),"v-4c9a8daf":()=>t.e(120).then(t.bind(null,448)),"v-7fb17d6f":()=>t.e(121).then(t.bind(null,449)),"v-4f2a97f8":()=>t.e(122).then(t.bind(null,450)),"v-b9b0e048":()=>t.e(123).then(t.bind(null,451)),"v-0cbd5080":()=>t.e(124).then(t.bind(null,452)),"v-e881c4e6":()=>t.e(125).then(t.bind(null,453)),"v-d47abc7a":()=>t.e(126).then(t.bind(null,454)),"v-1609c2a2":()=>t.e(127).then(t.bind(null,455)),"v-8fb1bcce":()=>t.e(128).then(t.bind(null,456)),"v-76d59d22":()=>t.e(129).then(t.bind(null,457)),"v-198322b5":()=>t.e(130).then(t.bind(null,458)),"v-72feb9e2":()=>t.e(131).then(t.bind(null,459)),"v-e3dedec8":()=>t.e(132).then(t.bind(null,460)),"v-bb055ad2":()=>t.e(133).then(t.bind(null,461)),"v-50cc48b9":()=>t.e(134).then(t.bind(null,462)),"v-8942e32e":()=>t.e(135).then(t.bind(null,463)),"v-0558a126":()=>t.e(136).then(t.bind(null,464)),"v-61eaf91f":()=>t.e(137).then(t.bind(null,465)),"v-0c4acd47":()=>t.e(138).then(t.bind(null,466)),"v-3c9c95c2":()=>t.e(140).then(t.bind(null,467)),"v-03ab99a8":()=>t.e(139).then(t.bind(null,468)),"v-e2d9dea8":()=>t.e(141).then(t.bind(null,469)),"v-267b9391":()=>t.e(142).then(t.bind(null,470)),"v-0ed16da6":()=>t.e(144).then(t.bind(null,471)),"v-ff8a52d4":()=>t.e(143).then(t.bind(null,472)),"v-4fd4978c":()=>t.e(145).then(t.bind(null,473)),"v-ed559c8a":()=>t.e(146).then(t.bind(null,474)),"v-9293f6fe":()=>t.e(147).then(t.bind(null,475)),"v-9def6d84":()=>t.e(148).then(t.bind(null,476)),"v-a1774298":()=>t.e(149).then(t.bind(null,477)),"v-94e34874":()=>t.e(150).then(t.bind(null,478)),"v-413e5888":()=>t.e(152).then(t.bind(null,479)),"v-2b1a6bb0":()=>t.e(151).then(t.bind(null,480)),"v-212948d8":()=>t.e(153).then(t.bind(null,481)),"v-2321347c":()=>t.e(154).then(t.bind(null,482)),"v-5f62ebdd":()=>t.e(155).then(t.bind(null,483)),"v-5577614c":()=>t.e(157).then(t.bind(null,484)),"v-45d11251":()=>t.e(156).then(t.bind(null,485)),"v-0acda84f":()=>t.e(158).then(t.bind(null,486)),"v-3fae4a68":()=>t.e(159).then(t.bind(null,487)),"v-72be4f88":()=>t.e(160).then(t.bind(null,488)),"v-bbee9aae":()=>t.e(161).then(t.bind(null,489)),"v-2bd5f0c1":()=>t.e(162).then(t.bind(null,490)),"v-ee275a20":()=>t.e(163).then(t.bind(null,491)),"v-9639b96e":()=>t.e(164).then(t.bind(null,492)),"v-65d2e9dd":()=>t.e(165).then(t.bind(null,493)),"v-410d79ac":()=>t.e(166).then(t.bind(null,494)),"v-b4901270":()=>t.e(167).then(t.bind(null,495)),"v-81352ca6":()=>t.e(168).then(t.bind(null,496)),"v-01f863d2":()=>t.e(169).then(t.bind(null,497)),"v-224eac3e":()=>t.e(170).then(t.bind(null,498)),"v-146a511a":()=>t.e(171).then(t.bind(null,499)),"v-1377e2ab":()=>t.e(172).then(t.bind(null,500)),"v-17acde74":()=>t.e(173).then(t.bind(null,501)),"v-7a68118b":()=>t.e(174).then(t.bind(null,502)),"v-cd4c36e6":()=>t.e(175).then(t.bind(null,503)),"v-22193641":()=>t.e(176).then(t.bind(null,504)),"v-7e207d18":()=>t.e(177).then(t.bind(null,505)),"v-3547f7f4":()=>t.e(178).then(t.bind(null,506)),"v-6321bba8":()=>t.e(179).then(t.bind(null,507)),"v-d6281a1a":()=>t.e(180).then(t.bind(null,508)),"v-69d10f5e":()=>t.e(181).then(t.bind(null,509)),"v-0cc0fa08":()=>t.e(183).then(t.bind(null,510)),"v-a5c47462":()=>t.e(182).then(t.bind(null,511)),"v-e0c0e444":()=>t.e(184).then(t.bind(null,512)),"v-accee9b2":()=>t.e(185).then(t.bind(null,513)),"v-4645f627":()=>t.e(186).then(t.bind(null,514)),"v-22c566d9":()=>t.e(187).then(t.bind(null,515)),"v-54b9b1f0":()=>t.e(188).then(t.bind(null,516)),"v-79db4046":()=>t.e(189).then(t.bind(null,517)),"v-3437b616":()=>t.e(190).then(t.bind(null,518)),"v-26fbe376":()=>t.e(191).then(t.bind(null,519)),"v-81be5d5c":()=>t.e(193).then(t.bind(null,520)),"v-0fab340e":()=>t.e(192).then(t.bind(null,521)),"v-17a3e06a":()=>t.e(195).then(t.bind(null,522)),"v-24edffca":()=>t.e(194).then(t.bind(null,523)),"v-6c1f0267":()=>t.e(196).then(t.bind(null,524)),"v-4a1b1da4":()=>t.e(197).then(t.bind(null,525)),"v-e1f5ee38":()=>t.e(198).then(t.bind(null,526)),"v-3b17764e":()=>t.e(199).then(t.bind(null,527)),"v-32e2c4a0":()=>t.e(200).then(t.bind(null,528)),"v-a173582a":()=>t.e(201).then(t.bind(null,529)),"v-3b0ec81b":()=>t.e(202).then(t.bind(null,530)),"v-7c5ca52a":()=>t.e(203).then(t.bind(null,531)),"v-1d3b852d":()=>t.e(204).then(t.bind(null,532)),"v-23710361":()=>t.e(205).then(t.bind(null,533)),"v-769e6dac":()=>t.e(206).then(t.bind(null,534)),"v-215e8422":()=>t.e(207).then(t.bind(null,535)),"v-173573e4":()=>t.e(208).then(t.bind(null,536)),"v-c577cb28":()=>t.e(209).then(t.bind(null,537)),"v-5d4c33ae":()=>t.e(210).then(t.bind(null,538)),"v-c211ae4e":()=>t.e(211).then(t.bind(null,539)),"v-5cc9cd12":()=>t.e(212).then(t.bind(null,540)),"v-ceb7a5d6":()=>t.e(213).then(t.bind(null,541)),"v-46a7403e":()=>t.e(214).then(t.bind(null,542)),"v-f2eceaa8":()=>t.e(215).then(t.bind(null,543)),"v-17bfcefe":()=>t.e(216).then(t.bind(null,544)),"v-1605ad46":()=>t.e(217).then(t.bind(null,545)),"v-01a08eb8":()=>t.e(218).then(t.bind(null,546)),"v-05f2fd30":()=>t.e(219).then(t.bind(null,547)),"v-bbf26266":()=>t.e(220).then(t.bind(null,548)),"v-c81ae684":()=>t.e(222).then(t.bind(null,549)),"v-96855454":()=>t.e(221).then(t.bind(null,550)),"v-4291a2a5":()=>t.e(224).then(t.bind(null,551)),"v-f6070724":()=>t.e(223).then(t.bind(null,552)),"v-0ddafc4e":()=>t.e(225).then(t.bind(null,553)),"v-685447f2":()=>t.e(226).then(t.bind(null,554)),"v-044944ba":()=>t.e(227).then(t.bind(null,555)),"v-c8d7917a":()=>t.e(228).then(t.bind(null,556)),"v-150471d8":()=>t.e(229).then(t.bind(null,557)),"v-cd5ad1da":()=>t.e(230).then(t.bind(null,558)),"v-3cd3d4c7":()=>t.e(231).then(t.bind(null,559)),"v-42cd3ee3":()=>t.e(232).then(t.bind(null,560)),"v-397483cd":()=>t.e(234).then(t.bind(null,561)),"v-307c0396":()=>t.e(233).then(t.bind(null,562)),"v-50732f42":()=>t.e(235).then(t.bind(null,563)),"v-4f7538bc":()=>t.e(236).then(t.bind(null,564)),"v-79207f6a":()=>t.e(237).then(t.bind(null,565)),"v-e97a13f8":()=>t.e(238).then(t.bind(null,566)),"v-35c33a67":()=>t.e(239).then(t.bind(null,567)),"v-0f0c029a":()=>t.e(240).then(t.bind(null,568)),"v-c3849332":()=>t.e(241).then(t.bind(null,569)),"v-26b135d0":()=>t.e(242).then(t.bind(null,570)),"v-03aac67e":()=>t.e(243).then(t.bind(null,571)),"v-728ffe5c":()=>t.e(115).then(t.bind(null,572)),"v-32b59ad8":()=>t.e(245).then(t.bind(null,573)),"v-01106406":()=>t.e(246).then(t.bind(null,574)),"v-7cf7d88f":()=>t.e(247).then(t.bind(null,575)),"v-58a84061":()=>t.e(248).then(t.bind(null,576)),"v-50e23e90":()=>t.e(249).then(t.bind(null,577)),"v-0655e210":()=>t.e(250).then(t.bind(null,578)),"v-2dd6bfbf":()=>t.e(251).then(t.bind(null,579)),"v-c5fea8b6":()=>t.e(252).then(t.bind(null,580)),"v-f0de70a4":()=>t.e(253).then(t.bind(null,581)),"v-a1ea609c":()=>t.e(254).then(t.bind(null,582)),"v-01beeb53":()=>t.e(255).then(t.bind(null,583)),"v-02cdca3c":()=>t.e(256).then(t.bind(null,584)),"v-361b4710":()=>t.e(258).then(t.bind(null,585)),"v-42669813":()=>t.e(257).then(t.bind(null,586)),"v-062eca5c":()=>t.e(259).then(t.bind(null,587)),"v-31c26ebc":()=>t.e(260).then(t.bind(null,588)),"v-271f65bc":()=>t.e(261).then(t.bind(null,589)),"v-0fcc2923":()=>t.e(262).then(t.bind(null,590)),"v-44b8a6d8":()=>t.e(263).then(t.bind(null,591)),"v-87928544":()=>t.e(264).then(t.bind(null,592)),"v-8c73d138":()=>t.e(265).then(t.bind(null,593)),"v-1f7eea30":()=>t.e(266).then(t.bind(null,594)),"v-d8eae0b2":()=>t.e(267).then(t.bind(null,595)),"v-d427c83c":()=>t.e(268).then(t.bind(null,596)),"v-66e5c5d4":()=>t.e(269).then(t.bind(null,597)),"v-8ca31366":()=>t.e(270).then(t.bind(null,598)),"v-0d7e111b":()=>t.e(271).then(t.bind(null,599)),"v-75371f4a":()=>t.e(272).then(t.bind(null,600)),"v-1240e29a":()=>t.e(274).then(t.bind(null,601)),"v-7a859bad":()=>t.e(273).then(t.bind(null,602)),"v-6f3304ca":()=>t.e(276).then(t.bind(null,603)),"v-032678fa":()=>t.e(275).then(t.bind(null,604)),"v-29a02ce2":()=>t.e(277).then(t.bind(null,605)),"v-60b82d43":()=>t.e(278).then(t.bind(null,606)),"v-b87222ae":()=>t.e(280).then(t.bind(null,607)),"v-0bb0b492":()=>t.e(279).then(t.bind(null,608)),"v-58999b90":()=>t.e(281).then(t.bind(null,609)),"v-5f8b8f7b":()=>t.e(282).then(t.bind(null,610)),"v-5464c35d":()=>t.e(283).then(t.bind(null,611)),"v-444484c2":()=>t.e(284).then(t.bind(null,612)),"v-5c3b871e":()=>t.e(285).then(t.bind(null,613)),"v-47d644e5":()=>t.e(286).then(t.bind(null,614)),"v-f689eb36":()=>t.e(288).then(t.bind(null,615)),"v-b7a2df76":()=>t.e(287).then(t.bind(null,616)),"v-309ec2fe":()=>t.e(289).then(t.bind(null,617)),"v-43cefae9":()=>t.e(114).then(t.bind(null,618)),"v-1e816680":()=>t.e(244).then(t.bind(null,619))};function $s(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Vs=/-(\w)/g,Ns=$s(n=>n.replace(Vs,(n,e)=>e?e.toUpperCase():"")),Ws=/\B([A-Z])/g,Gs=$s(n=>n.replace(Ws,"-$1").toLowerCase()),Zs=$s(n=>n.charAt(0).toUpperCase()+n.slice(1));function Xs(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Zs(Ns(e))):n(Zs(e))||n(Gs(e))}const Ys=Object.assign({},Rs,Us),Ks=n=>Ys[n],Qs=n=>Us[n],ni=n=>Rs[n],ei=n=>Rt.component(n);function ti(n){return Xs(Qs,n)}function oi(n){return Xs(ni,n)}function ri(n){return Xs(Ks,n)}function ai(n){return Xs(ei,n)}function si(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ai(n)&&ri(n)){const e=await ri(n)();Rt.component(n,e.default)}}))}function ii(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var li=t(91),ci=t.n(li),di=t(92),ui=t.n(di),pi={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ui()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=hi(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=fi(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ci()([{name:"description",content:this.$description}],n,this.siteMeta,gi)},updateCanonicalLink(){mi(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",hi(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){fi(null,this.currentMetaTags),mi()}};function mi(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function hi(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function fi(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function gi(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var vi=t(50),bi={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(vi)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),o=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],s=e[n+1],i=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(i&&l!==decodeURIComponent(a.hash)){const t=a;if(r===o)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}};t(233),t(234);class yi{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var xi={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new yi).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},wi="auto",Ei="zoom-in",Si="zoom-out",ki="grab",ji="move";function Ti(n,e,t){var o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};o?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Ai(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Bi(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Fi(n,e,t){!function(n){var e=Ci,t=Pi;if(n.transition){var o=n.transition;delete n.transition,n[e]=o}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var o=n.style,r={};for(var a in e)t&&(r[a]=o[a]||""),o[a]=e[a];return r}var Ci="transition",Pi="transform",zi="transform",Ii="transitionend";var Ji=function(){},qi={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ji,onClose:Ji,onGrab:Ji,onMove:Ji,onRelease:Ji,onBeforeOpen:Ji,onBeforeClose:Ji,onBeforeGrab:Ji,onBeforeRelease:Ji,onImageLoading:Ji,onImageLoaded:Ji},Di={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),_i(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var o=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(r)>=a||Math.abs(o)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Mi(n)&&!_i(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Mi(n)&&!_i(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,o=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,o)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,o=e.clientY;this.move(t,o)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Mi(n){return 0===n.button}function _i(n){return n.metaKey||n.ctrlKey}var Oi={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Fi(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ti(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Fi(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Li="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Hi=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),Ri=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n},Ui={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Bi(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,o=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?ki:Si,transition:zi+"\n        "+o+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Fi(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Fi(this.el,{transform:"none"})},grab:function(n,e,t){var o=$i(),r=o.x-n,a=o.y-e;Fi(this.el,{cursor:ji,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var o=$i(),r=o.x-n,a=o.y-e;Fi(this.el,{transition:zi,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Fi(this.el,this.styleClose)},restoreOpenStyle:function(){Fi(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=$i(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,o=this.instance.options,r=o.customSize,a=o.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":Li(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var s=this.rect.width/2,i=this.rect.height/2,l=$i(),c={x:l.x-s,y:l.y-i},d=c.x/s,u=c.y/i,p=a+Math.min(d,u);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function $i(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Vi(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(o){Ti(n,o,e[o],t)}))}var Ni=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ui),this.overlay=Object.create(Oi),this.handler=Object.create(Di),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Ri({},qi,e),this.overlay.init(this),this.handler.init(this)}return Hi(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Ei,Ti(n,"click",this.handler.click),this.options.preloadImage&&Ai(Bi(n)));return this}},{key:"config",value:function(n){return n?(Ri(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var o="string"==typeof n?document.querySelector(n):n;if("IMG"===o.tagName){if(this.options.onBeforeOpen(o),this.target.init(o,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(o),Ai(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ti(document,"scroll",this.handler.scroll),Ti(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ti(window,"resize",this.handler.resizeWindow);var a=function n(){Ti(o,Ii,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Vi(document,e.handler,!0),t(o)};return Ti(o,Ii,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=wi,this.overlay.fadeOut(),this.target.zoomOut(),Ti(document,"scroll",this.handler.scroll,!1),Ti(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ti(window,"resize",this.handler.resizeWindow,!1);var o=function o(){Ti(t,Ii,o,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Vi(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ti(t,Ii,o),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var a=function n(){Ti(r,Ii,n,!1),o(r)};return Ti(r,Ii,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=ji,this.target.move(n,e,t);var r=this.target.el,a=function n(){Ti(r,Ii,n,!1),o(r)};return Ti(r,Ii,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=wi,this.target.restoreOpenStyle();var o=function o(){Ti(t,Ii,o,!1),n.lock=!1,n.released=!0,e(t)};return Ti(t,Ii,o),this}}}]),n}();const Wi=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Gi=Number("500");class Zi{constructor(){this.instance=new Ni(Wi)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=Gi){setTimeout(()=>this.update(n),e)}}var Xi={watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new Zi,this.$vuepress.zooming.updateDelay()}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var o=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&o.firstChild?o.insertBefore(r,o.firstChild):o.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Yi={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Ki={},Qi=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},nl=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Yi[n]},el=function n(e,t,o){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),o&&o.forEach((function(e){var t=e.tag,o=e.attrs,a=e.children;r.appendChild(n(t,o,a))})),r},tl=function(n,e,t){var o,r=(o=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(o));return 1!==r.length||t?r:r[0]},ol=function(n,e){var t,o,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),s=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:s&&s[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};i.htmlTpl=Qi(i.html),i.jsTpl=(t=i.js,o=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(o,"\n})")),i.script=function(n,e){var t=n.split(/export\s+default/),o="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(o,{presets:["es2015"]}).code:o,a=[eval][0](r);return a.template=e,a}(i.js,i.html);var l=nl("vue");return i.jsLib.unshift(l),i},rl=function(n,e){var t,o=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),s={css:o&&o[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return s.htmlTpl=s.html,s.jsTpl=s.js,s.script=(t=s.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),s},al=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function sl(){var n=tl(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=tl(n,"vuepress-plugin-demo-block__code"),t=tl(n,"vuepress-plugin-demo-block__display"),o=tl(n,"vuepress-plugin-demo-block__footer"),r=tl(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),s=decodeURIComponent(n.dataset.config),i=decodeURIComponent(n.dataset.type);s=s?JSON.parse(s):{};var l=e.querySelector("div").clientHeight,c="react"===i?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,o="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(o))(),a={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:al(n),htmlTpl:Qi("")},s=nl("react"),i=nl("reactDOM");return a.jsLib.unshift(s,i),a}(a,s):"vanilla"===i?rl(a,s):ol(a,s),d=el("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(o.appendChild(d),d.addEventListener("click",il.bind(null,d,l,e,o)),nl("jsfiddle")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,r=n.jsLib,a=n.cssLib,s=r.concat(a).concat(nl("cssLib")).concat(nl("jsLib")).join(",");return el("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:o}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:s}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),nl("codepen")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,r=n.jsLib,a=n.cssLib,s=JSON.stringify({css:e,html:t,js:o,js_external:r.concat(nl("jsLib")).join(";"),css_external:a.concat(nl("cssLib")).join(";"),layout:nl("codepenLayout"),js_pre_processor:nl("codepenJsProcessor"),editors:nl("codepenEditors")});return el("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:s}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==s.horizontal?s.horizontal:nl("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Ki[n]){var e=el("style",{innerHTML:n});document.body.appendChild(e),Ki[n]=!0}}(c.css),"react"===i)ReactDOM.render(React.createElement(c.js),r);else if("vue"===i){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===i&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){sl()}),300)}function il(n,e,t,o){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?o.classList.add("vuepress-plugin-demo-block__show-link"):o.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var ll={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",jsfiddle:!0,codepen:!0,horizontal:!1},sl()},updated:function(){sl()}},cl=t(24),dl=t.n(cl),ul=[pi,bi,xi,Xi,ll,{mounted(){dl.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Rt.component(n.name)||dl.a.start(),t()}),this.$router.afterEach(()=>{dl.a.done(),this.isSidebarOpen=!1})}}],pl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ii("layout",n),Rt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ml=t(3),hl=Object(ml.a)(pl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(hl,"mixins",ul);const fl=[{name:"v-ccb821ec",path:"/pages/d63a9a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-ccb821ec").then(t)}},{path:"/pages/d63a9a/index.html",redirect:"/pages/d63a9a/"},{path:"/01. 🍎 ES6 变量声明相关.html",redirect:"/pages/d63a9a/"},{name:"v-696b0a49",path:"/front-end/roadmap/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-696b0a49").then(t)}},{path:"/front-end/roadmap/index.html",redirect:"/front-end/roadmap/"},{path:"/01. 📚 前端笔记/01. 🗺 前端学习路线.html",redirect:"/front-end/roadmap/"},{name:"v-23ff1010",path:"/front-end/beginning/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-23ff1010").then(t)}},{path:"/front-end/beginning/index.html",redirect:"/front-end/beginning/"},{path:"/01. 📚 前端笔记/02. 💻 前端学习笔记/100. 🚶 前端入门基础.html",redirect:"/front-end/beginning/"},{name:"v-5e9f586b",path:"/front-end/stable/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5e9f586b").then(t)}},{path:"/front-end/stable/index.html",redirect:"/front-end/stable/"},{path:"/01. 📚 前端笔记/02. 💻 前端学习笔记/101. 🚶🏻 前端巩固基础.html",redirect:"/front-end/stable/"},{name:"v-636b316c",path:"/front-end/core-frame/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-636b316c").then(t)}},{path:"/front-end/core-frame/index.html",redirect:"/front-end/core-frame/"},{path:"/01. 📚 前端笔记/02. 💻 前端学习笔记/105. 🏃 前端核心框架.html",redirect:"/front-end/core-frame/"},{name:"v-34e195e9",path:"/front-end/algorithm/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-34e195e9").then(t)}},{path:"/front-end/algorithm/index.html",redirect:"/front-end/algorithm/"},{path:"/01. 📚 前端笔记/02. 💻 前端学习笔记/120. 🕹 前端算法指北.html",redirect:"/front-end/algorithm/"},{name:"v-8e2f20b6",path:"/pages/46470d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-8e2f20b6").then(t)}},{path:"/pages/46470d/index.html",redirect:"/pages/46470d/"},{path:"/01. 📚 前端笔记/03. 🗺️ 前端学习路线相关/01. 🍎 计算机网络.html",redirect:"/pages/46470d/"},{name:"v-71a62a83",path:"/pages/5bded3/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-71a62a83").then(t)}},{path:"/pages/5bded3/index.html",redirect:"/pages/5bded3/"},{path:"/01. 📚 前端笔记/100. ⚖️ 前端编码规范相关/10. 🛟  HTML 5 样式指南代码约定.html",redirect:"/pages/5bded3/"},{name:"v-5a8ed19a",path:"/pages/176ef8/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5a8ed19a").then(t)}},{path:"/pages/176ef8/index.html",redirect:"/pages/176ef8/"},{path:"/01. 📚 前端笔记/100. ⚖️ 前端编码规范相关/20. 🍽 JavaScript 代码规范.html",redirect:"/pages/176ef8/"},{name:"v-64d5b56e",path:"/pages/f582e8/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-64d5b56e").then(t)}},{path:"/pages/f582e8/index.html",redirect:"/pages/f582e8/"},{path:"/01. 📚 前端笔记/100. ⚖️ 前端编码规范相关/99. 🧰 前端开发工程化.html",redirect:"/pages/f582e8/"},{name:"v-6c5d0ea6",path:"/front-end/interview/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6c5d0ea6").then(t)}},{path:"/front-end/interview/index.html",redirect:"/front-end/interview/"},{path:"/01. 📚 前端笔记/20. 🪞 前端面试题收集.html",redirect:"/front-end/interview/"},{name:"v-c5dd7ffa",path:"/front-end/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c5dd7ffa").then(t)}},{path:"/front-end/index.html",redirect:"/front-end/"},{path:"/01. 📚 前端笔记/",redirect:"/front-end/"},{name:"v-27e10230",path:"/about/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-27e10230").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/10. 🪧 关于/",redirect:"/about/"},{name:"v-489164fc",path:"/pages/c70272/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-489164fc").then(t)}},{path:"/pages/c70272/index.html",redirect:"/pages/c70272/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/01. 📰 HTML 基础.html",redirect:"/pages/c70272/"},{name:"v-157bc241",path:"/pages/286aba/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-157bc241").then(t)}},{path:"/pages/286aba/index.html",redirect:"/pages/286aba/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/03. 🍣 HTML 文本元素.html",redirect:"/pages/286aba/"},{name:"v-36daa0e9",path:"/pages/64a1a7/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-36daa0e9").then(t)}},{path:"/pages/64a1a7/index.html",redirect:"/pages/64a1a7/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/04. 🫕 HTML 结构元素.html",redirect:"/pages/64a1a7/"},{name:"v-fb81fc8a",path:"/pages/7acc1d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-fb81fc8a").then(t)}},{path:"/pages/7acc1d/index.html",redirect:"/pages/7acc1d/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/05. 🥙 HTML 更多元素.html",redirect:"/pages/7acc1d/"},{name:"v-4f5c3eb5",path:"/pages/bb41df/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4f5c3eb5").then(t)}},{path:"/pages/bb41df/index.html",redirect:"/pages/bb41df/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/07. 🍱 HTML 块元素和行内元素.html",redirect:"/pages/bb41df/"},{name:"v-fecb5b10",path:"/pages/3886ef/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-fecb5b10").then(t)}},{path:"/pages/3886ef/index.html",redirect:"/pages/3886ef/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/08. 🍳 HTML 类与 id.html",redirect:"/pages/3886ef/"},{name:"v-47839f38",path:"/pages/42605a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-47839f38").then(t)}},{path:"/pages/42605a/index.html",redirect:"/pages/42605a/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/09. 🧅 HTML 头部元素.html",redirect:"/pages/42605a/"},{name:"v-55ad45a1",path:"/pages/aa23b5/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-55ad45a1").then(t)}},{path:"/pages/aa23b5/index.html",redirect:"/pages/aa23b5/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/10. 🧀 HTML 响应式页面.html",redirect:"/pages/aa23b5/"},{name:"v-2321eb02",path:"/pages/1c9bbf/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2321eb02").then(t)}},{path:"/pages/1c9bbf/index.html",redirect:"/pages/1c9bbf/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/11. 🥨 HTML 表单元素.html",redirect:"/pages/1c9bbf/"},{name:"v-4bfbfc8f",path:"/pages/3f6201/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4bfbfc8f").then(t)}},{path:"/pages/3f6201/index.html",redirect:"/pages/3f6201/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/15. 🌯 HTML canvans 画布与 SVG.html",redirect:"/pages/3f6201/"},{name:"v-f1fc15c0",path:"/pages/6bdb29/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f1fc15c0").then(t)}},{path:"/pages/6bdb29/index.html",redirect:"/pages/6bdb29/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/20. ⚡️ HTML5  语义化标签.html",redirect:"/pages/6bdb29/"},{name:"v-18f501c4",path:"/pages/30c725/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-18f501c4").then(t)}},{path:"/pages/30c725/index.html",redirect:"/pages/30c725/"},{path:"/100. 🚶 前端入门基础/10. 🕸 HTML/40. 🍗 HTML5 API.html",redirect:"/pages/30c725/"},{name:"v-eaa28632",path:"/pages/4d5e63/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-eaa28632").then(t)}},{path:"/pages/4d5e63/index.html",redirect:"/pages/4d5e63/"},{path:"/100. 🚶 前端入门基础/100. 🛤 Git 版本控制/01. 🚏 Git 版本控制学习路线.html",redirect:"/pages/4d5e63/"},{name:"v-6e674884",path:"/pages/3b80ae/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6e674884").then(t)}},{path:"/pages/3b80ae/index.html",redirect:"/pages/3b80ae/"},{path:"/100. 🚶 前端入门基础/100. 🛤 Git 版本控制/10. 🚗 VCS 版本控制系统.html",redirect:"/pages/3b80ae/"},{name:"v-bb016a66",path:"/pages/f2d32b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-bb016a66").then(t)}},{path:"/pages/f2d32b/index.html",redirect:"/pages/f2d32b/"},{path:"/100. 🚶 前端入门基础/100. 🛤 Git 版本控制/20. 🚚 一些实际工作模型.html",redirect:"/pages/f2d32b/"},{name:"v-2b3ae24e",path:"/pages/823b22/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2b3ae24e").then(t)}},{path:"/pages/823b22/index.html",redirect:"/pages/823b22/"},{path:"/100. 🚶 前端入门基础/100. 🛤 Git 版本控制/25. 🏎 Git 的基本使用命令.html",redirect:"/pages/823b22/"},{name:"v-cccab4ca",path:"/pages/ffbab0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-cccab4ca").then(t)}},{path:"/pages/ffbab0/index.html",redirect:"/pages/ffbab0/"},{path:"/100. 🚶 前端入门基础/100. 🛤 Git 版本控制/30. 🚒 Git 的 HEAD、master 与 branch.html",redirect:"/pages/ffbab0/"},{name:"v-b48c1564",path:"/pages/0fa378/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-b48c1564").then(t)}},{path:"/pages/0fa378/index.html",redirect:"/pages/0fa378/"},{path:"/100. 🚶 前端入门基础/100. 🛤 Git 版本控制/40. 🚕 Git 的 push .html",redirect:"/pages/0fa378/"},{name:"v-e8174f44",path:"/pages/f50277/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e8174f44").then(t)}},{path:"/pages/f50277/index.html",redirect:"/pages/f50277/"},{path:"/100. 🚶 前端入门基础/110. 👣 前端基础辅助/10. 🗂 JSON 笔记.html",redirect:"/pages/f50277/"},{name:"v-e993351a",path:"/pages/3ac8a3/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e993351a").then(t)}},{path:"/pages/3ac8a3/index.html",redirect:"/pages/3ac8a3/"},{path:"/100. 🚶 前端入门基础/110. 👣 前端基础辅助/20. 📕 jQuery 笔记.html",redirect:"/pages/3ac8a3/"},{name:"v-4adbdfdc",path:"/pages/bade75/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4adbdfdc").then(t)}},{path:"/pages/bade75/index.html",redirect:"/pages/bade75/"},{path:"/100. 🚶 前端入门基础/110. 👣 前端基础辅助/40. 📐Less 笔记.html",redirect:"/pages/bade75/"},{name:"v-586acead",path:"/pages/17c13a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-586acead").then(t)}},{path:"/pages/17c13a/index.html",redirect:"/pages/17c13a/"},{path:"/100. 🚶 前端入门基础/110. 👣 前端基础辅助/50. 🅱️ Bootstrap 使用笔记.html",redirect:"/pages/17c13a/"},{name:"v-2bfb06ae",path:"/pages/7fb68c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2bfb06ae").then(t)}},{path:"/pages/7fb68c/index.html",redirect:"/pages/7fb68c/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/01. 📖 CSS 基本语法.html",redirect:"/pages/7fb68c/"},{name:"v-65651d2c",path:"/pages/eb2dd9/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-65651d2c").then(t)}},{path:"/pages/eb2dd9/index.html",redirect:"/pages/eb2dd9/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/02. 🥽 CSS 单位.html",redirect:"/pages/eb2dd9/"},{name:"v-7d17d9c4",path:"/pages/82c43f/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7d17d9c4").then(t)}},{path:"/pages/82c43f/index.html",redirect:"/pages/82c43f/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/100. 🗃 CSS 弹性盒子模型.html",redirect:"/pages/82c43f/"},{name:"v-8458d62a",path:"/pages/8d9180/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-8458d62a").then(t)}},{path:"/pages/8d9180/index.html",redirect:"/pages/8d9180/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/10. 🧾 CSS 列表布局示例.html",redirect:"/pages/8d9180/"},{name:"v-5c2e274a",path:"/pages/a6e1ef/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5c2e274a").then(t)}},{path:"/pages/a6e1ef/index.html",redirect:"/pages/a6e1ef/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/20. 🌬 CSS 浮动布局示例.html",redirect:"/pages/a6e1ef/"},{name:"v-f3a6bcd4",path:"/pages/bf8c69/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f3a6bcd4").then(t)}},{path:"/pages/bf8c69/index.html",redirect:"/pages/bf8c69/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/30. 🚏 CSS 定位实例.html",redirect:"/pages/bf8c69/"},{name:"v-f80fbb16",path:"/pages/8f342b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f80fbb16").then(t)}},{path:"/pages/8f342b/index.html",redirect:"/pages/8f342b/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/40. 📦 CSS 弹性盒布局实例.html",redirect:"/pages/8f342b/"},{name:"v-943d629a",path:"/pages/508db5/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-943d629a").then(t)}},{path:"/pages/508db5/index.html",redirect:"/pages/508db5/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/50. 💙 使用 CSS 绘制图形.html",redirect:"/pages/508db5/"},{name:"v-7aced672",path:"/pages/74c5a0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7aced672").then(t)}},{path:"/pages/74c5a0/index.html",redirect:"/pages/74c5a0/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/60. ❤️ CSS 动画示例.html",redirect:"/pages/74c5a0/"},{name:"v-6e17c6b9",path:"/pages/59c3c4/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6e17c6b9").then(t)}},{path:"/pages/59c3c4/index.html",redirect:"/pages/59c3c4/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/20. 🎮 CSS 选择器.html",redirect:"/pages/59c3c4/"},{name:"v-2a227a05",path:"/pages/33f36d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2a227a05").then(t)}},{path:"/pages/33f36d/index.html",redirect:"/pages/33f36d/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/30. 🎁 CSS 盒子模型.html",redirect:"/pages/33f36d/"},{name:"v-ac317b20",path:"/pages/a8f349/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-ac317b20").then(t)}},{path:"/pages/a8f349/index.html",redirect:"/pages/a8f349/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/40. 🪁 CSS 浮动.html",redirect:"/pages/a8f349/"},{name:"v-1d792e48",path:"/pages/3fa9cc/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1d792e48").then(t)}},{path:"/pages/3fa9cc/index.html",redirect:"/pages/3fa9cc/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/50. 🧭 CSS 定位.html",redirect:"/pages/3fa9cc/"},{name:"v-49aa8c49",path:"/pages/27df4e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-49aa8c49").then(t)}},{path:"/pages/27df4e/index.html",redirect:"/pages/27df4e/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/60. 🗚 CSS 字体.html",redirect:"/pages/27df4e/"},{name:"v-1572ebde",path:"/pages/ef3d83/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1572ebde").then(t)}},{path:"/pages/ef3d83/index.html",redirect:"/pages/ef3d83/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/70. 🖼 CSS 背景.html",redirect:"/pages/ef3d83/"},{name:"v-13f3c2ee",path:"/pages/9de79a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-13f3c2ee").then(t)}},{path:"/pages/9de79a/index.html",redirect:"/pages/9de79a/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/90. 🔍 CSS 变形.html",redirect:"/pages/9de79a/"},{name:"v-c3cc3544",path:"/pages/c46d43/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c3cc3544").then(t)}},{path:"/pages/c46d43/index.html",redirect:"/pages/c46d43/"},{path:"/100. 🚶 前端入门基础/20. 🎨 CSS/80. 🐈 CSS 过渡与动画.html",redirect:"/pages/c46d43/"},{name:"v-49546196",path:"/pages/d84d57/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-49546196").then(t)}},{path:"/pages/d84d57/index.html",redirect:"/pages/d84d57/"},{path:"/100. 🚶 前端入门基础/30. 🍪 JavaScript/01. 🌱 JavaScript 基本使用.html",redirect:"/pages/d84d57/"},{name:"v-5bff9ca2",path:"/pages/b51680/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5bff9ca2").then(t)}},{path:"/pages/b51680/index.html",redirect:"/pages/b51680/"},{path:"/100. 🚶 前端入门基础/30. 🍪 JavaScript/02. 🗝 JavaScript 变量与数据类型.html",redirect:"/pages/b51680/"},{name:"v-3baa6731",path:"/pages/f8003b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3baa6731").then(t)}},{path:"/pages/f8003b/index.html",redirect:"/pages/f8003b/"},{path:"/100. 🚶 前端入门基础/30. 🍪 JavaScript/03. 🧮 JavaScript 运算符.html",redirect:"/pages/f8003b/"},{name:"v-43c073c8",path:"/pages/54cab4/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-43c073c8").then(t)}},{path:"/pages/54cab4/index.html",redirect:"/pages/54cab4/"},{path:"/100. 🚶 前端入门基础/30. 🍪 JavaScript/04. 🚰 JavaScript 流程控制.html",redirect:"/pages/54cab4/"},{name:"v-19c0f996",path:"/pages/944277/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-19c0f996").then(t)}},{path:"/pages/944277/index.html",redirect:"/pages/944277/"},{path:"/100. 🚶 前端入门基础/30. 🍪 JavaScript/05. ⚙️ JavaScript 函数.html",redirect:"/pages/944277/"},{name:"v-5aec749e",path:"/pages/93f713/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5aec749e").then(t)}},{path:"/pages/93f713/index.html",redirect:"/pages/93f713/"},{path:"/100. 🚶 前端入门基础/30. 🍪 JavaScript/100. 📒 JavaScript 基础实例.html",redirect:"/pages/93f713/"},{name:"v-bdb3a544",path:"/pages/f88075/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-bdb3a544").then(t)}},{path:"/pages/f88075/index.html",redirect:"/pages/f88075/"},{path:"/100. 🚶 前端入门基础/30. 🍪 JavaScript/50. 🔭 JavaScript 作用域 .html",redirect:"/pages/f88075/"},{name:"v-44f445c1",path:"/pages/519b8a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-44f445c1").then(t)}},{path:"/pages/519b8a/index.html",redirect:"/pages/519b8a/"},{path:"/101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/10. 🥯 ES6 的变量与常量.html",redirect:"/pages/519b8a/"},{name:"v-9cb66582",path:"/pages/ce93cb/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-9cb66582").then(t)}},{path:"/pages/ce93cb/index.html",redirect:"/pages/ce93cb/"},{path:"/101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/20. 🥖 ES6 的模版字符串.html",redirect:"/pages/ce93cb/"},{name:"v-586b2e40",path:"/pages/4f8b56/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-586b2e40").then(t)}},{path:"/pages/4f8b56/index.html",redirect:"/pages/4f8b56/"},{path:"/101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/30. 🥐 ES6 箭头函数与函数的默认参数.html",redirect:"/pages/4f8b56/"},{name:"v-e275eb9c",path:"/pages/876bd2/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e275eb9c").then(t)}},{path:"/pages/876bd2/index.html",redirect:"/pages/876bd2/"},{path:"/101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/40. 🥞 ES6 对象.html",redirect:"/pages/876bd2/"},{name:"v-c5c30270",path:"/pages/4e50dd/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c5c30270").then(t)}},{path:"/pages/4e50dd/index.html",redirect:"/pages/4e50dd/"},{path:"/101. 🚶🏻 前端巩固基础/10. 🌱 NodeJS 基本使用.html",redirect:"/pages/4e50dd/"},{name:"v-3ef35fa2",path:"/pages/b7cfae/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3ef35fa2").then(t)}},{path:"/pages/b7cfae/index.html",redirect:"/pages/b7cfae/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/10. 🔐 JavaScript Object 对象基础知识.html",redirect:"/pages/b7cfae/"},{name:"v-2ed9553b",path:"/pages/01d74c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2ed9553b").then(t)}},{path:"/pages/01d74c/index.html",redirect:"/pages/01d74c/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/11. ⌛️ JavaScript 对象的复制与引用.html",redirect:"/pages/01d74c/"},{name:"v-2cb1cf16",path:"/pages/d20597/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2cb1cf16").then(t)}},{path:"/pages/d20597/index.html",redirect:"/pages/d20597/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/12. 🧭  JavaScript 垃圾回收机制.html",redirect:"/pages/d20597/"},{name:"v-f88617ea",path:"/pages/a661c0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f88617ea").then(t)}},{path:"/pages/a661c0/index.html",redirect:"/pages/a661c0/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/13. 📡 JavaScript 对象方法.html",redirect:"/pages/a661c0/"},{name:"v-7d208927",path:"/pages/42cfe9/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7d208927").then(t)}},{path:"/pages/42cfe9/index.html",redirect:"/pages/42cfe9/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/14. 💾 JavaScript 对象构造器.html",redirect:"/pages/42cfe9/"},{name:"v-5ceaba30",path:"/pages/a17557/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5ceaba30").then(t)}},{path:"/pages/a17557/index.html",redirect:"/pages/a17557/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/16. 🗽 JavaScript symbol 类型.html",redirect:"/pages/a17557/"},{name:"v-9d907de4",path:"/pages/5d0f4e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-9d907de4").then(t)}},{path:"/pages/5d0f4e/index.html",redirect:"/pages/5d0f4e/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/17. ⏳ JavaScript 对象与原始值的转换.html",redirect:"/pages/5d0f4e/"},{name:"v-3b15d3d5",path:"/pages/058cb5/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3b15d3d5").then(t)}},{path:"/pages/058cb5/index.html",redirect:"/pages/058cb5/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/15. 🔗 JavaScript 对象可选链.html",redirect:"/pages/058cb5/"},{name:"v-3e61f4a4",path:"/pages/1f8eeb/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3e61f4a4").then(t)}},{path:"/pages/1f8eeb/index.html",redirect:"/pages/1f8eeb/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/18. 💡 JavaScript 对象属性标志和属性描述符.html",redirect:"/pages/1f8eeb/"},{name:"v-1be9ae19",path:"/pages/6ea59d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1be9ae19").then(t)}},{path:"/pages/6ea59d/index.html",redirect:"/pages/6ea59d/"},{path:"/101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/19. 🔦 JavaScript 对象的访问器属性和描述符.html",redirect:"/pages/6ea59d/"},{name:"v-1cd573e8",path:"/pages/75d69a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1cd573e8").then(t)}},{path:"/pages/75d69a/index.html",redirect:"/pages/75d69a/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/20. ⏺ JavaScript 原始类型的方法.html",redirect:"/pages/75d69a/"},{name:"v-04bd74da",path:"/pages/f89962/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-04bd74da").then(t)}},{path:"/pages/f89962/index.html",redirect:"/pages/f89962/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/21. 🔢 JavaScript 数字类型.html",redirect:"/pages/f89962/"},{name:"v-57dee333",path:"/pages/33f8b7/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-57dee333").then(t)}},{path:"/pages/33f8b7/index.html",redirect:"/pages/33f8b7/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/22. ♒️ JavaScript 字符串.html",redirect:"/pages/33f8b7/"},{name:"v-1c37d794",path:"/pages/e6c21b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1c37d794").then(t)}},{path:"/pages/e6c21b/index.html",redirect:"/pages/e6c21b/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/24. 🔃 JavaScript 数组.html",redirect:"/pages/e6c21b/"},{name:"v-11fc5ceb",path:"/pages/2c7626/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-11fc5ceb").then(t)}},{path:"/pages/2c7626/index.html",redirect:"/pages/2c7626/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/25. 🔀 JavaScript 可迭代对象.html",redirect:"/pages/2c7626/"},{name:"v-0a26fed9",path:"/pages/ca2625/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0a26fed9").then(t)}},{path:"/pages/ca2625/index.html",redirect:"/pages/ca2625/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/26. 🔂 JavaScript 映射与集合.html",redirect:"/pages/ca2625/"},{name:"v-4768b646",path:"/pages/5de515/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4768b646").then(t)}},{path:"/pages/5de515/index.html",redirect:"/pages/5de515/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/27. 🔄 JavaScript 弱映射与弱集合.html",redirect:"/pages/5de515/"},{name:"v-cc0ff3e4",path:"/pages/aa670e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-cc0ff3e4").then(t)}},{path:"/pages/aa670e/index.html",redirect:"/pages/aa670e/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/28. 🔀 JavaScript 更多迭代方法.html",redirect:"/pages/aa670e/"},{name:"v-5fdcd749",path:"/pages/62fb3f/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5fdcd749").then(t)}},{path:"/pages/62fb3f/index.html",redirect:"/pages/62fb3f/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/29. 📶 JavaScript 解构赋值.html",redirect:"/pages/62fb3f/"},{name:"v-358d30aa",path:"/pages/3f5e62/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-358d30aa").then(t)}},{path:"/pages/3f5e62/index.html",redirect:"/pages/3f5e62/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/30. 🆕 JavaScript 日期和时间.html",redirect:"/pages/3f5e62/"},{name:"v-af0f602e",path:"/pages/cf5da1/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-af0f602e").then(t)}},{path:"/pages/cf5da1/index.html",redirect:"/pages/cf5da1/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/31. 🈁 JavaScript 与 JSON.html",redirect:"/pages/cf5da1/"},{name:"v-5f9ee188",path:"/pages/cb7d78/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5f9ee188").then(t)}},{path:"/pages/cb7d78/index.html",redirect:"/pages/cb7d78/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/40. 🧭 JavaScript 数组方法应用实例.html",redirect:"/pages/cb7d78/"},{name:"v-145b3250",path:"/pages/183c8c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-145b3250").then(t)}},{path:"/pages/183c8c/index.html",redirect:"/pages/183c8c/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/41. 🖇 JavaScript 映射与集合应用实例.html",redirect:"/pages/183c8c/"},{name:"v-3fcbcc4a",path:"/pages/b5e223/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3fcbcc4a").then(t)}},{path:"/pages/b5e223/index.html",redirect:"/pages/b5e223/"},{path:"/101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/42. 🗑 JavaScript 弱映射与弱集合应用实例.html",redirect:"/pages/b5e223/"},{name:"v-25736eb0",path:"/pages/acdd55/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-25736eb0").then(t)}},{path:"/pages/acdd55/index.html",redirect:"/pages/acdd55/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/01. 🚝  JavaScript 函数递归与堆栈.html",redirect:"/pages/acdd55/"},{name:"v-50873160",path:"/pages/208b1a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-50873160").then(t)}},{path:"/pages/208b1a/index.html",redirect:"/pages/208b1a/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/02. 🚅 JavaScript Rest 参数与 Spread 语法.html",redirect:"/pages/208b1a/"},{name:"v-ddbd9348",path:"/pages/7b2364/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-ddbd9348").then(t)}},{path:"/pages/7b2364/index.html",redirect:"/pages/7b2364/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/03. 🚈 JavaScript 变量作用域与闭包.html",redirect:"/pages/7b2364/"},{name:"v-8eb7b8b2",path:"/pages/b89842/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-8eb7b8b2").then(t)}},{path:"/pages/b89842/index.html",redirect:"/pages/b89842/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/04. 🚂 JavaScript 全局对象.html",redirect:"/pages/b89842/"},{name:"v-621fc681",path:"/pages/577e1c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-621fc681").then(t)}},{path:"/pages/577e1c/index.html",redirect:"/pages/577e1c/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/05. 🚆 JavaScript 函数对象.html",redirect:"/pages/577e1c/"},{name:"v-52852f48",path:"/pages/b022f1/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-52852f48").then(t)}},{path:"/pages/b022f1/index.html",redirect:"/pages/b022f1/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/06. 🚞 JavaScript 创建函数 new Function.html",redirect:"/pages/b022f1/"},{name:"v-9f196f3c",path:"/pages/222f6f/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-9f196f3c").then(t)}},{path:"/pages/222f6f/index.html",redirect:"/pages/222f6f/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/07. 🚠 JavaScript 中的调度函数.html",redirect:"/pages/222f6f/"},{name:"v-4e6c610e",path:"/pages/23d75e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4e6c610e").then(t)}},{path:"/pages/23d75e/index.html",redirect:"/pages/23d75e/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/08. 🚃 JavaScript 装饰器模式和转发.html",redirect:"/pages/23d75e/"},{name:"v-6d6cd2d3",path:"/pages/9c420b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6d6cd2d3").then(t)}},{path:"/pages/9c420b/index.html",redirect:"/pages/9c420b/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/09. 🚡 JavaScript 函数绑定.html",redirect:"/pages/9c420b/"},{name:"v-6a714abe",path:"/pages/92a793/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6a714abe").then(t)}},{path:"/pages/92a793/index.html",redirect:"/pages/92a793/"},{path:"/101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/10. 🛺 JavaScript 深入箭头函数.html",redirect:"/pages/92a793/"},{name:"v-3e4b87bc",path:"/pages/0d9ae4/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3e4b87bc").then(t)}},{path:"/pages/0d9ae4/index.html",redirect:"/pages/0d9ae4/"},{path:"/101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/10. ⛰ JavaScript 原型继承 .html",redirect:"/pages/0d9ae4/"},{name:"v-7e3a34cb",path:"/pages/63877d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7e3a34cb").then(t)}},{path:"/pages/63877d/index.html",redirect:"/pages/63877d/"},{path:"/101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/20. 🗻 JavaScript 原型构造.html",redirect:"/pages/63877d/"},{name:"v-0ba73a86",path:"/pages/439d84/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0ba73a86").then(t)}},{path:"/pages/439d84/index.html",redirect:"/pages/439d84/"},{path:"/101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/30. 🏕 JavaScript 原生的原型.html",redirect:"/pages/439d84/"},{name:"v-4828f3e8",path:"/pages/ed1ff1/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4828f3e8").then(t)}},{path:"/pages/ed1ff1/index.html",redirect:"/pages/ed1ff1/"},{path:"/101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/40. 🏜 JavaScript 原型方法.html",redirect:"/pages/ed1ff1/"},{name:"v-08213124",path:"/pages/2864a5/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-08213124").then(t)}},{path:"/pages/2864a5/index.html",redirect:"/pages/2864a5/"},{path:"/101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/01. ⚽️ JavaScript 类的基本语法.html",redirect:"/pages/2864a5/"},{name:"v-0aa835c0",path:"/pages/5bccfe/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0aa835c0").then(t)}},{path:"/pages/5bccfe/index.html",redirect:"/pages/5bccfe/"},{path:"/101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/02. 🏀 JavaScript 类继承.html",redirect:"/pages/5bccfe/"},{name:"v-c96a83c6",path:"/pages/e02f65/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c96a83c6").then(t)}},{path:"/pages/e02f65/index.html",redirect:"/pages/e02f65/"},{path:"/101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/03. 🥏 JavaScript 类的静态属性和静态方法.html",redirect:"/pages/e02f65/"},{name:"v-48513a41",path:"/pages/9fa26b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-48513a41").then(t)}},{path:"/pages/9fa26b/index.html",redirect:"/pages/9fa26b/"},{path:"/101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/04. 🪀 JavaScript 类的私有和受保护的属性和方法.html",redirect:"/pages/9fa26b/"},{name:"v-33781e61",path:"/pages/0bac3b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-33781e61").then(t)}},{path:"/pages/0bac3b/index.html",redirect:"/pages/0bac3b/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/01. 🍕 JavaScript DOM 树 .html",redirect:"/pages/0bac3b/"},{name:"v-34aea119",path:"/pages/f3541c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-34aea119").then(t)}},{path:"/pages/f3541c/index.html",redirect:"/pages/f3541c/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/04. 🥘 JavaScript 浏览器事件.html",redirect:"/pages/f3541c/"},{name:"v-371f7877",path:"/pages/5fe7c6/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-371f7877").then(t)}},{path:"/pages/5fe7c6/index.html",redirect:"/pages/5fe7c6/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/10. 🥫 JavaScript 事件使用示例.html",redirect:"/pages/5fe7c6/"},{name:"v-7bbab4e8",path:"/pages/2a600b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7bbab4e8").then(t)}},{path:"/pages/2a600b/index.html",redirect:"/pages/2a600b/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/70. 🌲 JavaScript DOM与BOM.html",redirect:"/pages/2a600b/"},{name:"v-3e2ba5ca",path:"/pages/006f30/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3e2ba5ca").then(t)}},{path:"/pages/006f30/index.html",redirect:"/pages/006f30/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/30. 🍩 JavaScript 事件循环.html",redirect:"/pages/006f30/"},{name:"v-4c9a8daf",path:"/pages/883723/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4c9a8daf").then(t)}},{path:"/pages/883723/index.html",redirect:"/pages/883723/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/80. 🥡 JavaScript 文档和资源加载.html",redirect:"/pages/883723/"},{name:"v-7fb17d6f",path:"/pages/e0da75/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7fb17d6f").then(t)}},{path:"/pages/e0da75/index.html",redirect:"/pages/e0da75/"},{path:"/101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/01. 🥢 JavaScript Fetch.html",redirect:"/pages/e0da75/"},{name:"v-4f2a97f8",path:"/pages/def96d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4f2a97f8").then(t)}},{path:"/pages/def96d/index.html",redirect:"/pages/def96d/"},{path:"/101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/02. 🥤 JavaScript Fetch API.html",redirect:"/pages/def96d/"},{name:"v-b9b0e048",path:"/pages/162aa2/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-b9b0e048").then(t)}},{path:"/pages/162aa2/index.html",redirect:"/pages/162aa2/"},{path:"/101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/03.🧉 JavaScript URL 对象.html",redirect:"/pages/162aa2/"},{name:"v-0cbd5080",path:"/pages/644542/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0cbd5080").then(t)}},{path:"/pages/644542/index.html",redirect:"/pages/644542/"},{path:"/101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/04. 🍶 JavaScript XMLHttpRequest.html",redirect:"/pages/644542/"},{name:"v-e881c4e6",path:"/pages/527bc8/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e881c4e6").then(t)}},{path:"/pages/527bc8/index.html",redirect:"/pages/527bc8/"},{path:"/101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/05. 🥃 JavaScript 长轮询 WebSocket.html",redirect:"/pages/527bc8/"},{name:"v-d47abc7a",path:"/pages/1d9ea1/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-d47abc7a").then(t)}},{path:"/pages/1d9ea1/index.html",redirect:"/pages/1d9ea1/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/01. ⛴  JavaScript 回调函数引入.html",redirect:"/pages/1d9ea1/"},{name:"v-1609c2a2",path:"/pages/948475/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1609c2a2").then(t)}},{path:"/pages/948475/index.html",redirect:"/pages/948475/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/02. 🚊 Promise 的基本使用.html",redirect:"/pages/948475/"},{name:"v-8fb1bcce",path:"/pages/befb4f/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-8fb1bcce").then(t)}},{path:"/pages/befb4f/index.html",redirect:"/pages/befb4f/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/03. 🛞 Promise 链式调用.html",redirect:"/pages/befb4f/"},{name:"v-76d59d22",path:"/pages/ac44b6/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-76d59d22").then(t)}},{path:"/pages/ac44b6/index.html",redirect:"/pages/ac44b6/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/04. 🛟 Promise 错误处理.html",redirect:"/pages/ac44b6/"},{name:"v-198322b5",path:"/pages/6c6065/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-198322b5").then(t)}},{path:"/pages/6c6065/index.html",redirect:"/pages/6c6065/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/07. 🚉 Promise 相关 API.html",redirect:"/pages/6c6065/"},{name:"v-72feb9e2",path:"/pages/dbb94a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-72feb9e2").then(t)}},{path:"/pages/dbb94a/index.html",redirect:"/pages/dbb94a/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/08. 🛰 Promise 的几个关键问题.html",redirect:"/pages/dbb94a/"},{name:"v-e3dedec8",path:"/pages/02f98e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e3dedec8").then(t)}},{path:"/pages/02f98e/index.html",redirect:"/pages/02f98e/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/09. 🛫 Promise 的自定义封装.html",redirect:"/pages/02f98e/"},{name:"v-bb055ad2",path:"/pages/0eb0a7/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-bb055ad2").then(t)}},{path:"/pages/0eb0a7/index.html",redirect:"/pages/0eb0a7/"},{path:"/101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/10. 🛩 Promise 的 async 和 await.html",redirect:"/pages/0eb0a7/"},{name:"v-50cc48b9",path:"/pages/921863/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-50cc48b9").then(t)}},{path:"/pages/921863/index.html",redirect:"/pages/921863/"},{path:"/101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/01. 🧨 JavaScript 防抖与节流.html",redirect:"/pages/921863/"},{name:"v-8942e32e",path:"/pages/ce4056/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-8942e32e").then(t)}},{path:"/pages/ce4056/index.html",redirect:"/pages/ce4056/"},{path:"/101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/02. 🗑 JavaScript 关于使用 var 声明变量.html",redirect:"/pages/ce4056/"},{name:"v-0558a126",path:"/pages/6edabb/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0558a126").then(t)}},{path:"/pages/6edabb/index.html",redirect:"/pages/6edabb/"},{path:"/101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/10. 🪤JavaScript 的模块管理.html",redirect:"/pages/6edabb/"},{name:"v-61eaf91f",path:"/pages/7c3484/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-61eaf91f").then(t)}},{path:"/pages/7c3484/index.html",redirect:"/pages/7c3484/"},{path:"/101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/20. 🔦 JavaScript 的错误处理.html",redirect:"/pages/7c3484/"},{name:"v-0c4acd47",path:"/pages/15a7cb/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0c4acd47").then(t)}},{path:"/pages/15a7cb/index.html",redirect:"/pages/15a7cb/"},{path:"/101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/30. 🎪 JavaScript Proxy 和 Reflect.html",redirect:"/pages/15a7cb/"},{name:"v-3c9c95c2",path:"/pages/f38565/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3c9c95c2").then(t)}},{path:"/pages/f38565/index.html",redirect:"/pages/f38565/"},{path:"/101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/60. 🎣 JavaScript 正则表达式.html",redirect:"/pages/f38565/"},{name:"v-03ab99a8",path:"/pages/40ee0e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-03ab99a8").then(t)}},{path:"/pages/40ee0e/index.html",redirect:"/pages/40ee0e/"},{path:"/101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/50. 📦 JavaScript 浏览器存储.html",redirect:"/pages/40ee0e/"},{name:"v-e2d9dea8",path:"/pages/d7055d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e2d9dea8").then(t)}},{path:"/pages/d7055d/index.html",redirect:"/pages/d7055d/"},{path:"/101. 🚶🏻 前端巩固基础/50. 🏃 JavaScript 进阶高级/07. 🎱 JavaScript 闭包.html",redirect:"/pages/d7055d/"},{name:"v-267b9391",path:"/pages/502815/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-267b9391").then(t)}},{path:"/pages/502815/index.html",redirect:"/pages/502815/"},{path:"/101. 🚶🏻 前端巩固基础/50. 🏃 JavaScript 进阶高级/08. 🕶 JavaScript 对象高级.html",redirect:"/pages/502815/"},{name:"v-0ed16da6",path:"/pages/8d9f46/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0ed16da6").then(t)}},{path:"/pages/8d9f46/index.html",redirect:"/pages/8d9f46/"},{path:"/101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/01. 🚛 TypeScript 前言.html",redirect:"/pages/8d9f46/"},{name:"v-ff8a52d4",path:"/pages/fb7e0f/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-ff8a52d4").then(t)}},{path:"/pages/fb7e0f/index.html",redirect:"/pages/fb7e0f/"},{path:"/101. 🚶🏻 前端巩固基础/50. 🏃 JavaScript 进阶高级/09. 🎲 JavaScript 线程机制与事件机制.html",redirect:"/pages/fb7e0f/"},{name:"v-4fd4978c",path:"/pages/3d1460/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4fd4978c").then(t)}},{path:"/pages/3d1460/index.html",redirect:"/pages/3d1460/"},{path:"/101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/02. 🚌 TypeScript 变量的声明与数据类型.html",redirect:"/pages/3d1460/"},{name:"v-ed559c8a",path:"/pages/47c91c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-ed559c8a").then(t)}},{path:"/pages/47c91c/index.html",redirect:"/pages/47c91c/"},{path:"/101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/03. 🚙 TypeScript 函数类型.html",redirect:"/pages/47c91c/"},{name:"v-9293f6fe",path:"/pages/f615a2/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-9293f6fe").then(t)}},{path:"/pages/f615a2/index.html",redirect:"/pages/f615a2/"},{path:"/101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/04. 🏎 TypeScript 中的类与接口.html",redirect:"/pages/f615a2/"},{name:"v-9def6d84",path:"/pages/9cb8e3/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-9def6d84").then(t)}},{path:"/pages/9cb8e3/index.html",redirect:"/pages/9cb8e3/"},{path:"/101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/05. 🚐 TypeScript 泛型.html",redirect:"/pages/9cb8e3/"},{name:"v-a1774298",path:"/pages/eb9b04/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-a1774298").then(t)}},{path:"/pages/eb9b04/index.html",redirect:"/pages/eb9b04/"},{path:"/101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/06. 🚕 TypeScript 模块化与类型声明.html",redirect:"/pages/eb9b04/"},{name:"v-94e34874",path:"/pages/48e822/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-94e34874").then(t)}},{path:"/pages/48e822/index.html",redirect:"/pages/48e822/"},{path:"/101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/07. 🚠 TypeScript 的常用配置.html",redirect:"/pages/48e822/"},{name:"v-413e5888",path:"/pages/2626b9/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-413e5888").then(t)}},{path:"/pages/2626b9/index.html",redirect:"/pages/2626b9/"},{path:"/101. 🚶🏻 前端巩固基础/90. 🚟 axios/02. 🚞 axios 在 Vue 项目中的封装.html",redirect:"/pages/2626b9/"},{name:"v-2b1a6bb0",path:"/pages/a24b1b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2b1a6bb0").then(t)}},{path:"/pages/a24b1b/index.html",redirect:"/pages/a24b1b/"},{path:"/101. 🚶🏻 前端巩固基础/90. 🚟 axios/01. 🚋 axios 理解与使用.html",redirect:"/pages/a24b1b/"},{name:"v-212948d8",path:"/typescript-axios/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-212948d8").then(t)}},{path:"/typescript-axios/index.html",redirect:"/typescript-axios/"},{path:"/101. 🚶🏻 前端巩固基础/90. 🚟 axios/10. 💽 使用 TypeScript 重构 axios 库.html",redirect:"/typescript-axios/"},{name:"v-2321347c",path:"/pages/57c232/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2321347c").then(t)}},{path:"/pages/57c232/index.html",redirect:"/pages/57c232/"},{path:"/105. 🏃 前端核心框架/01. 🎹 Web Components/01. 🧩 Web Components .html",redirect:"/pages/57c232/"},{name:"v-5f62ebdd",path:"/pages/a3a824/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5f62ebdd").then(t)}},{path:"/pages/a3a824/index.html",redirect:"/pages/a3a824/"},{path:"/105. 🏃 前端核心框架/01. 🎹 Web Components/02. 🍙 Custom Elements 自定义标签md.html",redirect:"/pages/a3a824/"},{name:"v-5577614c",path:"/pages/f0961b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5577614c").then(t)}},{path:"/pages/f0961b/index.html",redirect:"/pages/f0961b/"},{path:"/105. 🏃 前端核心框架/01. 🎹 Web Components/04. 🥮 template 模版元素.html",redirect:"/pages/f0961b/"},{name:"v-45d11251",path:"/pages/639649/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-45d11251").then(t)}},{path:"/pages/639649/index.html",redirect:"/pages/639649/"},{path:"/105. 🏃 前端核心框架/01. 🎹 Web Components/03. 🍘 Shadow DOM 影子 DOM.html",redirect:"/pages/639649/"},{name:"v-0acda84f",path:"/pages/1a639e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0acda84f").then(t)}},{path:"/pages/1a639e/index.html",redirect:"/pages/1a639e/"},{path:"/105. 🏃 前端核心框架/04. ☔️ 核心框架项目搭建/10. 🥯 Vue 2.x 脚手架创建项目.html",redirect:"/pages/1a639e/"},{name:"v-3fae4a68",path:"/pages/bb1311/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3fae4a68").then(t)}},{path:"/pages/bb1311/index.html",redirect:"/pages/bb1311/"},{path:"/105. 🏃 前端核心框架/04. ☔️ 核心框架项目搭建/11. 🪝  Vue 3  + TypeScript  项目搭建.html",redirect:"/pages/bb1311/"},{name:"v-72be4f88",path:"/pages/85a3ba/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-72be4f88").then(t)}},{path:"/pages/85a3ba/index.html",redirect:"/pages/85a3ba/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/01. 🌨 Vue 的基本使用.html",redirect:"/pages/85a3ba/"},{name:"v-bbee9aae",path:"/pages/c0d42b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-bbee9aae").then(t)}},{path:"/pages/c0d42b/index.html",redirect:"/pages/c0d42b/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/02. 🌕 Vue 模版语法.html",redirect:"/pages/c0d42b/"},{name:"v-2bd5f0c1",path:"/pages/14aa98/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2bd5f0c1").then(t)}},{path:"/pages/14aa98/index.html",redirect:"/pages/14aa98/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/03. 🌔 Vue 数据绑定原理.html",redirect:"/pages/14aa98/"},{name:"v-ee275a20",path:"/pages/9aa1bb/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-ee275a20").then(t)}},{path:"/pages/9aa1bb/index.html",redirect:"/pages/9aa1bb/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/04. 🌗 Vue 事件处理.html",redirect:"/pages/9aa1bb/"},{name:"v-9639b96e",path:"/pages/c10950/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-9639b96e").then(t)}},{path:"/pages/c10950/index.html",redirect:"/pages/c10950/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/05. 🌓 Vue 计算属性与侦听器md.html",redirect:"/pages/c10950/"},{name:"v-65d2e9dd",path:"/pages/64e761/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-65d2e9dd").then(t)}},{path:"/pages/64e761/index.html",redirect:"/pages/64e761/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/06. 🌗 Vue 样式绑定.html",redirect:"/pages/64e761/"},{name:"v-410d79ac",path:"/pages/55d982/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-410d79ac").then(t)}},{path:"/pages/55d982/index.html",redirect:"/pages/55d982/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/07. 🌑 Vue 指令.html",redirect:"/pages/55d982/"},{name:"v-b4901270",path:"/pages/fcee68/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-b4901270").then(t)}},{path:"/pages/fcee68/index.html",redirect:"/pages/fcee68/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/08. 🌒 Vue 条件渲染与列表渲染.html",redirect:"/pages/fcee68/"},{name:"v-81352ca6",path:"/pages/021159/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-81352ca6").then(t)}},{path:"/pages/021159/index.html",redirect:"/pages/021159/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/09. 🌞 Vue 生命周期.html",redirect:"/pages/021159/"},{name:"v-01f863d2",path:"/pages/701e29/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-01f863d2").then(t)}},{path:"/pages/701e29/index.html",redirect:"/pages/701e29/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/20. 🌟 Vue 关键问题.html",redirect:"/pages/701e29/"},{name:"v-224eac3e",path:"/pages/905c0c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-224eac3e").then(t)}},{path:"/pages/905c0c/index.html",redirect:"/pages/905c0c/"},{path:"/105. 🏃 前端核心框架/10. 🌧️ Vue 基础/30. ✨ Vue 实用实例.html",redirect:"/pages/905c0c/"},{name:"v-146a511a",path:"/pages/5935fd/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-146a511a").then(t)}},{path:"/pages/5935fd/index.html",redirect:"/pages/5935fd/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/01. 🌘 Vue 组件化编程概念.html",redirect:"/pages/5935fd/"},{name:"v-1377e2ab",path:"/pages/f7e44a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1377e2ab").then(t)}},{path:"/pages/f7e44a/index.html",redirect:"/pages/f7e44a/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/02.🌈 Vue 组件注册.html",redirect:"/pages/f7e44a/"},{name:"v-17acde74",path:"/pages/50df35/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-17acde74").then(t)}},{path:"/pages/50df35/index.html",redirect:"/pages/50df35/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/10. 🌊 Vue Prop.html",redirect:"/pages/50df35/"},{name:"v-7a68118b",path:"/pages/fce04e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7a68118b").then(t)}},{path:"/pages/fce04e/index.html",redirect:"/pages/fce04e/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/100. 🌕 Vue 组件编程案例.html",redirect:"/pages/fce04e/"},{name:"v-cd4c36e6",path:"/pages/8e154e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-cd4c36e6").then(t)}},{path:"/pages/8e154e/index.html",redirect:"/pages/8e154e/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/101. 🪐 Vue 浏览器本地存储.html",redirect:"/pages/8e154e/"},{name:"v-22193641",path:"/pages/19709c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-22193641").then(t)}},{path:"/pages/19709c/index.html",redirect:"/pages/19709c/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/15. 💫 Vue 自定义事件.html",redirect:"/pages/19709c/"},{name:"v-7e207d18",path:"/pages/914583/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7e207d18").then(t)}},{path:"/pages/914583/index.html",redirect:"/pages/914583/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/20. ✨ Vue Slot 插槽 .html",redirect:"/pages/914583/"},{name:"v-3547f7f4",path:"/pages/432c01/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3547f7f4").then(t)}},{path:"/pages/432c01/index.html",redirect:"/pages/432c01/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/30. ⭐️ Vue 动态组件与异步组件.html",redirect:"/pages/432c01/"},{name:"v-6321bba8",path:"/pages/2a073b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6321bba8").then(t)}},{path:"/pages/2a073b/index.html",redirect:"/pages/2a073b/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/41. ☀️ Vue 全局事件总线.html",redirect:"/pages/2a073b/"},{name:"v-d6281a1a",path:"/pages/e784e6/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-d6281a1a").then(t)}},{path:"/pages/e784e6/index.html",redirect:"/pages/e784e6/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/43. ⚡️ Vue 消息订阅与发布.html",redirect:"/pages/e784e6/"},{name:"v-69d10f5e",path:"/pages/5a0c40/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-69d10f5e").then(t)}},{path:"/pages/5a0c40/index.html",redirect:"/pages/5a0c40/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/50. 🌙 Vue 动画与过渡.html",redirect:"/pages/5a0c40/"},{name:"v-0cc0fa08",path:"/pages/def0ac/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0cc0fa08").then(t)}},{path:"/pages/def0ac/index.html",redirect:"/pages/def0ac/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/70. 🌩 Vuex 状态管理.html",redirect:"/pages/def0ac/"},{name:"v-a5c47462",path:"/pages/b2106c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-a5c47462").then(t)}},{path:"/pages/b2106c/index.html",redirect:"/pages/b2106c/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/60. 🛒 Vue 中的 AJAX.html",redirect:"/pages/b2106c/"},{name:"v-e0c0e444",path:"/pages/c2ae57/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e0c0e444").then(t)}},{path:"/pages/c2ae57/index.html",redirect:"/pages/c2ae57/"},{path:"/105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/90. ☔️ Vue Router 路由.html",redirect:"/pages/c2ae57/"},{name:"v-accee9b2",path:"/pages/c8dfe0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-accee9b2").then(t)}},{path:"/pages/c8dfe0/index.html",redirect:"/pages/c8dfe0/"},{path:"/105. 🏃 前端核心框架/15. 🌨 Vue 3 组合式 API/01. ☂️ Vue 3 创建项目.html",redirect:"/pages/c8dfe0/"},{name:"v-4645f627",path:"/pages/0768ce/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4645f627").then(t)}},{path:"/pages/0768ce/index.html",redirect:"/pages/0768ce/"},{path:"/105. 🏃 前端核心框架/15. 🌨 Vue 3 组合式 API/02. 🧊 Vue 3 的组合 API 编程.html",redirect:"/pages/0768ce/"},{name:"v-22c566d9",path:"/pages/f33531/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-22c566d9").then(t)}},{path:"/pages/f33531/index.html",redirect:"/pages/f33531/"},{path:"/105. 🏃 前端核心框架/15. 🌨 Vue 3 组合式 API/03. 🌊 Vue 3 其他更新.html",redirect:"/pages/f33531/"},{name:"v-54b9b1f0",path:"/pages/a2e141/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-54b9b1f0").then(t)}},{path:"/pages/a2e141/index.html",redirect:"/pages/a2e141/"},{path:"/200. 🪞 前端面试题收集/01. ⛳️ 准备工作/02. 💡 面试常见问题收集.html",redirect:"/pages/a2e141/"},{name:"v-79db4046",path:"/pages/fc5676/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-79db4046").then(t)}},{path:"/pages/fc5676/index.html",redirect:"/pages/fc5676/"},{path:"/200. 🪞 前端面试题收集/01. ⛳️ 准备工作/03. 🧳 面试项目经验.html",redirect:"/pages/fc5676/"},{name:"v-3437b616",path:"/pages/f9fc1b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3437b616").then(t)}},{path:"/pages/f9fc1b/index.html",redirect:"/pages/f9fc1b/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/01. 🍎 HTTP 与 HTTPS .html",redirect:"/pages/f9fc1b/"},{name:"v-26fbe376",path:"/pages/1fc4db/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-26fbe376").then(t)}},{path:"/pages/1fc4db/index.html",redirect:"/pages/1fc4db/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/02. 🍏 HTTP 常见的请求头.html",redirect:"/pages/1fc4db/"},{name:"v-81be5d5c",path:"/pages/6caede/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-81be5d5c").then(t)}},{path:"/pages/6caede/index.html",redirect:"/pages/6caede/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/04. 🍎 HTTP 常见的状态码.html",redirect:"/pages/6caede/"},{name:"v-0fab340e",path:"/pages/f53072/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0fab340e").then(t)}},{path:"/pages/f53072/index.html",redirect:"/pages/f53072/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/03. 🍏 HTTP 1.0 1.1 2.0 区别.html",redirect:"/pages/f53072/"},{name:"v-17a3e06a",path:"/pages/58170b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-17a3e06a").then(t)}},{path:"/pages/58170b/index.html",redirect:"/pages/58170b/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/10. 🍏 TCP 与 UDP 的区别.html",redirect:"/pages/58170b/"},{name:"v-24edffca",path:"/pages/9506f5/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-24edffca").then(t)}},{path:"/pages/9506f5/index.html",redirect:"/pages/9506f5/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/05. 🍎 HTTP 请求方法.html",redirect:"/pages/9506f5/"},{name:"v-6c1f0267",path:"/pages/6d9faf/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6c1f0267").then(t)}},{path:"/pages/6d9faf/index.html",redirect:"/pages/6d9faf/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/11. 🍏 TCP 的三次握手与四次挥手.html",redirect:"/pages/6d9faf/"},{name:"v-4a1b1da4",path:"/pages/d329d0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4a1b1da4").then(t)}},{path:"/pages/d329d0/index.html",redirect:"/pages/d329d0/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/12. 🍏 TCPIP 协议.html",redirect:"/pages/d329d0/"},{name:"v-e1f5ee38",path:"/pages/47ce67/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e1f5ee38").then(t)}},{path:"/pages/47ce67/index.html",redirect:"/pages/47ce67/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/30. 🍏 WebSocket 相关.html",redirect:"/pages/47ce67/"},{name:"v-3b17764e",path:"/pages/606924/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3b17764e").then(t)}},{path:"/pages/606924/index.html",redirect:"/pages/606924/"},{path:"/200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/40. 🍎 输入 URL 回车后发生的事情.html",redirect:"/pages/606924/"},{name:"v-32e2c4a0",path:"/pages/34b808/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-32e2c4a0").then(t)}},{path:"/pages/34b808/index.html",redirect:"/pages/34b808/"},{path:"/200. 🪞 前端面试题收集/06. 🌆 HTML 相关/01. 🍏 HTML 语义化标签理解.html",redirect:"/pages/34b808/"},{name:"v-a173582a",path:"/pages/28d421/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-a173582a").then(t)}},{path:"/pages/28d421/index.html",redirect:"/pages/28d421/"},{path:"/200. 🪞 前端面试题收集/06. 🌆 HTML 相关/02. 🍎 实现响应式设计的相关.html",redirect:"/pages/28d421/"},{name:"v-3b0ec81b",path:"/pages/efa419/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3b0ec81b").then(t)}},{path:"/pages/efa419/index.html",redirect:"/pages/efa419/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/01. 🍎 CSS 的盒子模型相关 .html",redirect:"/pages/efa419/"},{name:"v-7c5ca52a",path:"/pages/10ff5a/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7c5ca52a").then(t)}},{path:"/pages/10ff5a/index.html",redirect:"/pages/10ff5a/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/02. 🍎 CSS 的选择器相关.html",redirect:"/pages/10ff5a/"},{name:"v-1d3b852d",path:"/pages/5fc469/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1d3b852d").then(t)}},{path:"/pages/5fc469/index.html",redirect:"/pages/5fc469/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/03. 🍎 CSS 的计量单位相关.html",redirect:"/pages/5fc469/"},{name:"v-23710361",path:"/pages/9ca940/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-23710361").then(t)}},{path:"/pages/9ca940/index.html",redirect:"/pages/9ca940/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/04. 🍏 CSS 实现隐藏元素.html",redirect:"/pages/9ca940/"},{name:"v-769e6dac",path:"/pages/46067c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-769e6dac").then(t)}},{path:"/pages/46067c/index.html",redirect:"/pages/46067c/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/05. 🍏 CSS 实现元素居中.html",redirect:"/pages/46067c/"},{name:"v-215e8422",path:"/pages/0cd1d6/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-215e8422").then(t)}},{path:"/pages/0cd1d6/index.html",redirect:"/pages/0cd1d6/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/06. 🍎 CSS BFC 相关.html",redirect:"/pages/0cd1d6/"},{name:"v-173573e4",path:"/pages/d79434/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-173573e4").then(t)}},{path:"/pages/d79434/index.html",redirect:"/pages/d79434/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/10. 🍎 CSS 弹性盒布局相关.html",redirect:"/pages/d79434/"},{name:"v-c577cb28",path:"/pages/babf64/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c577cb28").then(t)}},{path:"/pages/babf64/index.html",redirect:"/pages/babf64/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/101. 🍎 CSS 预编语言相关.html",redirect:"/pages/babf64/"},{name:"v-5d4c33ae",path:"/pages/574676/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5d4c33ae").then(t)}},{path:"/pages/574676/index.html",redirect:"/pages/574676/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/11. 🍎 CSS 网格布局相关.html",redirect:"/pages/574676/"},{name:"v-c211ae4e",path:"/pages/928d4e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c211ae4e").then(t)}},{path:"/pages/928d4e/index.html",redirect:"/pages/928d4e/"},{path:"/200. 🪞 前端面试题收集/07. 🏞 CSS 相关/90. 🍏 CSS 性能优化相关.html",redirect:"/pages/928d4e/"},{name:"v-5cc9cd12",path:"/pages/7f3bfc/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5cc9cd12").then(t)}},{path:"/pages/7f3bfc/index.html",redirect:"/pages/7f3bfc/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/01. 🍎 JavaScript 数据类型.html",redirect:"/pages/7f3bfc/"},{name:"v-ceb7a5d6",path:"/pages/3cfb49/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-ceb7a5d6").then(t)}},{path:"/pages/3cfb49/index.html",redirect:"/pages/3cfb49/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/02. 🍎 JavaScript 数组常用方法.html",redirect:"/pages/3cfb49/"},{name:"v-46a7403e",path:"/pages/d3e8df/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-46a7403e").then(t)}},{path:"/pages/d3e8df/index.html",redirect:"/pages/d3e8df/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/03. 🍎 JavaScript 字符串常用方法.html",redirect:"/pages/d3e8df/"},{name:"v-f2eceaa8",path:"/pages/d7f372/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f2eceaa8").then(t)}},{path:"/pages/d7f372/index.html",redirect:"/pages/d7f372/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/04. 🍏 JavaScript typeof 与 instanceof.html",redirect:"/pages/d7f372/"},{name:"v-17bfcefe",path:"/pages/aef8c2/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-17bfcefe").then(t)}},{path:"/pages/aef8c2/index.html",redirect:"/pages/aef8c2/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/05. 🍏 JavaScript 数字精度丢失相关.html",redirect:"/pages/aef8c2/"},{name:"v-1605ad46",path:"/pages/6e10ef/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1605ad46").then(t)}},{path:"/pages/6e10ef/index.html",redirect:"/pages/6e10ef/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/10. 🍏 JavaScript 数据变量内存.html",redirect:"/pages/6e10ef/"},{name:"v-01a08eb8",path:"/pages/99b9ce/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-01a08eb8").then(t)}},{path:"/pages/99b9ce/index.html",redirect:"/pages/99b9ce/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/20. 🍎 JavaScript 深拷贝与浅拷贝.html",redirect:"/pages/99b9ce/"},{name:"v-05f2fd30",path:"/pages/b0ab4c/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-05f2fd30").then(t)}},{path:"/pages/b0ab4c/index.html",redirect:"/pages/b0ab4c/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/02. 🍎 JavaScript 对象相关/02. 🍎 JavaScript new 操作符相关.html",redirect:"/pages/b0ab4c/"},{name:"v-bbf26266",path:"/pages/d76014/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-bbf26266").then(t)}},{path:"/pages/d76014/index.html",redirect:"/pages/d76014/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/02. 🍎 JavaScript 对象相关/03. 🍏 JavaScript 对象模式.html",redirect:"/pages/d76014/"},{name:"v-c81ae684",path:"/pages/8ae2cd/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c81ae684").then(t)}},{path:"/pages/8ae2cd/index.html",redirect:"/pages/8ae2cd/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/03. 🍎 JavaScript 作用域与作用域链.html",redirect:"/pages/8ae2cd/"},{name:"v-96855454",path:"/pages/7a9353/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-96855454").then(t)}},{path:"/pages/7a9353/index.html",redirect:"/pages/7a9353/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/02. 🍎 JavaScript 闭包.html",redirect:"/pages/7a9353/"},{name:"v-4291a2a5",path:"/pages/b16ce1/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4291a2a5").then(t)}},{path:"/pages/b16ce1/index.html",redirect:"/pages/b16ce1/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/05. 🍎 JavaScript  this 指向问题.html",redirect:"/pages/b16ce1/"},{name:"v-f6070724",path:"/pages/b66da8/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f6070724").then(t)}},{path:"/pages/b66da8/index.html",redirect:"/pages/b66da8/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/04. 🍎 JavaScript 执行上下文与执行栈.html",redirect:"/pages/b66da8/"},{name:"v-0ddafc4e",path:"/pages/e6af48/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0ddafc4e").then(t)}},{path:"/pages/e6af48/index.html",redirect:"/pages/e6af48/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/10. 🍎 JavaScript 函数式编程相关.html",redirect:"/pages/e6af48/"},{name:"v-685447f2",path:"/pages/f5f615/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-685447f2").then(t)}},{path:"/pages/f5f615/index.html",redirect:"/pages/f5f615/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/11. 🍎 JavaScript 函数缓存相关.html",redirect:"/pages/f5f615/"},{name:"v-044944ba",path:"/pages/a78536/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-044944ba").then(t)}},{path:"/pages/a78536/index.html",redirect:"/pages/a78536/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/04. 🍎 JavaScript 原型与继承相关/01. 🍎 JavaScript 原型与原型链.html",redirect:"/pages/a78536/"},{name:"v-c8d7917a",path:"/pages/bc77a3/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c8d7917a").then(t)}},{path:"/pages/bc77a3/index.html",redirect:"/pages/bc77a3/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/04. 🍎 JavaScript 原型与继承相关/02. 🍎 JavaScript 继承相关.html",redirect:"/pages/bc77a3/"},{name:"v-150471d8",path:"/pages/104705/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-150471d8").then(t)}},{path:"/pages/104705/index.html",redirect:"/pages/104705/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/02. 🍏 ES6 新增特性.html",redirect:"/pages/104705/"},{name:"v-cd5ad1da",path:"/pages/c14014/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-cd5ad1da").then(t)}},{path:"/pages/c14014/index.html",redirect:"/pages/c14014/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/03. 🍎 ES6 Promise 相关.html",redirect:"/pages/c14014/"},{name:"v-3cd3d4c7",path:"/pages/f1fa30/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-3cd3d4c7").then(t)}},{path:"/pages/f1fa30/index.html",redirect:"/pages/f1fa30/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/04. 🍏 ES6 Generator 相关.html",redirect:"/pages/f1fa30/"},{name:"v-42cd3ee3",path:"/pages/0e8ab8/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-42cd3ee3").then(t)}},{path:"/pages/0e8ab8/index.html",redirect:"/pages/0e8ab8/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/05. 🍏 ES6 Module 模块化相关.html",redirect:"/pages/0e8ab8/"},{name:"v-397483cd",path:"/pages/a30824/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-397483cd").then(t)}},{path:"/pages/a30824/index.html",redirect:"/pages/a30824/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/12. 🍎 JavaScript 事件循环相关.html",redirect:"/pages/a30824/"},{name:"v-307c0396",path:"/pages/2f3265/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-307c0396").then(t)}},{path:"/pages/2f3265/index.html",redirect:"/pages/2f3265/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/11. 🍎 JavaScript 事件模型.html",redirect:"/pages/2f3265/"},{name:"v-50732f42",path:"/pages/a50766/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-50732f42").then(t)}},{path:"/pages/a50766/index.html",redirect:"/pages/a50766/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/13. 🍏 JavaScript 线程机制相关.html",redirect:"/pages/a50766/"},{name:"v-4f7538bc",path:"/pages/b84b16/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-4f7538bc").then(t)}},{path:"/pages/b84b16/index.html",redirect:"/pages/b84b16/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/20. 🍏 JavaScript BOM 相关问题.html",redirect:"/pages/b84b16/"},{name:"v-79207f6a",path:"/pages/cc4083/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-79207f6a").then(t)}},{path:"/pages/cc4083/index.html",redirect:"/pages/cc4083/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/30. 🍎 JavaScript 本地存储相关.html",redirect:"/pages/cc4083/"},{name:"v-e97a13f8",path:"/pages/0a56d1/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-e97a13f8").then(t)}},{path:"/pages/0a56d1/index.html",redirect:"/pages/0a56d1/"},{path:"/200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/40. 🍎 JavaScript 防抖与节流相关.html",redirect:"/pages/0a56d1/"},{name:"v-35c33a67",path:"/pages/370325/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-35c33a67").then(t)}},{path:"/pages/370325/index.html",redirect:"/pages/370325/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/01. 🍎  Vue 的理解相关.html",redirect:"/pages/370325/"},{name:"v-0f0c029a",path:"/pages/27cb22/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0f0c029a").then(t)}},{path:"/pages/27cb22/index.html",redirect:"/pages/27cb22/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/03. 🍎 Vue v-show 与 v-if 的区别.html",redirect:"/pages/27cb22/"},{name:"v-c3849332",path:"/pages/c589b0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c3849332").then(t)}},{path:"/pages/c589b0/index.html",redirect:"/pages/c589b0/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/04. 🍏 Vue v-if 和 v-for.html",redirect:"/pages/c589b0/"},{name:"v-26b135d0",path:"/pages/68ecc7/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-26b135d0").then(t)}},{path:"/pages/68ecc7/index.html",redirect:"/pages/68ecc7/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/05. 🍎 Vue 生命周期相关.html",redirect:"/pages/68ecc7/"},{name:"v-03aac67e",path:"/pages/31a16b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-03aac67e").then(t)}},{path:"/pages/31a16b/index.html",redirect:"/pages/31a16b/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/10. 🍎  Vue SPA 单页应用相关.html",redirect:"/pages/31a16b/"},{name:"v-728ffe5c",path:"/pages/9992c4/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-728ffe5c").then(t)}},{path:"/pages/9992c4/index.html",redirect:"/pages/9992c4/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/03. 🥗 JavaScript DOM 样式和类.html",redirect:"/pages/9992c4/"},{name:"v-32b59ad8",path:"/pages/9221e7/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-32b59ad8").then(t)}},{path:"/pages/9221e7/index.html",redirect:"/pages/9221e7/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/21. 🍎 Vue 双向数据绑定.html",redirect:"/pages/9221e7/"},{name:"v-01106406",path:"/pages/f561af/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-01106406").then(t)}},{path:"/pages/f561af/index.html",redirect:"/pages/f561af/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 虚拟 DOM 的理解.html",redirect:"/pages/f561af/"},{name:"v-7cf7d88f",path:"/pages/96c489/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7cf7d88f").then(t)}},{path:"/pages/96c489/index.html",redirect:"/pages/96c489/"},{path:"/200. 🪞 前端面试题收集/10. 📦  Webpack 相关/01. 🍎 对 Webpack 的理解相关.html",redirect:"/pages/96c489/"},{name:"v-58a84061",path:"/pages/6e40af/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-58a84061").then(t)}},{path:"/pages/6e40af/index.html",redirect:"/pages/6e40af/"},{path:"/200. 🪞 前端面试题收集/10. 📦  Webpack 相关/02. 🍏 Webpack 的构建流程.html",redirect:"/pages/6e40af/"},{name:"v-50e23e90",path:"/pages/7bb20b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-50e23e90").then(t)}},{path:"/pages/7bb20b/index.html",redirect:"/pages/7bb20b/"},{path:"/200. 🪞 前端面试题收集/20. 📦 NodeJS 相关/01. 🍎 NodeJS 理解相关.html",redirect:"/pages/7bb20b/"},{name:"v-0655e210",path:"/pages/d38a08/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0655e210").then(t)}},{path:"/pages/d38a08/index.html",redirect:"/pages/d38a08/"},{path:"/200. 🪞 前端面试题收集/20. 📦 NodeJS 相关/02. 🍎 NodeJS 前端模块化开发相关.html",redirect:"/pages/d38a08/"},{name:"v-2dd6bfbf",path:"/pages/ce7138/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-2dd6bfbf").then(t)}},{path:"/pages/ce7138/index.html",redirect:"/pages/ce7138/"},{path:"/200. 🪞 前端面试题收集/60. 📦 设计模式相关/01. 🍎 设计模式的理解.html",redirect:"/pages/ce7138/"},{name:"v-c5fea8b6",path:"/pages/003555/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-c5fea8b6").then(t)}},{path:"/pages/003555/index.html",redirect:"/pages/003555/"},{path:"/200. 🪞 前端面试题收集/70. 📦 前端工程化/01. 🍏 前端项目使用脚手架.html",redirect:"/pages/003555/"},{name:"v-f0de70a4",path:"/pages/99638b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f0de70a4").then(t)}},{path:"/pages/99638b/index.html",redirect:"/pages/99638b/"},{path:"/400. 🚪 其他文章收集/10. 📡 关于本笔记的搭建.html",redirect:"/pages/99638b/"},{name:"v-a1ea609c",path:"/pages/a07897/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-a1ea609c").then(t)}},{path:"/pages/a07897/index.html",redirect:"/pages/a07897/"},{path:"/801. 💽 TypeScript-Axios/01. 🌑 初始化 TypeScript 库项目.html",redirect:"/pages/a07897/"},{name:"v-01beeb53",path:"/pages/a6d7da/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-01beeb53").then(t)}},{path:"/pages/a6d7da/index.html",redirect:"/pages/a6d7da/"},{path:"/801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/02. 🌒 实现基础请求.html",redirect:"/pages/a6d7da/"},{name:"v-02cdca3c",path:"/pages/2c5ed7/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-02cdca3c").then(t)}},{path:"/pages/2c5ed7/index.html",redirect:"/pages/2c5ed7/"},{path:"/801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/03. 🌒 实现处理请求 URL 参数.html",redirect:"/pages/2c5ed7/"},{name:"v-361b4710",path:"/pages/1d2040/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-361b4710").then(t)}},{path:"/pages/1d2040/index.html",redirect:"/pages/1d2040/"},{path:"/801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/05. 🌒 实现处理请求 head.html",redirect:"/pages/1d2040/"},{name:"v-42669813",path:"/pages/fa5bf4/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-42669813").then(t)}},{path:"/pages/fa5bf4/index.html",redirect:"/pages/fa5bf4/"},{path:"/801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/04. 🌒 实现处理请求 body 数据.html",redirect:"/pages/fa5bf4/"},{name:"v-062eca5c",path:"/pages/f3a9f8/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-062eca5c").then(t)}},{path:"/pages/f3a9f8/index.html",redirect:"/pages/f3a9f8/"},{path:"/801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/06. 🌒 获取响应数据.html",redirect:"/pages/f3a9f8/"},{name:"v-31c26ebc",path:"/pages/e463f4/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-31c26ebc").then(t)}},{path:"/pages/e463f4/index.html",redirect:"/pages/e463f4/"},{path:"/801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/07. 🌒 实现处理响应 header 和 data.html",redirect:"/pages/e463f4/"},{name:"v-271f65bc",path:"/pages/3de0b0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-271f65bc").then(t)}},{path:"/pages/3de0b0/index.html",redirect:"/pages/3de0b0/"},{path:"/801. 💽 TypeScript-Axios/10. 🌘 实现异常情况处理.html",redirect:"/pages/3de0b0/"},{name:"v-0fcc2923",path:"/pages/8fff17/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0fcc2923").then(t)}},{path:"/pages/8fff17/index.html",redirect:"/pages/8fff17/"},{path:"/801. 💽 TypeScript-Axios/20. 🌘 实现接口拓展.html",redirect:"/pages/8fff17/"},{name:"v-44b8a6d8",path:"/pages/291f04/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-44b8a6d8").then(t)}},{path:"/pages/291f04/index.html",redirect:"/pages/291f04/"},{path:"/801. 💽 TypeScript-Axios/30. 🌘 实现拦截器.html",redirect:"/pages/291f04/"},{name:"v-87928544",path:"/pages/1e5c77/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-87928544").then(t)}},{path:"/pages/1e5c77/index.html",redirect:"/pages/1e5c77/"},{path:"/801. 💽 TypeScript-Axios/40. 🌓 实现合并默认配置.html",redirect:"/pages/1e5c77/"},{name:"v-8c73d138",path:"/pages/4c10b2/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-8c73d138").then(t)}},{path:"/pages/4c10b2/index.html",redirect:"/pages/4c10b2/"},{path:"/801. 💽 TypeScript-Axios/41. 🌓 实现请求和响应配置化.html",redirect:"/pages/4c10b2/"},{name:"v-1f7eea30",path:"/pages/87b8ba/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1f7eea30").then(t)}},{path:"/pages/87b8ba/index.html",redirect:"/pages/87b8ba/"},{path:"/801. 💽 TypeScript-Axios/42. 🌓 拓展创建axios静态接口.html",redirect:"/pages/87b8ba/"},{name:"v-d8eae0b2",path:"/pages/0a6e3d/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-d8eae0b2").then(t)}},{path:"/pages/0a6e3d/index.html",redirect:"/pages/0a6e3d/"},{path:"/801. 💽 TypeScript-Axios/43. 🌗 实现取消功能.html",redirect:"/pages/0a6e3d/"},{name:"v-d427c83c",path:"/pages/211982/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-d427c83c").then(t)}},{path:"/pages/211982/index.html",redirect:"/pages/211982/"},{path:"/801. 💽 TypeScript-Axios/44. 🌗 实现权限相关功能.html",redirect:"/pages/211982/"},{name:"v-66e5c5d4",path:"/pages/767314/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-66e5c5d4").then(t)}},{path:"/pages/767314/index.html",redirect:"/pages/767314/"},{path:"/801. 💽 TypeScript-Axios/45. 🌗 实现 XSRF 防御.html",redirect:"/pages/767314/"},{name:"v-8ca31366",path:"/pages/2871e0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-8ca31366").then(t)}},{path:"/pages/2871e0/index.html",redirect:"/pages/2871e0/"},{path:"/801. 💽 TypeScript-Axios/46. 🌗 实现上传和下载进度监控.html",redirect:"/pages/2871e0/"},{name:"v-0d7e111b",path:"/pages/441f8f/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0d7e111b").then(t)}},{path:"/pages/441f8f/index.html",redirect:"/pages/441f8f/"},{path:"/801. 💽 TypeScript-Axios/47. 🌗 实现 HTTP 授权.html",redirect:"/pages/441f8f/"},{name:"v-75371f4a",path:"/pages/97d131/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-75371f4a").then(t)}},{path:"/pages/97d131/index.html",redirect:"/pages/97d131/"},{path:"/801. 💽 TypeScript-Axios/48. 🌗 实现自定义合法状态码.html",redirect:"/pages/97d131/"},{name:"v-1240e29a",path:"/pages/206979/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1240e29a").then(t)}},{path:"/pages/206979/index.html",redirect:"/pages/206979/"},{path:"/801. 💽 TypeScript-Axios/50. 🌗 实现 baseURL.html",redirect:"/pages/206979/"},{name:"v-7a859bad",path:"/pages/d6c1c4/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-7a859bad").then(t)}},{path:"/pages/d6c1c4/index.html",redirect:"/pages/d6c1c4/"},{path:"/801. 💽 TypeScript-Axios/49. 🌗 实现自定义参数序列化.html",redirect:"/pages/d6c1c4/"},{name:"v-6f3304ca",path:"/pages/4b46b1/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-6f3304ca").then(t)}},{path:"/pages/4b46b1/index.html",redirect:"/pages/4b46b1/"},{path:"/801. 💽 TypeScript-Axios/70. 🌖 单元测试 Jest 的使用.html",redirect:"/pages/4b46b1/"},{name:"v-032678fa",path:"/pages/9850cb/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-032678fa").then(t)}},{path:"/pages/9850cb/index.html",redirect:"/pages/9850cb/"},{path:"/801. 💽 TypeScript-Axios/60. 🌓 静态方法拓展.html",redirect:"/pages/9850cb/"},{name:"v-29a02ce2",path:"/pages/73c2b6/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-29a02ce2").then(t)}},{path:"/pages/73c2b6/index.html",redirect:"/pages/73c2b6/"},{path:"/801. 💽 TypeScript-Axios/71. 🌖 辅助模块单元测试.html",redirect:"/pages/73c2b6/"},{name:"v-60b82d43",path:"/pages/169950/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-60b82d43").then(t)}},{path:"/pages/169950/index.html",redirect:"/pages/169950/"},{path:"/801. 💽 TypeScript-Axios/72. 🌖 请求模块单元测试.html",redirect:"/pages/169950/"},{name:"v-b87222ae",path:"/pages/528987/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-b87222ae").then(t)}},{path:"/pages/528987/index.html",redirect:"/pages/528987/"},{path:"/801. 💽 TypeScript-Axios/74. 🌖 Axios 实例模块单元测试.html",redirect:"/pages/528987/"},{name:"v-0bb0b492",path:"/pages/f4e917/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-0bb0b492").then(t)}},{path:"/pages/f4e917/index.html",redirect:"/pages/f4e917/"},{path:"/801. 💽 TypeScript-Axios/73. 🌖 headers 模块单元测试.html",redirect:"/pages/f4e917/"},{name:"v-58999b90",path:"/pages/7e14c7/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-58999b90").then(t)}},{path:"/pages/7e14c7/index.html",redirect:"/pages/7e14c7/"},{path:"/801. 💽 TypeScript-Axios/75. 🌖 拦截器模块单元测试.html",redirect:"/pages/7e14c7/"},{name:"v-5f8b8f7b",path:"/pages/f2e77e/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5f8b8f7b").then(t)}},{path:"/pages/f2e77e/index.html",redirect:"/pages/f2e77e/"},{path:"/801. 💽 TypeScript-Axios/76. 🌖 合并配置模块单元测试.html",redirect:"/pages/f2e77e/"},{name:"v-5464c35d",path:"/pages/4877d8/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5464c35d").then(t)}},{path:"/pages/4877d8/index.html",redirect:"/pages/4877d8/"},{path:"/801. 💽 TypeScript-Axios/77. 🌖 请求取消模块单元测试.html",redirect:"/pages/4877d8/"},{name:"v-444484c2",path:"/pages/b58e50/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-444484c2").then(t)}},{path:"/pages/b58e50/index.html",redirect:"/pages/b58e50/"},{path:"/801. 💽 TypeScript-Axios/78. 🌖 更多模块单元测试.html",redirect:"/pages/b58e50/"},{name:"v-5c3b871e",path:"/pages/2b07f0/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-5c3b871e").then(t)}},{path:"/pages/2b07f0/index.html",redirect:"/pages/2b07f0/"},{path:"/801. 💽 TypeScript-Axios/80. 🌕 部署与发布.html",redirect:"/pages/2b07f0/"},{name:"v-47d644e5",path:"/archives/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-47d644e5").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-f689eb36",path:"/tags/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-f689eb36").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-b7a2df76",path:"/categories/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-b7a2df76").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-309ec2fe",path:"/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-309ec2fe").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-43cefae9",path:"/pages/cae956/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-43cefae9").then(t)}},{path:"/pages/cae956/index.html",redirect:"/pages/cae956/"},{path:"/101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/02. 🍥 JavaScript DOM 操作.html",redirect:"/pages/cae956/"},{name:"v-1e816680",path:"/pages/dcf29b/",component:hl,beforeEnter:(n,e,t)=>{si("Layout","v-1e816680").then(t)}},{path:"/pages/dcf29b/index.html",redirect:"/pages/dcf29b/"},{path:"/200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/20. 🍎 Vue data 属性.html",redirect:"/pages/dcf29b/"},{path:"*",component:hl}],gl={title:"notebook",description:"a frontend notebook by Simon",base:"/notebook/",headTags:[["link",{rel:"icon",href:"/notebook/favicon.ico"}],["meta",{name:"viewport",content:"width=device-width,initial-scale=1,user-scalable=no"}],["meta",{name:"keywords",content:"个人学习笔记,前端学习笔记,前端学习,前端学习资源,前端学习路线,HTML,CSS,JavaScript,Vue,React"}],["meta",{name:"theme-color",content:"#204A7A"}],["link",{rel:"stylesheet",href:"/notebook//at.alicdn.com/t/font_3114978_qe0b39no76.css"}],["link",{rel:"stylesheet",href:"https://unpkg.com/@waline/client@v2/dist/waline.css"}],["script",{src:"https://unpkg.com/@waline/client@v2/dist/waline.js"}]],pages:[{title:"🍎 ES6 变量声明相关",frontmatter:{title:"🍎 ES6 变量声明相关",date:"2022-06-08T17:24:07.000Z",permalink:"/pages/d63a9a/",categories:["🪞冲刺","🗾 JavaScript 相关","🍎 ES6 相关"],tags:[null]},regularPath:"/01.%20%F0%9F%8D%8E%20ES6%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9B%B8%E5%85%B3.html",relativePath:"01. 🍎 ES6 变量声明相关.md",key:"v-ccb821ec",path:"/pages/d63a9a/",headers:[{level:2,title:"三者的概念",slug:"三者的概念",normalizedTitle:"三者的概念",charIndex:36},{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:28}],headersStr:"三者的概念 区别",content:">  * var 、 let 、 const 声明变量的区别？\n\n\n# 三者的概念\n\n * 在 ES5 中，使用 var 声明的变量既是全局变量，也是顶级变量；\n   \n   * 全局变量指在 window 对象中能获取到该变量的值；\n   \n   * 顶级变量指的是 var 生命的变量存在变量提升；\n   \n   * 使用 var 声明变量可以对一个变量多次声明，后面生面的变量会覆盖前面的声明；\n   \n   * 函数中使用 var 声明的变量是局部变量；不在函数内声明的变量是全局变量；\n\n * 在 ES6 中新增使用 let 声明变量：\n   \n   * 声明的变量只在 let 命令的代码块内有效；\n   * 声明的变量不存在变量提升；（即声明之前，该变量不存在）\n   * 不允许在相同作用域中重复声明变量；\n   * 在块级作用域中内存在 let 命令，这个区域就不再受外部影响；\n\n * 使用 const 声明只读常量，一旦声明之后无法修改：\n   \n   * 意味着声明时就要出初始化变量的值；\n   * 不能重复声明 var 或者 let 已经声明过的变量；\n   * 实际上保证的是 变量指向的内存地址保存的数据不改变，对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量；对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针， const 只能保证这个指针是固定的，并不能确保改变量的结构不变；\n\n\n# 区别\n\n从五方面展开讲：\n\n * 变量的提升：\n   * var 声明的变量存在变量提升，即在变量声明之前就可以调用，值为 undefined ；\n   * let 和 const 都不存在变量提升，即变量必须要在声明之后才能使用，否则报错；\n * 暂时性死区：\n   * var 不存在暂时性死区，对于未知变量为 undefined 不报错；\n   * let 和 const 存在暂时性死区，只有等到声明变量的那一行出现才能使用变量，否则报错；\n * 块级作用域：\n   * var 不存在块级作用域；\n   * let 和 const 存在块级作用域：\n * 重复声明：\n   * var 允许重复声明变量；\n   * let 和 const 不允许重复声明变量；\n * 修改声明变量：\n   * var 和 let 可以修改；\n   * cosnt 声明常量，一旦生命不可修改；\n * 使用情况：\n   * 能用 const 的情况尽量使用 const ，其他情况下大多数使用 let ，避免使用 var",normalizedContent:">  * var 、 let 、 const 声明变量的区别？\n\n\n# 三者的概念\n\n * 在 es5 中，使用 var 声明的变量既是全局变量，也是顶级变量；\n   \n   * 全局变量指在 window 对象中能获取到该变量的值；\n   \n   * 顶级变量指的是 var 生命的变量存在变量提升；\n   \n   * 使用 var 声明变量可以对一个变量多次声明，后面生面的变量会覆盖前面的声明；\n   \n   * 函数中使用 var 声明的变量是局部变量；不在函数内声明的变量是全局变量；\n\n * 在 es6 中新增使用 let 声明变量：\n   \n   * 声明的变量只在 let 命令的代码块内有效；\n   * 声明的变量不存在变量提升；（即声明之前，该变量不存在）\n   * 不允许在相同作用域中重复声明变量；\n   * 在块级作用域中内存在 let 命令，这个区域就不再受外部影响；\n\n * 使用 const 声明只读常量，一旦声明之后无法修改：\n   \n   * 意味着声明时就要出初始化变量的值；\n   * 不能重复声明 var 或者 let 已经声明过的变量；\n   * 实际上保证的是 变量指向的内存地址保存的数据不改变，对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量；对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针， const 只能保证这个指针是固定的，并不能确保改变量的结构不变；\n\n\n# 区别\n\n从五方面展开讲：\n\n * 变量的提升：\n   * var 声明的变量存在变量提升，即在变量声明之前就可以调用，值为 undefined ；\n   * let 和 const 都不存在变量提升，即变量必须要在声明之后才能使用，否则报错；\n * 暂时性死区：\n   * var 不存在暂时性死区，对于未知变量为 undefined 不报错；\n   * let 和 const 存在暂时性死区，只有等到声明变量的那一行出现才能使用变量，否则报错；\n * 块级作用域：\n   * var 不存在块级作用域；\n   * let 和 const 存在块级作用域：\n * 重复声明：\n   * var 允许重复声明变量；\n   * let 和 const 不允许重复声明变量；\n * 修改声明变量：\n   * var 和 let 可以修改；\n   * cosnt 声明常量，一旦生命不可修改；\n * 使用情况：\n   * 能用 const 的情况尽量使用 const ，其他情况下大多数使用 let ，避免使用 var",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗺 前端学习路线",frontmatter:{title:"🗺 前端学习路线",date:"2021-09-14T22:52:55.000Z",permalink:"/front-end/roadmap/",tags:["前端学习"],categories:["📚 前端笔记"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/01.%20%F0%9F%97%BA%20%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html",relativePath:"01. 📚 前端笔记/01. 🗺 前端学习路线.md",key:"v-696b0a49",path:"/front-end/roadmap/",headers:[{level:4,title:"前端学习相关的开发工具/环境",slug:"前端学习相关的开发工具-环境",normalizedTitle:"前端学习相关的开发工具 / 环境",charIndex:230},{level:3,title:"🚶 入门部分",slug:"🚶-入门部分",normalizedTitle:"🚶 入门部分",charIndex:647},{level:4,title:"🍎 计算机网络",slug:"🍎-计算机网络",normalizedTitle:"🍎 计算机网络",charIndex:718},{level:4,title:"🍎 HTML 基础 / HTML 5",slug:"🍎-html-基础-html-5",normalizedTitle:"🍎 html 基础 / html 5",charIndex:730},{level:4,title:"🍎 CSS 基础 / CSS 3",slug:"🍎-css-基础-css-3",normalizedTitle:"🍎 css 基础 / css 3",charIndex:809},{level:4,title:"🍎 JavaScript 基础",slug:"🍎-javascript-基础",normalizedTitle:"🍎 javascript 基础",charIndex:830},{level:4,title:"🍎 CSS 3",slug:"🍎-css-3",normalizedTitle:"🍎 css 3",charIndex:850},{level:4,title:"🍏 JSON",slug:"🍏-json",normalizedTitle:"🍏 json",charIndex:862},{level:4,title:"🫐 jQuery",slug:"🫐-jquery",normalizedTitle:"🫐 jquery",charIndex:873},{level:4,title:"🍎 Git 版本管理与控制",slug:"🍎-git-版本管理与控制",normalizedTitle:"🍎 git 版本管理与控制",charIndex:886},{level:3,title:"🚶 巩固基础",slug:"🚶-巩固基础",normalizedTitle:"🚶 巩固基础",charIndex:905},{level:4,title:"🍎 ES6 语法",slug:"🍎-es6-语法",normalizedTitle:"🍎 es6 语法",charIndex:916},{level:4,title:"🍎 JavaScript 深入进阶",slug:"🍎-javascript-深入进阶",normalizedTitle:"🍎 javascript 深入进阶",charIndex:929},{level:4,title:"🍎 软件开发相关",slug:"🍎-软件开发相关",normalizedTitle:"🍎 软件开发相关",charIndex:951},{level:4,title:"🍏 设计模式",slug:"🍏-设计模式",normalizedTitle:"🍏 设计模式",charIndex:964},{level:4,title:"🍏 Linux 服务器",slug:"🍏-linux-服务器",normalizedTitle:"🍏 linux 服务器",charIndex:975},{level:4,title:"🍏 正则表达式",slug:"🍏-正则表达式",normalizedTitle:"🍏 正则表达式",charIndex:991},{level:4,title:"🍎 计算机基础知识",slug:"🍎-计算机基础知识",normalizedTitle:"🍎 计算机基础知识",charIndex:1003},{level:4,title:"🍎 重要辅助",slug:"🍎-重要辅助",normalizedTitle:"🍎 重要辅助",charIndex:1070},{level:3,title:"🏃 高级核心",slug:"🏃-高级核心",normalizedTitle:"🏃 高级核心",charIndex:1151},{level:4,title:"🍎 前端工程化",slug:"🍎-前端工程化",normalizedTitle:"🍎 前端工程化",charIndex:1162},{level:4,title:"🍎 前端架构设计",slug:"🍎-前端架构设计",normalizedTitle:"🍎 前端架构设计",charIndex:1189},{level:4,title:"🍎 前端核心框架",slug:"🍎-前端核心框架",normalizedTitle:"🍎 前端核心框架",charIndex:1294},{level:4,title:"🍎 前端框架脚手架",slug:"🍎-前端框架脚手架",normalizedTitle:"🍎 前端框架脚手架",charIndex:1379},{level:4,title:"🍎 CSS 进阶相关",slug:"🍎-css-进阶相关",normalizedTitle:"🍎 css 进阶相关",charIndex:1615},{level:3,title:"🍎 JavaScript 相关拓展库",slug:"🍎-javascript-相关拓展库",normalizedTitle:"🍎 javascript 相关拓展库",charIndex:1822},{level:4,title:"🍏 测试相关",slug:"🍏-测试相关",normalizedTitle:"🍏 测试相关",charIndex:2051},{level:4,title:"🍏 代码质量",slug:"🍏-代码质量",normalizedTitle:"🍏 代码质量",charIndex:2146},{level:4,title:"🫐 构建工具",slug:"🫐-构建工具",normalizedTitle:"🫐 构建工具",charIndex:2380},{level:4,title:"🫐 打包工具",slug:"🫐-打包工具",normalizedTitle:"🫐 打包工具",charIndex:2421},{level:4,title:"🫐 部署相关",slug:"🫐-部署相关",normalizedTitle:"🫐 部署相关",charIndex:2471},{level:4,title:"🍏 前端优化相关",slug:"🍏-前端优化相关",normalizedTitle:"🍏 前端优化相关",charIndex:2547},{level:4,title:"🍏 前端兼容性",slug:"🍏-前端兼容性",normalizedTitle:"🍏 前端兼容性",charIndex:2583},{level:3,title:"🤛 面试求职相关",slug:"🤛-面试求职相关",normalizedTitle:"🤛 面试求职相关",charIndex:2629},{level:4,title:"🍎 准备简历",slug:"🍎-准备简历",normalizedTitle:"🍎 准备简历",charIndex:2642},{level:4,title:"🍎 熟悉流程",slug:"🍎-熟悉流程",normalizedTitle:"🍎 熟悉流程",charIndex:2653},{level:4,title:"🍎 充分准备",slug:"🍎-充分准备",normalizedTitle:"🍎 充分准备",charIndex:2664},{level:4,title:"🚀 冲冲冲！",slug:"🚀-冲冲冲",normalizedTitle:"🚀 冲冲冲！",charIndex:2675},{level:3,title:"🥕 拓展阅读与相关资源",slug:"🥕-拓展阅读与相关资源",normalizedTitle:"🥕 拓展阅读与相关资源",charIndex:2687}],headersStr:"前端学习相关的开发工具/环境 🚶 入门部分 🍎 计算机网络 🍎 HTML 基础 / HTML 5 🍎 CSS 基础 / CSS 3 🍎 JavaScript 基础 🍎 CSS 3 🍏 JSON 🫐 jQuery 🍎 Git 版本管理与控制 🚶 巩固基础 🍎 ES6 语法 🍎 JavaScript 深入进阶 🍎 软件开发相关 🍏 设计模式 🍏 Linux 服务器 🍏 正则表达式 🍎 计算机基础知识 🍎 重要辅助 🏃 高级核心 🍎 前端工程化 🍎 前端架构设计 🍎 前端核心框架 🍎 前端框架脚手架 🍎 CSS 进阶相关 🍎 JavaScript 相关拓展库 🍏 测试相关 🍏 代码质量 🫐 构建工具 🫐 打包工具 🫐 部署相关 🍏 前端优化相关 🍏 前端兼容性 🤛 面试求职相关 🍎 准备简历 🍎 熟悉流程 🍎 充分准备 🚀 冲冲冲！ 🥕 拓展阅读与相关资源",content:"👣 为了自己的学习更加调理清晰，并且清楚自己一步一步走过的脚印，决定梳理一下先前从学习前端开始到最近在学习的核心框架，经历的知识栈路线。本路线从看过不少培训网站、个人博客抽取精华的部分，并且附上了本「笔记」中的相关笔记的链接，不一定完美精准，阅读与参考需谨慎，酌情况根据最新的前端学习知识栈更新。\n\n提示\n\n相关 emoji 标识：\n\n🍎 重中之重，必学。\n\n🍏 相对重要，建议学习。\n\n🫐 选择性学习。\n\n🥕 面试重点。\n\n🍞 相关资源。\n\n# 前端学习相关的开发工具 / 环境\n\n * 🍎 WebStorm 用来写项目方便舒服，简单来说就是我的神。配置无脑快速简单，集合多种框架方案，插件丰富，UI 颜值在线，字体舒服。夸不下去了我快。缺点就是要订阅，不过可以趁着学生邮箱申请 JetBrains 的学生计划（或者选择加入 GitHub 的 Education 计划，也有包含 JetBrains 全家桶）。\n * 🍎 Visual Studio Code 作为 WebStorm 忙不过来的另一个代码编辑器吧。在编写一些轻量的代码时也很好用，插件的选择也非常丰富，不过我还是选择少点去折腾，毕竟懒。\n * 🍏 浏览器可以选择基于 Chromium 的 Chrome 或者 Edge。个人很爱 Edge，毕竟是苹果最佳开发者微软开发的软件。\n * 🍎 Typora 一个写 Markdown 文档、笔记都非常好用的软件。主要还是可见即所得的特性就让人离不开了。\n\n\n# 🚶 入门部分\n\n了解前端学习的方向，所需的开发环境与工具。「前端三件套」是基础中的重中之重。对应本笔记中的 「🚶 前端基础部分」。\n\n# 🍎 计算机网络\n\n# 🍎 HTML 基础 / HTML 5\n\n * 🍎 HTML 基本语法\n * 🍏 HTML 的语义化写法\n * 🍎 HTML 表单 / 表单验证\n\n# 🍎 CSS 基础 / CSS 3\n\n# 🍎 JavaScript 基础\n\n# 🍎 CSS 3\n\n# 🍏 JSON\n\n# 🫐 jQuery\n\n# 🍎 Git 版本管理与控制\n\n\n# 🚶 巩固基础\n\n# 🍎 ES6 语法\n\n# 🍎 JavaScript 深入进阶\n\n# 🍎 软件开发相关\n\n# 🍏 设计模式\n\n# 🍏 Linux 服务器\n\n# 🍏 正则表达式\n\n# 🍎 计算机基础知识\n\n * 🍎/🍏 计算机网路\n * 🍎 算法与数据结构\n * 🍏 操作系统\n * 🍎 数据库基础\n\n# 🍎 重要辅助\n\n * 🍎 Node.JS\n * 🍏 包管理 npm /yarn/npx\n * 🫐 开发框架 Express / Koa /egg\n\n\n# 🏃 高级核心\n\n# 🍎 前端工程化\n\n🍞 🧰 前端开发工程化\n\n# 🍎 前端架构设计\n\n * 模块化 / 组件化\n * 🍏 MVVM\n * 设计原则\n * 🍎 SPA 单页应用\n * 🍎 多页应用\n * 🍏 前端路由 Router\n * PWA\n * 有损服务\n\n# 🍎 前端核心框架\n\n * 🍎 Vue.js / Vue 3\n   * Vuex\n   * Vue-router\n * 🍎 React\n * 🍏 UmiJS\n\n# 🍎 前端框架脚手架\n\n * 🍎 Vue-CLI for Vue\n\n * 🫐 Vite for Vue\n\n * 🍎 create-react-app for React\n\n * 🍏 前端组件库：\n   \n   * 🍎 Element UI for Vue\n   * 🍏 VantUI for Vue\n   * 🍎 Ant Design for React\n\n * 🍏 前端数据可视化\n   \n   * 🫐 ECharts\n   * 🍏 AntV\n\n# 🍎 CSS 进阶相关\n\n * 🍏 Bootstrap\n\n * 🍎 Tailwind CSS\n\n * CSS 模块化\n   \n   * 🍎 CSS modules\n   * 🍏 styled-components\n   * 🍏 Styled JSX\n\n * CSS 预编译\n   \n   * 🍏 Stylus\n   * 🫐 Less\n   * 🍎 SASS\n   * 🍏 PortCSS\n\n\n# 🍎 JavaScript 相关拓展库\n\n * 🔧 工具库\n   \n   * 🍎 Promise\n   * 🍎 axios\n   * 🍎 Lodash 防抖与节流\n\n * 组件 / 插件\n   \n   * 富文本编辑器\n   * 弹窗\n   * 轮播图\n\n * 动效库\n   \n   * 🍏 Animate.css\n   * Ant motion\n\n * 字体库\n   \n   * 🍎 IconFont\n   * Font Awesome\n\n# 🍏 测试相关\n\n * 测试分类\n   \n   * 🍎 Jest\n   * 🍎 UT 单元测试\n\n * 测试工具：\n   \n   * 🍎 Mock：模拟数据工具 Mock.js\n\n# 🍏 代码质量\n\n * 开发规范：\n   \n   * HTML Guide\n   \n   * JavaScript Style Guide\n   \n   * CSS Style Guide\n   \n   > 🍞 相关链接：\n   > \n   >  * 编码规范 by @mdo (bootcss.com)\n\n * 类型校验：\n   \n   * 🍏 TypeScript\n\n * 代码检查：\n   \n   * 🫐 ESLint\n   * StyleLint\n\n# 🫐 构建工具\n\n * 🍎 npm\n\n * Gulp\n\n * Grunt\n\n# 🫐 打包工具\n\n * 🍎 webpack\n * 🍏 Vite\n * 🍏 Rollup\n\n# 🫐 部署相关\n\n * 🍎 Web 服务器\n   * 🍎 Nginx\n   * 🍏 Apache\n * 容器\n   * 🍏 Docker\n\n# 🍏 前端优化相关\n\n * 性能优化\n * 搜索引擎优化 SEO\n\n# 🍏 前端兼容性\n\n * 浏览器兼容性\n * 屏幕分辨率兼容性\n * 跨平台兼容性\n\n\n# 🤛 面试求职相关\n\n# 🍎 准备简历\n\n# 🍎 熟悉流程\n\n# 🍎 充分准备\n\n# 🚀 冲冲冲！\n\n\n# 🥕 拓展阅读与相关资源\n\n🔗 部分参考来源：\n\n * Frontend Developer Roadmap: Learn to become a modern frontend developer\n\n * 鱼皮前端学习路线\n\n🍎 优秀作者推荐收藏夹：\n\n * 编程导航 - 发现优质编程资源 (code-nav.cn)\n\n * CodingStartup 起码课\n\n * 前端小课 (lefex.github.io)\n\n🍏 相关阅读收藏夹：\n\n * 网道 ES6 ECMAScript 6 简介 - ES6 教程 - 网道 (wangdoc.com)\n\n * 你不懂 ES6 系列丛书 JoeHetfield/You-Dont-Know-JS: A book series on JavaScript. @YDKJS on twitter. (github.com)\n\n * Wscats 前端学习笔记 Wscats/articles: 🔖My Learning Notes and Memories - 分享我的学习片段和与你的回忆 (github.com)",normalizedContent:"👣 为了自己的学习更加调理清晰，并且清楚自己一步一步走过的脚印，决定梳理一下先前从学习前端开始到最近在学习的核心框架，经历的知识栈路线。本路线从看过不少培训网站、个人博客抽取精华的部分，并且附上了本「笔记」中的相关笔记的链接，不一定完美精准，阅读与参考需谨慎，酌情况根据最新的前端学习知识栈更新。\n\n提示\n\n相关 emoji 标识：\n\n🍎 重中之重，必学。\n\n🍏 相对重要，建议学习。\n\n🫐 选择性学习。\n\n🥕 面试重点。\n\n🍞 相关资源。\n\n# 前端学习相关的开发工具 / 环境\n\n * 🍎 webstorm 用来写项目方便舒服，简单来说就是我的神。配置无脑快速简单，集合多种框架方案，插件丰富，ui 颜值在线，字体舒服。夸不下去了我快。缺点就是要订阅，不过可以趁着学生邮箱申请 jetbrains 的学生计划（或者选择加入 github 的 education 计划，也有包含 jetbrains 全家桶）。\n * 🍎 visual studio code 作为 webstorm 忙不过来的另一个代码编辑器吧。在编写一些轻量的代码时也很好用，插件的选择也非常丰富，不过我还是选择少点去折腾，毕竟懒。\n * 🍏 浏览器可以选择基于 chromium 的 chrome 或者 edge。个人很爱 edge，毕竟是苹果最佳开发者微软开发的软件。\n * 🍎 typora 一个写 markdown 文档、笔记都非常好用的软件。主要还是可见即所得的特性就让人离不开了。\n\n\n# 🚶 入门部分\n\n了解前端学习的方向，所需的开发环境与工具。「前端三件套」是基础中的重中之重。对应本笔记中的 「🚶 前端基础部分」。\n\n# 🍎 计算机网络\n\n# 🍎 html 基础 / html 5\n\n * 🍎 html 基本语法\n * 🍏 html 的语义化写法\n * 🍎 html 表单 / 表单验证\n\n# 🍎 css 基础 / css 3\n\n# 🍎 javascript 基础\n\n# 🍎 css 3\n\n# 🍏 json\n\n# 🫐 jquery\n\n# 🍎 git 版本管理与控制\n\n\n# 🚶 巩固基础\n\n# 🍎 es6 语法\n\n# 🍎 javascript 深入进阶\n\n# 🍎 软件开发相关\n\n# 🍏 设计模式\n\n# 🍏 linux 服务器\n\n# 🍏 正则表达式\n\n# 🍎 计算机基础知识\n\n * 🍎/🍏 计算机网路\n * 🍎 算法与数据结构\n * 🍏 操作系统\n * 🍎 数据库基础\n\n# 🍎 重要辅助\n\n * 🍎 node.js\n * 🍏 包管理 npm /yarn/npx\n * 🫐 开发框架 express / koa /egg\n\n\n# 🏃 高级核心\n\n# 🍎 前端工程化\n\n🍞 🧰 前端开发工程化\n\n# 🍎 前端架构设计\n\n * 模块化 / 组件化\n * 🍏 mvvm\n * 设计原则\n * 🍎 spa 单页应用\n * 🍎 多页应用\n * 🍏 前端路由 router\n * pwa\n * 有损服务\n\n# 🍎 前端核心框架\n\n * 🍎 vue.js / vue 3\n   * vuex\n   * vue-router\n * 🍎 react\n * 🍏 umijs\n\n# 🍎 前端框架脚手架\n\n * 🍎 vue-cli for vue\n\n * 🫐 vite for vue\n\n * 🍎 create-react-app for react\n\n * 🍏 前端组件库：\n   \n   * 🍎 element ui for vue\n   * 🍏 vantui for vue\n   * 🍎 ant design for react\n\n * 🍏 前端数据可视化\n   \n   * 🫐 echarts\n   * 🍏 antv\n\n# 🍎 css 进阶相关\n\n * 🍏 bootstrap\n\n * 🍎 tailwind css\n\n * css 模块化\n   \n   * 🍎 css modules\n   * 🍏 styled-components\n   * 🍏 styled jsx\n\n * css 预编译\n   \n   * 🍏 stylus\n   * 🫐 less\n   * 🍎 sass\n   * 🍏 portcss\n\n\n# 🍎 javascript 相关拓展库\n\n * 🔧 工具库\n   \n   * 🍎 promise\n   * 🍎 axios\n   * 🍎 lodash 防抖与节流\n\n * 组件 / 插件\n   \n   * 富文本编辑器\n   * 弹窗\n   * 轮播图\n\n * 动效库\n   \n   * 🍏 animate.css\n   * ant motion\n\n * 字体库\n   \n   * 🍎 iconfont\n   * font awesome\n\n# 🍏 测试相关\n\n * 测试分类\n   \n   * 🍎 jest\n   * 🍎 ut 单元测试\n\n * 测试工具：\n   \n   * 🍎 mock：模拟数据工具 mock.js\n\n# 🍏 代码质量\n\n * 开发规范：\n   \n   * html guide\n   \n   * javascript style guide\n   \n   * css style guide\n   \n   > 🍞 相关链接：\n   > \n   >  * 编码规范 by @mdo (bootcss.com)\n\n * 类型校验：\n   \n   * 🍏 typescript\n\n * 代码检查：\n   \n   * 🫐 eslint\n   * stylelint\n\n# 🫐 构建工具\n\n * 🍎 npm\n\n * gulp\n\n * grunt\n\n# 🫐 打包工具\n\n * 🍎 webpack\n * 🍏 vite\n * 🍏 rollup\n\n# 🫐 部署相关\n\n * 🍎 web 服务器\n   * 🍎 nginx\n   * 🍏 apache\n * 容器\n   * 🍏 docker\n\n# 🍏 前端优化相关\n\n * 性能优化\n * 搜索引擎优化 seo\n\n# 🍏 前端兼容性\n\n * 浏览器兼容性\n * 屏幕分辨率兼容性\n * 跨平台兼容性\n\n\n# 🤛 面试求职相关\n\n# 🍎 准备简历\n\n# 🍎 熟悉流程\n\n# 🍎 充分准备\n\n# 🚀 冲冲冲！\n\n\n# 🥕 拓展阅读与相关资源\n\n🔗 部分参考来源：\n\n * frontend developer roadmap: learn to become a modern frontend developer\n\n * 鱼皮前端学习路线\n\n🍎 优秀作者推荐收藏夹：\n\n * 编程导航 - 发现优质编程资源 (code-nav.cn)\n\n * codingstartup 起码课\n\n * 前端小课 (lefex.github.io)\n\n🍏 相关阅读收藏夹：\n\n * 网道 es6 ecmascript 6 简介 - es6 教程 - 网道 (wangdoc.com)\n\n * 你不懂 es6 系列丛书 joehetfield/you-dont-know-js: a book series on javascript. @ydkjs on twitter. (github.com)\n\n * wscats 前端学习笔记 wscats/articles: 🔖my learning notes and memories - 分享我的学习片段和与你的回忆 (github.com)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚶 前端入门基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"100. 🚶 前端入门基础",imgUrl:null,description:"🍞 包括内容：<br/>"}},title:"🚶 前端入门基础",date:"2020-03-11T21:50:55.000Z",permalink:"/front-end/beginning",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/02.%20%F0%9F%92%BB%20%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80.html",relativePath:"01. 📚 前端笔记/02. 💻 前端学习笔记/100. 🚶 前端入门基础.md",key:"v-23ff1010",path:"/front-end/beginning/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚶🏻 前端巩固基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"101. 🚶🏻 前端巩固基础",imgUrl:null,description:"🍞 包括内容：<br/>"}},title:"🚶🏻 前端巩固基础",date:"2020-03-11T21:50:55.000Z",permalink:"/front-end/stable",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/02.%20%F0%9F%92%BB%20%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80.html",relativePath:"01. 📚 前端笔记/02. 💻 前端学习笔记/101. 🚶🏻 前端巩固基础.md",key:"v-5e9f586b",path:"/front-end/stable/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🏃 前端核心框架",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"105. 🏃 前端核心框架",imgUrl:null,description:null}},title:"🏃 前端核心框架",date:"2020-03-11T21:50:55.000Z",permalink:"/front-end/core-frame",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/02.%20%F0%9F%92%BB%20%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6.html",relativePath:"01. 📚 前端笔记/02. 💻 前端学习笔记/105. 🏃 前端核心框架.md",key:"v-636b316c",path:"/front-end/core-frame/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🕹 前端算法指北",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"120. 🕹 前端算法指北",imgUrl:null,description:"🍞 包括内容：<br/>"}},title:"🕹 前端算法指北",date:"2020-03-11T21:50:55.000Z",permalink:"/front-end/algorithm",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/02.%20%F0%9F%92%BB%20%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/120.%20%F0%9F%95%B9%20%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E6%8C%87%E5%8C%97.html",relativePath:"01. 📚 前端笔记/02. 💻 前端学习笔记/120. 🕹 前端算法指北.md",key:"v-34e195e9",path:"/front-end/algorithm/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 计算机网络",frontmatter:{title:"🍎 计算机网络",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/46470d/",categories:["📚 前端笔记","🗺️ 前端学习路线相关"],tags:[null]},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/03.%20%F0%9F%97%BA%EF%B8%8F%20%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html",relativePath:"01. 📚 前端笔记/03. 🗺️ 前端学习路线相关/01. 🍎 计算机网络.md",key:"v-8e2f20b6",path:"/pages/46470d/",headersStr:null,content:"⛳️ 基本学习清单：\n\n * 🍎 网络的工作原理\n * 🍎 HTTP 是什么（理解）\n * 🍎 浏览器的工作原理\n * 🍎 DNS 是什么（理解）以及工作原理\n * 🍎 域名的理解\n * 🍎 主机（服务器）的理解\n\n📚 相关资源阅读：\n\n * 网络工作原理：\n   \n   * The internet, explained - Vox\n   \n   * 互联网是如何工作的 - 学习 Web 开发 | MDN (mozilla.org)\n\n * HTTP 的理解：\n   \n   * 什么是 HTTP？ | Cloudflare\n   * How HTTPS works - How HTTPS works\n   * Journey to HTTP/2 (kamranahmed.info)\n   * HTTP/3 From A To Z: Core Concepts — Smashing Magazine\n\n * 浏览器工作原理：\n   \n   * How browsers work (web.dev) 浏览器工作原理\n   * Role of Rendering Engines in Browsers | BrowserStack 浏览器的渲染引擎\n   * 渲染页面：浏览器的工作原理 - Web 性能 | MDN (mozilla.org)\n\n * DNS 的理解：\n   \n   * 什么是 DNS？ | DNS 的工作方式 | Cloudflare\n   * mess with dns\n\n * 域名的理解：\n   \n   * 什么是域名？ - 学习 Web 开发 | MDN (mozilla.org)\n   * 什么是域名？| 域名与 URL | Cloudflare",normalizedContent:"⛳️ 基本学习清单：\n\n * 🍎 网络的工作原理\n * 🍎 http 是什么（理解）\n * 🍎 浏览器的工作原理\n * 🍎 dns 是什么（理解）以及工作原理\n * 🍎 域名的理解\n * 🍎 主机（服务器）的理解\n\n📚 相关资源阅读：\n\n * 网络工作原理：\n   \n   * the internet, explained - vox\n   \n   * 互联网是如何工作的 - 学习 web 开发 | mdn (mozilla.org)\n\n * http 的理解：\n   \n   * 什么是 http？ | cloudflare\n   * how https works - how https works\n   * journey to http/2 (kamranahmed.info)\n   * http/3 from a to z: core concepts — smashing magazine\n\n * 浏览器工作原理：\n   \n   * how browsers work (web.dev) 浏览器工作原理\n   * role of rendering engines in browsers | browserstack 浏览器的渲染引擎\n   * 渲染页面：浏览器的工作原理 - web 性能 | mdn (mozilla.org)\n\n * dns 的理解：\n   \n   * 什么是 dns？ | dns 的工作方式 | cloudflare\n   * mess with dns\n\n * 域名的理解：\n   \n   * 什么是域名？ - 学习 web 开发 | mdn (mozilla.org)\n   * 什么是域名？| 域名与 url | cloudflare",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛟 HTML 5 样式指南代码约定",frontmatter:{title:"🛟 HTML 5 样式指南代码约定",date:"2022-06-08T00:51:16.000Z",permalink:"/pages/5bded3/",categories:["📚 前端笔记","⚖️ 规范相关"],tags:[null]},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/100.%20%E2%9A%96%EF%B8%8F%20%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E7%9B%B8%E5%85%B3/10.%20%F0%9F%9B%9F%20%20HTML%205%20%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97%E4%BB%A3%E7%A0%81%E7%BA%A6%E5%AE%9A.html",relativePath:"01. 📚 前端笔记/100. ⚖️ 前端编码规范相关/10. 🛟  HTML 5 样式指南代码约定.md",key:"v-71a62a83",path:"/pages/5bded3/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍽 JavaScript 代码规范",frontmatter:{title:"🍽 JavaScript 代码规范",date:"2022-05-30T14:12:25.000Z",permalink:"/pages/176ef8/",categories:["📚 前端笔记","⚖️ 规范相关"],tags:[null]},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/100.%20%E2%9A%96%EF%B8%8F%20%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E7%9B%B8%E5%85%B3/20.%20%F0%9F%8D%BD%20JavaScript%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html",relativePath:"01. 📚 前端笔记/100. ⚖️ 前端编码规范相关/20. 🍽 JavaScript 代码规范.md",key:"v-5a8ed19a",path:"/pages/176ef8/",headers:[{level:2,title:"{} 花括号的使用",slug:"花括号的使用",normalizedTitle:"{} 花括号的使用",charIndex:199},{level:2,title:"一行代码的最大长度",slug:"一行代码的最大长度",normalizedTitle:"一行代码的最大长度",charIndex:506},{level:2,title:"代码缩进",slug:"代码缩进",normalizedTitle:"代码缩进",charIndex:573},{level:2,title:"分号的使用",slug:"分号的使用",normalizedTitle:"分号的使用",charIndex:886},{level:2,title:"避免过度的嵌套",slug:"避免过度的嵌套",normalizedTitle:"避免过度的嵌套",charIndex:1016},{level:2,title:"函数的位置",slug:"函数的位置",normalizedTitle:"函数的位置",charIndex:1715},{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:2610}],headersStr:"{} 花括号的使用 一行代码的最大长度 代码缩进 分号的使用 避免过度的嵌套 函数的位置 注释",content:"> 可以参考的 JavaScript 代码风格：\n> \n>  * Google JavaScript Style Guide\n>  * airbnb/javascript: JavaScript Style Guide (github.com)\n>  * JavaScript Standard Style (standardjs.com)\n\n一个常见的 JavaScript 编写风格：\n\n\n# {} 花括号的使用\n\n在大多数的 JavaScript 项目中，代码段的开括号位于一行的末尾（即与关键字在同一行，而不是新起一行），并且相对于 括号 () 有一个空格：\n\nif (condition) {\n  // ... \n}\n\n\n1\n2\n3\n\n\n提示\n\n对于单行的构造，不应该使用花括号：\n\nif (condition) return;\n\n\n1\n\n\n并且注意拆分单行时，最好添加花括号以免在添加新行时出错：\n\nif (condition) {\n\treturn;\n\t// ...\n}\n\n\n1\n2\n3\n4\n\n\n所以一般多行的构造最好使用 花括号。单行能完成的很短的代码，直接写成一行不带花括号的形式即可。\n\n\n# 一行代码的最大长度\n\n一般一个项目中的 编辑器代码美化 规范中有定义一行代码的最大长度。通常是 80 或者 120 个字符。\n\n\n# 代码缩进\n\n水平方向的缩进：一般为 2 或者 4 个空格。可以直接使用 Tab 键，也可以使用 空格。（使用空格能够更加灵活）\n\n垂直方向的缩进：用于将代码拆分成逻辑块的空行。 使用额外的空行有助于代码更具有可读性。写代码时，不应该出现连续超过 9 行都没有被垂直分割的代码。\n\n🌰 例子 / 垂直分割初始化的变量、主循环结构和返回值：\n\nfunction pow(x, n) {\n  let result = 1;\n  \n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n  \n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 分号的使用\n\n对于普遍的 JavaScript 脚本的编写，每一个代码语句都结尾都应该加上分号 ; 。可以根据 不同的代码风格选择是否添加分号。\n\nJavaScript Standard Style (standardjs.com) 无分号代码风格。\n\n\n# 避免过度的嵌套\n\n尽量避免代码过度嵌套过深：\n\n🌰 例子：\n\nfor (let i = 0; i < 10; i++) {\n  if (condition) {\n    // ... \n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n改写写成：\n\nfor (let i = 0; i < 10; i++) {\n  if (!condition) continue;\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n🌰 例子：\n\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n  } else {\n    let result = 1;\n\n    for (let i = 0; i < n; i++) {\n      result *= x;\n    }\n\n    return result;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n改写成：\n\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n    return;\n  }\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 一开始处理了不符合条件的情况，就不必额外的嵌套。\n\n\n# 函数的位置\n\n三种编写函数的方式：\n\n * 在函数调用之前，声明函数。\n   \n   🌰 例子：\n   \n   // 函数声明\n   function createElement() {\n     ...\n   }\n    \n   function setHandler(elem) {\n     ...\n   }\n     \n   // 调用函数\n   let element = createElement()\n   setHandler(elem);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 先调用函数，在声明函数。\n   \n   🌰 例子：\n   \n   // 调用函数\n   let element = createElement()\n   setHandler(elem);\n   \n   \n   // 函数声明\n   function createElement() {\n     ...\n   }\n     \n   function setHandler(elem) {\n     ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 混合声明与调用。\n   \n   🌰 例子：\n   \n   // 函数声明\n   function createElement() {\n     ...\n   }\n     \n   // 调用函数\n   let element = createElement()\n   \n   function setHandler(elem) {\n     ...\n   }\n   \n   setHandler(elem);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 注释\n\n> 一个好的注释应该包括的内容：能够直接理解函数的目的 Why（不需要研究其内部的实现代码，就可以直接正确地使用它）。而不应该是解释性的注释 how /what（一般可以通过 自描述型的代码（良好的函数命名） 能理解代码） 。\n> \n>  * 描述整体架构，高层次的观点。\n>  * 记录函数的 参数和用法。\n>  * 重要的解决方法。\n> \n> 好的注释可以使我们更好地维护代码，一段时间之后依然可以更高效地回到代码高效开发。\n\n🌰 例子：\n\n/**\n * 返回 x 的 n 次幂的值。\n *\n * @param {number} x 要改变的值。\n * @param {number} n 幂数，必须是一个自然数。\n * @return {number} x 的 n 次幂的值。\n */\nfunction pow(x, n) {\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"> 可以参考的 javascript 代码风格：\n> \n>  * google javascript style guide\n>  * airbnb/javascript: javascript style guide (github.com)\n>  * javascript standard style (standardjs.com)\n\n一个常见的 javascript 编写风格：\n\n\n# {} 花括号的使用\n\n在大多数的 javascript 项目中，代码段的开括号位于一行的末尾（即与关键字在同一行，而不是新起一行），并且相对于 括号 () 有一个空格：\n\nif (condition) {\n  // ... \n}\n\n\n1\n2\n3\n\n\n提示\n\n对于单行的构造，不应该使用花括号：\n\nif (condition) return;\n\n\n1\n\n\n并且注意拆分单行时，最好添加花括号以免在添加新行时出错：\n\nif (condition) {\n\treturn;\n\t// ...\n}\n\n\n1\n2\n3\n4\n\n\n所以一般多行的构造最好使用 花括号。单行能完成的很短的代码，直接写成一行不带花括号的形式即可。\n\n\n# 一行代码的最大长度\n\n一般一个项目中的 编辑器代码美化 规范中有定义一行代码的最大长度。通常是 80 或者 120 个字符。\n\n\n# 代码缩进\n\n水平方向的缩进：一般为 2 或者 4 个空格。可以直接使用 tab 键，也可以使用 空格。（使用空格能够更加灵活）\n\n垂直方向的缩进：用于将代码拆分成逻辑块的空行。 使用额外的空行有助于代码更具有可读性。写代码时，不应该出现连续超过 9 行都没有被垂直分割的代码。\n\n🌰 例子 / 垂直分割初始化的变量、主循环结构和返回值：\n\nfunction pow(x, n) {\n  let result = 1;\n  \n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n  \n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 分号的使用\n\n对于普遍的 javascript 脚本的编写，每一个代码语句都结尾都应该加上分号 ; 。可以根据 不同的代码风格选择是否添加分号。\n\njavascript standard style (standardjs.com) 无分号代码风格。\n\n\n# 避免过度的嵌套\n\n尽量避免代码过度嵌套过深：\n\n🌰 例子：\n\nfor (let i = 0; i < 10; i++) {\n  if (condition) {\n    // ... \n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n改写写成：\n\nfor (let i = 0; i < 10; i++) {\n  if (!condition) continue;\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n🌰 例子：\n\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"negative 'n' not supported\");\n  } else {\n    let result = 1;\n\n    for (let i = 0; i < n; i++) {\n      result *= x;\n    }\n\n    return result;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n改写成：\n\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"negative 'n' not supported\");\n    return;\n  }\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 一开始处理了不符合条件的情况，就不必额外的嵌套。\n\n\n# 函数的位置\n\n三种编写函数的方式：\n\n * 在函数调用之前，声明函数。\n   \n   🌰 例子：\n   \n   // 函数声明\n   function createelement() {\n     ...\n   }\n    \n   function sethandler(elem) {\n     ...\n   }\n     \n   // 调用函数\n   let element = createelement()\n   sethandler(elem);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 先调用函数，在声明函数。\n   \n   🌰 例子：\n   \n   // 调用函数\n   let element = createelement()\n   sethandler(elem);\n   \n   \n   // 函数声明\n   function createelement() {\n     ...\n   }\n     \n   function sethandler(elem) {\n     ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 混合声明与调用。\n   \n   🌰 例子：\n   \n   // 函数声明\n   function createelement() {\n     ...\n   }\n     \n   // 调用函数\n   let element = createelement()\n   \n   function sethandler(elem) {\n     ...\n   }\n   \n   sethandler(elem);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 注释\n\n> 一个好的注释应该包括的内容：能够直接理解函数的目的 why（不需要研究其内部的实现代码，就可以直接正确地使用它）。而不应该是解释性的注释 how /what（一般可以通过 自描述型的代码（良好的函数命名） 能理解代码） 。\n> \n>  * 描述整体架构，高层次的观点。\n>  * 记录函数的 参数和用法。\n>  * 重要的解决方法。\n> \n> 好的注释可以使我们更好地维护代码，一段时间之后依然可以更高效地回到代码高效开发。\n\n🌰 例子：\n\n/**\n * 返回 x 的 n 次幂的值。\n *\n * @param {number} x 要改变的值。\n * @param {number} n 幂数，必须是一个自然数。\n * @return {number} x 的 n 次幂的值。\n */\nfunction pow(x, n) {\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧰 前端开发工程化",frontmatter:{title:"🧰 前端开发工程化",date:"2021-09-18T21:32:18.000Z",permalink:"/pages/f582e8/",categories:["前端笔记"],tags:["规范"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/100.%20%E2%9A%96%EF%B8%8F%20%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E7%9B%B8%E5%85%B3/99.%20%F0%9F%A7%B0%20%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%8C%96.html",relativePath:"01. 📚 前端笔记/100. ⚖️ 前端编码规范相关/99. 🧰 前端开发工程化.md",key:"v-64d5b56e",path:"/pages/f582e8/",headers:[{level:2,title:"前端相关名词书写规范",slug:"前端相关名词书写规范",normalizedTitle:"前端相关名词书写规范",charIndex:10}],headersStr:"前端相关名词书写规范",content:"相关链接：\n\n\n# 前端相关名词书写规范\n\n规范书写         备注\nHTTP         Hyper Text Transfer Protocol\nHTTPS        Hyper Text Transfer Protocol over SecureSocket Layer\nDOM          Document Object Model\nJavaScript   \nCSS          Cascading Style Sheets\nHTML         Hyper Text Markup Language\njQuery       \nBootstrap    \nNode.js      \nVue.js       \nReact        \nAngular      \nSPA          Single Page Application\nMPA          Mutiple Page Application",normalizedContent:"相关链接：\n\n\n# 前端相关名词书写规范\n\n规范书写         备注\nhttp         hyper text transfer protocol\nhttps        hyper text transfer protocol over securesocket layer\ndom          document object model\njavascript   \ncss          cascading style sheets\nhtml         hyper text markup language\njquery       \nbootstrap    \nnode.js      \nvue.js       \nreact        \nangular      \nspa          single page application\nmpa          mutiple page application",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🪞 前端面试题收集",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"200. 🪞 前端面试题收集",imgUrl:null,description:null}},title:"🪞 前端面试题收集",date:"2020-03-11T21:50:55.000Z",permalink:"/front-end/interview",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/20.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86.html",relativePath:"01. 📚 前端笔记/20. 🪞 前端面试题收集.md",key:"v-6c5d0ea6",path:"/front-end/interview/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📚 前端笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01. 📚 前端笔记",imgUrl:null,description:null}},title:"📚 前端笔记",date:"2020-03-11T21:50:55.000Z",permalink:"/front-end",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/01.%20%F0%9F%93%9A%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/",relativePath:"01. 📚 前端笔记/index.md",key:"v-c5dd7ffa",path:"/front-end/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🪧 关于",frontmatter:{title:"🪧 关于",date:"1970-01-01T00:00:00.000Z",permalink:"/about/",categories:["🪧 关于"],tags:[null]},regularPath:"/10.%20%F0%9F%AA%A7%20%E5%85%B3%E4%BA%8E/",relativePath:"10. 🪧 关于/index.md",key:"v-27e10230",path:"/about/",headers:[{level:2,title:"关于本笔记",slug:"关于本笔记",normalizedTitle:"关于本笔记",charIndex:2},{level:2,title:"关于本笔记的搭建",slug:"关于本笔记的搭建",normalizedTitle:"关于本笔记的搭建",charIndex:501},{level:2,title:"关于本笔记的排版",slug:"关于本笔记的排版",normalizedTitle:"关于本笔记的排版",charIndex:901}],headersStr:"关于本笔记 关于本笔记的搭建 关于本笔记的排版",content:"# 关于本笔记\n\n👋🏻 这是一个大部分关于前端内容的「笔记本」。\n\n为何要搭建这个笔记本？其实网上已经有很多关于前端的内容 / 博客 / 笔记 / 分享，但是要用某一部分的内容的时候还得慢慢查找、好的解决方案并不是立刻就能找到，经验还是自己总结的最好。所以，结合一句老话 「好记性不如烂笔头」？现在大概要改为「好记性不如烂键盘」了。很多内容，看过以后没啥感觉，还得用自己的语言总结一遍、过一遍。如果不行，那就看多几篇文章，不断迭代笔记，不懂的内容慢慢就懂了。这就是目前我对我个人来说，比较有效的学习方法了。\n\n看过 Sherlock （神探夏洛克）的人应该对里面一个「记忆宫殿」的场景有印象。这个笔记本，大概就是个「联网版」的记忆宫殿？但是也没有那么高大上、玄学的概念。毕竟经过自己手里整理过的内容，还是能记住个大概的位置、大概的内容概要。要用的时候，过来一找就找到了。并且在每次找的过程，对这个内容的印象又加深了。\n\n这大概就是我关于这个笔记本的一些想法了，希望这里有能帮助到你的内容，不要忘了给我的 GitHub 仓库一个 Star 🫱🏻 simon1uo/notebook) 。\n\n\n# 关于本笔记的搭建\n\n关于记笔记，已经尝试过太多的软件、工具。包括 OneNote、Notion、各家的云笔记。OneNote 是很好用，在我学习 高数、大物、离散数学、线代 时，真的很好用，无限延伸的页面，并且随意拼贴内容，无论是记笔记和贴错题都很友好，但对于要支持代码高亮和 Markdown 的场景实在有点难用。无数次尝试过使用 notion（或者同类的软件），感觉确实很不错，但是的的确确不是我的菜。最后还是选择了本地 Markdown 文档。Typora 就是一个最适合的软件，就不过多介绍了，并且文件管理是基于电脑的本地文件夹，备份和版本控制同步交给 GitHub 就好了。\n\n为了要部署一个能分享出来的笔记网站，也看过很多的博客。刚好正在学习 Vue 框架，而 VuePress 就是一个很好部署 Markdown 文档静态网站生成的选择。搭建过程转到 📡 关于本笔记的搭建。\n\n\n# 关于本笔记的排版\n\n空格的使用：\n\n * 中英文单词之间增加空格；\n\n * 中文与数字之间不增加空格；\n\n * 数字与单位之间不增加空格；\n\n * 全角标点与其他字符之间不增加空格；\n\n * 链接之间增加空格；\n\n标点符号相关：\n\n * 不重复使用标点符号；\n\n * 书写中文文章使用 中文全角标点符号；\n   \n   * 中文的引号使用 直角引号；\n\n * 遇到完整的英文整句、特殊名词中的标点符号使用 英文半角符号；\n\n英文单词或者专有名词相关：\n\n * 专有名词正确使用的大小写；\n\n * 不要使用不地道的缩写；\n\n> 🍞 参考自 中文文案排版指北（简体中文版） — 码志 (mazhuang.org)。",normalizedContent:"# 关于本笔记\n\n👋🏻 这是一个大部分关于前端内容的「笔记本」。\n\n为何要搭建这个笔记本？其实网上已经有很多关于前端的内容 / 博客 / 笔记 / 分享，但是要用某一部分的内容的时候还得慢慢查找、好的解决方案并不是立刻就能找到，经验还是自己总结的最好。所以，结合一句老话 「好记性不如烂笔头」？现在大概要改为「好记性不如烂键盘」了。很多内容，看过以后没啥感觉，还得用自己的语言总结一遍、过一遍。如果不行，那就看多几篇文章，不断迭代笔记，不懂的内容慢慢就懂了。这就是目前我对我个人来说，比较有效的学习方法了。\n\n看过 sherlock （神探夏洛克）的人应该对里面一个「记忆宫殿」的场景有印象。这个笔记本，大概就是个「联网版」的记忆宫殿？但是也没有那么高大上、玄学的概念。毕竟经过自己手里整理过的内容，还是能记住个大概的位置、大概的内容概要。要用的时候，过来一找就找到了。并且在每次找的过程，对这个内容的印象又加深了。\n\n这大概就是我关于这个笔记本的一些想法了，希望这里有能帮助到你的内容，不要忘了给我的 github 仓库一个 star 🫱🏻 simon1uo/notebook) 。\n\n\n# 关于本笔记的搭建\n\n关于记笔记，已经尝试过太多的软件、工具。包括 onenote、notion、各家的云笔记。onenote 是很好用，在我学习 高数、大物、离散数学、线代 时，真的很好用，无限延伸的页面，并且随意拼贴内容，无论是记笔记和贴错题都很友好，但对于要支持代码高亮和 markdown 的场景实在有点难用。无数次尝试过使用 notion（或者同类的软件），感觉确实很不错，但是的的确确不是我的菜。最后还是选择了本地 markdown 文档。typora 就是一个最适合的软件，就不过多介绍了，并且文件管理是基于电脑的本地文件夹，备份和版本控制同步交给 github 就好了。\n\n为了要部署一个能分享出来的笔记网站，也看过很多的博客。刚好正在学习 vue 框架，而 vuepress 就是一个很好部署 markdown 文档静态网站生成的选择。搭建过程转到 📡 关于本笔记的搭建。\n\n\n# 关于本笔记的排版\n\n空格的使用：\n\n * 中英文单词之间增加空格；\n\n * 中文与数字之间不增加空格；\n\n * 数字与单位之间不增加空格；\n\n * 全角标点与其他字符之间不增加空格；\n\n * 链接之间增加空格；\n\n标点符号相关：\n\n * 不重复使用标点符号；\n\n * 书写中文文章使用 中文全角标点符号；\n   \n   * 中文的引号使用 直角引号；\n\n * 遇到完整的英文整句、特殊名词中的标点符号使用 英文半角符号；\n\n英文单词或者专有名词相关：\n\n * 专有名词正确使用的大小写；\n\n * 不要使用不地道的缩写；\n\n> 🍞 参考自 中文文案排版指北（简体中文版） — 码志 (mazhuang.org)。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📰 HTML 基础",frontmatter:{title:"📰 HTML 基础",date:"2021-09-29T15:51:51.000Z",permalink:"/pages/c70272/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/01.%20%F0%9F%93%B0%20HTML%20%E5%9F%BA%E7%A1%80.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/01. 📰 HTML 基础.md",key:"v-489164fc",path:"/pages/c70272/",headers:[{level:2,title:"HTML 简介",slug:"html-简介",normalizedTitle:"html 简介",charIndex:2},{level:2,title:"HTML 元素",slug:"html-元素",normalizedTitle:"html 元素",charIndex:541},{level:2,title:"HTML 属性",slug:"html-属性",normalizedTitle:"html 属性",charIndex:890},{level:2,title:"HTML 文档类型",slug:"html-文档类型",normalizedTitle:"html 文档类型",charIndex:1178},{level:2,title:"HTML5 简介",slug:"html5-简介",normalizedTitle:"html5 简介",charIndex:1729}],headersStr:"HTML 简介 HTML 元素 HTML 属性 HTML 文档类型 HTML5 简介",content:'# HTML 简介\n\nHTML 全称为「Hyper Text Markup Language」（超文本标记语言）。\n\n * HTML 的基本结构：\n   \n   1. 文档声明： <!DOCTYPE HTML>\n   \n   2. HTML 文档中： <html>\n      \n      页头： <head></head>\n      \n      页身： <body></body>\n      \n      </html>\n\n * 基本标签：\n   \n   1. HTML 标签： <html> 整个网页的开始与结束。\n   \n   2. 页头 <head> 中包含的标签：定义特殊内容，浏览器网页一般不可见：\n      \n      标签         说明\n      <title>    定义网页标题\n      <meta>     定义网页基本元信息\n      <style>    定义网页 CSS 样式\n      <link>     链接外部文件\n      <script>   定义脚本语言\n      <base>     定义页面所有连接的基础定位（少用）\n   \n   3. 页身 <body> 中的标签：定义网页中展示的内容。\n\n\n# HTML 元素\n\nHTML 元素指的是从开始标签到结束标签的所有代码。\n\n> 开始标签又称开放标签（Opening tag），结束标签又称闭合标签（Closing tag）。\n\nHTML 元素语法：\n\n * 元素以 开始标签 开始；\n\n * 元素以 结束标签 终止；\n\n * 元素的内容是 开始标签与结束标签 之间的内容；\n\n * 某些 HTML 元素具有空内容；\n   \n   * 空元素在开始标签中进行关闭（开始标签的结束 <br> ）\n   \n   > 在开始标签中添加斜杠，比如 <br /> ，是关闭空元素的正确方法。在 HTML、XHTML、XML 都接受。\n\n * 大多数 HTML 元素可以拥有属性。\n\n * HTML 标签对大小写不敏感。但是 W3C 标准推荐使用小写。\n\n\n# HTML 属性\n\nHTML 标签的属性提供了与 HTML 元素相关的信息。（JavaScript 篇中称 Attribute 为特性）。\n\n * 总是以 name="value" 形式出现，总是在开始标签中。\n * 对大小写不敏感，但是要求建议小写的形式的 属性 / 属性值。\n * 属性值应该始终被包围在引号中。如果属性值本身包含单引号，那整个属性值要用双引号包含。\n\n🌰 例子 / 链接 <a> 标签：\n\n<a href="http://simon1uo.dev">this is a link</a>\n\n\n1\n\n\n🔗 链接：完整的 HTML 属性参考手册。\n\n\n# HTML 文档类型\n\n在文档的开头使用 <!DOCTYPE> 声明文档的类型，帮助浏览器正确地显示网页。（不是 HTML 标签，只是提供给浏览器的一项 HTML 版本信息）\n\nWeb 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 <!DOCTYPE> 的用处。\n\n🌰 例子 / HTML5 DOCTYPE 文档：\n\n<!DOCTYPE html>\n<html>\n<head>\n<title>Title of the document</title>\n</head>\n\n<body>\nThe content of the document......\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> HTML 4.01 版本的 DOCTYPE：\n> \n> <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"\n> "http://www.w3.org/TR/html4/loose.dtd">\n> \n> \n> 1\n> 2\n\n\n# HTML5 简介\n\n * HTML 与 XHTML：\n   \n   HTML，全称 HyperText Mark-up Language （超文本标记语言），是构成网页文档的主要语言。常说的 HTML 指的是版本是 HTML 4.01。\n   \n   XHTML，全称 Extensible HyperText Mark-up Language（扩展的超文本标记语言）, 它是 XML 风格的 HTML 4.01，可以称之为更严格、更纯净的 HTML 4.01。\n   \n   HTML 语法书写比较松散，容易编写。但是对于机器，如电脑、手机等来说，语法越松散，处理困难。因此为了让机器更好地处理 HTML，于是在 HTML 基础上引入了 XHTML。\n   \n   XHTML 的语法与 HTML 相比更加严格：\n   \n   1. XHTML 中的标签必须闭合：例如， <p></p> 或者 <input /> （空标签也必须闭合 <br/> ）。\n   \n   2. XHTML 中的标签以及属性必须使用小写，不能使用大小写混合。但是属性值可以使用大些。\n   \n   3. XHTML 中的标签属性必须使用引号 “” / ‘’ 包含。\n   \n   4. XHTML 中的除了表单元素以外的所有标签都必须使用 id 标识，而不使用 name 。\n\n * HTML 5\n   \n   HTML 指的是 HTML 4.01，XHTML 是 HTML 的过渡版本，XHTML 是 XML 风格的 HTML 4.01。而 HTML 5 指的是下一代的 HTML，也就是 HTML 4.01 的升级版。\n   \n   新一代版本的 HTML 5 已经不再是单纯意义上的标签了，它已经远远超越了标签的范畴。HTML 5 除了新增部分标签之外，还增加了一组技术，包括 canvas、SVG、WebSocket 本地存储等。这些新增的技术都是使用 JavaScript 来操作。也就是说，HTML 5 使得 HTML 从一门「标记语言」转变为一门「编程语言」。\n   \n   有以下与 HTML 旧版本的区别：\n   \n   1. 文档类型的说明简化为：\n      \n      <!DOCTYPE html>\n      \n      \n      1\n      \n   \n   2. 标签可以不分大小写，但实际开发一般都使用小写。\n   \n   3. 允许属性值不加引号，但是实际开发中一般都要加引号。\n   \n   4. 允许部分的属性值省略，例如 disabled 、 selected 等。',normalizedContent:'# html 简介\n\nhtml 全称为「hyper text markup language」（超文本标记语言）。\n\n * html 的基本结构：\n   \n   1. 文档声明： <!doctype html>\n   \n   2. html 文档中： <html>\n      \n      页头： <head></head>\n      \n      页身： <body></body>\n      \n      </html>\n\n * 基本标签：\n   \n   1. html 标签： <html> 整个网页的开始与结束。\n   \n   2. 页头 <head> 中包含的标签：定义特殊内容，浏览器网页一般不可见：\n      \n      标签         说明\n      <title>    定义网页标题\n      <meta>     定义网页基本元信息\n      <style>    定义网页 css 样式\n      <link>     链接外部文件\n      <script>   定义脚本语言\n      <base>     定义页面所有连接的基础定位（少用）\n   \n   3. 页身 <body> 中的标签：定义网页中展示的内容。\n\n\n# html 元素\n\nhtml 元素指的是从开始标签到结束标签的所有代码。\n\n> 开始标签又称开放标签（opening tag），结束标签又称闭合标签（closing tag）。\n\nhtml 元素语法：\n\n * 元素以 开始标签 开始；\n\n * 元素以 结束标签 终止；\n\n * 元素的内容是 开始标签与结束标签 之间的内容；\n\n * 某些 html 元素具有空内容；\n   \n   * 空元素在开始标签中进行关闭（开始标签的结束 <br> ）\n   \n   > 在开始标签中添加斜杠，比如 <br /> ，是关闭空元素的正确方法。在 html、xhtml、xml 都接受。\n\n * 大多数 html 元素可以拥有属性。\n\n * html 标签对大小写不敏感。但是 w3c 标准推荐使用小写。\n\n\n# html 属性\n\nhtml 标签的属性提供了与 html 元素相关的信息。（javascript 篇中称 attribute 为特性）。\n\n * 总是以 name="value" 形式出现，总是在开始标签中。\n * 对大小写不敏感，但是要求建议小写的形式的 属性 / 属性值。\n * 属性值应该始终被包围在引号中。如果属性值本身包含单引号，那整个属性值要用双引号包含。\n\n🌰 例子 / 链接 <a> 标签：\n\n<a href="http://simon1uo.dev">this is a link</a>\n\n\n1\n\n\n🔗 链接：完整的 html 属性参考手册。\n\n\n# html 文档类型\n\n在文档的开头使用 <!doctype> 声明文档的类型，帮助浏览器正确地显示网页。（不是 html 标签，只是提供给浏览器的一项 html 版本信息）\n\nweb 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。html 也有多个不同的版本，只有完全明白页面中使用的确切 html 版本，浏览器才能完全正确地显示出 html 页面。这就是 <!doctype> 的用处。\n\n🌰 例子 / html5 doctype 文档：\n\n<!doctype html>\n<html>\n<head>\n<title>title of the document</title>\n</head>\n\n<body>\nthe content of the document......\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> html 4.01 版本的 doctype：\n> \n> <!doctype html public "-//w3c//dtd html 4.01 transitional//en"\n> "http://www.w3.org/tr/html4/loose.dtd">\n> \n> \n> 1\n> 2\n\n\n# html5 简介\n\n * html 与 xhtml：\n   \n   html，全称 hypertext mark-up language （超文本标记语言），是构成网页文档的主要语言。常说的 html 指的是版本是 html 4.01。\n   \n   xhtml，全称 extensible hypertext mark-up language（扩展的超文本标记语言）, 它是 xml 风格的 html 4.01，可以称之为更严格、更纯净的 html 4.01。\n   \n   html 语法书写比较松散，容易编写。但是对于机器，如电脑、手机等来说，语法越松散，处理困难。因此为了让机器更好地处理 html，于是在 html 基础上引入了 xhtml。\n   \n   xhtml 的语法与 html 相比更加严格：\n   \n   1. xhtml 中的标签必须闭合：例如， <p></p> 或者 <input /> （空标签也必须闭合 <br/> ）。\n   \n   2. xhtml 中的标签以及属性必须使用小写，不能使用大小写混合。但是属性值可以使用大些。\n   \n   3. xhtml 中的标签属性必须使用引号 “” / ‘’ 包含。\n   \n   4. xhtml 中的除了表单元素以外的所有标签都必须使用 id 标识，而不使用 name 。\n\n * html 5\n   \n   html 指的是 html 4.01，xhtml 是 html 的过渡版本，xhtml 是 xml 风格的 html 4.01。而 html 5 指的是下一代的 html，也就是 html 4.01 的升级版。\n   \n   新一代版本的 html 5 已经不再是单纯意义上的标签了，它已经远远超越了标签的范畴。html 5 除了新增部分标签之外，还增加了一组技术，包括 canvas、svg、websocket 本地存储等。这些新增的技术都是使用 javascript 来操作。也就是说，html 5 使得 html 从一门「标记语言」转变为一门「编程语言」。\n   \n   有以下与 html 旧版本的区别：\n   \n   1. 文档类型的说明简化为：\n      \n      <!doctype html>\n      \n      \n      1\n      \n   \n   2. 标签可以不分大小写，但实际开发一般都使用小写。\n   \n   3. 允许属性值不加引号，但是实际开发中一般都要加引号。\n   \n   4. 允许部分的属性值省略，例如 disabled 、 selected 等。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍣 HTML 文本元素",frontmatter:{title:"🍣 HTML 文本元素",date:"2022-06-07T22:46:26.000Z",permalink:"/pages/286aba/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/03.%20%F0%9F%8D%A3%20HTML%20%E6%96%87%E6%9C%AC%E5%85%83%E7%B4%A0.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/03. 🍣 HTML 文本元素.md",key:"v-157bc241",path:"/pages/286aba/",headers:[{level:2,title:"HTML 标题",slug:"html-标题",normalizedTitle:"html 标题",charIndex:2},{level:2,title:"HMTL 水平线 <hr / >",slug:"hmtl-水平线-hr",normalizedTitle:"hmtl 水平线 &lt;hr /&gt;",charIndex:null},{level:2,title:"<p> 标签",slug:"p-标签",normalizedTitle:"<p> 标签",charIndex:378},{level:2,title:"文本格式化标签",slug:"文本格式化标签",normalizedTitle:"文本格式化标签",charIndex:449},{level:3,title:"斜体",slug:"斜体",normalizedTitle:"斜体",charIndex:461},{level:3,title:"加粗",slug:"加粗",normalizedTitle:"加粗",charIndex:715},{level:3,title:"缩小文字",slug:"缩小文字",normalizedTitle:"缩小文字",charIndex:953},{level:3,title:"换行",slug:"换行",normalizedTitle:"换行",charIndex:65},{level:2,title:"HTML 引用",slug:"html-引用",normalizedTitle:"html 引用",charIndex:1207}],headersStr:"HTML 标题 HMTL 水平线 <hr / > <p> 标签 文本格式化标签 斜体 加粗 缩小文字 换行 HTML 引用",content:'# HTML 标题\n\nHTML 标题是通过 <h1> ～ <h6> 等标签进行定义的。\n\n * 一些浏览器会自动在标题前后后添加 换行；\n * 默认情况下 HTML 会自动 在块级元素添加额外的的空行，例如段落、标题前后。\n\n🌰 例子：\n\n<h1>This is a heading</h1>\n<h2>This is a heading</h2>\n<h3>This is a heading</h3>\n\n\n1\n2\n3\n\n\n\n# HMTL 水平线 <hr / >\n\n在 HTML 页面中创建水平线，用于分割内容。\n\n🌰 例子：\n\n<p>This is a paragraph</p>\n<hr />\n<p>This is a paragraph</p>\n<hr />\n<p>This is a paragraph</p>\n\n\n1\n2\n3\n4\n5\n\n\n\n# <p> 标签\n\n对于普通的文本可以使用 <p></p> 包含。\n\n<p>something about women</p>\n\n\n1\n\n\n\n# 文本格式化标签\n\n\n# 斜体\n\n<em> 和 <i> 的区别：\n\n\x3c!-- emphasis --\x3e\n<p>I think you <em>should</em> do it.</p>\n\n\x3c!-- foreign language phrases --\x3e\n<p>that old <i>cliché</i> \'a woman\'s place is in the home\'</p>\n\n\n1\n2\n3\n4\n5\n\n\n<i> 元素标签由于某种原因可以在文本范围中区别于正常文本，例如技术术语、外语短语或角色想法。它通常以斜体显示。\n\n\n# 加粗\n\n<strong> / <b> 的区别：\n\n> 虽然 <strong> 和 <b> 效果相同，但语义不同。\n> \n> <b> 和 <i> 是视觉要素（presentationl elements），分别表示无意义的加粗，无意义的斜体。\n> \n> <em> 和 <strong> 是表达要素 (phrase elements)。但这时的 <strong> 表示 html 页面上的强调（emphasized text）， <em> 表示句子中的强调（即强调语义）\n\n\n# 缩小文字\n\n<small> 此元素代表旁注和小字体，例如版权和法律文本。与普通文本相比，它使内容更小。\n\n<p>Check out this Offer! \n  <small>Terms and conditions apply.</small>\n</p>\n\n\n1\n2\n3\n\n\n\n# 换行\n\n<p></p> 元素中，允许在段落中创建换行符 <br/> 。它对于写一首诗或写地址很有用，行的划分很重要。\n\n🔗 链接：[更多文本格式化标签](HTML 文本格式化 (w3school.com.cn))\n\n\n# HTML 引用\n\n使用 <q> 标签定义 短的引用元素。通常浏览器会自动包围引号。\n\n🌰 例子：\n\n<html>\n  <p>WWF 的目标是：<q>构建人与自然和谐共存的世界。</q></p>\n</html>\n\n\n1\n2\n3\n\n\n\n使用 <blockquote> 定义被引用的节段。通常浏览器会对该元素进行 缩进 处理。\n\n🌰 例子：\n\n<html>\n  <p>以下内容引用自 WWF 的网站：</p>\n  <blockquote cite="http://www.worldwildlife.org/who/index.html">\n    五十年来，WWF 一直致力于保护自然界的未来。\n    世界领先的环保组织，WWF 工作于 100 个国家，\n    并得到美国一百二十万会员及全球近五百万会员的支持。\n  </blockquote>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n使用 <abbr> 定义 缩略词 元素；\n\n🌰 例子：\n\n<html>\n  <p><abbr title="World Health Organization">WHO</abbr> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n使用 <dfn> 定义 项目或者缩写的定义 元素；\n\n * 如果 设置了 <dfn> 的 title 元素，定义的是项目；\n * 如果 <dfn> 元素包含具有标题的 <abbr> 元素，则 title 定义项目：\n * 否则 <dfn> 的文本内容是项目，父元素包含定义。\n\n🌰 例子 / 项目：\n\n<html>\n  <p><dfn title="World Health Organization">WHO</dfn> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n🌰 例子 / title 定义项目：\n\n<html>\n  <p><dfn><abbr title="World Health Organization">WHO</abbr></dfn> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n🌰 例子 / 文本内容是项目，父元素包含定义：\n\n<html>\n  <p><dfn><abbr title="World Health Organization">WHO</abbr></dfn> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n使用 <address> 定义文档或者文章作者的联系方式。此元素通常以斜体显示。大多数浏览器会在此元素前后添加折行。\n\n使用 <cite> 定义著作的标题。通常以 斜体 显示。\n\n🌰 例子：\n\n<html>\n  <address>\n    Written by Donald Duck.<br> \n    Visit us at:<br>\n    Example.com<br>\n    Box 564, Disneyland<br>\n    USA\n  </address>\n  \n  <p><cite>The Scream</cite> by Edward Munch. Painted in 1893.</p>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n',normalizedContent:'# html 标题\n\nhtml 标题是通过 <h1> ～ <h6> 等标签进行定义的。\n\n * 一些浏览器会自动在标题前后后添加 换行；\n * 默认情况下 html 会自动 在块级元素添加额外的的空行，例如段落、标题前后。\n\n🌰 例子：\n\n<h1>this is a heading</h1>\n<h2>this is a heading</h2>\n<h3>this is a heading</h3>\n\n\n1\n2\n3\n\n\n\n# hmtl 水平线 <hr / >\n\n在 html 页面中创建水平线，用于分割内容。\n\n🌰 例子：\n\n<p>this is a paragraph</p>\n<hr />\n<p>this is a paragraph</p>\n<hr />\n<p>this is a paragraph</p>\n\n\n1\n2\n3\n4\n5\n\n\n\n# <p> 标签\n\n对于普通的文本可以使用 <p></p> 包含。\n\n<p>something about women</p>\n\n\n1\n\n\n\n# 文本格式化标签\n\n\n# 斜体\n\n<em> 和 <i> 的区别：\n\n\x3c!-- emphasis --\x3e\n<p>i think you <em>should</em> do it.</p>\n\n\x3c!-- foreign language phrases --\x3e\n<p>that old <i>cliche</i> \'a woman\'s place is in the home\'</p>\n\n\n1\n2\n3\n4\n5\n\n\n<i> 元素标签由于某种原因可以在文本范围中区别于正常文本，例如技术术语、外语短语或角色想法。它通常以斜体显示。\n\n\n# 加粗\n\n<strong> / <b> 的区别：\n\n> 虽然 <strong> 和 <b> 效果相同，但语义不同。\n> \n> <b> 和 <i> 是视觉要素（presentationl elements），分别表示无意义的加粗，无意义的斜体。\n> \n> <em> 和 <strong> 是表达要素 (phrase elements)。但这时的 <strong> 表示 html 页面上的强调（emphasized text）， <em> 表示句子中的强调（即强调语义）\n\n\n# 缩小文字\n\n<small> 此元素代表旁注和小字体，例如版权和法律文本。与普通文本相比，它使内容更小。\n\n<p>check out this offer! \n  <small>terms and conditions apply.</small>\n</p>\n\n\n1\n2\n3\n\n\n\n# 换行\n\n<p></p> 元素中，允许在段落中创建换行符 <br/> 。它对于写一首诗或写地址很有用，行的划分很重要。\n\n🔗 链接：[更多文本格式化标签](html 文本格式化 (w3school.com.cn))\n\n\n# html 引用\n\n使用 <q> 标签定义 短的引用元素。通常浏览器会自动包围引号。\n\n🌰 例子：\n\n<html>\n  <p>wwf 的目标是：<q>构建人与自然和谐共存的世界。</q></p>\n</html>\n\n\n1\n2\n3\n\n\n\n使用 <blockquote> 定义被引用的节段。通常浏览器会对该元素进行 缩进 处理。\n\n🌰 例子：\n\n<html>\n  <p>以下内容引用自 wwf 的网站：</p>\n  <blockquote cite="http://www.worldwildlife.org/who/index.html">\n    五十年来，wwf 一直致力于保护自然界的未来。\n    世界领先的环保组织，wwf 工作于 100 个国家，\n    并得到美国一百二十万会员及全球近五百万会员的支持。\n  </blockquote>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n使用 <abbr> 定义 缩略词 元素；\n\n🌰 例子：\n\n<html>\n  <p><abbr title="world health organization">who</abbr> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n使用 <dfn> 定义 项目或者缩写的定义 元素；\n\n * 如果 设置了 <dfn> 的 title 元素，定义的是项目；\n * 如果 <dfn> 元素包含具有标题的 <abbr> 元素，则 title 定义项目：\n * 否则 <dfn> 的文本内容是项目，父元素包含定义。\n\n🌰 例子 / 项目：\n\n<html>\n  <p><dfn title="world health organization">who</dfn> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n🌰 例子 / title 定义项目：\n\n<html>\n  <p><dfn><abbr title="world health organization">who</abbr></dfn> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n🌰 例子 / 文本内容是项目，父元素包含定义：\n\n<html>\n  <p><dfn><abbr title="world health organization">who</abbr></dfn> 成立于 1948 年。</p>\n</html>\n\n\n1\n2\n3\n\n\n\n使用 <address> 定义文档或者文章作者的联系方式。此元素通常以斜体显示。大多数浏览器会在此元素前后添加折行。\n\n使用 <cite> 定义著作的标题。通常以 斜体 显示。\n\n🌰 例子：\n\n<html>\n  <address>\n    written by donald duck.<br> \n    visit us at:<br>\n    example.com<br>\n    box 564, disneyland<br>\n    usa\n  </address>\n  \n  <p><cite>the scream</cite> by edward munch. painted in 1893.</p>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🫕 HTML 结构元素",frontmatter:{title:"🫕 HTML 结构元素",date:"2022-06-07T22:47:37.000Z",permalink:"/pages/64a1a7/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/04.%20%F0%9F%AB%95%20HTML%20%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/04. 🫕 HTML 结构元素.md",key:"v-36daa0e9",path:"/pages/64a1a7/",headers:[{level:2,title:"Header",slug:"header",normalizedTitle:"header",charIndex:28},{level:2,title:"Navigation",slug:"navigation",normalizedTitle:"navigation",charIndex:225},{level:2,title:"Article",slug:"article",normalizedTitle:"article",charIndex:350},{level:2,title:"Section",slug:"section",normalizedTitle:"section",charIndex:508},{level:2,title:"div / article / section",slug:"div-article-section",normalizedTitle:"div / article / section",charIndex:561},{level:2,title:"Aside",slug:"aside",normalizedTitle:"aside",charIndex:677},{level:2,title:"Footer",slug:"footer",normalizedTitle:"footer",charIndex:737}],headersStr:"Header Navigation Article Section div / article / section Aside Footer",content:"🌰 例子 / 一个 HTML 页面结构：\n\n\n\n\n# Header\n\n<header> 元素来包含代表一组介绍性或辅助导航的内容：\n\n * 可能包含一些标题元素（h1、h2 ...），但也包含其他元素，如 Logo、搜索表单等。\n\n * 是一个块元素， 位于 body 元素中\n   \n   <header>\n   \t<h1> Head Name </h1>\n   </header>\n   \n   \n   1\n   2\n   3\n   \n\n\n# Navigation\n\n表示链接到其他页面或页面中的一部分，它是带有导航链接的部分。 <nav> 仅用于主要导航部分，例如页眉页面，页面页脚或目录。\n\n一个关闭的导航链接不应使用 <nav> ，例如指向网站其他部分或外部网站的段落中的链接。\n\n\n# Article\n\n * <article> 元素表示页面中的自包含内容，都是可独立分发或重用的。\n\n<article>\n  <p>paragraphs about something</p>\n  <p>paragraphs about something</p>\n</article>\n\n\n1\n2\n3\n4\n\n\n\n# Section\n\n<section> 表示文档的通用部分，例如一类主题内容的分组，通常带有标题。\n\n\n# div / article / section\n\n * 仅以样式目的对内容进行分组 : <div>\n * 内容是独立的并添加到页面大纲中， <article>\n * 将相关内容组合在一起并添加到页面中， <section>\n\n\n# Aside\n\n网站一侧垂直的内容：块元素，默认占用整个页面的宽度。\n\n<aside> ... </aside>\n\n\n# Footer\n\n表示根元素的页脚。页脚通常包含有关该部分的作者、版权数据或相关文档的链接的信息。也可以是具有其他导航链接的站点页脚。\n\n<footer> ... </footer>",normalizedContent:"🌰 例子 / 一个 html 页面结构：\n\n\n\n\n# header\n\n<header> 元素来包含代表一组介绍性或辅助导航的内容：\n\n * 可能包含一些标题元素（h1、h2 ...），但也包含其他元素，如 logo、搜索表单等。\n\n * 是一个块元素， 位于 body 元素中\n   \n   <header>\n   \t<h1> head name </h1>\n   </header>\n   \n   \n   1\n   2\n   3\n   \n\n\n# navigation\n\n表示链接到其他页面或页面中的一部分，它是带有导航链接的部分。 <nav> 仅用于主要导航部分，例如页眉页面，页面页脚或目录。\n\n一个关闭的导航链接不应使用 <nav> ，例如指向网站其他部分或外部网站的段落中的链接。\n\n\n# article\n\n * <article> 元素表示页面中的自包含内容，都是可独立分发或重用的。\n\n<article>\n  <p>paragraphs about something</p>\n  <p>paragraphs about something</p>\n</article>\n\n\n1\n2\n3\n4\n\n\n\n# section\n\n<section> 表示文档的通用部分，例如一类主题内容的分组，通常带有标题。\n\n\n# div / article / section\n\n * 仅以样式目的对内容进行分组 : <div>\n * 内容是独立的并添加到页面大纲中， <article>\n * 将相关内容组合在一起并添加到页面中， <section>\n\n\n# aside\n\n网站一侧垂直的内容：块元素，默认占用整个页面的宽度。\n\n<aside> ... </aside>\n\n\n# footer\n\n表示根元素的页脚。页脚通常包含有关该部分的作者、版权数据或相关文档的链接的信息。也可以是具有其他导航链接的站点页脚。\n\n<footer> ... </footer>",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥙 HTML 更多元素",frontmatter:{title:"🥙 HTML 更多元素",date:"2022-06-07T22:54:34.000Z",permalink:"/pages/7acc1d/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/05.%20%F0%9F%A5%99%20HTML%20%E6%9B%B4%E5%A4%9A%E5%85%83%E7%B4%A0.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/05. 🥙 HTML 更多元素.md",key:"v-fb81fc8a",path:"/pages/7acc1d/",headers:[{level:2,title:"HTML 列表元素",slug:"html-列表元素",normalizedTitle:"html 列表元素",charIndex:2},{level:3,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:16},{level:3,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:420},{level:3,title:"有序列表中嵌套无序列表",slug:"有序列表中嵌套无序列表",normalizedTitle:"有序列表中嵌套无序列表",charIndex:582},{level:2,title:"HTML 多媒体元素",slug:"html-多媒体元素",normalizedTitle:"html 多媒体元素",charIndex:922},{level:3,title:"处理媒体路径",slug:"处理媒体路径",normalizedTitle:"处理媒体路径",charIndex:937},{level:3,title:"链接（超链接）",slug:"链接-超链接",normalizedTitle:"链接（超链接）",charIndex:1454},{level:3,title:"图片",slug:"图片",normalizedTitle:"图片",charIndex:1329},{level:3,title:"音频",slug:"音频",normalizedTitle:"音频",charIndex:2121},{level:3,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:2505},{level:3,title:"<iframe> 内联框架",slug:"iframe-内联框架",normalizedTitle:"<iframe> 内联框架",charIndex:2707},{level:2,title:"HTML 表格",slug:"html-表格",normalizedTitle:"html 表格",charIndex:3071}],headersStr:"HTML 列表元素 有序列表 无序列表 有序列表中嵌套无序列表 HTML 多媒体元素 处理媒体路径 链接（超链接） 图片 音频 视频 <iframe> 内联框架 HTML 表格",content:'# HTML 列表元素\n\n\n# 有序列表\n\n使用 <ol> 标签配合 <li> 标签定义有序列表项。\n\n<html>\n  <ol>\n    <li>1st item</li>\n    <li>2nd item</li>\n    <li>3rd item</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n使用 start 属性定义有序列表启动的数字：\n\n<html>\n  <ol start="21">\n    <li>21st item</li>\n    <li>22nd item</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n使用按字母顺序排列列表项，可以使用 type 属性：\n\n<html>\n  <ol type="a">\n    <li>item a</li>\n    <li>item b</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 无序列表\n\n使用 <ul> 标签配合 <li> 标签定义无序列表：\n\n<html>\n  <ul>\n    <li>Milk</li>\n    <li>Eggs</li>\n    <li>Flour</li>\n    <li>Honey</li>\n\t</ul>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n# 有序列表中嵌套无序列表\n\n<html>\n  <ol>\n    <li>\n      Pancake\n      <ul>\n        <li>Milk</li>\n        <li>Eggs</li>\n        <li>Flour</li>\n        <li>Honey</li>\n      </ul>\n    </li>\n    <li>Spaghetti</li>\n    <li>Beef brisket</li>\n    <li>Tomatoes</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n> 一些 HTML 列表样式参考：Webdesign-Lists\n\n\n# HTML 多媒体元素\n\n\n# 处理媒体路径\n\n🌟 相对路径\n\n当前文件相关的路径，起点是当前文件开始的文件夹时，使用 ./ ，例如使用当前文件夹的 images 文件夹中的 *.jpg 文件： ./images/example_image.jpg 。\n\n访问当前文件上一级文件夹，使用 ../ 。\n\n[] Lab\n├──[] html\n│   ├── index.html\n│   └── ducks.html\n├──[] css\n│   └── style.css\n└──[] images\n    └── rubber_duck.png\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例，当前文件是 index.html ，要使用 style.css 文件时：\n\n<link href="../css/style.css" rel="stylesheet" type="text/css" /> \n\n\n1\n\n\n使用图片文件：\n\n<img src=\'../images/rubber_duck.png\'>\n\n\n1\n\n\n绝对路径：完整的资源 / 文件路径地址。\n\n例如： <img src="https://placekitten.com/50/50" />\n\n\n# 链接（超链接）\n\n超链接使用 <a> 标签：\n\n * 使用 href 属性，创建指向另一个文档的链接；\n * 使用 name 属性，创建文档内的书签。\n\n🌰 例子：\n\n<a href="link" target=""/>\n\n\n1\n\n\n * target 表示链接的打开方式，有以下属性值：\n   \n   属性值      说明\n   _self    默认方式，在当前窗口打开\n   _blank   在全新空白的窗口打开\n\n * 超链接根据链接对象的不同分为：\n   \n   * 外部链接\n   * 内部链接：（1）内部页面链接；（2）锚点链接；\n     * 锚点链接为：点击某一个超链接，它就会跳到当前页面的某一部分。\n\n\n# 图片\n\n相关属性：\n\n * src ：图像的资源链接；\n\n * alt ：替换文本属性，用于添加图像的描述，有助于搜索引擎了解图像的内容。\n\n图像可以采用宽度和高度设置，在使用宽度和高度定义图像大小时，宽高比可能会中断。要定义图片高度和宽度，浏览器将自动调整以保持正确的宽高比。\n\n默认情况下， <img> 标签是行内元素，它将与其周围元素内联。\n\n<p>\n  This is a rubber duck.\n  <img src="./images/rubber_duck.png" alt="rubber duck">\n  It is yellow and made of rubber.\n</p>\n\n\n1\n2\n3\n4\n5\n\n\n可以使用 display: block; 将其调整为块元素\n\n\n# 音频\n\n使用 <audio> 标签添加音频。具有自动播放、循环和预加载等属性。类似 img 图片元素，使用 src 标识文件的资源。\n\n * autoplay 属性：自动播放添加标签，则音频元素将不会显示在页面上，但在页面加载时音频文件自动播放。\n\n<audio src="song.mp3" autoplay></audio>\n\n\n1\n\n * controls 属性：在页面上显示音频控制面板：\n\n<audio src="song.mp3" controls></audio>\n\n\n1\n\n * preload ：该属性接受三个值： none ， auto 和 metadata 。** 默认无设置下，页面将将其视为选择了 auto ，预加载音频文件的所有信息。** 如果音频文件不是页面的基本组件，建议使用 metadata/none 提高页面加载的速度。\n\n\n# 视频\n\n使用 <video> 标签添加视频元素，接受的属性包括：\n\n * autoplay ：一般用于不希望用户控制视频，且不能与 controls 使用。\n\n * poster ：设置视频的封面，最好不要与 autoplay 并用以免减弱效果。\n\n🌰 例子：\n\n<video src="video.mp4" controls poster="poster.jpg"></vide>\n\n\n1\n\n\n\n# <iframe> 内联框架\n\n嵌入其他网站支持的内容，使用 <iframe> 标签。\n\n🌰 例子：\n\n<iframe src="URL"></iframe>\n\n\n1\n\n\n> 浮动框架是一种较为特殊的框架，它是在浏览器窗口中嵌套的子窗口，整个页面并不一定是框架页面，但要包含一个框架窗口。 <iframe> 框架可以完全由设计者定义宽度和高度，并且可以放置在一个网页的任何位置，这极大地扩展了框架页面的应用范围。\n\n属性：\n\n * 设置框架的宽和高： width / height\n\n * 设置框架是否显示滚动条 scrolling ，三种取值： auto 为默认值，整个表哥在浏览器页面向左对齐； yes 总是显示滚动条； no 任何情况都不显示。\n\n * frameborder ：设置边框。设置为 0 移除边框。\n\n\n# HTML 表格\n\n🌰 例子：\n\n<html>\n<table border="1">\n    <tr>\n        <th>Header 1</th>\n        <th>Header 2</th>\n    </tr>\n    <tr>\n        <td>row 1, cell 1</td>\n        <td>row 1, cell 2</td>\n    </tr>\n    <tr>\n        <td>row 2, cell 1</td>\n        <td>row 2, cell 2</td>\n    </tr>\n</table></html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n表头标签： <th> </th>\n\n标签           描述\n<table>      定义表格\n<th>         定义表格的表头\n<tr>         定义表格的行\n<td>         定义表格单元\n<caption>    定义表格标题\n<colgroup>   定义表格列的组\n<col>        定义用于表格列的属性\n<thead>      定义表格的页眉\n<tbody>      定义表格的主体\n<tfoot>      定义表格的页脚',normalizedContent:'# html 列表元素\n\n\n# 有序列表\n\n使用 <ol> 标签配合 <li> 标签定义有序列表项。\n\n<html>\n  <ol>\n    <li>1st item</li>\n    <li>2nd item</li>\n    <li>3rd item</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n使用 start 属性定义有序列表启动的数字：\n\n<html>\n  <ol start="21">\n    <li>21st item</li>\n    <li>22nd item</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n使用按字母顺序排列列表项，可以使用 type 属性：\n\n<html>\n  <ol type="a">\n    <li>item a</li>\n    <li>item b</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 无序列表\n\n使用 <ul> 标签配合 <li> 标签定义无序列表：\n\n<html>\n  <ul>\n    <li>milk</li>\n    <li>eggs</li>\n    <li>flour</li>\n    <li>honey</li>\n\t</ul>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n# 有序列表中嵌套无序列表\n\n<html>\n  <ol>\n    <li>\n      pancake\n      <ul>\n        <li>milk</li>\n        <li>eggs</li>\n        <li>flour</li>\n        <li>honey</li>\n      </ul>\n    </li>\n    <li>spaghetti</li>\n    <li>beef brisket</li>\n    <li>tomatoes</li>\n\t</ol>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n> 一些 html 列表样式参考：webdesign-lists\n\n\n# html 多媒体元素\n\n\n# 处理媒体路径\n\n🌟 相对路径\n\n当前文件相关的路径，起点是当前文件开始的文件夹时，使用 ./ ，例如使用当前文件夹的 images 文件夹中的 *.jpg 文件： ./images/example_image.jpg 。\n\n访问当前文件上一级文件夹，使用 ../ 。\n\n[] lab\n├──[] html\n│   ├── index.html\n│   └── ducks.html\n├──[] css\n│   └── style.css\n└──[] images\n    └── rubber_duck.png\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例，当前文件是 index.html ，要使用 style.css 文件时：\n\n<link href="../css/style.css" rel="stylesheet" type="text/css" /> \n\n\n1\n\n\n使用图片文件：\n\n<img src=\'../images/rubber_duck.png\'>\n\n\n1\n\n\n绝对路径：完整的资源 / 文件路径地址。\n\n例如： <img src="https://placekitten.com/50/50" />\n\n\n# 链接（超链接）\n\n超链接使用 <a> 标签：\n\n * 使用 href 属性，创建指向另一个文档的链接；\n * 使用 name 属性，创建文档内的书签。\n\n🌰 例子：\n\n<a href="link" target=""/>\n\n\n1\n\n\n * target 表示链接的打开方式，有以下属性值：\n   \n   属性值      说明\n   _self    默认方式，在当前窗口打开\n   _blank   在全新空白的窗口打开\n\n * 超链接根据链接对象的不同分为：\n   \n   * 外部链接\n   * 内部链接：（1）内部页面链接；（2）锚点链接；\n     * 锚点链接为：点击某一个超链接，它就会跳到当前页面的某一部分。\n\n\n# 图片\n\n相关属性：\n\n * src ：图像的资源链接；\n\n * alt ：替换文本属性，用于添加图像的描述，有助于搜索引擎了解图像的内容。\n\n图像可以采用宽度和高度设置，在使用宽度和高度定义图像大小时，宽高比可能会中断。要定义图片高度和宽度，浏览器将自动调整以保持正确的宽高比。\n\n默认情况下， <img> 标签是行内元素，它将与其周围元素内联。\n\n<p>\n  this is a rubber duck.\n  <img src="./images/rubber_duck.png" alt="rubber duck">\n  it is yellow and made of rubber.\n</p>\n\n\n1\n2\n3\n4\n5\n\n\n可以使用 display: block; 将其调整为块元素\n\n\n# 音频\n\n使用 <audio> 标签添加音频。具有自动播放、循环和预加载等属性。类似 img 图片元素，使用 src 标识文件的资源。\n\n * autoplay 属性：自动播放添加标签，则音频元素将不会显示在页面上，但在页面加载时音频文件自动播放。\n\n<audio src="song.mp3" autoplay></audio>\n\n\n1\n\n * controls 属性：在页面上显示音频控制面板：\n\n<audio src="song.mp3" controls></audio>\n\n\n1\n\n * preload ：该属性接受三个值： none ， auto 和 metadata 。** 默认无设置下，页面将将其视为选择了 auto ，预加载音频文件的所有信息。** 如果音频文件不是页面的基本组件，建议使用 metadata/none 提高页面加载的速度。\n\n\n# 视频\n\n使用 <video> 标签添加视频元素，接受的属性包括：\n\n * autoplay ：一般用于不希望用户控制视频，且不能与 controls 使用。\n\n * poster ：设置视频的封面，最好不要与 autoplay 并用以免减弱效果。\n\n🌰 例子：\n\n<video src="video.mp4" controls poster="poster.jpg"></vide>\n\n\n1\n\n\n\n# <iframe> 内联框架\n\n嵌入其他网站支持的内容，使用 <iframe> 标签。\n\n🌰 例子：\n\n<iframe src="url"></iframe>\n\n\n1\n\n\n> 浮动框架是一种较为特殊的框架，它是在浏览器窗口中嵌套的子窗口，整个页面并不一定是框架页面，但要包含一个框架窗口。 <iframe> 框架可以完全由设计者定义宽度和高度，并且可以放置在一个网页的任何位置，这极大地扩展了框架页面的应用范围。\n\n属性：\n\n * 设置框架的宽和高： width / height\n\n * 设置框架是否显示滚动条 scrolling ，三种取值： auto 为默认值，整个表哥在浏览器页面向左对齐； yes 总是显示滚动条； no 任何情况都不显示。\n\n * frameborder ：设置边框。设置为 0 移除边框。\n\n\n# html 表格\n\n🌰 例子：\n\n<html>\n<table border="1">\n    <tr>\n        <th>header 1</th>\n        <th>header 2</th>\n    </tr>\n    <tr>\n        <td>row 1, cell 1</td>\n        <td>row 1, cell 2</td>\n    </tr>\n    <tr>\n        <td>row 2, cell 1</td>\n        <td>row 2, cell 2</td>\n    </tr>\n</table></html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n表头标签： <th> </th>\n\n标签           描述\n<table>      定义表格\n<th>         定义表格的表头\n<tr>         定义表格的行\n<td>         定义表格单元\n<caption>    定义表格标题\n<colgroup>   定义表格列的组\n<col>        定义用于表格列的属性\n<thead>      定义表格的页眉\n<tbody>      定义表格的主体\n<tfoot>      定义表格的页脚',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍱 HTML 块元素和行内元素",frontmatter:{title:"🍱 HTML 块元素和行内元素",date:"2022-06-07T22:45:22.000Z",permalink:"/pages/bb41df/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/07.%20%F0%9F%8D%B1%20HTML%20%E5%9D%97%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/07. 🍱 HTML 块元素和行内元素.md",key:"v-4f5c3eb5",path:"/pages/bb41df/",headers:[{level:2,title:"HTML 块元素",slug:"html-块元素",normalizedTitle:"html 块元素",charIndex:2},{level:3,title:"<div>",slug:"div",normalizedTitle:"<div>",charIndex:152},{level:2,title:"HTML 行内元素（内联元素）",slug:"html-行内元素-内联元素",normalizedTitle:"html 行内元素（内联元素）",charIndex:269},{level:3,title:"<span>",slug:"span",normalizedTitle:"<span>",charIndex:468}],headersStr:"HTML 块元素 <div> HTML 行内元素（内联元素） <span>",content:"# HTML 块元素\n\n * 块元素始终 在新一行 开始；\n * 块元素层叠在一起，并占据整个宽度；\n * 块元素可以彼此嵌套并包装行内元素；\n\n<html>\n  <h1>block element</h1>\n\t<p>block element1</p>\n</html>\n\n\n1\n2\n3\n4\n\n\n\n\n# <div>\n\n是常见的块级元素，可用于组合其他 HTML 元素的容器。\n\n * 没有特殊的含义；\n * 如果同 CSS 一同食用，可用对于大的内容块设置样式；\n * 常见用途进行文档布局，取代使用 表格标签 的老式布局方法。\n\n\n# HTML 行内元素（内联元素）\n\n * 不会再新一行开始；\n\n * 根据在 HTML 出现的顺序以此排列；\n\n * 仅占用其内容的宽度；\n\n * 可以将行内元素嵌套在彼此内部；\n\n * 不能使用行内元素包装块元素；\n\n * 行内元素通常是比较小的内容，如单词。\n   \n   <strong>粗体</strong>\n   <em>斜体</em>\n   \n   \n   1\n   2\n   \n\n\n# <span>\n\n是常见的行内元素，可以用作文本的容器：\n\n * 没有特殊的含义；\n * 与 CSS 一同使用，设置文本的样式属性。",normalizedContent:"# html 块元素\n\n * 块元素始终 在新一行 开始；\n * 块元素层叠在一起，并占据整个宽度；\n * 块元素可以彼此嵌套并包装行内元素；\n\n<html>\n  <h1>block element</h1>\n\t<p>block element1</p>\n</html>\n\n\n1\n2\n3\n4\n\n\n\n\n# <div>\n\n是常见的块级元素，可用于组合其他 html 元素的容器。\n\n * 没有特殊的含义；\n * 如果同 css 一同食用，可用对于大的内容块设置样式；\n * 常见用途进行文档布局，取代使用 表格标签 的老式布局方法。\n\n\n# html 行内元素（内联元素）\n\n * 不会再新一行开始；\n\n * 根据在 html 出现的顺序以此排列；\n\n * 仅占用其内容的宽度；\n\n * 可以将行内元素嵌套在彼此内部；\n\n * 不能使用行内元素包装块元素；\n\n * 行内元素通常是比较小的内容，如单词。\n   \n   <strong>粗体</strong>\n   <em>斜体</em>\n   \n   \n   1\n   2\n   \n\n\n# <span>\n\n是常见的行内元素，可以用作文本的容器：\n\n * 没有特殊的含义；\n * 与 css 一同使用，设置文本的样式属性。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍳 HTML 类与 id",frontmatter:{title:"🍳 HTML 类与 id",date:"2022-06-08T00:21:51.000Z",permalink:"/pages/3886ef/",categories:["🚶 前端入门基础","🕸 HTML"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/08.%20%F0%9F%8D%B3%20HTML%20%E7%B1%BB%E4%B8%8E%20id.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/08. 🍳 HTML 类与 id.md",key:"v-fecb5b10",path:"/pages/3886ef/",headers:[{level:2,title:"HTML 类",slug:"html-类",normalizedTitle:"html 类",charIndex:2},{level:2,title:"HTML id",slug:"html-id",normalizedTitle:"html id",charIndex:986},{level:2,title:"HTML id 与 class 的区别",slug:"html-id-与-class-的区别",normalizedTitle:"html id 与 class 的区别",charIndex:1541}],headersStr:"HTML 类 HTML id HTML id 与 class 的区别",content:'# HTML 类\n\n对 HTML 的内容进行分类，可以为 元素的类 定义 CSS 样式，对相同的类使用相同的样式。\n\n🌰 例子 / 块级元素分类：\n\n<style>\n\t.cities {\n    background-color:black;\n    color:white;\n    margin:20px;\n    padding:20px;\n\t} \n</style>\n<html>\n  <div class="cities">\n    <h2>London</h2>\n    <p>\n    London is the capital city of England. \n    It is the most populous city in the United Kingdom, \n    with a metropolitan area of over 13 million inhabitants.\n    </p>\n  </div> \n  \n  <div class="cities">\n    <h2>Paris</h2>\n    <p>Paris is the capital and most populous city of France.</p>\n  </div>\n  \n  \n  <div class="cities">\n    <h2>Tokyo</h2>\n    <p>Tokyo is the capital of Japan, the center of the Greater Tokyo Area,\n    and the most populous metropolitan area in the world.</p>\n  </div>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n🌰 例子 / 行内元素分类：\n\n<style>\n  span.red {color:red;}\n</style>\n<html>\n  <h1>My <span class="red">Important</span> Heading</h1>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# HTML id\n\nHTML id 属性用于为 HTML 元素指定一个唯一的标识 id。一个 HTML 文档中不能存在相同的 id 的元素。\n\n * 用于指向样式表中特定的样式声明；\n * 用于 JavaScript 中用它来访问和操作特定 id 的元素；\n\n注意\n\n * id 名称对大小写敏感；\n * id 必须包含一个字符，字符不能包含空白字符；\n\n🌰 例子：\n\n<style>\n  #myHeader {\n    background-color: lightblue;\n    color: black;\n    padding: 40px;\n    text-align: center;\n  }\n</style>\n<html>\n  <h1 id="myHeader">My Header</h1>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n🌰 例子 / JavaScript 使用 ID：\n\n<script>\nfunction displayResult() {\n  document.getElementById("myHeader").innerHTML = "Have a nice day!";\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n\n# HTML id 与 class 的区别\n\n * 在同一个 HTML 文档中可以存在多个使用同一个类名的元素；\n * 在同一个 HTML 文档中只能存在使用唯一 id 的元素；',normalizedContent:'# html 类\n\n对 html 的内容进行分类，可以为 元素的类 定义 css 样式，对相同的类使用相同的样式。\n\n🌰 例子 / 块级元素分类：\n\n<style>\n\t.cities {\n    background-color:black;\n    color:white;\n    margin:20px;\n    padding:20px;\n\t} \n</style>\n<html>\n  <div class="cities">\n    <h2>london</h2>\n    <p>\n    london is the capital city of england. \n    it is the most populous city in the united kingdom, \n    with a metropolitan area of over 13 million inhabitants.\n    </p>\n  </div> \n  \n  <div class="cities">\n    <h2>paris</h2>\n    <p>paris is the capital and most populous city of france.</p>\n  </div>\n  \n  \n  <div class="cities">\n    <h2>tokyo</h2>\n    <p>tokyo is the capital of japan, the center of the greater tokyo area,\n    and the most populous metropolitan area in the world.</p>\n  </div>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n🌰 例子 / 行内元素分类：\n\n<style>\n  span.red {color:red;}\n</style>\n<html>\n  <h1>my <span class="red">important</span> heading</h1>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# html id\n\nhtml id 属性用于为 html 元素指定一个唯一的标识 id。一个 html 文档中不能存在相同的 id 的元素。\n\n * 用于指向样式表中特定的样式声明；\n * 用于 javascript 中用它来访问和操作特定 id 的元素；\n\n注意\n\n * id 名称对大小写敏感；\n * id 必须包含一个字符，字符不能包含空白字符；\n\n🌰 例子：\n\n<style>\n  #myheader {\n    background-color: lightblue;\n    color: black;\n    padding: 40px;\n    text-align: center;\n  }\n</style>\n<html>\n  <h1 id="myheader">my header</h1>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n🌰 例子 / javascript 使用 id：\n\n<script>\nfunction displayresult() {\n  document.getelementbyid("myheader").innerhtml = "have a nice day!";\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n\n# html id 与 class 的区别\n\n * 在同一个 html 文档中可以存在多个使用同一个类名的元素；\n * 在同一个 html 文档中只能存在使用唯一 id 的元素；',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧅 HTML 头部元素",frontmatter:{title:"🧅 HTML 头部元素",date:"2022-06-08T00:35:15.000Z",permalink:"/pages/42605a/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/09.%20%F0%9F%A7%85%20HTML%20%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/09. 🧅 HTML 头部元素.md",key:"v-47839f38",path:"/pages/42605a/",headers:[{level:2,title:"HTML <head>",slug:"html-head",normalizedTitle:"html <head>",charIndex:2},{level:2,title:"HTML <title>",slug:"html-title",normalizedTitle:"html <title>",charIndex:56},{level:2,title:"HTML <base>",slug:"html-base",normalizedTitle:"html <base>",charIndex:213},{level:2,title:"HTML <link>",slug:"html-link",normalizedTitle:"html <link>",charIndex:361},{level:2,title:"HTML <style>",slug:"html-style",normalizedTitle:"html <style>",charIndex:500},{level:2,title:"HTML <meta>",slug:"html-meta",normalizedTitle:"html <meta>",charIndex:657},{level:2,title:"HTML <script>",slug:"html-script",normalizedTitle:"html <script>",charIndex:1013}],headersStr:"HTML <head> HTML <title> HTML <base> HTML <link> HTML <style> HTML <meta> HTML <script>",content:'# HTML <head>\n\n是所有头部元素的容器，在 <head> 内的元素，可以包含脚本或者样式。\n\n\n# HTML <title>\n\n * 定义文档的标题。（提供搜索引擎结果中的页面标题；添加到收藏夹时的页面标题）\n\n * 在 HTML / XHTML 文档中是必须的。\n\n🌰 例子：\n\n<head>\n<title>Title of the document</title>\n</head>\n\n\n1\n2\n3\n\n\n\n# HTML <base>\n\n为页面上的所有链接规定默认地址或者默认目标。\n\n🌰 例子：\n\n<head>\n<base href="http://www.simon1uo.dev/images/" />\n<base target="_blank" />\n</head>\n\n\n1\n2\n3\n4\n\n\n\n# HTML <link>\n\n定义文档与外部资源之间的关系，最常用于链接外部样式表。\n\n🌰 例子：\n\n<head>\n<link rel="stylesheet" type="text/css" href="mystyle.css" />\n</head>\n\n\n1\n2\n3\n\n\n\n# HTML <style>\n\n常用于定义 HTML 文档内的样式信息。\n\n🌰 例子：\n\n<head>\n<style type="text/css">\nbody {background-color:yellow}\np {color:blue}\n</style>\n</head>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# HTML <meta>\n\n * 提供关于 HTML 文档的元数据。不会显示到页面上，但是对于机器是可读的。被用于规定页面的描述、关键词、文档作者、修改时间以及其他元数据。用于 浏览器（显示页面标题）、搜索引擎（搜索关键词 SEO）、或者其他 Web 服务。\n * 始终位于 <head> 元素中。\n\n🌰 例子： description 定义页面的描述， keywords 定义页面的关键词。\n\n<head>\n  <meta name="description" content="Free Web tutorials on HTML, CSS, XML" />\n\t<meta name="keywords" content="HTML, CSS, XML" />\n</head>\n\n\n1\n2\n3\n4\n\n\n\n# HTML <script>\n\n用于定义客户端脚本，比如 JavaScript。',normalizedContent:'# html <head>\n\n是所有头部元素的容器，在 <head> 内的元素，可以包含脚本或者样式。\n\n\n# html <title>\n\n * 定义文档的标题。（提供搜索引擎结果中的页面标题；添加到收藏夹时的页面标题）\n\n * 在 html / xhtml 文档中是必须的。\n\n🌰 例子：\n\n<head>\n<title>title of the document</title>\n</head>\n\n\n1\n2\n3\n\n\n\n# html <base>\n\n为页面上的所有链接规定默认地址或者默认目标。\n\n🌰 例子：\n\n<head>\n<base href="http://www.simon1uo.dev/images/" />\n<base target="_blank" />\n</head>\n\n\n1\n2\n3\n4\n\n\n\n# html <link>\n\n定义文档与外部资源之间的关系，最常用于链接外部样式表。\n\n🌰 例子：\n\n<head>\n<link rel="stylesheet" type="text/css" href="mystyle.css" />\n</head>\n\n\n1\n2\n3\n\n\n\n# html <style>\n\n常用于定义 html 文档内的样式信息。\n\n🌰 例子：\n\n<head>\n<style type="text/css">\nbody {background-color:yellow}\np {color:blue}\n</style>\n</head>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# html <meta>\n\n * 提供关于 html 文档的元数据。不会显示到页面上，但是对于机器是可读的。被用于规定页面的描述、关键词、文档作者、修改时间以及其他元数据。用于 浏览器（显示页面标题）、搜索引擎（搜索关键词 seo）、或者其他 web 服务。\n * 始终位于 <head> 元素中。\n\n🌰 例子： description 定义页面的描述， keywords 定义页面的关键词。\n\n<head>\n  <meta name="description" content="free web tutorials on html, css, xml" />\n\t<meta name="keywords" content="html, css, xml" />\n</head>\n\n\n1\n2\n3\n4\n\n\n\n# html <script>\n\n用于定义客户端脚本，比如 javascript。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧀 HTML 响应式页面",frontmatter:{title:"🧀 HTML 响应式页面",date:"2022-06-08T00:43:06.000Z",permalink:"/pages/aa23b5/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/10.%20%F0%9F%A7%80%20HTML%20%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/10. 🧀 HTML 响应式页面.md",key:"v-55ad45a1",path:"/pages/aa23b5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥨 HTML 表单元素",frontmatter:{title:"🥨 HTML 表单元素",date:"2022-06-07T23:21:59.000Z",permalink:"/pages/1c9bbf/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/11.%20%F0%9F%A5%A8%20HTML%20%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/11. 🥨 HTML 表单元素.md",key:"v-2321eb02",path:"/pages/1c9bbf/",headers:[{level:2,title:"form 元素",slug:"form-元素",normalizedTitle:"form 元素",charIndex:2},{level:3,title:"action 属性和 method 属性",slug:"action-属性和-method-属性",normalizedTitle:"action 属性和 method 属性",charIndex:176},{level:3,title:"fieldset 元素组合表单数据",slug:"fieldset-元素组合表单数据",normalizedTitle:"fieldset 元素组合表单数据",charIndex:401},{level:3,title:"更多属性",slug:"更多属性",normalizedTitle:"更多属性",charIndex:885},{level:3,title:"name 属性",slug:"name-属性",normalizedTitle:"name 属性",charIndex:1281},{level:2,title:"input 元素",slug:"input-元素",normalizedTitle:"input 元素",charIndex:1556},{level:3,title:"文本输入 text",slug:"文本输入-text",normalizedTitle:"文本输入 text",charIndex:1604},{level:3,title:"密码输入 password",slug:"密码输入-password",normalizedTitle:"密码输入 password",charIndex:1874},{level:3,title:"单选按钮 radio",slug:"单选按钮-radio",normalizedTitle:"单选按钮 radio",charIndex:2090},{level:3,title:"复选框 checkbox",slug:"复选框-checkbox",normalizedTitle:"复选框 checkbox",charIndex:2320},{level:3,title:"普通按钮 button",slug:"普通按钮-button",normalizedTitle:"普通按钮 button",charIndex:2599},{level:3,title:"数字输入 number",slug:"数字输入-number",normalizedTitle:"数字输入 number",charIndex:2723},{level:3,title:"提交按钮 submit",slug:"提交按钮-submit",normalizedTitle:"提交按钮 submit",charIndex:3029},{level:3,title:"限制输入类型的属性",slug:"限制输入类型的属性",normalizedTitle:"限制输入类型的属性",charIndex:3444},{level:3,title:"新增输入属性",slug:"新增输入属性",normalizedTitle:"新增输入属性",charIndex:4202},{level:2,title:"<select> 下拉列表元素",slug:"select-下拉列表元素",normalizedTitle:"<select> 下拉列表元素",charIndex:5697},{level:2,title:"<textarea> 元素",slug:"textarea-元素",normalizedTitle:"<textarea> 元素",charIndex:6046},{level:2,title:"<button> 元素",slug:"button-元素",normalizedTitle:"<button> 元素",charIndex:6247}],headersStr:"form 元素 action 属性和 method 属性 fieldset 元素组合表单数据 更多属性 name 属性 input 元素 文本输入 text 密码输入 password 单选按钮 radio 复选框 checkbox 普通按钮 button 数字输入 number 提交按钮 submit 限制输入类型的属性 新增输入属性 <select> 下拉列表元素 <textarea> 元素 <button> 元素",content:'# form 元素\n\n使用 <form> 标签 收集用户输入的数据，定义 HTML 表单元素。\n\n🌰 例子：\n\n<form>\n  \x3c!-- form elements --\x3e\n</form>\n\n\n1\n2\n3\n\n\n表单元素包含 不同类型的 input 输入元素、 select 复选框元素、 radio 单选按钮、 button 提交按钮等。\n\n\n# action 属性和 method 属性\n\n * action 属性定义在提交表单执行时的动作。如果忽略则 action 为当前页面。\n * method 属性规定在提交表单时使用的 HTTP 方法。\n\n🌰 例子：\n\n<html>\n  <form action="action_page.php" method="GET">\n  \t\x3c!-- form elements --\x3e\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n# fieldset 元素组合表单数据\n\n * <fieldset> 标签组合表单中的相关数据的元素；\n * <legend> 元素为为 <fieldset> 元素定义标题；\n\n🌰 例子：\n\n<html>\n  <form action="/">\n    <fieldset>\n      <legend>Personal information:</legend>\n      First name:<br>\n      <input type="text" name="firstname" value="Mickey">\n      <br>\n      Last name:<br>\n      <input type="text" name="lastname" value="Mouse">\n      <br><br>\n      <input type="submit" value="Submit">\n    </fieldset>\n  </form> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n# 更多属性\n\n属性               描述\naccept-charset   规定在被提交表单中使用的字符集（默认：页面字符集）。\naction           规定向何处提交表单的地址（URL）（提交页面）。\nautocomplete     规定浏览器应该自动完成表单（默认值： on 开启）。\nenctype          规定被提交数据的编码（默认： url-encoded ）。\nmethod           规定在提交表单时所用的 HTTP 方法（默认值： GET ）。\nname             规定识别表单的名称（对于 DOM 使用： document.forms.name ）。\nnovalidate       规定浏览器不验证表单。\ntarget           规定 action 属性中地址的目标（默认值： _self ）。\n\n\n# name 属性\n\n如果表单数据要被正确的提交，每个输入字段都必须要设置 name 属性。\n\n🌰 例子：\n\n<form>\n  First name:<br>\n  <input type="text" value="Mickey">\n  <br>\n  Last name:<br>\n  <input type="text" name="lastname" value="Mouse">\n  <br><br>\n  <input type="submit" value="Submit">\n</form>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# input 元素\n\n根据不同类型 type 的属性，有不同的形态；是最重要的表单元素。\n\n\n# 文本输入 text\n\n<input type="text"> 用于文本输入的单行输入字段：\n\n * 注意文本字段的 默认宽度是 20 个字符。\n\n🌰 例子：\n\n<html>\n  <form>\n    First name:<br>\n    <input type="text" name="firstname">\n    <br>\n    Last name:<br>\n    <input type="text" name="lastname">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n# 密码输入 password\n\n🌰 例子：\n\n<html>\n  <form>\n     User name:<br>\n    <input type="text" name="username">\n    <br>\n     User password:<br>\n    <input type="password" name="psw">\n  </form> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n# 单选按钮 radio\n\n<input type="radio"> 定义单选按钮，允许用户在有限数量的选项中选择其中之一的值。\n\n🌰 例子：\n\n<html>\n  <input type="radio" name="sex" value="male" checked> Male\n  <br />\n  <input type="radio" name="sex" value="female"> Female\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n# 复选框 checkbox\n\n<input type="checkbox>" 定义复选框。允许用户在有限数量的选项中选择零个或者多个值。\n\n🌰 例子：\n\n<html>\n  <form>\n    <input type="checkbox" name="vehicle" value="Bike">I have a bike\n    <br>\n    <input type="checkbox" name="vehicle" value="Car">I have a car \n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# 普通按钮 button\n\n🌰 例子：\n\n<html>\n  <input type="button" onclick="alert(\'Hello World!\')" value="Click Me!">\n</html>\n\n\n1\n2\n3\n\n\n\n\n# 数字输入 number\n\n<input type="number"> 用于限制输入的内容为数字字段的输入框。\n\n🌰 例子：\n\n<html>\n  <form>\n    Quantity (between 1 and 5):\n  \t<input type="number" name="quantity" min="1" max="5">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n更多的 HTML 5 新增的输入类型：\n\n * time\n\n * week\n\n * datetime\n\n * color\n\n * email\n\n * tel\n\n * search\n\n * url\n\n\n# 提交按钮 submit\n\n<input type="submit"> 用于定义表单处理程序提交表单的按钮。\n\n * 表单处理程序通常用来处理 输入数据的脚本 的服务器页面；\n * 表单处理程序在 form 的 action 属性中指定；\n\n🌰 例子：\n\n<html>\n  <form action="/">\n    First name:<br>\n    <input type="text" name="firstname" value="Mickey">\n    <br>\n    Last name:<br>\n    <input type="text" name="lastname" value="Mouse">\n    <br><br>\n\t\t<input type="submit" value="Submit">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n# 限制输入类型的属性\n\n * disabled ：禁用输入字段；\n * max / min ：规定输入字段的最大值和最小值；\n * maxlength ：规定输入字段的最大字符数；\n * pattern ：规定通过其检查输入值的正则表达式；\n * readonly ：规定输入字段为只读（无法修改）；\n * requeired ：规定输入字段是必须填写的；\n * size ：规定输入字段的宽度（以字符个数计）；\n * step ：规定输入字段的合法数字间隔；\n * value ：规定输入字段的默认值；\n\n🌰 例子 / 只读输入、默认值 value 、禁用字段 disabled ：\n\n<html>\n  <form>\n    First name:<br>\n    <input type="text" name="firstname" value="Bill" readonly>\n    <br>\n     Last name:<br>\n    <input type="text" name="lastname" disabled>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n🌰 例子 / maxlength 规定字段最大长度：\n\n<html>\n  <form action="">\n     First name:<br>\n    <input type="text" name="firstname" maxlength="10">\n    <br>\n     Last name:<br>\n    <input type="text" name="lastname">\n  </form> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n# 新增输入属性\n\n * autocomplete ：规定表单或者输入字段是否由 浏览器自动填充。（基于用户之前填写的值自动填写），设为 on / off ；适用于 表单 <form> 和 这些 <input> 类型： text / search / url / tel / email / password / phone / color ；\n\n * placeholder ：规定输入字段的预设值提示。适用于文本类的输入类型。\n\n * pattern ：规定输入字段检查 <input> 元素的值的正则表达式。\n\n * novalidate ：用于 <form> 元素的属性。设置后，规定提交表单时不对表单数据进行验证。\n\n * autofocus ：设置时，当页面加载时，该输入元素（如 <input> ）会自动获得焦点。\n\n * form 属性：用于 <input> 指定所属的一个或者多个表单（使用表单的 id 标识）；如果需要引用一个以上的表达， 使用空格分开表单 id 。\n\n * formaction 属性：规定当前输入字段的输入 action 。会覆盖 <form> 元素设置的 action 属性。适用于 type="submit" 或者 type="image" ；\n\n * formenctype 属性：规定当前表单数据提交至服务器时，如何对其编码（仅针对 post 方法提交表单时），会覆盖 <form> 元素的 enctype 元素。适用于 type="submit" 或者 type="image" ；\n\n * formmethod / formnovalid / formtarget 同与上两同理。覆盖 <form> 元素设置的对应属性；\n\n * height / width ：设置 <input> 元素高度和宽度。仅适用于 <input type="image"> 类型的输入类型。\n\n * list ：引用 <datalist> 元素中包含的 <input> 元素的预定义选项；\n\n * muitple ：如果设置，允许用户在 <input> 中输入一个以上的值；适用于 email / file 的 <input> 输入类型。\n\n🌰 例子 / pattern ：\n\n<html>\n  <form>\n    Country code: \n\t\t<input type="text" name="country_code" pattern="[A-Za-z]{3}" title="Three letter country code">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n🌰 例子 / list ：\n\n<html>\n  <input list="browsers">\n\n  <datalist id="browsers">\n     <option value="Internet Explorer">\n     <option value="Firefox">\n     <option value="Chrome">\n     <option value="Opera">\n     <option value="Safari">\n  </datalist> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n🌰 例子 / mutiple 上传多个文件：\n\nSelect images: <input type="file" name="img" multiple>\n\n\n1\n\n\n\n# <select> 下拉列表元素\n\n定义下拉列表元素。\n\n * 使用 selected 属性定义预定义选项。通常为第一个选项。\n\n🌰 例子：\n\n<html>\n  <form>\n    <select name="cars">\n      <option value="volvo" selected>Volvo</option>\n      <option value="saab">Saab</option>\n      <option value="fiat">Fiat</option>\n      <option value="audi">Audi</option>\n    </select>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# <textarea> 元素\n\n定义多行输入字段（文字域）。\n\n🌰 例子：\n\n<html>\n  <form>\n    <textarea name="message" rows="10" cols="30">\n    \tThe cat was playing in the garden.\n    </textarea>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# <button> 元素\n\n定义可点击的按钮。\n\n🌰 例子：\n\n<html>\n  <form>\n    <button type="button" onclick="alert(\'Hello World!\')">Click Me!</button>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n\n',normalizedContent:'# form 元素\n\n使用 <form> 标签 收集用户输入的数据，定义 html 表单元素。\n\n🌰 例子：\n\n<form>\n  \x3c!-- form elements --\x3e\n</form>\n\n\n1\n2\n3\n\n\n表单元素包含 不同类型的 input 输入元素、 select 复选框元素、 radio 单选按钮、 button 提交按钮等。\n\n\n# action 属性和 method 属性\n\n * action 属性定义在提交表单执行时的动作。如果忽略则 action 为当前页面。\n * method 属性规定在提交表单时使用的 http 方法。\n\n🌰 例子：\n\n<html>\n  <form action="action_page.php" method="get">\n  \t\x3c!-- form elements --\x3e\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n# fieldset 元素组合表单数据\n\n * <fieldset> 标签组合表单中的相关数据的元素；\n * <legend> 元素为为 <fieldset> 元素定义标题；\n\n🌰 例子：\n\n<html>\n  <form action="/">\n    <fieldset>\n      <legend>personal information:</legend>\n      first name:<br>\n      <input type="text" name="firstname" value="mickey">\n      <br>\n      last name:<br>\n      <input type="text" name="lastname" value="mouse">\n      <br><br>\n      <input type="submit" value="submit">\n    </fieldset>\n  </form> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n# 更多属性\n\n属性               描述\naccept-charset   规定在被提交表单中使用的字符集（默认：页面字符集）。\naction           规定向何处提交表单的地址（url）（提交页面）。\nautocomplete     规定浏览器应该自动完成表单（默认值： on 开启）。\nenctype          规定被提交数据的编码（默认： url-encoded ）。\nmethod           规定在提交表单时所用的 http 方法（默认值： get ）。\nname             规定识别表单的名称（对于 dom 使用： document.forms.name ）。\nnovalidate       规定浏览器不验证表单。\ntarget           规定 action 属性中地址的目标（默认值： _self ）。\n\n\n# name 属性\n\n如果表单数据要被正确的提交，每个输入字段都必须要设置 name 属性。\n\n🌰 例子：\n\n<form>\n  first name:<br>\n  <input type="text" value="mickey">\n  <br>\n  last name:<br>\n  <input type="text" name="lastname" value="mouse">\n  <br><br>\n  <input type="submit" value="submit">\n</form>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# input 元素\n\n根据不同类型 type 的属性，有不同的形态；是最重要的表单元素。\n\n\n# 文本输入 text\n\n<input type="text"> 用于文本输入的单行输入字段：\n\n * 注意文本字段的 默认宽度是 20 个字符。\n\n🌰 例子：\n\n<html>\n  <form>\n    first name:<br>\n    <input type="text" name="firstname">\n    <br>\n    last name:<br>\n    <input type="text" name="lastname">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n# 密码输入 password\n\n🌰 例子：\n\n<html>\n  <form>\n     user name:<br>\n    <input type="text" name="username">\n    <br>\n     user password:<br>\n    <input type="password" name="psw">\n  </form> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n# 单选按钮 radio\n\n<input type="radio"> 定义单选按钮，允许用户在有限数量的选项中选择其中之一的值。\n\n🌰 例子：\n\n<html>\n  <input type="radio" name="sex" value="male" checked> male\n  <br />\n  <input type="radio" name="sex" value="female"> female\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n# 复选框 checkbox\n\n<input type="checkbox>" 定义复选框。允许用户在有限数量的选项中选择零个或者多个值。\n\n🌰 例子：\n\n<html>\n  <form>\n    <input type="checkbox" name="vehicle" value="bike">i have a bike\n    <br>\n    <input type="checkbox" name="vehicle" value="car">i have a car \n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# 普通按钮 button\n\n🌰 例子：\n\n<html>\n  <input type="button" onclick="alert(\'hello world!\')" value="click me!">\n</html>\n\n\n1\n2\n3\n\n\n\n\n# 数字输入 number\n\n<input type="number"> 用于限制输入的内容为数字字段的输入框。\n\n🌰 例子：\n\n<html>\n  <form>\n    quantity (between 1 and 5):\n  \t<input type="number" name="quantity" min="1" max="5">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n更多的 html 5 新增的输入类型：\n\n * time\n\n * week\n\n * datetime\n\n * color\n\n * email\n\n * tel\n\n * search\n\n * url\n\n\n# 提交按钮 submit\n\n<input type="submit"> 用于定义表单处理程序提交表单的按钮。\n\n * 表单处理程序通常用来处理 输入数据的脚本 的服务器页面；\n * 表单处理程序在 form 的 action 属性中指定；\n\n🌰 例子：\n\n<html>\n  <form action="/">\n    first name:<br>\n    <input type="text" name="firstname" value="mickey">\n    <br>\n    last name:<br>\n    <input type="text" name="lastname" value="mouse">\n    <br><br>\n\t\t<input type="submit" value="submit">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n# 限制输入类型的属性\n\n * disabled ：禁用输入字段；\n * max / min ：规定输入字段的最大值和最小值；\n * maxlength ：规定输入字段的最大字符数；\n * pattern ：规定通过其检查输入值的正则表达式；\n * readonly ：规定输入字段为只读（无法修改）；\n * requeired ：规定输入字段是必须填写的；\n * size ：规定输入字段的宽度（以字符个数计）；\n * step ：规定输入字段的合法数字间隔；\n * value ：规定输入字段的默认值；\n\n🌰 例子 / 只读输入、默认值 value 、禁用字段 disabled ：\n\n<html>\n  <form>\n    first name:<br>\n    <input type="text" name="firstname" value="bill" readonly>\n    <br>\n     last name:<br>\n    <input type="text" name="lastname" disabled>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n🌰 例子 / maxlength 规定字段最大长度：\n\n<html>\n  <form action="">\n     first name:<br>\n    <input type="text" name="firstname" maxlength="10">\n    <br>\n     last name:<br>\n    <input type="text" name="lastname">\n  </form> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n# 新增输入属性\n\n * autocomplete ：规定表单或者输入字段是否由 浏览器自动填充。（基于用户之前填写的值自动填写），设为 on / off ；适用于 表单 <form> 和 这些 <input> 类型： text / search / url / tel / email / password / phone / color ；\n\n * placeholder ：规定输入字段的预设值提示。适用于文本类的输入类型。\n\n * pattern ：规定输入字段检查 <input> 元素的值的正则表达式。\n\n * novalidate ：用于 <form> 元素的属性。设置后，规定提交表单时不对表单数据进行验证。\n\n * autofocus ：设置时，当页面加载时，该输入元素（如 <input> ）会自动获得焦点。\n\n * form 属性：用于 <input> 指定所属的一个或者多个表单（使用表单的 id 标识）；如果需要引用一个以上的表达， 使用空格分开表单 id 。\n\n * formaction 属性：规定当前输入字段的输入 action 。会覆盖 <form> 元素设置的 action 属性。适用于 type="submit" 或者 type="image" ；\n\n * formenctype 属性：规定当前表单数据提交至服务器时，如何对其编码（仅针对 post 方法提交表单时），会覆盖 <form> 元素的 enctype 元素。适用于 type="submit" 或者 type="image" ；\n\n * formmethod / formnovalid / formtarget 同与上两同理。覆盖 <form> 元素设置的对应属性；\n\n * height / width ：设置 <input> 元素高度和宽度。仅适用于 <input type="image"> 类型的输入类型。\n\n * list ：引用 <datalist> 元素中包含的 <input> 元素的预定义选项；\n\n * muitple ：如果设置，允许用户在 <input> 中输入一个以上的值；适用于 email / file 的 <input> 输入类型。\n\n🌰 例子 / pattern ：\n\n<html>\n  <form>\n    country code: \n\t\t<input type="text" name="country_code" pattern="[a-za-z]{3}" title="three letter country code">\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n🌰 例子 / list ：\n\n<html>\n  <input list="browsers">\n\n  <datalist id="browsers">\n     <option value="internet explorer">\n     <option value="firefox">\n     <option value="chrome">\n     <option value="opera">\n     <option value="safari">\n  </datalist> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n🌰 例子 / mutiple 上传多个文件：\n\nselect images: <input type="file" name="img" multiple>\n\n\n1\n\n\n\n# <select> 下拉列表元素\n\n定义下拉列表元素。\n\n * 使用 selected 属性定义预定义选项。通常为第一个选项。\n\n🌰 例子：\n\n<html>\n  <form>\n    <select name="cars">\n      <option value="volvo" selected>volvo</option>\n      <option value="saab">saab</option>\n      <option value="fiat">fiat</option>\n      <option value="audi">audi</option>\n    </select>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# <textarea> 元素\n\n定义多行输入字段（文字域）。\n\n🌰 例子：\n\n<html>\n  <form>\n    <textarea name="message" rows="10" cols="30">\n    \tthe cat was playing in the garden.\n    </textarea>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# <button> 元素\n\n定义可点击的按钮。\n\n🌰 例子：\n\n<html>\n  <form>\n    <button type="button" onclick="alert(\'hello world!\')">click me!</button>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌯 HTML canvans 画布与 SVG",frontmatter:{title:"🌯 HTML canvans 画布与 SVG",date:"2022-06-08T12:39:28.000Z",permalink:"/pages/3f6201/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/15.%20%F0%9F%8C%AF%20HTML%20canvans%20%E7%94%BB%E5%B8%83%E4%B8%8E%20SVG.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/15. 🌯 HTML canvans 画布与 SVG.md",key:"v-4bfbfc8f",path:"/pages/3f6201/",headers:[{level:2,title:"HMTL5 canvas 元素",slug:"hmtl5-canvas-元素",normalizedTitle:"hmtl5 canvas 元素",charIndex:2},{level:2,title:"HTML 内联 SVG",slug:"html-内联-svg",normalizedTitle:"html 内联 svg",charIndex:273},{level:2,title:"Canvas 与 SVG 比较",slug:"canvas-与-svg-比较",normalizedTitle:"canvas 与 svg 比较",charIndex:658},{level:3,title:"Canvas",slug:"canvas",normalizedTitle:"canvas",charIndex:208},{level:3,title:"SVG",slug:"svg",normalizedTitle:"svg",charIndex:281}],headersStr:"HMTL5 canvas 元素 HTML 内联 SVG Canvas 与 SVG 比较 Canvas SVG",content:'# HMTL5 canvas 元素\n\n * canvas 元素用于在网页上 使用 JavaScript 绘制图形；\n\n * canvas 画布是一个矩形区域，可以控制每一个像素；\n\n * canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\n🌰 例子 / 创建一个 canvas 元素，使用 width / height 规定元素的宽度和高度：\n\n<html>\n  <canvas id="newCanvas" width="200" height="100"></canvas>\n</html>\n\n\n1\n2\n3\n\n\n\n\n# HTML 内联 SVG\n\n> SVG ：可伸缩矢量图形（Scalable Vector Graphics），使用 XML 格式定义图形。与其他图形格式相比，可以通过文本编辑器修改；可以被搜索、索引、脚本化和压缩；并且可以在任何分辨率下被高质量打印、不下降质量的情况被放大；\n\n🌰 例子：\n\n<html>\n\t<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190">\n  \t<polygon points="100,10 40,180 190,60 10,60 160,180"\n  style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" />\n\t</svg>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# Canvas 与 SVG 比较\n\n\n# Canvas\n\n * 依赖分辨率\n * 不支持事件处理器\n * 弱的文本渲染能力\n * 能够以 .png 或 .jpg 格式保存结果图像\n * 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n\n# SVG\n\n * 不依赖分辨率\n * 支持事件处理器\n * 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n * 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n * 不适合游戏应用',normalizedContent:'# hmtl5 canvas 元素\n\n * canvas 元素用于在网页上 使用 javascript 绘制图形；\n\n * canvas 画布是一个矩形区域，可以控制每一个像素；\n\n * canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\n🌰 例子 / 创建一个 canvas 元素，使用 width / height 规定元素的宽度和高度：\n\n<html>\n  <canvas id="newcanvas" width="200" height="100"></canvas>\n</html>\n\n\n1\n2\n3\n\n\n\n\n# html 内联 svg\n\n> svg ：可伸缩矢量图形（scalable vector graphics），使用 xml 格式定义图形。与其他图形格式相比，可以通过文本编辑器修改；可以被搜索、索引、脚本化和压缩；并且可以在任何分辨率下被高质量打印、不下降质量的情况被放大；\n\n🌰 例子：\n\n<html>\n\t<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190">\n  \t<polygon points="100,10 40,180 190,60 10,60 160,180"\n  style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" />\n\t</svg>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# canvas 与 svg 比较\n\n\n# canvas\n\n * 依赖分辨率\n * 不支持事件处理器\n * 弱的文本渲染能力\n * 能够以 .png 或 .jpg 格式保存结果图像\n * 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n\n# svg\n\n * 不依赖分辨率\n * 支持事件处理器\n * 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n * 复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快）\n * 不适合游戏应用',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⚡️ HTML5 语义化标签",frontmatter:{title:"⚡️ HTML5 语义化标签",date:"2022-02-17T16:19:46.000Z",permalink:"/pages/6bdb29/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/20.%20%E2%9A%A1%EF%B8%8F%20HTML5%20%20%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/20. ⚡️ HTML5  语义化标签.md",key:"v-f1fc15c0",path:"/pages/6bdb29/",headers:[{level:3,title:"标题语义化",slug:"标题语义化",normalizedTitle:"标题语义化",charIndex:178},{level:3,title:"图片语义化",slug:"图片语义化",normalizedTitle:"图片语义化",charIndex:420},{level:3,title:"表格语义化",slug:"表格语义化",normalizedTitle:"表格语义化",charIndex:807},{level:3,title:"表单语义化",slug:"表单语义化",normalizedTitle:"表单语义化",charIndex:1555},{level:3,title:"其他语义化",slug:"其他语义化",normalizedTitle:"其他语义化",charIndex:265},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3580}],headersStr:"标题语义化 图片语义化 表格语义化 表单语义化 其他语义化 总结",content:'HTML 中的大部分标签都有自身的语义，例如 <p> 标签表示 paragraph 一个段落， <h1> 标签表示 header1 最高级的标题。\n\n而在实际开发中，如果使用成千上万的 <div> 或者 <span> 来代替语义化标签，会给后期维护增加难度。使用语义结构良好的编码在实际开发中十分重要，利于开发调试和后期维护；利于搜索引擎的优化。\n\n\n# 标题语义化\n\nh1 ~ h6 是分级标题标签， h 表示「header」。h1~ h6 在 HTML 语义化中占有极其重要的地位。 h1 为最高级的标题，以此往下类推。相对于其他语义化标签，分级标题在搜索引擎优化（即 SEO）中占有相当重要的地位。 在一个页面中，6 个分级标题不需要全部都用上，都是根据需要才用的。\n\n使用标题的分级，需要注意以下方面：\n\n * 一个页面只有一个 h1 标签；\n * h1 ~ h6 之间不要断层；\n * 不要使用分级标题的标签来定义样式；\n\n\n# 图片语义化\n\n<img> 标签中的 alt 属性和 title 属性：\n\n * alt 属性用于图片描述。并且当图片无法显示时，页面会显示 alt 中的文字。 alt 对搜索引擎识别网页中的图片内容起到作用。是 <img> 标签的必须属性。\n * title 属性也用于图片描述，当鼠标指针移到图片上时，会显示 title 中的内容。是可选属性。\n\n<figure> 和 <figcaption> 元素：用于实现图片加标注的效果，使得页面的语义更加良好，如下🌰：\n\n<html>\n  <figure>\n    <img src="https://placekitten.com/200/200" alt="可爱猫猫" />\n    <figcaption>可爱猫猫</figcaption>\n  </figure>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 表格语义化\n\n表格常用的三个标签为 <table> 、 <tr> 、 <td> ，为了加强语义化添加了 5 个标签：\n\n标签名       说明\nthead     表头的语义划分标签\ntbody     表身\ntfoot     表脚\ncaption   表格标题\nth        表头单元格\ntr        行\ntd        表格单元格\n\n例子 🌰 ：\n\n<html>\n  <table>\n    <caption> 表格标题 </caption> \n    \x3c!--表头--\x3e\n    <thead>\n      <tr>\n        <th>表头单元格l</th>\n        <th>表头单元格2</th> \n      </tr>\n    </thead>\n    \x3c!--表身--\x3e\n    <tbody>\n      <tr>\n        <td>标准单元格l</td>\n        <td>标准单元格2</td> \n      </tr>\n      <tr>\n        <td>标准单元格l</td>\n        <td>标准单元格2</td>\n      </tr>\n    </tbody>\n    \x3c!--表脚--\x3e\n    <tfoot>\n      <tr>\n        <td>表脚单元格l</td>\n        <td>表脚单元格2</td> \n      </tr>\n    </tfoot>\n  </table>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n# 表单语义化\n\n<label> 标签：用于显示在输入控件旁边的说明文字，即将表单元素与某段说明文字关联起来。例如：\n\n<html>\n  <input id="rdo" type="radio" /><label for="rdo">单选框</label>\n  \n  <input id="cbk" type="checkbox" /><label for="cbk">复选框</label>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n没使用语义化标签前，只能点击单选框才能选中单选框，点击它旁边的说明文字是不能选中的。使用语义化标签 <label> 后，可以点击单选框来选中单选框，并且点击它旁边的说明文字同样也可以选中单选框。而对于复选框来说，也是一样的效果。\n\n这就是 label 标签 for 属性的作用。 for 属性使得鼠标单击的范围扩大到 label 元素 上，极大地提高了用户单击的可操作性。使用 name 和 id 两种方式都可以通过 label 中的 for 关联。\n\nfieldset 与 legend 标签：\n\n使实现表单如下效果 🌰 ：\n\n<html>\n  <body>\n     <form>\n        <fieldset>\n            <legend>登录</legend>\n            <p>\n                <label for="name"> 账号：</1abel><input type="text" id="name" name="name" />\n            </p>\n            <label for="pwd"> 密码：</label><input type="password" id="pwd" name="pwd" />\n            </p>\n            <input type="checkbox" id="remember-me" name="remember-me" /> <label for="remember-me"> 记住我 </label>\n            <input type="submit" value="登录" />\n        </fieldset>\n    </form>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n# 其他语义化\n\n 1. 换行符语义化：HTML 5 中，W3C 标准规定， <br/> 换行符仅用于在段落标签中的换行，不能用于随便实现换行效果。\n\n 2. 无序列表：对于列表型的数据的展示，建议使用有序列表或者无序列表，而不是直接使用 <div> 标签加上 <span> 实现。如下：\n    \n    <html>\n      <ul>\n        <li><span>1、</span>列表项目1</li>\n        <li><span>2、</span>列表项目2</li>\n        <li><span>3、</span>列表项目3</li> \n    \t</ul>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    \n    （常用无序列表实现数字外观样式，而不使用有序列表的固定数字样式）\n\n 3. 加粗文本和斜体文本效果：通常用于对 SEO 中想要突出某些关键字被识别，可以使用 <strong> 标签和 <em> 标签加强语义化，搜索引擎对这两个标签赋予一定的权重，识别为强调的、重要的文本。\n    \n    *（一般情况下会去除 <strong> 和 <em> 标签的默认样式，重新定义这两个标签的样式，但是不会影响这两个标签的语义）\n\n 4. <del> 和 <ins> 标签：在 HTML 中，这两个标签配合使用，如下例子。（一般情况会重新定义这两个标签的默认样式）\n    \n    <html>\n      <p>新鲜的新西兰奇异果</p>\n      <p><del>原价:￥6.50/kg</del></p>\n      <p><ins>现在仅售：￥4.00/kg</ins></p>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n\n 5. 图片的语义化： 要在页面显示一张图片，使用两种方法，一种是使用 <img> 标签，另一种是通过 CSS 添加背景图片属性。对于实际开发，要想要进行 SEO，要被搜索引擎识别的图片最好使用 <img> 标签插入；如果仅仅是作为页面的修饰作用，则可直接使用背景图片属性实现即可\n\n\n# 总结\n\n对于 HMTL 5 中的语义化，应该注意：\n\n * 应该舍弃仅仅为了定义样式而存在的 HTML 标签，要改变样式应该通过 CSS 样式实现，而不要使用 HTML 标签。\n\n * 在不同的页面部分，优先使用正确的语义化标签，如果没有语义标签可用，才去考虑 <div> 和 <span> 等无语义标签。',normalizedContent:'html 中的大部分标签都有自身的语义，例如 <p> 标签表示 paragraph 一个段落， <h1> 标签表示 header1 最高级的标题。\n\n而在实际开发中，如果使用成千上万的 <div> 或者 <span> 来代替语义化标签，会给后期维护增加难度。使用语义结构良好的编码在实际开发中十分重要，利于开发调试和后期维护；利于搜索引擎的优化。\n\n\n# 标题语义化\n\nh1 ~ h6 是分级标题标签， h 表示「header」。h1~ h6 在 html 语义化中占有极其重要的地位。 h1 为最高级的标题，以此往下类推。相对于其他语义化标签，分级标题在搜索引擎优化（即 seo）中占有相当重要的地位。 在一个页面中，6 个分级标题不需要全部都用上，都是根据需要才用的。\n\n使用标题的分级，需要注意以下方面：\n\n * 一个页面只有一个 h1 标签；\n * h1 ~ h6 之间不要断层；\n * 不要使用分级标题的标签来定义样式；\n\n\n# 图片语义化\n\n<img> 标签中的 alt 属性和 title 属性：\n\n * alt 属性用于图片描述。并且当图片无法显示时，页面会显示 alt 中的文字。 alt 对搜索引擎识别网页中的图片内容起到作用。是 <img> 标签的必须属性。\n * title 属性也用于图片描述，当鼠标指针移到图片上时，会显示 title 中的内容。是可选属性。\n\n<figure> 和 <figcaption> 元素：用于实现图片加标注的效果，使得页面的语义更加良好，如下🌰：\n\n<html>\n  <figure>\n    <img src="https://placekitten.com/200/200" alt="可爱猫猫" />\n    <figcaption>可爱猫猫</figcaption>\n  </figure>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 表格语义化\n\n表格常用的三个标签为 <table> 、 <tr> 、 <td> ，为了加强语义化添加了 5 个标签：\n\n标签名       说明\nthead     表头的语义划分标签\ntbody     表身\ntfoot     表脚\ncaption   表格标题\nth        表头单元格\ntr        行\ntd        表格单元格\n\n例子 🌰 ：\n\n<html>\n  <table>\n    <caption> 表格标题 </caption> \n    \x3c!--表头--\x3e\n    <thead>\n      <tr>\n        <th>表头单元格l</th>\n        <th>表头单元格2</th> \n      </tr>\n    </thead>\n    \x3c!--表身--\x3e\n    <tbody>\n      <tr>\n        <td>标准单元格l</td>\n        <td>标准单元格2</td> \n      </tr>\n      <tr>\n        <td>标准单元格l</td>\n        <td>标准单元格2</td>\n      </tr>\n    </tbody>\n    \x3c!--表脚--\x3e\n    <tfoot>\n      <tr>\n        <td>表脚单元格l</td>\n        <td>表脚单元格2</td> \n      </tr>\n    </tfoot>\n  </table>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n# 表单语义化\n\n<label> 标签：用于显示在输入控件旁边的说明文字，即将表单元素与某段说明文字关联起来。例如：\n\n<html>\n  <input id="rdo" type="radio" /><label for="rdo">单选框</label>\n  \n  <input id="cbk" type="checkbox" /><label for="cbk">复选框</label>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n没使用语义化标签前，只能点击单选框才能选中单选框，点击它旁边的说明文字是不能选中的。使用语义化标签 <label> 后，可以点击单选框来选中单选框，并且点击它旁边的说明文字同样也可以选中单选框。而对于复选框来说，也是一样的效果。\n\n这就是 label 标签 for 属性的作用。 for 属性使得鼠标单击的范围扩大到 label 元素 上，极大地提高了用户单击的可操作性。使用 name 和 id 两种方式都可以通过 label 中的 for 关联。\n\nfieldset 与 legend 标签：\n\n使实现表单如下效果 🌰 ：\n\n<html>\n  <body>\n     <form>\n        <fieldset>\n            <legend>登录</legend>\n            <p>\n                <label for="name"> 账号：</1abel><input type="text" id="name" name="name" />\n            </p>\n            <label for="pwd"> 密码：</label><input type="password" id="pwd" name="pwd" />\n            </p>\n            <input type="checkbox" id="remember-me" name="remember-me" /> <label for="remember-me"> 记住我 </label>\n            <input type="submit" value="登录" />\n        </fieldset>\n    </form>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n# 其他语义化\n\n 1. 换行符语义化：html 5 中，w3c 标准规定， <br/> 换行符仅用于在段落标签中的换行，不能用于随便实现换行效果。\n\n 2. 无序列表：对于列表型的数据的展示，建议使用有序列表或者无序列表，而不是直接使用 <div> 标签加上 <span> 实现。如下：\n    \n    <html>\n      <ul>\n        <li><span>1、</span>列表项目1</li>\n        <li><span>2、</span>列表项目2</li>\n        <li><span>3、</span>列表项目3</li> \n    \t</ul>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    \n    （常用无序列表实现数字外观样式，而不使用有序列表的固定数字样式）\n\n 3. 加粗文本和斜体文本效果：通常用于对 seo 中想要突出某些关键字被识别，可以使用 <strong> 标签和 <em> 标签加强语义化，搜索引擎对这两个标签赋予一定的权重，识别为强调的、重要的文本。\n    \n    *（一般情况下会去除 <strong> 和 <em> 标签的默认样式，重新定义这两个标签的样式，但是不会影响这两个标签的语义）\n\n 4. <del> 和 <ins> 标签：在 html 中，这两个标签配合使用，如下例子。（一般情况会重新定义这两个标签的默认样式）\n    \n    <html>\n      <p>新鲜的新西兰奇异果</p>\n      <p><del>原价:￥6.50/kg</del></p>\n      <p><ins>现在仅售：￥4.00/kg</ins></p>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n\n 5. 图片的语义化： 要在页面显示一张图片，使用两种方法，一种是使用 <img> 标签，另一种是通过 css 添加背景图片属性。对于实际开发，要想要进行 seo，要被搜索引擎识别的图片最好使用 <img> 标签插入；如果仅仅是作为页面的修饰作用，则可直接使用背景图片属性实现即可\n\n\n# 总结\n\n对于 hmtl 5 中的语义化，应该注意：\n\n * 应该舍弃仅仅为了定义样式而存在的 html 标签，要改变样式应该通过 css 样式实现，而不要使用 html 标签。\n\n * 在不同的页面部分，优先使用正确的语义化标签，如果没有语义标签可用，才去考虑 <div> 和 <span> 等无语义标签。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍗 HTML5 API",frontmatter:{title:"🍗 HTML5 API",date:"2022-06-08T13:12:18.000Z",permalink:"/pages/30c725/",categories:["🚶 前端入门基础","🕸 HTML"],tags:["HTML"]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/10.%20%F0%9F%95%B8%20HTML/40.%20%F0%9F%8D%97%20HTML5%20API.html",relativePath:"100. 🚶 前端入门基础/10. 🕸 HTML/40. 🍗 HTML5 API.md",key:"v-18f501c4",path:"/pages/30c725/",headers:[{level:2,title:"HTML5 地理定位",slug:"html5-地理定位",normalizedTitle:"html5 地理定位",charIndex:2},{level:2,title:"HTML5 拖放",slug:"html5-拖放",normalizedTitle:"html5 拖放",charIndex:1110},{level:2,title:"HTML5 应用缓存",slug:"html5-应用缓存",normalizedTitle:"html5 应用缓存",charIndex:1200},{level:2,title:"HTML5 WebWorkers",slug:"html5-webworkers",normalizedTitle:"html5 webworkers",charIndex:2021}],headersStr:"HTML5 地理定位 HTML5 拖放 HTML5 应用缓存 HTML5 WebWorkers",content:'# HTML5 地理定位\n\nHTML Geolocation API 用于获取用户的地理位置，在获取之前需要用户的统一开启获取地理位置的权限。\n\n使用 getCurrentPosition() 方法获取。\n\n🌰 例子：\n\n>  * 首先检查是否支持地理定位，如果支持才运行 getCurrentPosiiton 方法。如果不支持，发送不支持的消息；\n>  * position.coords.latitude / position.coords.longitude 获取地理位置经纬度。\n\n更多的属性：\n\n属性                        描述\ncoords.latitude           十进制数的纬度\ncoords.longitude          十进制数的经度\ncoords.accuracy           位置精度\ncoords.altitude           海拔，海平面以上以米计\ncoords.altitudeAccuracy   位置的海拔精度\ncoords.heading            方向，从正北开始以度计\ncoords.speed              速度，以米 / 每秒计\ntimestamp                 响应的日期 / 时间\n\n使用 watchPosition() ：返回用户当前的位置，并继续返回用户移动时更新的位置； clearWatch() 方法：停止 watchPosition() 方法。\n\n🌰 例子：\n\n<script>\nvar x=document.getElementById("demo");\nfunction getLocation()\n  {\n  if (navigator.geolocation)\n    {\n    navigator.geolocation.watchPosition(showPosition);\n    }\n  else{x.innerHTML="Geolocation is not supported by this browser.";}\n  }\nfunction showPosition(position)\n  {\n  x.innerHTML="Latitude: " + position.coords.latitude +\n  "<br />Longitude: " + position.coords.longitude;\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# HTML5 拖放\n\n拖放（Drag 和 Drop）操作指的是用户抓取某个元素并拖入到不同的位置。拖放是 HTML5 标准中的一部分，任何元素都是可拖放的。\n\n🌰 例子：\n\n\n# HTML5 应用缓存\n\nHTML5 引入了应用程序缓存，意味着可对 web 应用进行缓存，并可在没有网络连接时进行访问。\n\n> 应用程序缓存为应用带来三个优势：\n> \n>  * 离线浏览：用户可在应用离线时使用它们；\n>  * 速度：已缓存资源加载得更快；\n>  * 减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源；\n\n🌰 例子 / 带有 cache manifest 的 HTML 文档，可供离线阅读：\n\n<!DOCTYPE HTML>\n<html manifest="demo.appcache">\n\n<body>\n文档内容 ......\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如需启用应用程序缓存，请在文档的 <html> 标签中包含 manifest 属性：\n\n<!DOCTYPE HTML>\n<html manifest="demo.appcache">\n...\n</html>\n\n\n1\n2\n3\n4\n\n\n每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。\n\n * manifest 的文件拓展名建议为 .appchache ；\n * manifest 文件需要设置正确的 MIME-type ，即 text/cache-manifest 。必须在 web 服务器上进行配置。\n\n更新缓存 / 一旦应用被缓存，就会保存缓存直到发生下列情况：\n\n * 用户清空浏览器缓存；\n * manifest 文件被修改；\n * 由程序来更新应用缓存；\n\n关于应用缓存需要注意：\n\n * 一旦文件被缓存，浏览器会继续展示已经缓存的版本，即使修改了服务器上的文件；为了确保浏览器更新缓存，需要更新 manifest 文件。\n * 浏览器对缓存数据的容量限制可能不太一样；\n\n\n# HTML5 WebWorkers\n\nWeb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。继续做任何事情：点击、选取内容等等，而此时 web worker 运行在后台。\n\n🌰 例子：\n\n<!DOCTYPE html>\n<html>\n<body>\n\n<p>计数: <output id="result"></output></p>\n<button onclick="startWorker()">开始 Worker</button> \n<button onclick="stopWorker()">停止 Worker</button>\n<br /><br />\n\n<script>\nvar w;\n\nfunction startWorker()\n{\nif(typeof(Worker)!=="undefined")\n  {\n  if(typeof(w)=="undefined")\n  {\n  w=new Worker("/example/html5/demo_workers.js");\n  }\n  w.onmessage = function (event) {\n    document.getElementById("result").innerHTML=event.data;\n    };\n  }\nelse\n  {\n  document.getElementById("result").innerHTML="Sorry, your browser does not support Web Workers...";\n  }\n}\n\nfunction stopWorker()\n{ \nw.terminate();\n}\n<\/script>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n * 在使用 Web Workers 之前，需要检查浏览器是否支持它。\n\n * 创建 Web Worker 文件。',normalizedContent:'# html5 地理定位\n\nhtml geolocation api 用于获取用户的地理位置，在获取之前需要用户的统一开启获取地理位置的权限。\n\n使用 getcurrentposition() 方法获取。\n\n🌰 例子：\n\n>  * 首先检查是否支持地理定位，如果支持才运行 getcurrentposiiton 方法。如果不支持，发送不支持的消息；\n>  * position.coords.latitude / position.coords.longitude 获取地理位置经纬度。\n\n更多的属性：\n\n属性                        描述\ncoords.latitude           十进制数的纬度\ncoords.longitude          十进制数的经度\ncoords.accuracy           位置精度\ncoords.altitude           海拔，海平面以上以米计\ncoords.altitudeaccuracy   位置的海拔精度\ncoords.heading            方向，从正北开始以度计\ncoords.speed              速度，以米 / 每秒计\ntimestamp                 响应的日期 / 时间\n\n使用 watchposition() ：返回用户当前的位置，并继续返回用户移动时更新的位置； clearwatch() 方法：停止 watchposition() 方法。\n\n🌰 例子：\n\n<script>\nvar x=document.getelementbyid("demo");\nfunction getlocation()\n  {\n  if (navigator.geolocation)\n    {\n    navigator.geolocation.watchposition(showposition);\n    }\n  else{x.innerhtml="geolocation is not supported by this browser.";}\n  }\nfunction showposition(position)\n  {\n  x.innerhtml="latitude: " + position.coords.latitude +\n  "<br />longitude: " + position.coords.longitude;\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# html5 拖放\n\n拖放（drag 和 drop）操作指的是用户抓取某个元素并拖入到不同的位置。拖放是 html5 标准中的一部分，任何元素都是可拖放的。\n\n🌰 例子：\n\n\n# html5 应用缓存\n\nhtml5 引入了应用程序缓存，意味着可对 web 应用进行缓存，并可在没有网络连接时进行访问。\n\n> 应用程序缓存为应用带来三个优势：\n> \n>  * 离线浏览：用户可在应用离线时使用它们；\n>  * 速度：已缓存资源加载得更快；\n>  * 减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源；\n\n🌰 例子 / 带有 cache manifest 的 html 文档，可供离线阅读：\n\n<!doctype html>\n<html manifest="demo.appcache">\n\n<body>\n文档内容 ......\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如需启用应用程序缓存，请在文档的 <html> 标签中包含 manifest 属性：\n\n<!doctype html>\n<html manifest="demo.appcache">\n...\n</html>\n\n\n1\n2\n3\n4\n\n\n每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。\n\n * manifest 的文件拓展名建议为 .appchache ；\n * manifest 文件需要设置正确的 mime-type ，即 text/cache-manifest 。必须在 web 服务器上进行配置。\n\n更新缓存 / 一旦应用被缓存，就会保存缓存直到发生下列情况：\n\n * 用户清空浏览器缓存；\n * manifest 文件被修改；\n * 由程序来更新应用缓存；\n\n关于应用缓存需要注意：\n\n * 一旦文件被缓存，浏览器会继续展示已经缓存的版本，即使修改了服务器上的文件；为了确保浏览器更新缓存，需要更新 manifest 文件。\n * 浏览器对缓存数据的容量限制可能不太一样；\n\n\n# html5 webworkers\n\nweb worker 是运行在后台的 javascript，独立于其他脚本，不会影响页面的性能。继续做任何事情：点击、选取内容等等，而此时 web worker 运行在后台。\n\n🌰 例子：\n\n<!doctype html>\n<html>\n<body>\n\n<p>计数: <output id="result"></output></p>\n<button onclick="startworker()">开始 worker</button> \n<button onclick="stopworker()">停止 worker</button>\n<br /><br />\n\n<script>\nvar w;\n\nfunction startworker()\n{\nif(typeof(worker)!=="undefined")\n  {\n  if(typeof(w)=="undefined")\n  {\n  w=new worker("/example/html5/demo_workers.js");\n  }\n  w.onmessage = function (event) {\n    document.getelementbyid("result").innerhtml=event.data;\n    };\n  }\nelse\n  {\n  document.getelementbyid("result").innerhtml="sorry, your browser does not support web workers...";\n  }\n}\n\nfunction stopworker()\n{ \nw.terminate();\n}\n<\/script>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n * 在使用 web workers 之前，需要检查浏览器是否支持它。\n\n * 创建 web worker 文件。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚏 Git 版本控制学习路线",frontmatter:{title:"🚏 Git 版本控制学习路线",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/4d5e63/",categories:["🚶 前端入门基础","🛤 Git 版本控制"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/100.%20%F0%9F%9B%A4%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/01.%20%F0%9F%9A%8F%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html",relativePath:"100. 🚶 前端入门基础/100. 🛤 Git 版本控制/01. 🚏 Git 版本控制学习路线.md",key:"v-eaa28632",path:"/pages/4d5e63/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚗 VCS 版本控制系统",frontmatter:{title:"🚗 VCS 版本控制系统",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/3b80ae/",categories:["🚶 前端入门基础","🛤 Git 版本控制"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/100.%20%F0%9F%9B%A4%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/10.%20%F0%9F%9A%97%20VCS%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.html",relativePath:"100. 🚶 前端入门基础/100. 🛤 Git 版本控制/10. 🚗 VCS 版本控制系统.md",key:"v-6e674884",path:"/pages/3b80ae/",headers:[{level:2,title:"版本控制系统",slug:"版本控制系统",normalizedTitle:"版本控制系统",charIndex:18},{level:3,title:"版本控制的理解",slug:"版本控制的理解",normalizedTitle:"版本控制的理解",charIndex:191},{level:3,title:"主动提交机制",slug:"主动提交机制",normalizedTitle:"主动提交机制",charIndex:284},{level:3,title:"中央仓库多人协作",slug:"中央仓库多人协作",normalizedTitle:"中央仓库多人协作",charIndex:554},{level:2,title:"中央式版本管理系统",slug:"中央式版本管理系统",normalizedTitle:"中央式版本管理系统",charIndex:628},{level:2,title:"分布式版本管理系统",slug:"分布式版本管理系统",normalizedTitle:"分布式版本管理系统",charIndex:1292}],headersStr:"版本控制系统 版本控制的理解 主动提交机制 中央仓库多人协作 中央式版本管理系统 分布式版本管理系统",content:"Git 是一个 分布式的 VCS （版本控制系统）。\n\n * VCS（Version Control System）保留了文件的修改历史，可以方便地撤销之前对文件的修改操作。\n\n * 分布式 VCS （DVCS，Distributed Version Control System）\n\n\n# 版本控制系统\n\n版本控制系统由 版本控制、主动提交、中央仓库 三个核心要素构成。\n\n\n# 版本控制的理解\n\n版本控制最基本的模型是 编辑器的撤销功能：对某个内容进行修改或者删除操作之后，想要回退这个操作，可以使用撤销操作。这就是一次版本管理，将内容回退到上一个版本。\n\n\n# 主动提交机制\n\n主动提交版本控制与常见的编辑器的撤销功能的区别：\n\n * 当文件（代码）的修改周期很长，一次文件的修改历史版本可能需要保存非常长久的时间，并且版本控制使用的是 主动提交改动 的机制，不用担心找不到修改的历史；\n * 而编辑器的自动保存和保留修改可撤销历史，频繁保存文件的历史版本自然是不现实的，并且改动历史无章可循，历史查找和回退较困难；\n\n版本控制的文件版本提交一般使用 commit 命令以及对该次改动的描述信息进行提交，这样这次改动就会记录到版本历史中，如果希望回退到这个版本，可以在版本历史中找到该次记录。\n\n\n# 中央仓库多人协作\n\n当多人开发代码时，需要一个中央仓库存储代码，并且所有人对代码的改动都会上传到仓库，通过同步可以获取其他人对代码的修改。\n\n\n# 中央式版本管理系统\n\n中央式版本管理系统（Centralized VCS） 是最早的版本管理系统。比较简单的版本管理系统。\n\n> 工作模型：假设你在一个三人团队，你们计划开发一个软件或者系统，并决定使用中央式 VCS 来管理代码。于是：\n> \n>  1. 作为项目的主工程师，你独自一人花两天时间搭建了项目的框架；\n>  2. 然后，你在公司的服务器（这个服务器可以是公司内的设备，也可以是你们买的云服务）上创建了一个中央仓库，并把你的代码提交到了中央仓库上；\n>  3. 你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三人开始并行开发；\n>  4. 在之后的开发过程中，你们三人为了工作方便，总是每人独立负责开发一个功能，在这个功能开发完成后，这个人就把他的这些新代码提交到中央仓库；\n>  5. 每次当有人把代码提交到中央仓库的时候，另外两个人就可以选择把这些代码同步到自己的机器上，保持自己的本地代码总是最新的。\n> \n> 而对于团队中的每个人来说，就会更简单一点：\n> \n>  1. 第一次加入团队时，把中央仓库的代码取下来；\n>  2. 写完的新功能提交到中央仓库；\n>  3. 同事提交到中央仓库的新代码，及时同步下来。\n> \n> 这样，一个三人的团队就成功做到了各自在自己的电脑上开发同一个项目，并且互不影响，就好像你们三个人是在同一台电脑上操作一样。\n\n但是通常开发中还需要处理代码冲突、版本历史、回退代码版本、版本分支，这些概念比中央式版本管理复杂，因此 Git 采用的是分布式版本系统。\n\n\n# 分布式版本管理系统\n\n分布式 VCS 与中央式 VCS 的区别在于：分布式 VCS 除了中央仓库以外，还有本地仓库。\n\n> 意味着每个成员的机器都有本地仓库，这个仓库包含了所有的版本历史，每个人可以在自己的本地仓库提交代码、查看历史，无需联网和中央仓库交互。\n\n分布式 VCS 的保存版本历史工作交给了本地仓库，中央仓库负责同步团队代码，并且保存的历史版本是作为团队的同步中转站。\n\n> 工作模型：依然以三人团队为例，分布式 VCS 的工作模型大致是这样：\n> \n>  1. 首先，你作为主工程师，独立搭建了项目架构，并把这些代码提交到了本地仓库；\n>  2. 然后，你在服务器上创建了一个中央仓库，并把 1 中的提交从本地仓库推送到了服务器的中央仓库；\n>  3. 其他同事把中央仓库的所有内容克隆到本地，拥有了各自的本地仓库，从此刻开始，你们三人开始并行开发；\n>  4. 在之后的开发过程中，你们三人总是每人独立负责开发一个功能，在这个功能开发过程中，一个人会把它的每一步改动提交到本地仓库。注意：由于本地提交无需立即上传到中央仓库，所以每一步提交不必是一个完整功能，而可以是功能中的一个步骤或块。\n>  5. 在一个人把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库；\n>  6. 每次当有人把新的提交推送到中央仓库的时候，另外两个人就可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并。\n\n分布式 VCS 与中央式 VCS 很相似，但是分布式 VCS 把代码提交和上传过程拆分开了。\n\n分布式 VCS 的优点：\n\n * 不需要联网就可以完成版本的提交和分支切换等操作；\n * 因为有本地仓库，可以将代码版本更加细分，更加方便 review。\n\n分布式 VCS 的缺点：\n\n * 初次从中央仓库中 clone 代码时可能会比较耗时；\n * 本地仓库保存完整版本占用的存储比中央式 VCS 高；\n\n> 实际上，大多数项目代码都是文本内容，实际代码（不包括依赖）的体积不会很大，VCS 可以利用算法压缩仓库的体积，所以 Git 等分布式 VCS 的仓库体积并不大。初次获取项目的耗时和本地仓库的存储占用都很小。\n> \n> 对于一些游戏开发包含大尺寸数据和媒体文件，不容易压缩尺寸，使用分布式 VCS 会导致仓库体积庞大，一般使用中央式 VCS 管理代码。",normalizedContent:"git 是一个 分布式的 vcs （版本控制系统）。\n\n * vcs（version control system）保留了文件的修改历史，可以方便地撤销之前对文件的修改操作。\n\n * 分布式 vcs （dvcs，distributed version control system）\n\n\n# 版本控制系统\n\n版本控制系统由 版本控制、主动提交、中央仓库 三个核心要素构成。\n\n\n# 版本控制的理解\n\n版本控制最基本的模型是 编辑器的撤销功能：对某个内容进行修改或者删除操作之后，想要回退这个操作，可以使用撤销操作。这就是一次版本管理，将内容回退到上一个版本。\n\n\n# 主动提交机制\n\n主动提交版本控制与常见的编辑器的撤销功能的区别：\n\n * 当文件（代码）的修改周期很长，一次文件的修改历史版本可能需要保存非常长久的时间，并且版本控制使用的是 主动提交改动 的机制，不用担心找不到修改的历史；\n * 而编辑器的自动保存和保留修改可撤销历史，频繁保存文件的历史版本自然是不现实的，并且改动历史无章可循，历史查找和回退较困难；\n\n版本控制的文件版本提交一般使用 commit 命令以及对该次改动的描述信息进行提交，这样这次改动就会记录到版本历史中，如果希望回退到这个版本，可以在版本历史中找到该次记录。\n\n\n# 中央仓库多人协作\n\n当多人开发代码时，需要一个中央仓库存储代码，并且所有人对代码的改动都会上传到仓库，通过同步可以获取其他人对代码的修改。\n\n\n# 中央式版本管理系统\n\n中央式版本管理系统（centralized vcs） 是最早的版本管理系统。比较简单的版本管理系统。\n\n> 工作模型：假设你在一个三人团队，你们计划开发一个软件或者系统，并决定使用中央式 vcs 来管理代码。于是：\n> \n>  1. 作为项目的主工程师，你独自一人花两天时间搭建了项目的框架；\n>  2. 然后，你在公司的服务器（这个服务器可以是公司内的设备，也可以是你们买的云服务）上创建了一个中央仓库，并把你的代码提交到了中央仓库上；\n>  3. 你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三人开始并行开发；\n>  4. 在之后的开发过程中，你们三人为了工作方便，总是每人独立负责开发一个功能，在这个功能开发完成后，这个人就把他的这些新代码提交到中央仓库；\n>  5. 每次当有人把代码提交到中央仓库的时候，另外两个人就可以选择把这些代码同步到自己的机器上，保持自己的本地代码总是最新的。\n> \n> 而对于团队中的每个人来说，就会更简单一点：\n> \n>  1. 第一次加入团队时，把中央仓库的代码取下来；\n>  2. 写完的新功能提交到中央仓库；\n>  3. 同事提交到中央仓库的新代码，及时同步下来。\n> \n> 这样，一个三人的团队就成功做到了各自在自己的电脑上开发同一个项目，并且互不影响，就好像你们三个人是在同一台电脑上操作一样。\n\n但是通常开发中还需要处理代码冲突、版本历史、回退代码版本、版本分支，这些概念比中央式版本管理复杂，因此 git 采用的是分布式版本系统。\n\n\n# 分布式版本管理系统\n\n分布式 vcs 与中央式 vcs 的区别在于：分布式 vcs 除了中央仓库以外，还有本地仓库。\n\n> 意味着每个成员的机器都有本地仓库，这个仓库包含了所有的版本历史，每个人可以在自己的本地仓库提交代码、查看历史，无需联网和中央仓库交互。\n\n分布式 vcs 的保存版本历史工作交给了本地仓库，中央仓库负责同步团队代码，并且保存的历史版本是作为团队的同步中转站。\n\n> 工作模型：依然以三人团队为例，分布式 vcs 的工作模型大致是这样：\n> \n>  1. 首先，你作为主工程师，独立搭建了项目架构，并把这些代码提交到了本地仓库；\n>  2. 然后，你在服务器上创建了一个中央仓库，并把 1 中的提交从本地仓库推送到了服务器的中央仓库；\n>  3. 其他同事把中央仓库的所有内容克隆到本地，拥有了各自的本地仓库，从此刻开始，你们三人开始并行开发；\n>  4. 在之后的开发过程中，你们三人总是每人独立负责开发一个功能，在这个功能开发过程中，一个人会把它的每一步改动提交到本地仓库。注意：由于本地提交无需立即上传到中央仓库，所以每一步提交不必是一个完整功能，而可以是功能中的一个步骤或块。\n>  5. 在一个人把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库；\n>  6. 每次当有人把新的提交推送到中央仓库的时候，另外两个人就可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并。\n\n分布式 vcs 与中央式 vcs 很相似，但是分布式 vcs 把代码提交和上传过程拆分开了。\n\n分布式 vcs 的优点：\n\n * 不需要联网就可以完成版本的提交和分支切换等操作；\n * 因为有本地仓库，可以将代码版本更加细分，更加方便 review。\n\n分布式 vcs 的缺点：\n\n * 初次从中央仓库中 clone 代码时可能会比较耗时；\n * 本地仓库保存完整版本占用的存储比中央式 vcs 高；\n\n> 实际上，大多数项目代码都是文本内容，实际代码（不包括依赖）的体积不会很大，vcs 可以利用算法压缩仓库的体积，所以 git 等分布式 vcs 的仓库体积并不大。初次获取项目的耗时和本地仓库的存储占用都很小。\n> \n> 对于一些游戏开发包含大尺寸数据和媒体文件，不容易压缩尺寸，使用分布式 vcs 会导致仓库体积庞大，一般使用中央式 vcs 管理代码。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚚 一些实际工作模型",frontmatter:{title:"🚚 一些实际工作模型",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/f2d32b/",categories:["🚶 前端入门基础","🛤 Git 版本控制"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/100.%20%F0%9F%9B%A4%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20.%20%F0%9F%9A%9A%20%E4%B8%80%E4%BA%9B%E5%AE%9E%E9%99%85%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.html",relativePath:"100. 🚶 前端入门基础/100. 🛤 Git 版本控制/20. 🚚 一些实际工作模型.md",key:"v-bb016a66",path:"/pages/f2d32b/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🏎 Git 的基本使用命令",frontmatter:{title:"🏎 Git 的基本使用命令",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/823b22/",categories:["🚶 前端入门基础","🛤 Git 版本控制"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/100.%20%F0%9F%9B%A4%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/25.%20%F0%9F%8F%8E%20Git%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"100. 🚶 前端入门基础/100. 🛤 Git 版本控制/25. 🏎 Git 的基本使用命令.md",key:"v-2b3ae24e",path:"/pages/823b22/",headersStr:null,content:" * git init ：初始化 git 仓库\n\n * git clone 代码仓库地址 ：初始化 git 仓库\n\n * git log ：获取提交历史信息（ commit 的 SHA-1 校验值（ID）、作者、日期）\n\n * git status ：查看工作目录当前状态。\n   \n   * 目前 HEAD 在哪个 branch\n   * 未追踪状态的文件。（untracked）",normalizedContent:" * git init ：初始化 git 仓库\n\n * git clone 代码仓库地址 ：初始化 git 仓库\n\n * git log ：获取提交历史信息（ commit 的 sha-1 校验值（id）、作者、日期）\n\n * git status ：查看工作目录当前状态。\n   \n   * 目前 head 在哪个 branch\n   * 未追踪状态的文件。（untracked）",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚒 Git 的 HEAD、master 与 branch",frontmatter:{title:"🚒 Git 的 HEAD、master 与 branch",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/ffbab0/",categories:["🚶 前端入门基础","🛤 Git 版本控制"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/100.%20%F0%9F%9B%A4%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/30.%20%F0%9F%9A%92%20Git%20%E7%9A%84%20HEAD%E3%80%81master%20%E4%B8%8E%20branch.html",relativePath:"100. 🚶 前端入门基础/100. 🛤 Git 版本控制/30. 🚒 Git 的 HEAD、master 与 branch.md",key:"v-cccab4ca",path:"/pages/ffbab0/",headers:[{level:2,title:"HEAD",slug:"head",normalizedTitle:"head",charIndex:2},{level:2,title:"master",slug:"master",normalizedTitle:"master",charIndex:11},{level:2,title:"branch",slug:"branch",normalizedTitle:"branch",charIndex:48},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:59}],headersStr:"HEAD master branch 总结",content:"# HEAD\n\n\n# master\n\n现在 GitHub 的默认主分支名称为 main\n\n\n# branch\n\n\n# 总结\n\n * HEAD 是指向 当前 commit 的引用。具有唯一性，每个仓库只有一个 HEAD。每次提交时会自动移向最新的 commit ；\n\n * branch 是一类 commit 引用。 HEAD 除了直接指向 commit ，也可以通过指向某个 branch 来间接指向 commit 。当 HEAD 指向一个 branch 时， commit 发生时， HEAD 会带着它所指向的 branch 一起移动。\n\n * master 是 Git 中默认的 branch 。与其他 branch 的区别：\n   \n   * 新建的仓库中第一个 commit 会被 master 自动指向；\n   * git clone 自动 checkout 的是 master\n\n * branch 的创建、切换与删除：\n   \n   * 创建 branch ： git branch 名称 或者 git checkout -b 名称 （创建后自动切换）\n   * 切换 branch ： git checkout 名称\n   * 删除 branch ： git branch -d 名称",normalizedContent:"# head\n\n\n# master\n\n现在 github 的默认主分支名称为 main\n\n\n# branch\n\n\n# 总结\n\n * head 是指向 当前 commit 的引用。具有唯一性，每个仓库只有一个 head。每次提交时会自动移向最新的 commit ；\n\n * branch 是一类 commit 引用。 head 除了直接指向 commit ，也可以通过指向某个 branch 来间接指向 commit 。当 head 指向一个 branch 时， commit 发生时， head 会带着它所指向的 branch 一起移动。\n\n * master 是 git 中默认的 branch 。与其他 branch 的区别：\n   \n   * 新建的仓库中第一个 commit 会被 master 自动指向；\n   * git clone 自动 checkout 的是 master\n\n * branch 的创建、切换与删除：\n   \n   * 创建 branch ： git branch 名称 或者 git checkout -b 名称 （创建后自动切换）\n   * 切换 branch ： git checkout 名称\n   * 删除 branch ： git branch -d 名称",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚕 Git 的 push",frontmatter:{title:"🚕 Git 的 push",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/0fa378/",categories:["🚶 前端入门基础","🛤 Git 版本控制"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/100.%20%F0%9F%9B%A4%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/40.%20%F0%9F%9A%95%20Git%20%E7%9A%84%20push%20.html",relativePath:"100. 🚶 前端入门基础/100. 🛤 Git 版本控制/40. 🚕 Git 的 push .md",key:"v-b48c1564",path:"/pages/0fa378/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗂 JSON 笔记",frontmatter:{title:"🗂 JSON 笔记",date:"2021-10-18T19:41:46.000Z",permalink:"/pages/f50277/",categories:["前端笔记","📦 JavaScript 笔记"],tags:["JSON"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/110.%20%F0%9F%91%A3%20%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BE%85%E5%8A%A9/10.%20%F0%9F%97%82%20JSON%20%E7%AC%94%E8%AE%B0.html",relativePath:"100. 🚶 前端入门基础/110. 👣 前端基础辅助/10. 🗂 JSON 笔记.md",key:"v-e8174f44",path:"/pages/f50277/",headers:[{level:2,title:"JSON 分类",slug:"json-分类",normalizedTitle:"json 分类",charIndex:229},{level:3,title:"对象 {}",slug:"对象",normalizedTitle:"对象 {}",charIndex:241},{level:3,title:"数组 []",slug:"数组",normalizedTitle:"数组 []",charIndex:462},{level:2,title:"JSON 用法",slug:"json-用法",normalizedTitle:"json 用法",charIndex:564},{level:3,title:"允许值",slug:"允许值",normalizedTitle:"允许值",charIndex:576},{level:3,title:"转换",slug:"转换",normalizedTitle:"转换",charIndex:81}],headersStr:"JSON 分类 对象 {} 数组 [] JSON 用法 允许值 转换",content:'JSON (JavaScript Object Notation，JavaScript 对象表示法）是一个特殊格式的字符串：\n\n * 被任意的语言所识别，并且可以转换为任意语言中的对象；\n * JSON 存储和交换文本信息，类似 XML，比 XML 更小、更快、更易解析；\n\nJSON 与 JavaScript 中的对象的格式一样，区别在于，JSON 中的字符串中的属性名必须使用 “” (双引号) 包裹，其他的语法与 JavaScript 一致；\n\n\n# JSON 分类\n\n\n# 对象 {}\n\nvar obj = {\n  "name": "name",\n  "age": 3,\n  "gender": "male"\n};\n\nvar jsonObjStr = \'{\n  "name": "name",\n  "age": 3,\n  "gender": "male"\n}\';\nconsole.log(typeof jsonObjStr); // string\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 数组 []\n\nvar jsonArrStr = \'[1,2,3,"hello", true]\';\nconsole.log(typeof jsonArrStr); // string\n\n\n1\n2\n\n\n\n# JSON 用法\n\n\n# 允许值\n\n在 JSON 中允许的值：\n\n * 字符串\n * 数值\n * 布尔值\n * null\n * 对象\n * 数组\n\n// json对象可以包含json数组\nvar obj1 = \'{"arr":[1,2,3]}\';\n\n// json数组可以包含json对象\nvar obj2 = \'[{\n  "name": "name1",\n  "age": 3,\n  "gender": "male"\n},{\n  "name": "name2",\n  "age": 3,\n  "gender": "male"\n}]\';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 转换\n\nJSON 与 JavaScript 的转换 ：\n\n使用 JSON.parse() 将 JSON 字符串转换为 JavaScript 中的对象，使用时需要一个 JSON 字符串作为参数，会讲字符串转换为 JavaScript 的对象并返回：\n\nvar jsonObj = JSON.parse(jsonObjStr);\nconsole.log(typeof jsonObj); // object\n\nvar jsonArr = JSON.parse(jsonArrStr);\nconsole.log(typeof jsonArr); // object\n\n\n1\n2\n3\n4\n5\n\n\n使用 JSON.stringify() 将 JavaScript 对象转换为 JSON 字符串，使用时需要一个 JavaScript 对象作为参数，会返回一个 JSON 字符串：\n\nvar obj2 = {\n  "name": "name",\n  "age": 3,\n  "gender": "male"\n};\n\nvar obj2JSONStr = JSON.stringify(obj2);\nconsole.log(typeof obj2JSONStr); // string\nconsole.log(obj2JSONStr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'json (javascript object notation，javascript 对象表示法）是一个特殊格式的字符串：\n\n * 被任意的语言所识别，并且可以转换为任意语言中的对象；\n * json 存储和交换文本信息，类似 xml，比 xml 更小、更快、更易解析；\n\njson 与 javascript 中的对象的格式一样，区别在于，json 中的字符串中的属性名必须使用 “” (双引号) 包裹，其他的语法与 javascript 一致；\n\n\n# json 分类\n\n\n# 对象 {}\n\nvar obj = {\n  "name": "name",\n  "age": 3,\n  "gender": "male"\n};\n\nvar jsonobjstr = \'{\n  "name": "name",\n  "age": 3,\n  "gender": "male"\n}\';\nconsole.log(typeof jsonobjstr); // string\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 数组 []\n\nvar jsonarrstr = \'[1,2,3,"hello", true]\';\nconsole.log(typeof jsonarrstr); // string\n\n\n1\n2\n\n\n\n# json 用法\n\n\n# 允许值\n\n在 json 中允许的值：\n\n * 字符串\n * 数值\n * 布尔值\n * null\n * 对象\n * 数组\n\n// json对象可以包含json数组\nvar obj1 = \'{"arr":[1,2,3]}\';\n\n// json数组可以包含json对象\nvar obj2 = \'[{\n  "name": "name1",\n  "age": 3,\n  "gender": "male"\n},{\n  "name": "name2",\n  "age": 3,\n  "gender": "male"\n}]\';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 转换\n\njson 与 javascript 的转换 ：\n\n使用 json.parse() 将 json 字符串转换为 javascript 中的对象，使用时需要一个 json 字符串作为参数，会讲字符串转换为 javascript 的对象并返回：\n\nvar jsonobj = json.parse(jsonobjstr);\nconsole.log(typeof jsonobj); // object\n\nvar jsonarr = json.parse(jsonarrstr);\nconsole.log(typeof jsonarr); // object\n\n\n1\n2\n3\n4\n5\n\n\n使用 json.stringify() 将 javascript 对象转换为 json 字符串，使用时需要一个 javascript 对象作为参数，会返回一个 json 字符串：\n\nvar obj2 = {\n  "name": "name",\n  "age": 3,\n  "gender": "male"\n};\n\nvar obj2jsonstr = json.stringify(obj2);\nconsole.log(typeof obj2jsonstr); // string\nconsole.log(obj2jsonstr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📕 jQuery 笔记",frontmatter:{title:"📕 jQuery 笔记",date:"2021-10-24T15:16:41.000Z",permalink:"/pages/3ac8a3/",categories:["前端笔记","📦 JavaScript 笔记"],tags:["JavaScript","JQuery"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/110.%20%F0%9F%91%A3%20%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BE%85%E5%8A%A9/20.%20%F0%9F%93%95%20jQuery%20%E7%AC%94%E8%AE%B0.html",relativePath:"100. 🚶 前端入门基础/110. 👣 前端基础辅助/20. 📕 jQuery 笔记.md",key:"v-e993351a",path:"/pages/3ac8a3/",headers:[{level:2,title:"jQuery 基础",slug:"jquery-基础",normalizedTitle:"jquery 基础",charIndex:2},{level:3,title:"引入",slug:"引入",normalizedTitle:"引入",charIndex:16},{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:668},{level:3,title:"jQuery 核心函数",slug:"jquery-核心函数",normalizedTitle:"jquery 核心函数",charIndex:722},{level:3,title:"jQuery 核心对象",slug:"jquery-核心对象",normalizedTitle:"jquery 核心对象",charIndex:923},{level:3,title:"jQuery 函数的使用",slug:"jquery-函数的使用",normalizedTitle:"jquery 函数的使用",charIndex:1107},{level:3,title:"jQuery 对象的使用",slug:"jquery-对象的使用",normalizedTitle:"jquery 对象的使用",charIndex:1863},{level:2,title:"jQuery 选择器",slug:"jquery-选择器",normalizedTitle:"jquery 选择器",charIndex:3265},{level:3,title:"基本选择器",slug:"基本选择器",normalizedTitle:"基本选择器",charIndex:3450},{level:3,title:"层级选择器",slug:"层级选择器",normalizedTitle:"层级选择器",charIndex:3845},{level:3,title:"过滤选择器",slug:"过滤选择器",normalizedTitle:"过滤选择器",charIndex:4142},{level:3,title:"表单选择器",slug:"表单选择器",normalizedTitle:"表单选择器",charIndex:5435},{level:2,title:"jQuery 工具方法",slug:"jquery-工具方法",normalizedTitle:"jquery 工具方法",charIndex:5870},{level:2,title:"jQuery 操作属性",slug:"jquery-操作属性",normalizedTitle:"jquery 操作属性",charIndex:6269},{level:2,title:"jQuery 操作元素样式",slug:"jquery-操作元素样式",normalizedTitle:"jquery 操作元素样式",charIndex:6680},{level:2,title:"jQuery 对象的过滤和查找",slug:"jquery-对象的过滤和查找",normalizedTitle:"jquery 对象的过滤和查找",charIndex:7153},{level:3,title:"对象的过滤",slug:"对象的过滤",normalizedTitle:"对象的过滤",charIndex:7160},{level:3,title:"对象的查找",slug:"对象的查找",normalizedTitle:"对象的查找",charIndex:7527},{level:2,title:"jQuery 文档处理",slug:"jquery-文档处理",normalizedTitle:"jquery 文档处理",charIndex:8206},{level:2,title:"jQuery 事件处理",slug:"jquery-事件处理",normalizedTitle:"jquery 事件处理",charIndex:9176},{level:2,title:"jQuery 事件委派",slug:"jquery-事件委派",normalizedTitle:"jquery 事件委派",charIndex:11892},{level:3,title:"事件委派 API",slug:"事件委派-api",normalizedTitle:"事件委派 api",charIndex:12097},{level:2,title:"jQuery 动画",slug:"jquery-动画",normalizedTitle:"jquery 动画",charIndex:12368},{level:3,title:"淡入淡出效果",slug:"淡入淡出效果",normalizedTitle:"淡入淡出效果",charIndex:13179},{level:3,title:"滑动",slug:"滑动",normalizedTitle:"滑动",charIndex:12530},{level:3,title:"显示隐藏",slug:"显示隐藏",normalizedTitle:"显示隐藏",charIndex:12428},{level:2,title:"jQuery",slug:"jquery",normalizedTitle:"jquery",charIndex:2},{level:3,title:"onload 和 ready 区别",slug:"onload-和-ready-区别",normalizedTitle:"onload 和 ready 区别",charIndex:13705}],headersStr:"jQuery 基础 引入 基本语法 jQuery 核心函数 jQuery 核心对象 jQuery 函数的使用 jQuery 对象的使用 jQuery 选择器 基本选择器 层级选择器 过滤选择器 表单选择器 jQuery 工具方法 jQuery 操作属性 jQuery 操作元素样式 jQuery 对象的过滤和查找 对象的过滤 对象的查找 jQuery 文档处理 jQuery 事件处理 jQuery 事件委派 事件委派 API jQuery 动画 淡入淡出效果 滑动 显示隐藏 jQuery onload 和 ready 区别",content:"# jQuery 基础\n\n\n# 引入\n\n\x3c!--服务器本地库--\x3e\n<script src=\"js/jquery-3.6.0.js\"><\/script>\n\x3c!--CDN远程库--\x3e\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\"><\/script>\n\n\n1\n2\n3\n4\n\n\n> 区别 2 种引用 JS 库的方式：\n> \n>  * 服务器本地库\n>  * CDN 远程库\n>  * * 项目上线时，一般使用比较靠谱的 CDN 资源库，减轻服务器负担；\n>  * * https://www.bootcdn.cn/：搜索 jQuery ，复制 <script> 标签到项目中即可使用；\n\n> 区别 jQuery 的不同版本：\n> \n>  * 1.x\n>    \n>    * 兼容老版本 IE\n>  * * 文件更大\n> \n>  * 2.x\n> \n>  * * 部分 IE8 及以下支持\n>  * * 文件小，执行效率更高\n> \n>  * 3.x\n> \n>  * * 完全不再支持 IE8 及以下版本\n>  * * 提供了一些新的 API\n>  * * 提供不包含 ajax / 动画 API 的版本\n\n> 在 codepen 中使用：\n> \n> 在 codepen 中引入 jQuery 包的最新版本：在 Pen Settins - JS - Add External Scripts/Pens 搜索栏中输入 jquery 后选择包：\n\n\n# 基本语法\n\n * 核心函数： $ /jQuery 函数\n * 核心对象： 执行 $() 返回的对象\n\n\n# jQuery 核心函数\n\n引入 jQuery 库后，直接使用：\n\n * 当函数用： $(xxx)\n * 当对象用： $.xxx()\n\n// jQuery函数：直接可用\nconsole.log($, typeof $);  // ƒ ( selector, context ) {}    function\nconsole.log(jQuery === $); // true\n\n\n1\n2\n3\n\n\n\n# jQuery 核心对象\n\n得到 jQuery 对象：执行 jQuery 函数返回的就是 jQuery 对象；\n\n使用 jQuery 对象： $obj.xxx() ；\n\nconsole.log($(), typeof $(), $() instanceof Object); \n// jQuery.fn.init {} \"object\" true\n\n\n1\n2\n\n\n\n# jQuery 函数的使用\n\n作为一般函数调用： $(param) ：\n\n * 参数为函数时：当 DOM 加载完成后，执行此回调函数；\n * 参数为选择器字符：查找所有匹配的标签并将它们封装为 jQuery 对象；\n * 参数为 DOM 对象：将 DOM 对象封装成 jQuery 对象；\n * 参数为 HTML 标签字符串（用得少）：创建标签对象并封装成 jQuery 对象；\n\n作为对象使用： $.xxx() ：\n\n * $.each() ：隐式遍历数组；\n   \n   var arr = [3, 7, 4];\n       $.each(arr, function (index, item) {\n           console.log(index, item); // 0 3    1 7    2 4\n       });\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * $.trim() ：去除两端的空格；\n   \n   var str = \"    my atguigu   \";\n       console.log('===' + str + '===');           \n   // ===    my atguigu   ===\n       console.log('===' + str.trim() + '===');    \n   // ===my atguigu===\n       console.log('===' + $.trim(str) + '===');   \n   // ===my atguigu===\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# jQuery 对象的使用\n\n即执行 jQuery 核心函数返回的对象，jQuery 对象内部包含的是 DOM 元素对象的伪数组（可能只有一个元素），jQuery 对象拥有很多有用的属性和方法，方便操作 DOM；\n\n属性和方法：\n\n * 基本行为： 操作标签的基本方法；\n * 属性：操作内部标签的属性和值；\n * CSS： 操作标签的样式；\n * 文档：对标签进行增、删、改操作；\n * 筛选：根据指定的规则过滤内部的标签；\n * 事件：处理事件的监听相关；\n * 效果：实现动画效果；\n\njQuery 基本行为\n\n * size() 、 length ：获取包含的 DOM 元素的个数\n   \n   // 统计一共有多少个按钮\n   var $buttons = $('button');\n   console.log($buttons.length); // 4\n   \n   \n   1\n   2\n   3\n   \n\n * [index] 、 get(index) ：获取对应位置的 DOM 元素；\n   \n   // 需求2.取出第2个button的文本\n   console.log($('button:nth-child(2)').text()); // 测试二\n   \n   console.log($buttons[1].innerHTML, $buttons.get(1).innerHTML);\n   // 测试二 测试二\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * each() ：遍历包含的所有的 DOM 元素；\n   \n   $buttons.each(function () {\n       console.log(this.innerHTML); // 测试一 测试二 测试三 测试四\n   });\n   \n   \n   1\n   2\n   3\n   \n\n * index() ：得到在所在兄弟元素中的下标索引；\n   \n   console.log($(\"#btn3\").index()); // 2\n   \n   \n   1\n   \n\n伪数组：\n\n * Object ： 对象；\n * length ：属性；\n * 数组下标的属性\n * 没有数组特别的方法： forEach() 、 push() 、 pop() 、 slice ；\n\nconsole.log($buttons instanceof Array); // false\n//自定义一个伪数组\nvar weiArr = {}\nweiArr.length = 0;\nweiArr[0] = 'atguigu';\nweiArr.length = 1;\nweiArr[1] = 123;\nweiArr.length = 2;\nfor (var i = 0; i < weiArr.length; i++) {\n    var obj = weiArr[i];\n    console.log(i, obj); // 0 \"atguigu\"    1 123\n}\nconsole.log(weiArr.forEach, $buttons.forEach); //undefined undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# jQuery 选择器\n\n * 选择器本身只是一个有特定语法规则的字符串，没有实质用处；\n\n * 它的基本语法规则使用的就是 CSS 的选择器语法，并对其进行了扩展；\n\n * 只有调用 $() ，并将选择器作为参数传入才能起作用；\n\n * $(selector) 作用：根据选择器规则在整个文档中查找所有匹配的标签的数组（伪数组），并封装成 jQuery 对象；\n\n\n# 基本选择器\n\n基本选择器                                 描述\nID 选择器 #id                            根据给定的 ID 匹配一个元素\n标签选择器 element                         根据给定的元素名匹配所有元素\n属性选择器 .class                          根据给定的类名匹配元素\n通用选择器 *                               匹配所有元素\n并集选择器 selector1,selector2,selectorN   将每一个选择器匹配到的元素合并后一起返回\n交集选择器 selector1 selector2             \n\n🌰：jQuery-example-selector-1 (codepen.io)\n\n\n# 层级选择器\n\n层级选择器                         描述\n后代元素选择器 ancestor descendant   在给定的祖先元素下匹配所有的后代元素\n子元素选择器 parent > child         在给定的父元素下匹配所有的子元素\n兄弟选择器 prev + next             匹配所有紧接在 prev 元素后的 next 元素\n兄弟选择器 prev ~ siblings         匹配 prev 元素之后的所有 siblings 元素\n\n🌰：jQuery-example-selector-2 (codepen.io)\n\n\n# 过滤选择器\n\n在原有的选择器匹配的元素中进一步进行过滤的选择器，选择器的语法中大部分是过滤选择器：\n\n * 基本；\n * 内容；\n * 可见性；\n * 属性；\n\n分类    过滤选择器                               描述\n基本    :first                              获取第一个元素\n      :last                               获取最后一个元素\n      :eq(index)                          匹配一个给定索引值的元素\n      :gt(index)                          匹配所有大于给定索引值的元素\n      :lt(index)                          匹配所有小于给定索引值的元素\n      :even                               匹配所有索引值为偶数的元素，从 0 开始计数\n      :odd                                匹配所有索引值为奇数的元素，从 0 开始计数\n      :not(selector)                      去除所有与给定选择器匹配的元素\n内容    :contains(text)                     匹配包含给定文本的元素\n      :has(selector)                      匹配含有选择器所匹配的元素的元素\n      :empty                              匹配所有不包含子元素或者文本的空元素\n      :parent                             匹配含有子元素或者文本的元素\n可见性   :hidden                             匹配所有不可见元素，或者 type 为 hidden 的元素\n      :visible                            匹配所有的可见元素\n属性    [attribute]                         匹配包含给定属性的元素\n      [attribute=value]                   匹配给定的属性是某个特定值的元素\n      [attribute!=value]                  匹配所有不含有指定的属性，或者属性不等于特定值的元素\n      [attribute*=value]                  匹配给定的属性是以包含某些值的元素\n      [selector1][selector2][selectorN]   复合属性选择器，需要同时满足多个条件时使用\n\n🌰：jQuery-example-selector-2 (codepen.io)\n\n\n# 表单选择器\n\n * 表单；\n * 表单对象属性；\n\n表单选择器       描述\n:input      匹配所有 input , textarea , select 和 button 元素\n:text       匹配所有的单行文本框\n:password   匹配所有密码框\n:radio      匹配所有单选按钮\n:checkbox   匹配所有复选框\n:submit     匹配所有提交按钮\n:reset      匹配所有重置按钮\n:button     匹配所有按钮\n表单对象属性      描述\n:enabled    匹配所有可用元素\n:disabled   匹配所有不可用元素\n:checked    匹配所有选中的被选中元素 (复选框、单选框等，不包括 select 中的 option )\n:selected   匹配所有选中的 option 元素\n\n🌰： jQuery-example-selector-3 (codepen.io)\n\n\n# jQuery 工具方法\n\n工具方法                        描述\n$.each(object,[callback])   通用遍历方法，可用于遍历对象和数组\n$.type(obj)                 检测 obj 的数据类型\n$.isArray(obj)              测试对象是否为数组\n$.isFunction(obj)           测试对象是否为函数\n$.isNumeric(value)          测试对象是否为数字\n$.parseJSON(json)           接受一个 JSON 字符串，返回解析后的对象\n\n🌰：jQuery-example-function (codepen.io)\n\n🌰 tab 切换实例： jQuery-example-function tab 切换 (codepen.io)\n\n\n# jQuery 操作属性\n\n方法              描述\nattr()          设置或返回被选元素的属性值\nremoveAttr()    从每一个匹配的元素中删除一个属性\nprop()          获取在匹配的元素集中的第一个元素的属性值\nremoveProp()    用来删除由 .prop() 方法设置的属性集\naddClass()      为每个匹配的元素添加指定的类名\nremoveClass()   从所有匹配的元素中删除全部或者指定的类\ntoggleClass()   如果存在（不存在）就删除（添加）一个类\nhtml()          取得第一个匹配元素的 HTML 内容\ntext()          取得所有匹配元素的内容\nval()           获得匹配元素的当前值\n\n🌰：jQuery-example-attribute (codepen.io)\n\n\n# jQuery 操作元素样式\n\n方法              描述\ncss()           访问匹配元素的样式属性\noffset()        获取匹配元素在当前视口的相对偏移\nposition()      获取匹配元素相对父元素的偏移\nscrollTop()     获取匹配元素相对滚动条顶部的偏移\nscrollLeft()    获取匹配元素相对滚动条左侧的偏移\nheight()        取得匹配元素当前计算的高度值 px\nwidth()         取得第一个匹配元素当前计算的宽度值 px\ninnerHeight()   获取第一个匹配元素内部区域高度（包括补白、不包括边框）\ninnerWidth()    获取第一个匹配元素内部区域宽度（包括补白、不包括边框）\nouterHeight()   获取第一个匹配元素外部高度（默认包括补白和边框）\nouterWidth()    获取第一个匹配元素外部宽度（默认包括补白和边框）\n\n🌰：jQuery-example-css (codepen.io)\n\n\n# jQuery 对象的过滤和查找\n\n\n# 对象的过滤\n\n过滤方法         描述\neq()         获取第 N 个元素\nfirst()      获取第一个元素\nlast()       获取最后一个元素\nhasClass()   检查当前的元素是否含有某个特定的类，如有则返回 ture\nfilter()     筛选出与指定表达式匹配的元素集合\nnot()        删除与指定表达式匹配的元素\nis()         根据选择器、DOM 元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合给定的表达式就返回 true\nhas()        保留包含特定后代的元素，移除不含有指定后代的元素\n\n * 🌰： jQuery-example-object-filter (codepen.io)\n\n\n# 对象的查找\n\n查找方法             描述\nchildren()       取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合\nfind()           搜索所有与指定表达式匹配的元素，这个函数是找出正在处理的元素的后代元素的好方法\nsiblings()       取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合\nnext()           取得一个包含匹配的元素集合中每一个元素紧邻的后一个同辈元素的元素集合\nnextAll()        查找当前元素之后所有的同辈元素\nnextUntil()      查找当前元素之后所有的同辈元素，直到遇到匹配的那个元素为止\nprev()           取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合\nprevAll()        查找当前元素之前所有的同辈元素\nprevUntil()      查找当前元素之前所有的同辈元素，直到遇到匹配的那个元素为止\noffsetParent()   返回第一个匹配元素用于定位的父节点\nparent()         取得一个包含着所有匹配元素的唯一父元素的元素集合\nparentsUntil()   查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止\n\n🌰：jQuery-example-object-match (codepen.io)\n\n🌰 过滤和查找的实例 爱好选择器：jQuery-example-object 爱好选择器 (codepen.io)\n\n\n# jQuery 文档处理\n\n       文档处理方法           描述\n内部插入   append()         向每个匹配的元素内部追加内容\n       appendTo()       把所有匹配的元素追加到另一个指定的元素元素集合中\n       prepend()        向每个匹配的元素内部前置内容\n       prependTo()      把所有匹配的元素前置到另一个、指定的元素元素集合中\n外部插入   after()          在每个匹配的元素之后插入内容\n       before()         在每个匹配的元素之前插入内容\n       insertAfter()    把所有匹配的元素插入到另一个、指定的元素元素集合的后面\n       insertBefore()   把所有匹配的元素插入到另一个、指定的元素元素集合的前面\n包裹     wrap()           把所有匹配的元素用其他元素的结构化标记包裹起来\n       unwrap()         这个方法将移出元素的父元素\n       wrapAll()        将所有匹配的元素用单个元素包裹起来\n       wrapInner()      将每一个匹配的元素的子内容 (包括文本节点) 用一个 HTML 结构包裹起来\n替换     replaceWith()    将所有匹配的元素替换成指定的 HTML 或 DOM 元素\n       replaceAll()     用匹配的元素替换掉所有 selector 匹配到的元素\n删除     empty()          删除匹配的元素集合中所有的子节点\n       remove()         从 DOM 中删除所有匹配的元素\n       detach()         从 DOM 中删除所有匹配的元素\n克隆     clone()          克隆匹配的 DOM 元素并且选中这些克隆的副本\n\n🌰：jQuery-example-HTML (codepen.io)\n\n🌰 添加、删除员工信息：jQuery-example-HTML add/delete Node (codepen.io)\n\n\n# jQuery 事件处理\n\n       事件方法                  描述\n页面载入   ready()               当 DOM 载入就绪可以查询及操纵时绑定一个要执行的函数\n事件处理   on()                  在选择元素上绑定一个或多个事件的事件处理函数\n       off()                 在选择元素上移除一个或多个事件的事件处理函数\n       bind()                为每个匹配元素的特定事件绑定事件处理函数\n       unbind()              bind () 的反向操作，从每一个匹配的元素中删除绑定的事件\n       one()                 为每一个匹配元素的特定事件（像 click）绑定一个一次性的事件处理函数\n       trigger()             在每一个匹配的元素上触发某类事件\n       triggerHandler()      这个特别的方法将会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认动作，也不会产生事件冒泡\n事件委派   delegate()            指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数\n       undelegate()          删除由 delegate () 方法添加的一个或多个事件处理程序\n事件切换   hover()               一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法\n       toggle()              用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件\n事件     focus() 、 focusin()   当元素获得焦点时，触发 focus、focusin 事件\n       blur() 、 focusout()   当元素失去焦点时，触发 blur、focusout 事件\n       change()              当元素的值发生改变时，会发生 change 事件\n       click()               触发每一个匹配元素的 click 事件\n       dblclick()            当双击元素时，会发生 dblclick 事件\n       error()               当元素遇到错误（没有正确载入）时，发生 error 事件\n       mousedown()           当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件\n       mouseup()             当在元素上放松鼠标按钮时，会发生 mouseup 事件\n       mouseenter()          当鼠标指针穿过元素时，会发生 mouseenter 事件\n       mouseleave()          当鼠标指针离开元素时，会发生 mouseleave 事件\n       mouseover()           当鼠标指针位于元素上方时，会发生 mouseover 事件\n       mouseout()            当鼠标指针从元素上移开时，发生 mouseout 事件\n       mousemove()           当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件\n       keypress()            当键盘或按钮被按下时，发生 keypress 事件\n       keydown()             当键盘或按钮被按下时，发生 keydown 事件\n       keyup()               当按钮被松开时，发生 keyup 事件\n       resize()              当调整浏览器窗口的大小时，发生 resize 事件\n       scroll()              当用户滚动指定的元素时，会发生 scroll 事件\n       select()              当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件\n       submit()              当提交表单时，会发生 submit 事件\n       unload()              在当用户离开页面时，会发生 unload 事件\n\nmouseover / mouseout 与 mouseenter / mouseleave 的区别在于子元素：\n\n * mouseover / mouseout 进入和离开子元素会再次触发\n\n * mouseenter / mouseleave 进入和离开子元素不会再次触发\n\n🌰事件绑定、鼠标事件、事件解绑：jQuery-example-event (codepen.io)\n\n坐标相关： offsetX、offsetY、pageX、pageY、clientX、clientY\n\n * offsetX 、 offsetY ：相对于触发事件对象的坐标；\n\n * pageX 、 pageY ：相对于视口的坐标；\n\n * clientX 、 clientY ：相对于屏幕的坐标；\n\n🌰：jQuery-example-event X/Y (codepen.io)\n\n停止冒泡 stopPropagation 、 preventDefault\n\n// 点击.inner区域，外部点击监听不响应\n$('.inner').on('click', function (event) {\n    alert('click inner');\n    event.stopPropagation(); // 停止冒泡\n});\n\n// 点击链接，如果当前时间是偶数不跳转\n$('#test4').on('click', function (event) {\n    if (Date.now() % 2 === 0) {\n        event.preventDefault(); // 阻止默认行为\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# jQuery 事件委派\n\n（事件代理 / 委托）：将多个子元素的事件委派给父元素处理，监听回调加在父元素上：\n\n * 当操作任何一个子元素时，事件会冒泡给父元素；\n * 父元素不会直接处理事件，而是根据 event.target 得到发生事件的子元素，通过这个子元素调用回调函数；\n\n事件委派的优点：\n\n * 对于新添加的子元素，自动有事件响应处理；\n * 减少事件监听的数量：从 n 个到 1 个；\n\n\n# 事件委派 API\n\n设置 / 移除事件委派 delegate / undelegate\n\n * 设置： $(parentSelector).delegate(childrenSelector, eventName, callback) ；\n * 移除： (parentSelector).undelegate(eventName) ；\n\n🌰：jQuery-example-event delegate/undelegate (codepen.io)\n\n🌰图片切换：jQuery-example 图片切换 (codepen.io)\n\n\n# jQuery 动画\n\n       动画              描述\n基本     show()          显示隐藏的匹配元素\n       hide()          隐藏显示的元素\n       toggle()        用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件\n滑动     slideDown()     通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数\n       slideUp()       通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数\n       slideToggle()   通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数\n淡入淡出   fadeIn()        通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数\n       fadeOut()       通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数\n       fadeTo()        把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数\n       fadeToggle()    通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数\n自定义    animate()       用于创建自定义动画的函数\n       stop()          停止所有在指定元素上正在运行的动画\n       finish()        停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画\n       delay()         设置一个延时来推迟执行队列中之后的项目\n\n\n# 淡入淡出效果\n\n不断改变元素的透明度 opacity 来实现的：\n\n * fadeIn() ：带动画的显示\n\n * fadeOut() ：带动画隐藏\n\n * fadeToggle() ：带动画切英显示 / 隐藏\n\n🌰：jQuery-example-animation fadeIn/fadeOut/fadeToggle (codepen.io)\n\n\n# 滑动\n\n不断改变元素的高度（ height ）实现：\n\n * slideDown() ：带动画的展开\n\n * slideUp() ：带动画的收缩\n\n * slideToggle() ：带动画的切换展开 / 收缩\n\n🌰：jQuery-example-animation Slide (codepen.io)\n\n\n# 显示隐藏\n\n默认没有动画，动画（修改样式 opacity / height / width ）：\n\n * show() ：（不）带动画的显示\n\n * hide() ：（不）带动画的隐藏\n\n * toggle() ：（不）带动画的切换显示 / 隐\n\n例子：jQuery-example-animation Show/Hide (codepen.io)\n\n\n# jQuery\n\n\n# onload 和 ready 区别\n\nwindow.onload 与 $(document).ready() 区别：\n\nwindow.onload\n\n * 包括页面的图片加载完后才会回调（晚）；\n * 只能有 一个监听回调；\n\n$(document).ready()\n\n * 等同于： $(function(){}) ；\n * 页面加载完就回调（早）；\n * 可以有 多个监听回调；\n\n// 1.直接打印img的宽度,观察其值\nconsole.log('直接', $('#logo').width()); // 直接 0\n\n// 2.在$(function(){})中打印img的宽度\n$(function () {\n    console.log('ready', $('#logo').width()); // ready 0\n});\n\n// 3.在window.onload中打印img的宽度\nwindow.onload = function () {\n    console.log('onload', $('#logo').width()); // onload 190\n};\n\n// 4.在img加载完成后打印宽度\n$('#logo').on('load', function () {\n    console.log('img load', $('#logo').width()); // img load 190\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# jquery 基础\n\n\n# 引入\n\n\x3c!--服务器本地库--\x3e\n<script src=\"js/jquery-3.6.0.js\"><\/script>\n\x3c!--cdn远程库--\x3e\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\"><\/script>\n\n\n1\n2\n3\n4\n\n\n> 区别 2 种引用 js 库的方式：\n> \n>  * 服务器本地库\n>  * cdn 远程库\n>  * * 项目上线时，一般使用比较靠谱的 cdn 资源库，减轻服务器负担；\n>  * * https://www.bootcdn.cn/：搜索 jquery ，复制 <script> 标签到项目中即可使用；\n\n> 区别 jquery 的不同版本：\n> \n>  * 1.x\n>    \n>    * 兼容老版本 ie\n>  * * 文件更大\n> \n>  * 2.x\n> \n>  * * 部分 ie8 及以下支持\n>  * * 文件小，执行效率更高\n> \n>  * 3.x\n> \n>  * * 完全不再支持 ie8 及以下版本\n>  * * 提供了一些新的 api\n>  * * 提供不包含 ajax / 动画 api 的版本\n\n> 在 codepen 中使用：\n> \n> 在 codepen 中引入 jquery 包的最新版本：在 pen settins - js - add external scripts/pens 搜索栏中输入 jquery 后选择包：\n\n\n# 基本语法\n\n * 核心函数： $ /jquery 函数\n * 核心对象： 执行 $() 返回的对象\n\n\n# jquery 核心函数\n\n引入 jquery 库后，直接使用：\n\n * 当函数用： $(xxx)\n * 当对象用： $.xxx()\n\n// jquery函数：直接可用\nconsole.log($, typeof $);  // ƒ ( selector, context ) {}    function\nconsole.log(jquery === $); // true\n\n\n1\n2\n3\n\n\n\n# jquery 核心对象\n\n得到 jquery 对象：执行 jquery 函数返回的就是 jquery 对象；\n\n使用 jquery 对象： $obj.xxx() ；\n\nconsole.log($(), typeof $(), $() instanceof object); \n// jquery.fn.init {} \"object\" true\n\n\n1\n2\n\n\n\n# jquery 函数的使用\n\n作为一般函数调用： $(param) ：\n\n * 参数为函数时：当 dom 加载完成后，执行此回调函数；\n * 参数为选择器字符：查找所有匹配的标签并将它们封装为 jquery 对象；\n * 参数为 dom 对象：将 dom 对象封装成 jquery 对象；\n * 参数为 html 标签字符串（用得少）：创建标签对象并封装成 jquery 对象；\n\n作为对象使用： $.xxx() ：\n\n * $.each() ：隐式遍历数组；\n   \n   var arr = [3, 7, 4];\n       $.each(arr, function (index, item) {\n           console.log(index, item); // 0 3    1 7    2 4\n       });\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * $.trim() ：去除两端的空格；\n   \n   var str = \"    my atguigu   \";\n       console.log('===' + str + '===');           \n   // ===    my atguigu   ===\n       console.log('===' + str.trim() + '===');    \n   // ===my atguigu===\n       console.log('===' + $.trim(str) + '===');   \n   // ===my atguigu===\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# jquery 对象的使用\n\n即执行 jquery 核心函数返回的对象，jquery 对象内部包含的是 dom 元素对象的伪数组（可能只有一个元素），jquery 对象拥有很多有用的属性和方法，方便操作 dom；\n\n属性和方法：\n\n * 基本行为： 操作标签的基本方法；\n * 属性：操作内部标签的属性和值；\n * css： 操作标签的样式；\n * 文档：对标签进行增、删、改操作；\n * 筛选：根据指定的规则过滤内部的标签；\n * 事件：处理事件的监听相关；\n * 效果：实现动画效果；\n\njquery 基本行为\n\n * size() 、 length ：获取包含的 dom 元素的个数\n   \n   // 统计一共有多少个按钮\n   var $buttons = $('button');\n   console.log($buttons.length); // 4\n   \n   \n   1\n   2\n   3\n   \n\n * [index] 、 get(index) ：获取对应位置的 dom 元素；\n   \n   // 需求2.取出第2个button的文本\n   console.log($('button:nth-child(2)').text()); // 测试二\n   \n   console.log($buttons[1].innerhtml, $buttons.get(1).innerhtml);\n   // 测试二 测试二\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * each() ：遍历包含的所有的 dom 元素；\n   \n   $buttons.each(function () {\n       console.log(this.innerhtml); // 测试一 测试二 测试三 测试四\n   });\n   \n   \n   1\n   2\n   3\n   \n\n * index() ：得到在所在兄弟元素中的下标索引；\n   \n   console.log($(\"#btn3\").index()); // 2\n   \n   \n   1\n   \n\n伪数组：\n\n * object ： 对象；\n * length ：属性；\n * 数组下标的属性\n * 没有数组特别的方法： foreach() 、 push() 、 pop() 、 slice ；\n\nconsole.log($buttons instanceof array); // false\n//自定义一个伪数组\nvar weiarr = {}\nweiarr.length = 0;\nweiarr[0] = 'atguigu';\nweiarr.length = 1;\nweiarr[1] = 123;\nweiarr.length = 2;\nfor (var i = 0; i < weiarr.length; i++) {\n    var obj = weiarr[i];\n    console.log(i, obj); // 0 \"atguigu\"    1 123\n}\nconsole.log(weiarr.foreach, $buttons.foreach); //undefined undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# jquery 选择器\n\n * 选择器本身只是一个有特定语法规则的字符串，没有实质用处；\n\n * 它的基本语法规则使用的就是 css 的选择器语法，并对其进行了扩展；\n\n * 只有调用 $() ，并将选择器作为参数传入才能起作用；\n\n * $(selector) 作用：根据选择器规则在整个文档中查找所有匹配的标签的数组（伪数组），并封装成 jquery 对象；\n\n\n# 基本选择器\n\n基本选择器                                 描述\nid 选择器 #id                            根据给定的 id 匹配一个元素\n标签选择器 element                         根据给定的元素名匹配所有元素\n属性选择器 .class                          根据给定的类名匹配元素\n通用选择器 *                               匹配所有元素\n并集选择器 selector1,selector2,selectorn   将每一个选择器匹配到的元素合并后一起返回\n交集选择器 selector1 selector2             \n\n🌰：jquery-example-selector-1 (codepen.io)\n\n\n# 层级选择器\n\n层级选择器                         描述\n后代元素选择器 ancestor descendant   在给定的祖先元素下匹配所有的后代元素\n子元素选择器 parent > child         在给定的父元素下匹配所有的子元素\n兄弟选择器 prev + next             匹配所有紧接在 prev 元素后的 next 元素\n兄弟选择器 prev ~ siblings         匹配 prev 元素之后的所有 siblings 元素\n\n🌰：jquery-example-selector-2 (codepen.io)\n\n\n# 过滤选择器\n\n在原有的选择器匹配的元素中进一步进行过滤的选择器，选择器的语法中大部分是过滤选择器：\n\n * 基本；\n * 内容；\n * 可见性；\n * 属性；\n\n分类    过滤选择器                               描述\n基本    :first                              获取第一个元素\n      :last                               获取最后一个元素\n      :eq(index)                          匹配一个给定索引值的元素\n      :gt(index)                          匹配所有大于给定索引值的元素\n      :lt(index)                          匹配所有小于给定索引值的元素\n      :even                               匹配所有索引值为偶数的元素，从 0 开始计数\n      :odd                                匹配所有索引值为奇数的元素，从 0 开始计数\n      :not(selector)                      去除所有与给定选择器匹配的元素\n内容    :contains(text)                     匹配包含给定文本的元素\n      :has(selector)                      匹配含有选择器所匹配的元素的元素\n      :empty                              匹配所有不包含子元素或者文本的空元素\n      :parent                             匹配含有子元素或者文本的元素\n可见性   :hidden                             匹配所有不可见元素，或者 type 为 hidden 的元素\n      :visible                            匹配所有的可见元素\n属性    [attribute]                         匹配包含给定属性的元素\n      [attribute=value]                   匹配给定的属性是某个特定值的元素\n      [attribute!=value]                  匹配所有不含有指定的属性，或者属性不等于特定值的元素\n      [attribute*=value]                  匹配给定的属性是以包含某些值的元素\n      [selector1][selector2][selectorn]   复合属性选择器，需要同时满足多个条件时使用\n\n🌰：jquery-example-selector-2 (codepen.io)\n\n\n# 表单选择器\n\n * 表单；\n * 表单对象属性；\n\n表单选择器       描述\n:input      匹配所有 input , textarea , select 和 button 元素\n:text       匹配所有的单行文本框\n:password   匹配所有密码框\n:radio      匹配所有单选按钮\n:checkbox   匹配所有复选框\n:submit     匹配所有提交按钮\n:reset      匹配所有重置按钮\n:button     匹配所有按钮\n表单对象属性      描述\n:enabled    匹配所有可用元素\n:disabled   匹配所有不可用元素\n:checked    匹配所有选中的被选中元素 (复选框、单选框等，不包括 select 中的 option )\n:selected   匹配所有选中的 option 元素\n\n🌰： jquery-example-selector-3 (codepen.io)\n\n\n# jquery 工具方法\n\n工具方法                        描述\n$.each(object,[callback])   通用遍历方法，可用于遍历对象和数组\n$.type(obj)                 检测 obj 的数据类型\n$.isarray(obj)              测试对象是否为数组\n$.isfunction(obj)           测试对象是否为函数\n$.isnumeric(value)          测试对象是否为数字\n$.parsejson(json)           接受一个 json 字符串，返回解析后的对象\n\n🌰：jquery-example-function (codepen.io)\n\n🌰 tab 切换实例： jquery-example-function tab 切换 (codepen.io)\n\n\n# jquery 操作属性\n\n方法              描述\nattr()          设置或返回被选元素的属性值\nremoveattr()    从每一个匹配的元素中删除一个属性\nprop()          获取在匹配的元素集中的第一个元素的属性值\nremoveprop()    用来删除由 .prop() 方法设置的属性集\naddclass()      为每个匹配的元素添加指定的类名\nremoveclass()   从所有匹配的元素中删除全部或者指定的类\ntoggleclass()   如果存在（不存在）就删除（添加）一个类\nhtml()          取得第一个匹配元素的 html 内容\ntext()          取得所有匹配元素的内容\nval()           获得匹配元素的当前值\n\n🌰：jquery-example-attribute (codepen.io)\n\n\n# jquery 操作元素样式\n\n方法              描述\ncss()           访问匹配元素的样式属性\noffset()        获取匹配元素在当前视口的相对偏移\nposition()      获取匹配元素相对父元素的偏移\nscrolltop()     获取匹配元素相对滚动条顶部的偏移\nscrollleft()    获取匹配元素相对滚动条左侧的偏移\nheight()        取得匹配元素当前计算的高度值 px\nwidth()         取得第一个匹配元素当前计算的宽度值 px\ninnerheight()   获取第一个匹配元素内部区域高度（包括补白、不包括边框）\ninnerwidth()    获取第一个匹配元素内部区域宽度（包括补白、不包括边框）\nouterheight()   获取第一个匹配元素外部高度（默认包括补白和边框）\nouterwidth()    获取第一个匹配元素外部宽度（默认包括补白和边框）\n\n🌰：jquery-example-css (codepen.io)\n\n\n# jquery 对象的过滤和查找\n\n\n# 对象的过滤\n\n过滤方法         描述\neq()         获取第 n 个元素\nfirst()      获取第一个元素\nlast()       获取最后一个元素\nhasclass()   检查当前的元素是否含有某个特定的类，如有则返回 ture\nfilter()     筛选出与指定表达式匹配的元素集合\nnot()        删除与指定表达式匹配的元素\nis()         根据选择器、dom 元素或 jquery 对象来检测匹配元素集合，如果其中至少有一个元素符合给定的表达式就返回 true\nhas()        保留包含特定后代的元素，移除不含有指定后代的元素\n\n * 🌰： jquery-example-object-filter (codepen.io)\n\n\n# 对象的查找\n\n查找方法             描述\nchildren()       取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合\nfind()           搜索所有与指定表达式匹配的元素，这个函数是找出正在处理的元素的后代元素的好方法\nsiblings()       取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合\nnext()           取得一个包含匹配的元素集合中每一个元素紧邻的后一个同辈元素的元素集合\nnextall()        查找当前元素之后所有的同辈元素\nnextuntil()      查找当前元素之后所有的同辈元素，直到遇到匹配的那个元素为止\nprev()           取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合\nprevall()        查找当前元素之前所有的同辈元素\nprevuntil()      查找当前元素之前所有的同辈元素，直到遇到匹配的那个元素为止\noffsetparent()   返回第一个匹配元素用于定位的父节点\nparent()         取得一个包含着所有匹配元素的唯一父元素的元素集合\nparentsuntil()   查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止\n\n🌰：jquery-example-object-match (codepen.io)\n\n🌰 过滤和查找的实例 爱好选择器：jquery-example-object 爱好选择器 (codepen.io)\n\n\n# jquery 文档处理\n\n       文档处理方法           描述\n内部插入   append()         向每个匹配的元素内部追加内容\n       appendto()       把所有匹配的元素追加到另一个指定的元素元素集合中\n       prepend()        向每个匹配的元素内部前置内容\n       prependto()      把所有匹配的元素前置到另一个、指定的元素元素集合中\n外部插入   after()          在每个匹配的元素之后插入内容\n       before()         在每个匹配的元素之前插入内容\n       insertafter()    把所有匹配的元素插入到另一个、指定的元素元素集合的后面\n       insertbefore()   把所有匹配的元素插入到另一个、指定的元素元素集合的前面\n包裹     wrap()           把所有匹配的元素用其他元素的结构化标记包裹起来\n       unwrap()         这个方法将移出元素的父元素\n       wrapall()        将所有匹配的元素用单个元素包裹起来\n       wrapinner()      将每一个匹配的元素的子内容 (包括文本节点) 用一个 html 结构包裹起来\n替换     replacewith()    将所有匹配的元素替换成指定的 html 或 dom 元素\n       replaceall()     用匹配的元素替换掉所有 selector 匹配到的元素\n删除     empty()          删除匹配的元素集合中所有的子节点\n       remove()         从 dom 中删除所有匹配的元素\n       detach()         从 dom 中删除所有匹配的元素\n克隆     clone()          克隆匹配的 dom 元素并且选中这些克隆的副本\n\n🌰：jquery-example-html (codepen.io)\n\n🌰 添加、删除员工信息：jquery-example-html add/delete node (codepen.io)\n\n\n# jquery 事件处理\n\n       事件方法                  描述\n页面载入   ready()               当 dom 载入就绪可以查询及操纵时绑定一个要执行的函数\n事件处理   on()                  在选择元素上绑定一个或多个事件的事件处理函数\n       off()                 在选择元素上移除一个或多个事件的事件处理函数\n       bind()                为每个匹配元素的特定事件绑定事件处理函数\n       unbind()              bind () 的反向操作，从每一个匹配的元素中删除绑定的事件\n       one()                 为每一个匹配元素的特定事件（像 click）绑定一个一次性的事件处理函数\n       trigger()             在每一个匹配的元素上触发某类事件\n       triggerhandler()      这个特别的方法将会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认动作，也不会产生事件冒泡\n事件委派   delegate()            指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数\n       undelegate()          删除由 delegate () 方法添加的一个或多个事件处理程序\n事件切换   hover()               一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法\n       toggle()              用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件\n事件     focus() 、 focusin()   当元素获得焦点时，触发 focus、focusin 事件\n       blur() 、 focusout()   当元素失去焦点时，触发 blur、focusout 事件\n       change()              当元素的值发生改变时，会发生 change 事件\n       click()               触发每一个匹配元素的 click 事件\n       dblclick()            当双击元素时，会发生 dblclick 事件\n       error()               当元素遇到错误（没有正确载入）时，发生 error 事件\n       mousedown()           当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件\n       mouseup()             当在元素上放松鼠标按钮时，会发生 mouseup 事件\n       mouseenter()          当鼠标指针穿过元素时，会发生 mouseenter 事件\n       mouseleave()          当鼠标指针离开元素时，会发生 mouseleave 事件\n       mouseover()           当鼠标指针位于元素上方时，会发生 mouseover 事件\n       mouseout()            当鼠标指针从元素上移开时，发生 mouseout 事件\n       mousemove()           当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件\n       keypress()            当键盘或按钮被按下时，发生 keypress 事件\n       keydown()             当键盘或按钮被按下时，发生 keydown 事件\n       keyup()               当按钮被松开时，发生 keyup 事件\n       resize()              当调整浏览器窗口的大小时，发生 resize 事件\n       scroll()              当用户滚动指定的元素时，会发生 scroll 事件\n       select()              当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件\n       submit()              当提交表单时，会发生 submit 事件\n       unload()              在当用户离开页面时，会发生 unload 事件\n\nmouseover / mouseout 与 mouseenter / mouseleave 的区别在于子元素：\n\n * mouseover / mouseout 进入和离开子元素会再次触发\n\n * mouseenter / mouseleave 进入和离开子元素不会再次触发\n\n🌰事件绑定、鼠标事件、事件解绑：jquery-example-event (codepen.io)\n\n坐标相关： offsetx、offsety、pagex、pagey、clientx、clienty\n\n * offsetx 、 offsety ：相对于触发事件对象的坐标；\n\n * pagex 、 pagey ：相对于视口的坐标；\n\n * clientx 、 clienty ：相对于屏幕的坐标；\n\n🌰：jquery-example-event x/y (codepen.io)\n\n停止冒泡 stoppropagation 、 preventdefault\n\n// 点击.inner区域，外部点击监听不响应\n$('.inner').on('click', function (event) {\n    alert('click inner');\n    event.stoppropagation(); // 停止冒泡\n});\n\n// 点击链接，如果当前时间是偶数不跳转\n$('#test4').on('click', function (event) {\n    if (date.now() % 2 === 0) {\n        event.preventdefault(); // 阻止默认行为\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# jquery 事件委派\n\n（事件代理 / 委托）：将多个子元素的事件委派给父元素处理，监听回调加在父元素上：\n\n * 当操作任何一个子元素时，事件会冒泡给父元素；\n * 父元素不会直接处理事件，而是根据 event.target 得到发生事件的子元素，通过这个子元素调用回调函数；\n\n事件委派的优点：\n\n * 对于新添加的子元素，自动有事件响应处理；\n * 减少事件监听的数量：从 n 个到 1 个；\n\n\n# 事件委派 api\n\n设置 / 移除事件委派 delegate / undelegate\n\n * 设置： $(parentselector).delegate(childrenselector, eventname, callback) ；\n * 移除： (parentselector).undelegate(eventname) ；\n\n🌰：jquery-example-event delegate/undelegate (codepen.io)\n\n🌰图片切换：jquery-example 图片切换 (codepen.io)\n\n\n# jquery 动画\n\n       动画              描述\n基本     show()          显示隐藏的匹配元素\n       hide()          隐藏显示的元素\n       toggle()        用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件\n滑动     slidedown()     通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数\n       slideup()       通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数\n       slidetoggle()   通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数\n淡入淡出   fadein()        通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数\n       fadeout()       通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数\n       fadeto()        把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数\n       fadetoggle()    通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数\n自定义    animate()       用于创建自定义动画的函数\n       stop()          停止所有在指定元素上正在运行的动画\n       finish()        停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画\n       delay()         设置一个延时来推迟执行队列中之后的项目\n\n\n# 淡入淡出效果\n\n不断改变元素的透明度 opacity 来实现的：\n\n * fadein() ：带动画的显示\n\n * fadeout() ：带动画隐藏\n\n * fadetoggle() ：带动画切英显示 / 隐藏\n\n🌰：jquery-example-animation fadein/fadeout/fadetoggle (codepen.io)\n\n\n# 滑动\n\n不断改变元素的高度（ height ）实现：\n\n * slidedown() ：带动画的展开\n\n * slideup() ：带动画的收缩\n\n * slidetoggle() ：带动画的切换展开 / 收缩\n\n🌰：jquery-example-animation slide (codepen.io)\n\n\n# 显示隐藏\n\n默认没有动画，动画（修改样式 opacity / height / width ）：\n\n * show() ：（不）带动画的显示\n\n * hide() ：（不）带动画的隐藏\n\n * toggle() ：（不）带动画的切换显示 / 隐\n\n例子：jquery-example-animation show/hide (codepen.io)\n\n\n# jquery\n\n\n# onload 和 ready 区别\n\nwindow.onload 与 $(document).ready() 区别：\n\nwindow.onload\n\n * 包括页面的图片加载完后才会回调（晚）；\n * 只能有 一个监听回调；\n\n$(document).ready()\n\n * 等同于： $(function(){}) ；\n * 页面加载完就回调（早）；\n * 可以有 多个监听回调；\n\n// 1.直接打印img的宽度,观察其值\nconsole.log('直接', $('#logo').width()); // 直接 0\n\n// 2.在$(function(){})中打印img的宽度\n$(function () {\n    console.log('ready', $('#logo').width()); // ready 0\n});\n\n// 3.在window.onload中打印img的宽度\nwindow.onload = function () {\n    console.log('onload', $('#logo').width()); // onload 190\n};\n\n// 4.在img加载完成后打印宽度\n$('#logo').on('load', function () {\n    console.log('img load', $('#logo').width()); // img load 190\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📐 Less 笔记",frontmatter:{title:"📐 Less 笔记",date:"2021-10-18T09:50:08.000Z",permalink:"/pages/bade75/",categories:["前端笔记","📦 HTML+CSS 笔记"],tags:["CSS","Less"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/110.%20%F0%9F%91%A3%20%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BE%85%E5%8A%A9/40.%20%F0%9F%93%90Less%20%E7%AC%94%E8%AE%B0.html",relativePath:"100. 🚶 前端入门基础/110. 👣 前端基础辅助/40. 📐Less 笔记.md",key:"v-4adbdfdc",path:"/pages/bade75/",headers:[{level:2,title:"Less 基本语法",slug:"less-基本语法",normalizedTitle:"less 基本语法",charIndex:51},{level:3,title:"嵌套关系",slug:"嵌套关系",normalizedTitle:"嵌套关系",charIndex:154},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:1003},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1531},{level:3,title:"混合函数",slug:"混合函数",normalizedTitle:"混合函数",charIndex:1611},{level:3,title:"其他函数",slug:"其他函数",normalizedTitle:"其他函数",charIndex:3107},{level:3,title:"引入",slug:"引入",normalizedTitle:"引入",charIndex:3354}],headersStr:"Less 基本语法 嵌套关系 变量 其他 混合函数 其他函数 引入",content:"🗄doc: Getting started | Less.js (lesscss.org)\n\n\n# Less 基本语法\n\n代码注释\n\n与 CSS 的注释分开，Less 的单行注释不会被解析到 CSS 文件中。\n\n// Less 单行注释\n\n/*\n\tCSS 中的注释\n*/\n\n\n1\n2\n3\n4\n5\n\n\n\n# 嵌套关系\n\n适用于父子元素的关系：\n\nbody {\n    --height: calc(200px /2);\n    --weight: 100px;\n\n    div {\n        height: var(--height);\n        width: var(--weight);\n    }\n\n    .box1 {\n        background-color: #bfa;\n    }\n  \n    .box2 {\n        background-color: red;\n\n        .box3 {\n            background-color: yellow;\n        }\n\n        >.box4 {\n            background-color: green;\n        }\n    }\n          \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n处理后的 CSS 文件：\n\nbody {\n  --height: calc(200px / 2);\n  --weight: 100px;\n}\nbody div {\n  height: var(--height);\n  width: var(--weight);\n}\nbody .box1 {\n  background-color: #bfa;\n}\nbody .box2 {\n  background-color: red;\n}\nbody .box2 .box3 {\n  background-color: yellow;\n}\nbody .box2 > .box4 {\n  background-color: green;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 变量\n\n可以存储一个任意的值，在需要时修改变量的值：\n\n * 直接使用使用变量时，则以 @变量名 的形式使用即可\n\n * 作为类名、属性名或者一部分值使用时，必须以 @{变量名} 的形式使用；\n\n * 可以在变量声明前就使用变量（可以但不建议）；\n\n@b1: box1;\n@size: 200px;\n@bc: background-color;\n@bi: background-image;\n@color: red;\n@path: img;\n\n.@{b1} {\n    width: @size;\n    height: $width;\n    @{bc}: @color;\n    @{bi}: url('@{path}/300/300');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n处理后的 CSS 文件：\n\n.box1 {\n  width: 200px;\n  height: 200px;\n  background-color: red;\n  background-image: url('img/300/300');\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 url 中需要使用变量需要使用引号包裹 @{…}\n\n\n# 其他\n\n * 使用 & 拼接；\n * 伪元素的使用；\n * :extend() 拓展指定选择器的样式\n * .xx() 对指定选择器的样式引用，相当于复制样式（混合函数）；\n\n@b1: box1;\n@size: 200px;\n@bc: background-color;\n@bi: background-image;\n@color: red;\n@path: img;\n\n.p1 {\n    width: @size;\n    height: $width;\n    &-wrapper {\n        background-color: #fff;\n    }\n\n    // &:hover {\n    //     background-color: skyblue;\n    // }\n    // 伪元素可以直接使用不用 & 拼接\n    :hover {\n        background-color: skyblue;\n    }\n}\n\n// 拓展 .p1 的样式\n.p2:extend(.p1) {\n    color: @color;\n}\n\n// 引用 .p1 的样式\n.p3 {\n    .p1();\n}\n\n// 混合函数创建\n.p4() {\n    width: @size;\n    height: $width;\n}\n\n.p5 {\n    .p4;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n处理后的 CSS 文件：\n\n.p1,\n.p2 {\n  width: 200px;\n  height: 200px;\n}\n.p1-wrapper {\n  background-color: #fff;\n}\n.p1 :hover {\n  background-color: skyblue;\n}\n.p2 {\n  color: red;\n}\n.p3 {\n  width: 200px;\n  height: 200px;\n}\n.p3-wrapper {\n  background-color: #fff;\n}\n.p3 :hover {\n  background-color: skyblue;\n}\n.p5 {\n  width: 200px;\n  height: 200px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 混合函数\n\n可以在括号内设置变量，指定默认值：\n\n用法🌰：\n\n.test (@w:200px, @h:100px, @bc:skyblue){\n    width: @w;\n    height: @h;\n    background-color: @bc;   \n}\n\n// 使用混合函数\n.p6 {\n    // .test(200px, 100px, red) 在对应的参数位置传值\n    // .test(@h:200px,@w:100px,@bc:red); // 写明对应属性，可变换顺序\n    // .test(300px); // 只修改 @w 的值\n    \n    .test()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n处理后的 CSS 文件：\n\n.p6 {\n  width: 200px;\n  height: 100px;\n  background-color: skyblue;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 其他函数\n\naverage() 混合函数，生成中间值：\n\n.h1 {\n    color: average(skyblue, pink);\n}\n\n\n1\n2\n3\n\n\n.h1 {\n  color: #c3c7db;\n}\n\n\n\n1\n2\n3\n4\n\n\ndarken() 混合函数\n\nbody{\n    background-color: darken(#bfa, 50%);\n}\n\n\n1\n2\n3\n\n\nbody{\n    background-color: #22aa00;\n}\n\n\n1\n2\n3\n\n\n\n# 引入\n\n使用 @import 引入其他 Less 文件 (.less)：\n\n@import \"style.less\";\n@import \"syntax.less\";\n\n\n1\n2\n",normalizedContent:"🗄doc: getting started | less.js (lesscss.org)\n\n\n# less 基本语法\n\n代码注释\n\n与 css 的注释分开，less 的单行注释不会被解析到 css 文件中。\n\n// less 单行注释\n\n/*\n\tcss 中的注释\n*/\n\n\n1\n2\n3\n4\n5\n\n\n\n# 嵌套关系\n\n适用于父子元素的关系：\n\nbody {\n    --height: calc(200px /2);\n    --weight: 100px;\n\n    div {\n        height: var(--height);\n        width: var(--weight);\n    }\n\n    .box1 {\n        background-color: #bfa;\n    }\n  \n    .box2 {\n        background-color: red;\n\n        .box3 {\n            background-color: yellow;\n        }\n\n        >.box4 {\n            background-color: green;\n        }\n    }\n          \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n处理后的 css 文件：\n\nbody {\n  --height: calc(200px / 2);\n  --weight: 100px;\n}\nbody div {\n  height: var(--height);\n  width: var(--weight);\n}\nbody .box1 {\n  background-color: #bfa;\n}\nbody .box2 {\n  background-color: red;\n}\nbody .box2 .box3 {\n  background-color: yellow;\n}\nbody .box2 > .box4 {\n  background-color: green;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 变量\n\n可以存储一个任意的值，在需要时修改变量的值：\n\n * 直接使用使用变量时，则以 @变量名 的形式使用即可\n\n * 作为类名、属性名或者一部分值使用时，必须以 @{变量名} 的形式使用；\n\n * 可以在变量声明前就使用变量（可以但不建议）；\n\n@b1: box1;\n@size: 200px;\n@bc: background-color;\n@bi: background-image;\n@color: red;\n@path: img;\n\n.@{b1} {\n    width: @size;\n    height: $width;\n    @{bc}: @color;\n    @{bi}: url('@{path}/300/300');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n处理后的 css 文件：\n\n.box1 {\n  width: 200px;\n  height: 200px;\n  background-color: red;\n  background-image: url('img/300/300');\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 url 中需要使用变量需要使用引号包裹 @{…}\n\n\n# 其他\n\n * 使用 & 拼接；\n * 伪元素的使用；\n * :extend() 拓展指定选择器的样式\n * .xx() 对指定选择器的样式引用，相当于复制样式（混合函数）；\n\n@b1: box1;\n@size: 200px;\n@bc: background-color;\n@bi: background-image;\n@color: red;\n@path: img;\n\n.p1 {\n    width: @size;\n    height: $width;\n    &-wrapper {\n        background-color: #fff;\n    }\n\n    // &:hover {\n    //     background-color: skyblue;\n    // }\n    // 伪元素可以直接使用不用 & 拼接\n    :hover {\n        background-color: skyblue;\n    }\n}\n\n// 拓展 .p1 的样式\n.p2:extend(.p1) {\n    color: @color;\n}\n\n// 引用 .p1 的样式\n.p3 {\n    .p1();\n}\n\n// 混合函数创建\n.p4() {\n    width: @size;\n    height: $width;\n}\n\n.p5 {\n    .p4;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n处理后的 css 文件：\n\n.p1,\n.p2 {\n  width: 200px;\n  height: 200px;\n}\n.p1-wrapper {\n  background-color: #fff;\n}\n.p1 :hover {\n  background-color: skyblue;\n}\n.p2 {\n  color: red;\n}\n.p3 {\n  width: 200px;\n  height: 200px;\n}\n.p3-wrapper {\n  background-color: #fff;\n}\n.p3 :hover {\n  background-color: skyblue;\n}\n.p5 {\n  width: 200px;\n  height: 200px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 混合函数\n\n可以在括号内设置变量，指定默认值：\n\n用法🌰：\n\n.test (@w:200px, @h:100px, @bc:skyblue){\n    width: @w;\n    height: @h;\n    background-color: @bc;   \n}\n\n// 使用混合函数\n.p6 {\n    // .test(200px, 100px, red) 在对应的参数位置传值\n    // .test(@h:200px,@w:100px,@bc:red); // 写明对应属性，可变换顺序\n    // .test(300px); // 只修改 @w 的值\n    \n    .test()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n处理后的 css 文件：\n\n.p6 {\n  width: 200px;\n  height: 100px;\n  background-color: skyblue;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 其他函数\n\naverage() 混合函数，生成中间值：\n\n.h1 {\n    color: average(skyblue, pink);\n}\n\n\n1\n2\n3\n\n\n.h1 {\n  color: #c3c7db;\n}\n\n\n\n1\n2\n3\n4\n\n\ndarken() 混合函数\n\nbody{\n    background-color: darken(#bfa, 50%);\n}\n\n\n1\n2\n3\n\n\nbody{\n    background-color: #22aa00;\n}\n\n\n1\n2\n3\n\n\n\n# 引入\n\n使用 @import 引入其他 less 文件 (.less)：\n\n@import \"style.less\";\n@import \"syntax.less\";\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🅱️ Bootstrap 使用笔记",frontmatter:{title:"🅱️ Bootstrap 使用笔记",date:"2022-02-09T10:32:25.000Z",permalink:"/pages/17c13a/",categories:["前端笔记"],tags:["Bootstrap"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/110.%20%F0%9F%91%A3%20%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BE%85%E5%8A%A9/50.%20%F0%9F%85%B1%EF%B8%8F%20Bootstrap%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html",relativePath:"100. 🚶 前端入门基础/110. 👣 前端基础辅助/50. 🅱️ Bootstrap 使用笔记.md",key:"v-586acead",path:"/pages/17c13a/",headers:[{level:2,title:"引入 Bootstrap",slug:"引入-bootstrap",normalizedTitle:"引入 bootstrap",charIndex:2},{level:2,title:"容器 Container",slug:"容器-container",normalizedTitle:"容器 container",charIndex:1216},{level:3,title:".container",slug:"container",normalizedTitle:".container",charIndex:1257},{level:3,title:".container-fluid 流式布局",slug:"container-fluid-流式布局",normalizedTitle:".container-fluid 流式布局",charIndex:1386},{level:2,title:"栅格布局 Grid",slug:"栅格布局-grid",normalizedTitle:"栅格布局 grid",charIndex:1507},{level:3,title:"自动布局列",slug:"自动布局列",normalizedTitle:"自动布局列",charIndex:1929},{level:4,title:"等宽布局",slug:"等宽布局",normalizedTitle:"等宽布局",charIndex:1938},{level:4,title:"设置列宽度",slug:"设置列宽度",normalizedTitle:"设置列宽度",charIndex:2158},{level:4,title:"可变宽度的弹性空间",slug:"可变宽度的弹性空间",normalizedTitle:"可变宽度的弹性空间",charIndex:2697},{level:4,title:"等宽列多行",slug:"等宽列多行",normalizedTitle:"等宽列多行",charIndex:3302},{level:3,title:"响应式类选择器",slug:"响应式类选择器",normalizedTitle:"响应式类选择器",charIndex:3625},{level:4,title:"覆盖所有设备",slug:"覆盖所有设备",normalizedTitle:"覆盖所有设备",charIndex:4045},{level:4,title:"水平堆砌",slug:"水平堆砌",normalizedTitle:"水平堆砌",charIndex:4368},{level:4,title:"混合布局",slug:"混合布局",normalizedTitle:"混合布局",charIndex:4697},{level:3,title:"对齐",slug:"对齐",normalizedTitle:"对齐",charIndex:5155},{level:4,title:"行列布局",slug:"行列布局",normalizedTitle:"行列布局",charIndex:5161},{level:4,title:"垂直对齐",slug:"垂直对齐",normalizedTitle:"垂直对齐",charIndex:6047},{level:4,title:"水平对齐",slug:"水平对齐",normalizedTitle:"水平对齐",charIndex:7288},{level:3,title:"列排序 order",slug:"列排序-order",normalizedTitle:"列排序 order",charIndex:7503},{level:3,title:"列偏移 offset",slug:"列偏移-offset",normalizedTitle:"列偏移 offset",charIndex:8418},{level:3,title:"列嵌套",slug:"列嵌套",normalizedTitle:"列嵌套",charIndex:8696},{level:3,title:"Margin 和 Padding",slug:"margin-和-padding",normalizedTitle:"margin 和 padding",charIndex:9112},{level:2,title:"内容 Content",slug:"内容-content",normalizedTitle:"内容 content",charIndex:9293},{level:3,title:"CSS 重置 Reboot",slug:"css-重置-reboot",normalizedTitle:"css 重置 reboot",charIndex:9308},{level:3,title:"排版 Typograhpy",slug:"排版-typograhpy",normalizedTitle:"排版 typograhpy",charIndex:9370},{level:3,title:"代码 Codes",slug:"代码-codes",normalizedTitle:"代码 codes",charIndex:11280},{level:3,title:"图片 Images",slug:"图片-images",normalizedTitle:"图片 images",charIndex:11746},{level:4,title:"响应式图片",slug:"响应式图片",normalizedTitle:"响应式图片",charIndex:11759},{level:4,title:"缩略图",slug:"缩略图",normalizedTitle:"缩略图",charIndex:11936},{level:4,title:"图片对齐",slug:"图片对齐",normalizedTitle:"图片对齐",charIndex:11981},{level:4,title:"picture元素",slug:"picture元素",normalizedTitle:"picture 元素",charIndex:12264},{level:3,title:"表格 Tables",slug:"表格-tables",normalizedTitle:"表格 tables",charIndex:12565},{level:4,title:"基本样式",slug:"基本样式",normalizedTitle:"基本样式",charIndex:12622},{level:4,title:"表头样式",slug:"表头样式",normalizedTitle:"表头样式",charIndex:12715},{level:4,title:"条纹表格样式",slug:"条纹表格样式",normalizedTitle:"条纹表格样式",charIndex:12782},{level:4,title:"表格边框",slug:"表格边框",normalizedTitle:"表格边框",charIndex:12836},{level:4,title:"表格状态",slug:"表格状态",normalizedTitle:"表格状态",charIndex:12886},{level:4,title:"行悬停效果",slug:"行悬停效果",normalizedTitle:"行悬停效果",charIndex:13067},{level:4,title:"紧缩表格",slug:"紧缩表格",normalizedTitle:"紧缩表格",charIndex:13089},{level:4,title:"响应式表格",slug:"响应式表格",normalizedTitle:"响应式表格",charIndex:13138},{level:3,title:"图文内容 Figures",slug:"图文内容-figures",normalizedTitle:"图文内容 figures",charIndex:13256}],headersStr:"引入 Bootstrap 容器 Container .container .container-fluid 流式布局 栅格布局 Grid 自动布局列 等宽布局 设置列宽度 可变宽度的弹性空间 等宽列多行 响应式类选择器 覆盖所有设备 水平堆砌 混合布局 对齐 行列布局 垂直对齐 水平对齐 列排序 order 列偏移 offset 列嵌套 Margin 和 Padding 内容 Content CSS 重置 Reboot 排版 Typograhpy 代码 Codes 图片 Images 响应式图片 缩略图 图片对齐 picture元素 表格 Tables 基本样式 表头样式 条纹表格样式 表格边框 表格状态 行悬停效果 紧缩表格 响应式表格 图文内容 Figures",content:'# 引入 Bootstrap\n\n * 通过包管理工具下载 *(不包括文档，但是包含了完整的编译系统和说明文件)：\n\n$ npm install bootstrap\n\n$ gem install bootstrap -v  4.2.1\n\n\n1\n2\n3\n\n\n * 在 HTML 中使用 CDN 引入：Bootstrap 官方 CDN 源\n\n * 在 HTML 中使用已下载好的目录文件：\n   \n   (使用模版)\n   \n   <!DOCTYPE html>\n   <html lang="en">\n   \t<head>\n           <meta charset="utf-8">\n           \x3c!-- X-UA-Compatible 设置兼容模式--\x3e\n           <meta http-equiv="X-UA-Compatible" content="IE=edge">\n           <meta name="viewport" content="width=device-width, initial-scale=1.0">\n       \t<title>Bootstrap EXAMPLE</title>\n       \n           \x3c!-- CSS ONLY --\x3e\n       \t<link href="css/bootstrap.min.css" rel="stylesheet">\n   \t</head>\n   \t<body>\n           <h1>Hello, world!</h1>\n           \n           \x3c!-- jQuery --\x3e\n           <script src="js/jquery-3.4.1.js"><\/script>\n           \x3c!-- Bootstrp.min.js　--\x3e\n           <script src="js/bootstrap.min.js"><\/script>\n   \t</body>\n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   * viewport 标记指定用户是否可以缩放页面， width 、 height 标记指示视区的宽度和高度（ device-width 、 device-height 表示设备的屏幕高度和宽度）， initial-scale=1 设置 Web 页面的初始缩放比例， 1.0 表示不缩放；\n   * 要使用 Bootstrap 中的 JavaScript 插件需要先引入 jQuery；\n\n\n# 容器 Container\n\n容器是窗口布局的最基本元素，我们推荐所有样式都定义在 .container 或 .container-fluid 容器之中；\n\n\n# .container\n\n用于固定宽度并支持响应式布局，网页两侧留白的布局；\n\n<div class="container">\n  ...\n</div>\n\n\n1\n2\n3\n\n\n\n# .container-fluid 流式布局\n\n用于 100% 宽度，占据全部 viewport 的容器，网页两侧不留白的布局；\n\n<div class="container-fluid">\n  ...\n</div>\n\n\n1\n2\n3\n\n\n\n# 栅格布局 Grid\n\n * Bootstrap 提供一套响应式、移动设备优先的流式栅格系统，随着屏幕或 viewport 尺寸的增加，系统会自动分为最多 12 列。\n * 用于通过一系列的行 row 与列 column 的组合来创建页面布局，内容放入这些创建好的布局中；\n * 网格系统就是将容器平分成 12 份；\n\n注意：\n\n * 行 row 必须要被包含在 .container 容器或者 .container-fluid 容器；\n * 具体的内容放在列容器 column 内；\n * .col-屏幕尺寸-列数\n   * 屏幕尺寸参数：\n   * xs (xsmall phones) 超小屏 (自动)；\n   * sm (small tablets) 小屏 (750px)；\n   * md (middle desktops) 中屏 (970px)；\n   * lg (larger desktops) 大屏 (1170px)；\n\n\n# 自动布局列\n\n# 等宽布局\n\n简单使用 .col 布局内容，在所有设备上都是等宽并占满一行；\n\n<div class="container">\n  <div class="row">\n    <div class="col">\n      1 of 2\n    </div>\n    <div class="col">\n      2 of 2\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# 设置列宽度\n\n在一行多列的情况下，设置一个列的占用宽度，同时其他列自动调整大小：\n\n\n\n<div class="container">\n  <div class="row">\n    <div class="col">\n      1 of 3\n    </div>\n    <div class="col-6">\n      2 of 3 (更宽-12格中占6格，其它6格另外两列平分)\n    </div>\n    <div class="col">\n      3 of 3\n    </div>\n  </div>\n  <div class="row">\n    <div class="col">\n      1 of 3\n    </div>\n    <div class="col-5">\n      2 of 3 (更宽-12格中占5格,其它7格另外两列平分-不论奇偶都能达成)\n    </div>\n    <div class="col">\n      3 of 3\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 可变宽度的弹性空间\n\n实现根据列中的内容的自然宽度进行列的大小调整：\n\n\n\n<div class="container">\n  <div class="row justify-content-md-center">\n    <div class="col col-lg-2">\n      1 of 3\n    </div>\n    <div class="col-md-auto">\n      Variable width content\n    </div>\n    <div class="col col-lg-2">\n      3 of 3\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<div class="container">\n  <div class="row">\n    <div class="col">\n      1 of 3\n    </div>\n    <div class="col-md-auto">\n      Variable width content\n    </div>\n    <div class="col col-lg-2">\n      3 of 3\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 等宽列多行\n\n跨多个行的等宽列可以使用插入 .w-100 拆分（ .w-100 还可以影响一些显示状态效果 https://getbootstrap.net/docs/4.0/utilities/display/）\n\n(使用 .clearfix 的效果也可)\n\n\n\n<div class="row">\n  <div class="col">col</div>\n  <div class="col">col</div>\n  <div class="w-100"></div>\n  <div class="col">col</div>\n  <div class="col">col</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 响应式类选择器\n\n可以根据屏幕尺寸大小定义样式， Bootstrap 包括了 5 种尺寸的与定义样式：\n\n                  超小屏幕          小屏幕        中等屏幕       大屏幕        超大屏幕\n                  <576PX        ≥576PX     ≥768PX     ≥992PX     ≥1200PX\n.container 最大宽度   None (auto)   540px      720px      960px      1140px\n类前缀               .col-         .col-sm-   .col-md-   .col-lg-   .col-xl-\n\n * 一个 row 的最大列 column 数都为 12 ；\n * 列之间的间隙为 30px，（每列两侧各 15px）；\n * 都可嵌套、可排序；\n\n# 覆盖所有设备\n\n一次性定义所有设备可以直接使用 .col ， .col-* 指定特定大小（占据的列数，不得超过 12）：\n\n\n\n<div class="row">\n  <div class="col">col</div>\n  <div class="col">col</div>\n  <div class="col">col</div>\n  <div class="col">col</div>\n</div>\n<div class="row">\n  <div class="col-8">col-8</div>\n  <div class="col-4">col-4</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 水平堆砌\n\n对于流行的移动设备屏幕，可以使用 col-sm-* 。随着屏幕宽度变窄，会自动成为每列与行、水平堆砌：\n\n在大屏幕:\n\n在小屏幕\n\n<div class="row">\n  <div class="col-sm-8">col-sm-8</div>\n  <div class="col-sm-4">col-sm-4</div>\n</div>\n<div class="row">\n  <div class="col-sm">col-sm</div>\n  <div class="col-sm">col-sm</div>\n  <div class="col-sm">col-sm</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 混合布局\n\n适应在各个屏幕下的布局，对每一个列进行不同的设备定义：\n\n\n\n\n\n\x3c!-- 定义在超小屏幕下1列全宽、1列半宽，而其它场景以8:4比例并行排列 --\x3e\n<div class="row">\n  <div class="col-12 col-md-8">.col-12 .col-md-8</div>\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\x3c!-- 在超小屏幕半宽，其他场景3等分--\x3e\n<div class="row">\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 对齐\n\n# 行列布局\n\n使用 .row-col–* 定义一行可以放的列数，并且支持不同的断点（ .col-* 、 .col-md-4 ）。该属性写在 .row 空间中。\n\n每行显示两列： row-col-2\n\n\n\n<div class="container">\n  <div class="row row-cols-2">\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当一行放的列数超出了定义的列数时，自动换到下一行：\n\n\n\n<div class="container">\n  <div class="row row-cols-3">\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n适应各种屏幕：\n\n在超窄屏幕显示为每行只有一列，小屏幕为每行两列，中等屏幕为每行四列：\n\n<div class="container">\n  <div class="row row-cols-1 row-cols-sm-2 row-cols-md-4">\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n    <div class="col">Column</div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 垂直对齐\n\n在 .row 空间中使用 .align-items-* ：\n\n * 上边对齐： align-items-start ；\n   \n   \n   \n    <div class="row align-items-start">\n       <div class="col"> One of three columns</div>\n       <div class="col">One of three columns</div>\n       <div class="col">One of three columns</div>\n     </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 上下居中对齐： align-items-center :\n   \n   \n   \n   <div class="row align-items-center">\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 下边对齐： align-items-end ：\n   \n   \n   \n   <div class="row align-items-end">\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n在 .col 空间中使用 align-self-* ：\n\n\n\n<div class="container">\n  <div class="row">\n    <div class="col align-self-start">\n      One of three columns\n    </div>\n    <div class="col align-self-center">\n      One of three columns\n    </div>\n    <div class="col align-self-end">\n      One of three columns\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 水平对齐\n\n在 .row 空间使用 .justify-content-*\n\n * 向左对齐： justify-content-start\n\n * 居中对齐： justify-content-center\n\n * 向右对齐： justify-content-end\n\n * 间隔相等对齐： justify-content-around\n\n * 两端对齐贴齐： justify-content-between\n   \n   \n\n\n# 列排序 order\n\n使用 .order-* 选择器，对列进行重新可视化的排序，Bootstrap 提供 .order-1 到 .order-12 12 个级别的顺序，在五种预设宽度中都生效：\n\n * 对于未定义顺序的列，不会受到定义了顺序的列的影响：\n   \n   \n   \n   <div class="container">\n     <div class="row">\n       <div class="col">\n   \t\tone of three colomns\n       </div>\n       <div class="col order-12">\n   \t\tone of three colomns\n       </div>\n       <div class="col order-1">\n   \t\tone of three colomns\n       </div>\n     </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 使用 .order-first ，快速更改一个顺序到最前面：\n   \n   \n   \n   <div class="container">\n     <div class="row">\n       <div class="col">\n   \t\tone of three colomns\n       </div>\n       <div class="col">\n   \t\tone of three colomns\n       </div>\n       <div class="col order-first">\n   \t\tone of three colomns\n       </div>\n     </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 列偏移 offset\n\n * 使用 .offset-* 偏移：\n   \n   \n   \n   <div class="row">\n     <div class="col-md-4">.col-md-4</div>\n     <div class="col-md-4 offset-md-4">.col-md-4 .offset-md-4</div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 使用边界处理 .ml-* 、 .mr-* 、 p-* 等（ margin 、 padding ）偏移；\n\n\n# 列嵌套\n\n通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-* 元素内。被嵌套的行 row 所包含的列 column 数量推荐不要超过 12 个。\n\n\n\n<div class="row">\n  <div class="col-sm-9">\n    Level 1: .col-sm-9\n    <div class="row">\n      <div class="col-8 col-sm-6">\n        Level 2: .col-8 .col-sm-6\n      </div>\n      <div class="col-4 col-sm-6">\n        Level 2: .col-4 .col-sm-6\n      </div>\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Margin 和 Padding\n\nBootstrap 可以使用 margin 和 padding CSS 函数控制元素和组建的间隔和大小，基于单位 rem （对于选择所有的视口， .mr-3 对应 margin-right: 1rem ）（以针对特定的视口（例如， .mr-md-3 对于 margin-right: 1rem 处于起步 md 断点）\n\n\n# 内容 Content\n\n\n# CSS 重置 Reboot\n\nReboot · Bootstrap v5.1 (getbootstrap.com)\n\n\n# 排版 Typograhpy\n\nTypography · Bootstrap v5.1 (getbootstrap.com)\n\n * 标题 <h1> … </h1>\n\n * 显式标题 .display-*\n\n * 中心内容 .lead\n\n * 内联元素：\n   \n   * <mark> … </mark> / .mark\n   * <small> … </small> / .small\n   * <s> … </s> / .text-decoration-line-through 划去文本\n   * <u> … </u> / .text-decoration-underline 下划线\n\n * 文本使用程序 Text・Bootstrap v5.1 (getbootstrap.com)：可更改文本对齐，变换，样式，权重，颜色 Colors · Bootstrap v5.1 (getbootstrap.com)；\n\n * 来源备注和引用 <blockquote class="blockquote">… </blockquote>\n   \n   底部备注来源 <footer class="blockquote-footer"> 用于标识来源，一般用于页脚（所以有 *-footer )，然后配合 <cite> 使用。\n\n文本对齐：\n\n * 居中 .text-center\n * 居右 .text-right\n\n列表：\n\n * 列表样式初始化 .list-unstyled ，只生效于在直接子列表项目上，不影响你嵌套的子列表；\n\n * 列表单行多列并排：用 .list-inline 和 .list-inline-item 搭配：\n   \n   <ul class="list-inline">\n     <li class="list-inline-item">list item</li>\n     <li class="list-inline-item">list item</li>\n     <li class="list-inline-item">list item</li>\n   </ul>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\ndl 描述列表：\n\n * 对于较长的条目，你可以视情况添加一个 .text-truncate 类，从而用省略号截断文本。\n   \n   \n\n<dl class="row">\n    <dt class="col-sm-3">Euismod</dt>\n  <dd class="col-sm-9">\n    <p>Vestibulum id ligula porta felis euismod semper eget lacinia odio sem nec elit.</p>\n    <p>Donec id elit non mi porta gravida at eget metus.</p>\n  </dd>\n\n  <dt class="col-sm-3">Malesuada porta</dt>\n  <dd class="col-sm-9">Etiam porta sem malesuada magna mollis euismod.</dd>\n\n  <dt class="col-sm-3 text-truncate">Truncated term is truncated</dt>\n  <dd class="col-sm-9">Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.</dd>\n\n  <dt class="col-sm-3">Nesting</dt>\n  <dd class="col-sm-9">\n    <dl class="row">\n      <dt class="col-sm-4">Nested definition list</dt>\n      <dd class="col-sm-8">Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc.</dd>\n    </dl>\n  </dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 代码 Codes\n\n * 内联代码片段： <code> </code>\n   \n   * 注意： HTML 尖括号需要转义： <code>&lt;section&gt;</code> ；\n\n * 代码块： <pre> … </pre>\n   \n   * 使用 .pre-scrollable 提供垂直滚动效果（默认 350px 高度限制）\n   \n   <pre>\n   <code>&lt;p&gt;Sample text here...&lt;/p&gt;\n   &lt;p&gt;And another line of sample text here...&lt;/p&gt;\n   </code>\n   </pre>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 变量： <var> a </var>\n\n * 键盘动作（键盘输入操作） <kbd> </kbd> ：\n   \n   * cmd + q\n\n * 代码实例： <samp> codes example </samp>\n\n\n# 图片 Images\n\n# 响应式图片\n\n * 添加 .img-fluid 或者 定义 max-width: 100%; height:auto; 样式，图片被赋予响应式的特性，图片大小随着父元素的代销同步缩放；\n   \n   <img src="..." class="img-fluid" alt="Responsive image">\n   \n   \n   1\n   \n\n# 缩略图\n\n使用 .img-thumbnail 获得样式： 带圆角的 1px 边框；\n\n# 图片对齐\n\n * .float-left 向左浮动、 .float-right 向右浮动；\n\n * 居中（浮动定义规范）：\n   \n   <img src="..." class="rounded mx-auto d-block" alt="...">\n   \n   \n   1\n   \n   \n   或者（文字对齐规范）：\n   \n   <div class="text-center">\n     <img src="..." class="rounded" alt="...">\n   </div>\n   \n   \n   1\n   2\n   3\n   \n\n# picture 元素\n\n利用 HTML5 新特性， <picture> … </picture> 实现图片在不同屏幕下的针对性响应式：\n\n<picture>\n  <source src="大规格图片.jpg"  media="(min-width: 800px)" >\n  <source src="中规格图片.jpg"  media="(min-width: 600px)">\n  <source src="小规格图片.jpg">\n  <img src="通用图片.jpg" alt="这是当浏览器不支持picture标签时显示的图片">\n</picture>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 表格 Tables\n\nTables · Bootstrap v5.1 (getbootstrap.com)\n\n# 基本样式\n\nBootstrap 基本表格样式： .table ：（使用该类选择器意味着任何嵌套的表格标签都采用该样式）\n\n\n\n.table-dark ：提供暗色模式的表格样式\n\n\n\n# 表头样式\n\n * 浅灰 .thead-light ；\n   \n   \n\n * 深色 .thead-dark ；\n   \n   \n\n# 条纹表格样式\n\n * .table-striped\n\n\n\n与 .table-dark 配合使用：\n\n\n\n# 表格边框\n\n.table-bordered\n\n\n\n与 .table-dark 配合使用：\n\n\n\n# 表格状态\n\n（与 Bootstrap 预设颜色表对应）可应用在 表格行 <tr> 或者 特定单元格 <td> 、 <th> ；\n\n\n\n * .table-defalut ；\n * .table-primary ;\n * … 以此类推；\n\n对于深色模式的表格，不适用以上的颜色，可以通过背景通用样式（ bg-* 实现）：\n\n * bg-primary 等；\n\n# 行悬停效果\n\ntable-hover\n\n# 紧缩表格\n\n.table-sm ：将表格的 padding 减缩，使表格更加紧凑；\n\n\n\n\n\n# 响应式表格\n\n当表格要在多屏幕上始终呈现水平滚动效果，可在 .table 的基础上加上 .table-responsive 获得响应式表现。（也可使用 table-responsive{-sm|-md|-lg|-xl} 定义）\n\n\n# 图文内容 Figures\n\nFigures · Bootstrap v5.1 (getbootstrap.com)\n\n.figure 与 .figure-caption 用于需要显示图片与文本描述（标题），适用于 HTML5 新增的特性：（由于默认的图片不会定义明确大小，所以最好使用 img-figure 实现响应式样式）\n\n<figure class="figure">\n  <img src="..." class="figure-img img-fluid rounded" alt="...">\n  <figcaption class="figure-caption">A caption for the above image.</figcaption>\n</figure>\n\n\n1\n2\n3\n4\n\n\n文本描述的对齐方式可以使用 .text-* 通用文本使用工具实现：\n\n<figure class="figure">\n  <img src="..." class="figure-img img-fluid rounded" alt="...">\n  <figcaption class="figure-caption text-right">A caption for the above image.</figcaption>\n</figure>\n\n\n1\n2\n3\n4\n',normalizedContent:'# 引入 bootstrap\n\n * 通过包管理工具下载 *(不包括文档，但是包含了完整的编译系统和说明文件)：\n\n$ npm install bootstrap\n\n$ gem install bootstrap -v  4.2.1\n\n\n1\n2\n3\n\n\n * 在 html 中使用 cdn 引入：bootstrap 官方 cdn 源\n\n * 在 html 中使用已下载好的目录文件：\n   \n   (使用模版)\n   \n   <!doctype html>\n   <html lang="en">\n   \t<head>\n           <meta charset="utf-8">\n           \x3c!-- x-ua-compatible 设置兼容模式--\x3e\n           <meta http-equiv="x-ua-compatible" content="ie=edge">\n           <meta name="viewport" content="width=device-width, initial-scale=1.0">\n       \t<title>bootstrap example</title>\n       \n           \x3c!-- css only --\x3e\n       \t<link href="css/bootstrap.min.css" rel="stylesheet">\n   \t</head>\n   \t<body>\n           <h1>hello, world!</h1>\n           \n           \x3c!-- jquery --\x3e\n           <script src="js/jquery-3.4.1.js"><\/script>\n           \x3c!-- bootstrp.min.js　--\x3e\n           <script src="js/bootstrap.min.js"><\/script>\n   \t</body>\n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   * viewport 标记指定用户是否可以缩放页面， width 、 height 标记指示视区的宽度和高度（ device-width 、 device-height 表示设备的屏幕高度和宽度）， initial-scale=1 设置 web 页面的初始缩放比例， 1.0 表示不缩放；\n   * 要使用 bootstrap 中的 javascript 插件需要先引入 jquery；\n\n\n# 容器 container\n\n容器是窗口布局的最基本元素，我们推荐所有样式都定义在 .container 或 .container-fluid 容器之中；\n\n\n# .container\n\n用于固定宽度并支持响应式布局，网页两侧留白的布局；\n\n<div class="container">\n  ...\n</div>\n\n\n1\n2\n3\n\n\n\n# .container-fluid 流式布局\n\n用于 100% 宽度，占据全部 viewport 的容器，网页两侧不留白的布局；\n\n<div class="container-fluid">\n  ...\n</div>\n\n\n1\n2\n3\n\n\n\n# 栅格布局 grid\n\n * bootstrap 提供一套响应式、移动设备优先的流式栅格系统，随着屏幕或 viewport 尺寸的增加，系统会自动分为最多 12 列。\n * 用于通过一系列的行 row 与列 column 的组合来创建页面布局，内容放入这些创建好的布局中；\n * 网格系统就是将容器平分成 12 份；\n\n注意：\n\n * 行 row 必须要被包含在 .container 容器或者 .container-fluid 容器；\n * 具体的内容放在列容器 column 内；\n * .col-屏幕尺寸-列数\n   * 屏幕尺寸参数：\n   * xs (xsmall phones) 超小屏 (自动)；\n   * sm (small tablets) 小屏 (750px)；\n   * md (middle desktops) 中屏 (970px)；\n   * lg (larger desktops) 大屏 (1170px)；\n\n\n# 自动布局列\n\n# 等宽布局\n\n简单使用 .col 布局内容，在所有设备上都是等宽并占满一行；\n\n<div class="container">\n  <div class="row">\n    <div class="col">\n      1 of 2\n    </div>\n    <div class="col">\n      2 of 2\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# 设置列宽度\n\n在一行多列的情况下，设置一个列的占用宽度，同时其他列自动调整大小：\n\n\n\n<div class="container">\n  <div class="row">\n    <div class="col">\n      1 of 3\n    </div>\n    <div class="col-6">\n      2 of 3 (更宽-12格中占6格，其它6格另外两列平分)\n    </div>\n    <div class="col">\n      3 of 3\n    </div>\n  </div>\n  <div class="row">\n    <div class="col">\n      1 of 3\n    </div>\n    <div class="col-5">\n      2 of 3 (更宽-12格中占5格,其它7格另外两列平分-不论奇偶都能达成)\n    </div>\n    <div class="col">\n      3 of 3\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 可变宽度的弹性空间\n\n实现根据列中的内容的自然宽度进行列的大小调整：\n\n\n\n<div class="container">\n  <div class="row justify-content-md-center">\n    <div class="col col-lg-2">\n      1 of 3\n    </div>\n    <div class="col-md-auto">\n      variable width content\n    </div>\n    <div class="col col-lg-2">\n      3 of 3\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<div class="container">\n  <div class="row">\n    <div class="col">\n      1 of 3\n    </div>\n    <div class="col-md-auto">\n      variable width content\n    </div>\n    <div class="col col-lg-2">\n      3 of 3\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 等宽列多行\n\n跨多个行的等宽列可以使用插入 .w-100 拆分（ .w-100 还可以影响一些显示状态效果 https://getbootstrap.net/docs/4.0/utilities/display/）\n\n(使用 .clearfix 的效果也可)\n\n\n\n<div class="row">\n  <div class="col">col</div>\n  <div class="col">col</div>\n  <div class="w-100"></div>\n  <div class="col">col</div>\n  <div class="col">col</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 响应式类选择器\n\n可以根据屏幕尺寸大小定义样式， bootstrap 包括了 5 种尺寸的与定义样式：\n\n                  超小屏幕          小屏幕        中等屏幕       大屏幕        超大屏幕\n                  <576px        ≥576px     ≥768px     ≥992px     ≥1200px\n.container 最大宽度   none (auto)   540px      720px      960px      1140px\n类前缀               .col-         .col-sm-   .col-md-   .col-lg-   .col-xl-\n\n * 一个 row 的最大列 column 数都为 12 ；\n * 列之间的间隙为 30px，（每列两侧各 15px）；\n * 都可嵌套、可排序；\n\n# 覆盖所有设备\n\n一次性定义所有设备可以直接使用 .col ， .col-* 指定特定大小（占据的列数，不得超过 12）：\n\n\n\n<div class="row">\n  <div class="col">col</div>\n  <div class="col">col</div>\n  <div class="col">col</div>\n  <div class="col">col</div>\n</div>\n<div class="row">\n  <div class="col-8">col-8</div>\n  <div class="col-4">col-4</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 水平堆砌\n\n对于流行的移动设备屏幕，可以使用 col-sm-* 。随着屏幕宽度变窄，会自动成为每列与行、水平堆砌：\n\n在大屏幕:\n\n在小屏幕\n\n<div class="row">\n  <div class="col-sm-8">col-sm-8</div>\n  <div class="col-sm-4">col-sm-4</div>\n</div>\n<div class="row">\n  <div class="col-sm">col-sm</div>\n  <div class="col-sm">col-sm</div>\n  <div class="col-sm">col-sm</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 混合布局\n\n适应在各个屏幕下的布局，对每一个列进行不同的设备定义：\n\n\n\n\n\n\x3c!-- 定义在超小屏幕下1列全宽、1列半宽，而其它场景以8:4比例并行排列 --\x3e\n<div class="row">\n  <div class="col-12 col-md-8">.col-12 .col-md-8</div>\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\x3c!-- 在超小屏幕半宽，其他场景3等分--\x3e\n<div class="row">\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n  <div class="col-6 col-md-4">.col-6 .col-md-4</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 对齐\n\n# 行列布局\n\n使用 .row-col–* 定义一行可以放的列数，并且支持不同的断点（ .col-* 、 .col-md-4 ）。该属性写在 .row 空间中。\n\n每行显示两列： row-col-2\n\n\n\n<div class="container">\n  <div class="row row-cols-2">\n    <div class="col">column</div>\n    <div class="col">column</div>\n    <div class="col">column</div>\n    <div class="col">column</div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当一行放的列数超出了定义的列数时，自动换到下一行：\n\n\n\n<div class="container">\n  <div class="row row-cols-3">\n    <div class="col">column</div>\n    <div class="col">column</div>\n    <div class="col">column</div>\n    <div class="col">column</div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n适应各种屏幕：\n\n在超窄屏幕显示为每行只有一列，小屏幕为每行两列，中等屏幕为每行四列：\n\n<div class="container">\n  <div class="row row-cols-1 row-cols-sm-2 row-cols-md-4">\n    <div class="col">column</div>\n    <div class="col">column</div>\n    <div class="col">column</div>\n    <div class="col">column</div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 垂直对齐\n\n在 .row 空间中使用 .align-items-* ：\n\n * 上边对齐： align-items-start ；\n   \n   \n   \n    <div class="row align-items-start">\n       <div class="col"> one of three columns</div>\n       <div class="col">one of three columns</div>\n       <div class="col">one of three columns</div>\n     </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 上下居中对齐： align-items-center :\n   \n   \n   \n   <div class="row align-items-center">\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 下边对齐： align-items-end ：\n   \n   \n   \n   <div class="row align-items-end">\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n     <div class="col"> one of three columns </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n在 .col 空间中使用 align-self-* ：\n\n\n\n<div class="container">\n  <div class="row">\n    <div class="col align-self-start">\n      one of three columns\n    </div>\n    <div class="col align-self-center">\n      one of three columns\n    </div>\n    <div class="col align-self-end">\n      one of three columns\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 水平对齐\n\n在 .row 空间使用 .justify-content-*\n\n * 向左对齐： justify-content-start\n\n * 居中对齐： justify-content-center\n\n * 向右对齐： justify-content-end\n\n * 间隔相等对齐： justify-content-around\n\n * 两端对齐贴齐： justify-content-between\n   \n   \n\n\n# 列排序 order\n\n使用 .order-* 选择器，对列进行重新可视化的排序，bootstrap 提供 .order-1 到 .order-12 12 个级别的顺序，在五种预设宽度中都生效：\n\n * 对于未定义顺序的列，不会受到定义了顺序的列的影响：\n   \n   \n   \n   <div class="container">\n     <div class="row">\n       <div class="col">\n   \t\tone of three colomns\n       </div>\n       <div class="col order-12">\n   \t\tone of three colomns\n       </div>\n       <div class="col order-1">\n   \t\tone of three colomns\n       </div>\n     </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 使用 .order-first ，快速更改一个顺序到最前面：\n   \n   \n   \n   <div class="container">\n     <div class="row">\n       <div class="col">\n   \t\tone of three colomns\n       </div>\n       <div class="col">\n   \t\tone of three colomns\n       </div>\n       <div class="col order-first">\n   \t\tone of three colomns\n       </div>\n     </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 列偏移 offset\n\n * 使用 .offset-* 偏移：\n   \n   \n   \n   <div class="row">\n     <div class="col-md-4">.col-md-4</div>\n     <div class="col-md-4 offset-md-4">.col-md-4 .offset-md-4</div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 使用边界处理 .ml-* 、 .mr-* 、 p-* 等（ margin 、 padding ）偏移；\n\n\n# 列嵌套\n\n通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-* 元素内。被嵌套的行 row 所包含的列 column 数量推荐不要超过 12 个。\n\n\n\n<div class="row">\n  <div class="col-sm-9">\n    level 1: .col-sm-9\n    <div class="row">\n      <div class="col-8 col-sm-6">\n        level 2: .col-8 .col-sm-6\n      </div>\n      <div class="col-4 col-sm-6">\n        level 2: .col-4 .col-sm-6\n      </div>\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# margin 和 padding\n\nbootstrap 可以使用 margin 和 padding css 函数控制元素和组建的间隔和大小，基于单位 rem （对于选择所有的视口， .mr-3 对应 margin-right: 1rem ）（以针对特定的视口（例如， .mr-md-3 对于 margin-right: 1rem 处于起步 md 断点）\n\n\n# 内容 content\n\n\n# css 重置 reboot\n\nreboot · bootstrap v5.1 (getbootstrap.com)\n\n\n# 排版 typograhpy\n\ntypography · bootstrap v5.1 (getbootstrap.com)\n\n * 标题 <h1> … </h1>\n\n * 显式标题 .display-*\n\n * 中心内容 .lead\n\n * 内联元素：\n   \n   * <mark> … </mark> / .mark\n   * <small> … </small> / .small\n   * <s> … </s> / .text-decoration-line-through 划去文本\n   * <u> … </u> / .text-decoration-underline 下划线\n\n * 文本使用程序 text・bootstrap v5.1 (getbootstrap.com)：可更改文本对齐，变换，样式，权重，颜色 colors · bootstrap v5.1 (getbootstrap.com)；\n\n * 来源备注和引用 <blockquote class="blockquote">… </blockquote>\n   \n   底部备注来源 <footer class="blockquote-footer"> 用于标识来源，一般用于页脚（所以有 *-footer )，然后配合 <cite> 使用。\n\n文本对齐：\n\n * 居中 .text-center\n * 居右 .text-right\n\n列表：\n\n * 列表样式初始化 .list-unstyled ，只生效于在直接子列表项目上，不影响你嵌套的子列表；\n\n * 列表单行多列并排：用 .list-inline 和 .list-inline-item 搭配：\n   \n   <ul class="list-inline">\n     <li class="list-inline-item">list item</li>\n     <li class="list-inline-item">list item</li>\n     <li class="list-inline-item">list item</li>\n   </ul>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\ndl 描述列表：\n\n * 对于较长的条目，你可以视情况添加一个 .text-truncate 类，从而用省略号截断文本。\n   \n   \n\n<dl class="row">\n    <dt class="col-sm-3">euismod</dt>\n  <dd class="col-sm-9">\n    <p>vestibulum id ligula porta felis euismod semper eget lacinia odio sem nec elit.</p>\n    <p>donec id elit non mi porta gravida at eget metus.</p>\n  </dd>\n\n  <dt class="col-sm-3">malesuada porta</dt>\n  <dd class="col-sm-9">etiam porta sem malesuada magna mollis euismod.</dd>\n\n  <dt class="col-sm-3 text-truncate">truncated term is truncated</dt>\n  <dd class="col-sm-9">fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.</dd>\n\n  <dt class="col-sm-3">nesting</dt>\n  <dd class="col-sm-9">\n    <dl class="row">\n      <dt class="col-sm-4">nested definition list</dt>\n      <dd class="col-sm-8">aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc.</dd>\n    </dl>\n  </dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 代码 codes\n\n * 内联代码片段： <code> </code>\n   \n   * 注意： html 尖括号需要转义： <code>&lt;section&gt;</code> ；\n\n * 代码块： <pre> … </pre>\n   \n   * 使用 .pre-scrollable 提供垂直滚动效果（默认 350px 高度限制）\n   \n   <pre>\n   <code>&lt;p&gt;sample text here...&lt;/p&gt;\n   &lt;p&gt;and another line of sample text here...&lt;/p&gt;\n   </code>\n   </pre>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 变量： <var> a </var>\n\n * 键盘动作（键盘输入操作） <kbd> </kbd> ：\n   \n   * cmd + q\n\n * 代码实例： <samp> codes example </samp>\n\n\n# 图片 images\n\n# 响应式图片\n\n * 添加 .img-fluid 或者 定义 max-width: 100%; height:auto; 样式，图片被赋予响应式的特性，图片大小随着父元素的代销同步缩放；\n   \n   <img src="..." class="img-fluid" alt="responsive image">\n   \n   \n   1\n   \n\n# 缩略图\n\n使用 .img-thumbnail 获得样式： 带圆角的 1px 边框；\n\n# 图片对齐\n\n * .float-left 向左浮动、 .float-right 向右浮动；\n\n * 居中（浮动定义规范）：\n   \n   <img src="..." class="rounded mx-auto d-block" alt="...">\n   \n   \n   1\n   \n   \n   或者（文字对齐规范）：\n   \n   <div class="text-center">\n     <img src="..." class="rounded" alt="...">\n   </div>\n   \n   \n   1\n   2\n   3\n   \n\n# picture 元素\n\n利用 html5 新特性， <picture> … </picture> 实现图片在不同屏幕下的针对性响应式：\n\n<picture>\n  <source src="大规格图片.jpg"  media="(min-width: 800px)" >\n  <source src="中规格图片.jpg"  media="(min-width: 600px)">\n  <source src="小规格图片.jpg">\n  <img src="通用图片.jpg" alt="这是当浏览器不支持picture标签时显示的图片">\n</picture>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 表格 tables\n\ntables · bootstrap v5.1 (getbootstrap.com)\n\n# 基本样式\n\nbootstrap 基本表格样式： .table ：（使用该类选择器意味着任何嵌套的表格标签都采用该样式）\n\n\n\n.table-dark ：提供暗色模式的表格样式\n\n\n\n# 表头样式\n\n * 浅灰 .thead-light ；\n   \n   \n\n * 深色 .thead-dark ；\n   \n   \n\n# 条纹表格样式\n\n * .table-striped\n\n\n\n与 .table-dark 配合使用：\n\n\n\n# 表格边框\n\n.table-bordered\n\n\n\n与 .table-dark 配合使用：\n\n\n\n# 表格状态\n\n（与 bootstrap 预设颜色表对应）可应用在 表格行 <tr> 或者 特定单元格 <td> 、 <th> ；\n\n\n\n * .table-defalut ；\n * .table-primary ;\n * … 以此类推；\n\n对于深色模式的表格，不适用以上的颜色，可以通过背景通用样式（ bg-* 实现）：\n\n * bg-primary 等；\n\n# 行悬停效果\n\ntable-hover\n\n# 紧缩表格\n\n.table-sm ：将表格的 padding 减缩，使表格更加紧凑；\n\n\n\n\n\n# 响应式表格\n\n当表格要在多屏幕上始终呈现水平滚动效果，可在 .table 的基础上加上 .table-responsive 获得响应式表现。（也可使用 table-responsive{-sm|-md|-lg|-xl} 定义）\n\n\n# 图文内容 figures\n\nfigures · bootstrap v5.1 (getbootstrap.com)\n\n.figure 与 .figure-caption 用于需要显示图片与文本描述（标题），适用于 html5 新增的特性：（由于默认的图片不会定义明确大小，所以最好使用 img-figure 实现响应式样式）\n\n<figure class="figure">\n  <img src="..." class="figure-img img-fluid rounded" alt="...">\n  <figcaption class="figure-caption">a caption for the above image.</figcaption>\n</figure>\n\n\n1\n2\n3\n4\n\n\n文本描述的对齐方式可以使用 .text-* 通用文本使用工具实现：\n\n<figure class="figure">\n  <img src="..." class="figure-img img-fluid rounded" alt="...">\n  <figcaption class="figure-caption text-right">a caption for the above image.</figcaption>\n</figure>\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📖 CSS 基本语法",frontmatter:{title:"📖 CSS 基本语法",date:"2022-02-11T14:46:33.000Z",permalink:"/pages/7fb68c/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/01.%20%F0%9F%93%96%20CSS%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/01. 📖 CSS 基本语法.md",key:"v-2bfb06ae",path:"/pages/7fb68c/",headers:[{level:2,title:"CSS 基本语法",slug:"css-基本语法",normalizedTitle:"css 基本语法",charIndex:2},{level:3,title:"注释方法",slug:"注释方法",normalizedTitle:"注释方法",charIndex:182},{level:2,title:"创建 CSS",slug:"创建-css",normalizedTitle:"创建 css",charIndex:326},{level:3,title:"三个插入样式表的方法",slug:"三个插入样式表的方法",normalizedTitle:"三个插入样式表的方法",charIndex:337},{level:3,title:"多重样式的优先级",slug:"多重样式的优先级",normalizedTitle:"多重样式的优先级",charIndex:968}],headersStr:"CSS 基本语法 注释方法 创建 CSS 三个插入样式表的方法 多重样式的优先级",content:'# CSS 基本语法\n\nCSS 规则通常包含两部分： 选择器和一条或者多条声明；\n\n * 每条声明由一个属性和一个值组成；\n\n * 属性值和单位之间不能留有空格： 20px\n\n * 每条声明以分号 ; 结束；\n\n * 总声明以大括号 {} 包含；\n\np\n{\n  color:red;\n  text-align:center;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 注释方法\n\n使用斜杠➕星号的方法： /* example */\n\n/*这是个注释*/\np {\n  text-align: center;\n  /*这是另一个注释*/\n  color: black;\n  font-family: arial;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 创建 CSS\n\n\n# 三个插入样式表的方法\n\n * 外部样式表：\n   \n   在 HTML 文档的头部使用 <link> 标签引入：\n   \n   <head>\n   <link rel="stylesheet" type="text/css" href="mystyle.css">\n   </head>\n   \n   \n   1\n   2\n   3\n   \n\n * 内部样式表：\n   \n   同样在 HTML 文档中的头部，使用 <style> 标签定义内部样式表：\n   \n   <head>\n   <style>\n     hr { color: sienna; }\n     p { margin-left: 20px; }\n     body { background-image: url("images/back40.gif"); }\n   </style>\n   </head>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 内部样式 /inline style\n   \n   在相关的标签内使用 style 属性，可以包含任意的 CSS 属性；\n   \n   ⚠️： 内联样式将表现和内容混合，损失样式表的优势；仅当使用在一个元素应用一次；\n   \n   <p style="color:sienna;margin-left:20px">这是一个段落。</p>\n   \n   \n   1\n   \n\n\n# 多重样式的优先级\n\n当发生多个样式表以不同的方式创建时，优先级为：\n\n内联样式 Inline style > 内部样式 Internal style sheet > 外部样式 External style sheet > 浏览器默认样式\n\n🌰当外部样式表和内部样式表同时针对 h3 选择器声明样式时：\n\n/* 外部样式表 */\nh3 {\n  color:red;\n  text-align:left;\n  font-size:8pt;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n/* 内部样式表 */\nh3 {\n  text-align:right;\n  font-size:20pt;\n}\n\n\n1\n2\n3\n4\n5\n\n\n最终的得到的样式以内部样式表优先，并且结合外部样式表：\n\n{ \n  color:red;\n\ttext-align:right;\n\tfont-size:20pt;\n}\n\n\n1\n2\n3\n4\n5\n\n\nCSS 选择器权重关系\n\n内联样式 > id 选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 标签选择器 = 伪元素选择器\n\n⚠️【避免使用 important 】使用 !important 声明样式会覆盖任何其他的声明，改变了原来的规则；\n\n>  * Always 要优化考虑使用样式规则的优先级来解决问题而不是 !important 。\n>  * Only 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 !important 。\n>  * Never 永远不要在全站范围的 css 上使用 !important 。\n>  * Never 永远不要在你的插件中使用 !important 。\n\n\n\nfrom: www.standardista.com',normalizedContent:'# css 基本语法\n\ncss 规则通常包含两部分： 选择器和一条或者多条声明；\n\n * 每条声明由一个属性和一个值组成；\n\n * 属性值和单位之间不能留有空格： 20px\n\n * 每条声明以分号 ; 结束；\n\n * 总声明以大括号 {} 包含；\n\np\n{\n  color:red;\n  text-align:center;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 注释方法\n\n使用斜杠➕星号的方法： /* example */\n\n/*这是个注释*/\np {\n  text-align: center;\n  /*这是另一个注释*/\n  color: black;\n  font-family: arial;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 创建 css\n\n\n# 三个插入样式表的方法\n\n * 外部样式表：\n   \n   在 html 文档的头部使用 <link> 标签引入：\n   \n   <head>\n   <link rel="stylesheet" type="text/css" href="mystyle.css">\n   </head>\n   \n   \n   1\n   2\n   3\n   \n\n * 内部样式表：\n   \n   同样在 html 文档中的头部，使用 <style> 标签定义内部样式表：\n   \n   <head>\n   <style>\n     hr { color: sienna; }\n     p { margin-left: 20px; }\n     body { background-image: url("images/back40.gif"); }\n   </style>\n   </head>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 内部样式 /inline style\n   \n   在相关的标签内使用 style 属性，可以包含任意的 css 属性；\n   \n   ⚠️： 内联样式将表现和内容混合，损失样式表的优势；仅当使用在一个元素应用一次；\n   \n   <p style="color:sienna;margin-left:20px">这是一个段落。</p>\n   \n   \n   1\n   \n\n\n# 多重样式的优先级\n\n当发生多个样式表以不同的方式创建时，优先级为：\n\n内联样式 inline style > 内部样式 internal style sheet > 外部样式 external style sheet > 浏览器默认样式\n\n🌰当外部样式表和内部样式表同时针对 h3 选择器声明样式时：\n\n/* 外部样式表 */\nh3 {\n  color:red;\n  text-align:left;\n  font-size:8pt;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n/* 内部样式表 */\nh3 {\n  text-align:right;\n  font-size:20pt;\n}\n\n\n1\n2\n3\n4\n5\n\n\n最终的得到的样式以内部样式表优先，并且结合外部样式表：\n\n{ \n  color:red;\n\ttext-align:right;\n\tfont-size:20pt;\n}\n\n\n1\n2\n3\n4\n5\n\n\ncss 选择器权重关系\n\n内联样式 > id 选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 标签选择器 = 伪元素选择器\n\n⚠️【避免使用 important 】使用 !important 声明样式会覆盖任何其他的声明，改变了原来的规则；\n\n>  * always 要优化考虑使用样式规则的优先级来解决问题而不是 !important 。\n>  * only 只在需要覆盖全站或外部 css（例如引用的 extjs 或者 yui ）的特定页面中使用 !important 。\n>  * never 永远不要在全站范围的 css 上使用 !important 。\n>  * never 永远不要在你的插件中使用 !important 。\n\n\n\nfrom: www.standardista.com',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥽 CSS 单位",frontmatter:{title:"🥽 CSS 单位",date:"2022-06-10T16:10:13.000Z",permalink:"/pages/eb2dd9/",categories:["🚶 前端入门基础","🎨 CSS"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/02.%20%F0%9F%A5%BD%20CSS%20%E5%8D%95%E4%BD%8D.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/02. 🥽 CSS 单位.md",key:"v-65651d2c",path:"/pages/eb2dd9/",headers:[{level:3,title:"px",slug:"px",normalizedTitle:"px",charIndex:15},{level:3,title:"em",slug:"em",normalizedTitle:"em",charIndex:20},{level:3,title:"rem",slug:"rem",normalizedTitle:"rem",charIndex:25},{level:3,title:"vw & vh 视口长宽",slug:"vw-vh-视口长宽",normalizedTitle:"vw &amp; vh 视口长宽",charIndex:null},{level:3,title:"颜色单位",slug:"颜色单位",normalizedTitle:"颜色单位",charIndex:1107}],headersStr:"px em rem vw & vh 视口长宽 颜色单位",content:"五个常用的 CSS 单位有： px , em , rem , vw & vh , vmin & vmax ；\n\n\n# px\n\n是一个绝对单位，一个 px 表示一个像素点；\n\n> 通常使用 px 作为字体大小单位时，更改字体大小 font-size 同时需要更改行距大小 line-height ；\n\n\n# em\n\n是一个相对的单位，基于目前的容器大小根据 em 的值算出最终的大小；\n\n1em = <self>.font-size * 10\n\n字体大小和行距大小会根据 em 的值按比例缩放；\n\n🌰 例子 / CSS - em1 (codepen.io)：\n\nSee the Pen CSS - em1 by simon1uo (@simon1uo) on CodePen.\n\n🌰 例子 / CSS - em2 (codepen.io)：\n\nSee the Pen CSS - em2 by simon1uo (@simon1uo) on CodePen.\n\n🌰 例子 / CSS - em3 (codepen.io)：\n\nSee the Pen CSS - em3 by simon1uo (@simon1uo) on CodePen.\n\n\n# rem\n\n与 em 的功能类似，但 rem 基于的元素是 root 元素（ html ）；\n\n1rem = <root>.font-size * 10\n\n相比于 em 更加容易计算，避免 HTML 元素在多层嵌套之后难以预测大小；\n\n🌰 例子：\n\nSee the Pen CSS - rem by simon1uo (@simon1uo) on CodePen.\n\n\n# vw & vh 视口长宽\n\nviewport width 和 viewport height 的缩写：\n\n> viewport 指的目前浏览器窗口能看到的大小：\n\n所以 vw & vh 是根据（相对于）可视窗口的大小计算的大小。（可以理解为按照百分比，将可视窗口分为一百份。例如， 50 vw 为可视窗口的大小的一半尺寸）\n\n🌰 例子：\n\nSee the Pen CSS - vw&vh by simon1uo (@simon1uo) on CodePen.\n\nvmin & vmax\n\n表示 vw & vh 较小的值。\n\n例如， 50vmax 表示如果当前视口的宽度较大时，那么 vmax 会按照视口的宽度进行相对计算，为当前视口宽度的一半。\n\nSee the Pen CSS - vmax&vmin by simon1uo (@simon1uo) on CodePen.\n\n\n# 颜色单位\n\nRGB 值：RGB 通过三原色的不同浓度来调配出不同的颜色；\n\n> CSS 为什么采用光学三原色：\n> \n> 屏幕是由像素组成的，每个像素就是一个单位色块。而这个单位色块之所以能显示颜色，就是靠发光来实现的；光是由三种色光组成的，任何一种颜色均可以由这三种颜色调和出来的；\n\n * 语法： RGB(red, green, blue)\n * 范围：每一种颜色的范围在 0 ~ 255（0% ~ 100%）之间；\n\nRGBA 值：就是在 RGB 的基础上增加了一个 A 表示不透明度\n\n * 1 表示完全不透明\n\n * 0 表示完全透明\n\n * .5 半透明\n\nRGB 值的十六进制：\n\n * 语法： #RRGGBB\n * 范围：每一种颜色的范围在 00 ~ ff 之间",normalizedContent:"五个常用的 css 单位有： px , em , rem , vw & vh , vmin & vmax ；\n\n\n# px\n\n是一个绝对单位，一个 px 表示一个像素点；\n\n> 通常使用 px 作为字体大小单位时，更改字体大小 font-size 同时需要更改行距大小 line-height ；\n\n\n# em\n\n是一个相对的单位，基于目前的容器大小根据 em 的值算出最终的大小；\n\n1em = <self>.font-size * 10\n\n字体大小和行距大小会根据 em 的值按比例缩放；\n\n🌰 例子 / css - em1 (codepen.io)：\n\nsee the pen css - em1 by simon1uo (@simon1uo) on codepen.\n\n🌰 例子 / css - em2 (codepen.io)：\n\nsee the pen css - em2 by simon1uo (@simon1uo) on codepen.\n\n🌰 例子 / css - em3 (codepen.io)：\n\nsee the pen css - em3 by simon1uo (@simon1uo) on codepen.\n\n\n# rem\n\n与 em 的功能类似，但 rem 基于的元素是 root 元素（ html ）；\n\n1rem = <root>.font-size * 10\n\n相比于 em 更加容易计算，避免 html 元素在多层嵌套之后难以预测大小；\n\n🌰 例子：\n\nsee the pen css - rem by simon1uo (@simon1uo) on codepen.\n\n\n# vw & vh 视口长宽\n\nviewport width 和 viewport height 的缩写：\n\n> viewport 指的目前浏览器窗口能看到的大小：\n\n所以 vw & vh 是根据（相对于）可视窗口的大小计算的大小。（可以理解为按照百分比，将可视窗口分为一百份。例如， 50 vw 为可视窗口的大小的一半尺寸）\n\n🌰 例子：\n\nsee the pen css - vw&vh by simon1uo (@simon1uo) on codepen.\n\nvmin & vmax\n\n表示 vw & vh 较小的值。\n\n例如， 50vmax 表示如果当前视口的宽度较大时，那么 vmax 会按照视口的宽度进行相对计算，为当前视口宽度的一半。\n\nsee the pen css - vmax&vmin by simon1uo (@simon1uo) on codepen.\n\n\n# 颜色单位\n\nrgb 值：rgb 通过三原色的不同浓度来调配出不同的颜色；\n\n> css 为什么采用光学三原色：\n> \n> 屏幕是由像素组成的，每个像素就是一个单位色块。而这个单位色块之所以能显示颜色，就是靠发光来实现的；光是由三种色光组成的，任何一种颜色均可以由这三种颜色调和出来的；\n\n * 语法： rgb(red, green, blue)\n * 范围：每一种颜色的范围在 0 ~ 255（0% ~ 100%）之间；\n\nrgba 值：就是在 rgb 的基础上增加了一个 a 表示不透明度\n\n * 1 表示完全不透明\n\n * 0 表示完全透明\n\n * .5 半透明\n\nrgb 值的十六进制：\n\n * 语法： #rrggbb\n * 范围：每一种颜色的范围在 00 ~ ff 之间",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗃 CSS 弹性盒子模型",frontmatter:{title:"🗃 CSS 弹性盒子模型",date:"2022-02-11T15:30:40.000Z",permalink:"/pages/82c43f/",categories:["☕️Web编程笔记","🚶 基础部分","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/100.%20%F0%9F%97%83%20CSS%20%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/100. 🗃 CSS 弹性盒子模型.md",key:"v-7d17d9c4",path:"/pages/82c43f/",headers:[{level:2,title:"弹性盒",slug:"弹性盒",normalizedTitle:"弹性盒",charIndex:2},{level:3,title:"主轴属性",slug:"主轴属性",normalizedTitle:"主轴属性",charIndex:271},{level:3,title:"辅轴属性",slug:"辅轴属性",normalizedTitle:"辅轴属性",charIndex:974},{level:3,title:"伸缩属性",slug:"伸缩属性",normalizedTitle:"伸缩属性",charIndex:1410},{level:3,title:"基础长度",slug:"基础长度",normalizedTitle:"基础长度",charIndex:1596},{level:3,title:"简写属性",slug:"简写属性",normalizedTitle:"简写属性",charIndex:532},{level:3,title:"排列顺序",slug:"排列顺序",normalizedTitle:"排列顺序",charIndex:1881}],headersStr:"弹性盒 主轴属性 辅轴属性 伸缩属性 基础长度 简写属性 排列顺序",content:"# 弹性盒\n\nflex ：\n\n * 代替浮动完成页面布局；\n * 具有弹性，可以跟随页面的大小而改变；\n\n相关概念：\n\n弹性容器：\n\n使用 flex 布局，要通过 display 设置弹性容器：\n\n * display: flex ：设置为块级弹性容器；\n * display: inline-flex ：设置为行内的弹性容器；\n\n弹性元素：\n\n弹性容器的子元素是弹性元素（弹性项），弹性元素可以同时是弹性容器；\n\n弹性容器的属性：\n\n主轴与侧轴：\n\n * 主轴：弹性元素的排列方向称为主轴；\n * 侧轴：与主轴垂直方向的称为侧轴；\n\n\n# 主轴属性\n\n排列方式 flex-direction ：指定容器中弹性元素的排列方式：\n\n * row ：默认值，弹性元素在容器中水平排列（自左向右）\n\n * row-reverse ：弹性元素在容器中反向水平排列（自右向左）\n * column ：弹性元素纵向排列（自上向下）\n * column-reverse ：弹性元素反向纵向排列（自下向上）\n\n自动换行 flex-wrap ：设置弹性元素是否在弹性容器中自动换行：\n\n * nowrap 默认值，元素不会自动换行；\n\n * wrap 元素沿着辅轴方向自动换行；\n\n简写属性\n\nflex-flow ： wrap 和 direction 的简写属性：\n\n{\n\tflex-flow: row wrap;\n}\n\n\n1\n2\n3\n\n\n🌰 例子：\n\nSee the Pen\nflex-example-1 by simon1uo (@simon1uo)\non CodePen.\n\n\n分配空白\n\njustify-content 分配主轴上的空白空间（主轴的排列）：\n\nSee the Pen flex-example-4 by simon1uo (@simon1uo) on CodePen.\n * flex-start ：元素沿着主轴起边排列；\n\n\n\n * flex-end ：元素沿着主轴终边排列；\n   \n   \n\n * center ：元素居中排列；\n\n\n\n * space-around ：空白分布到元素两侧；\n\n\n\n * space-between ：空白均匀分布到元素间；\n\n\n\n * space-evenly ：空白分布到元素的单侧；\n\n\n\n\n# 辅轴属性\n\n辅轴的对齐：\nalign-items ：元素在辅轴上的对齐方式：\n\n * stretch 默认值，将元素的长度设置为相同的值；\n * flex-start 元素不会拉伸，沿着辅轴起边对齐；\n * flex-end 沿着辅轴的终边对齐；\n * base-line 基线对齐；\n\n分配空白：\n\nalign-content ：分配辅轴的空白空间：\n\n * 属性值与 justify-content 类似；\n\n覆盖辅轴：\n\nalign-self ：用来覆盖当前弹性元素上的 align-items 属性；\n\n🌰 辅轴属性：\n\nSee the Pen flex-example-5 by simon1uo (@simon1uo) on CodePen.\n\n弹性容器的居中\n\n{\n  display: flex;\n  justify-content: center;\n\talign-items: center;\n}\n\n\n1\n2\n3\n4\n5\n\n\n弹性元素的属性：\n\n\n# 伸缩属性\n\nflex-grow 指定弹性元素的伸展系数：\n\n * 父元素有多余的空间时，子元素如何伸展；\n * 剩余的空间按照比例（指定系数）进行分配；\n\nflex-shrink 指定弹性元素的收缩系数：\n\n * 当父元素中的空间不足以容纳所有的子元素时，如何对子元素进行收缩\n\n * 缩减系数的计算方式比较复杂，缩减多少是根据 缩减系数 和 元素大小 来计算；\n\n\n# 基础长度\n\nflex-basis 元素在主轴上的基本长度：\n\n * 如果主轴是横向的，则该值指定的就是元素的宽度；\n\n * 如果主轴是纵向的，则该值指定的就是元素的高度；\n\n * 默认值是 auto ，表示参考元素自身的高度或宽度；\n\n * 如果传递了一个具体的数值，则以该值为准；\n\n\n# 简写属性\n\nflex: 可以设置弹性元素所有的三个样式：增长、缩减、基础长度：\n\n * initial ： flex: 0 1 auto ；\n\n * auto ： flex: 1 1 auto ；\n\n * none ： flex: 0 0 auto 弹性元素没有弹性；\n\n\n# 排列顺序\n\n使用 order 设定决定弹性元素的排列顺序：\n\nSee the Pen flex-example-6 order by simon1uo (@simon1uo) on CodePen.",normalizedContent:"# 弹性盒\n\nflex ：\n\n * 代替浮动完成页面布局；\n * 具有弹性，可以跟随页面的大小而改变；\n\n相关概念：\n\n弹性容器：\n\n使用 flex 布局，要通过 display 设置弹性容器：\n\n * display: flex ：设置为块级弹性容器；\n * display: inline-flex ：设置为行内的弹性容器；\n\n弹性元素：\n\n弹性容器的子元素是弹性元素（弹性项），弹性元素可以同时是弹性容器；\n\n弹性容器的属性：\n\n主轴与侧轴：\n\n * 主轴：弹性元素的排列方向称为主轴；\n * 侧轴：与主轴垂直方向的称为侧轴；\n\n\n# 主轴属性\n\n排列方式 flex-direction ：指定容器中弹性元素的排列方式：\n\n * row ：默认值，弹性元素在容器中水平排列（自左向右）\n\n * row-reverse ：弹性元素在容器中反向水平排列（自右向左）\n * column ：弹性元素纵向排列（自上向下）\n * column-reverse ：弹性元素反向纵向排列（自下向上）\n\n自动换行 flex-wrap ：设置弹性元素是否在弹性容器中自动换行：\n\n * nowrap 默认值，元素不会自动换行；\n\n * wrap 元素沿着辅轴方向自动换行；\n\n简写属性\n\nflex-flow ： wrap 和 direction 的简写属性：\n\n{\n\tflex-flow: row wrap;\n}\n\n\n1\n2\n3\n\n\n🌰 例子：\n\nsee the pen\nflex-example-1 by simon1uo (@simon1uo)\non codepen.\n\n\n分配空白\n\njustify-content 分配主轴上的空白空间（主轴的排列）：\n\nsee the pen flex-example-4 by simon1uo (@simon1uo) on codepen.\n * flex-start ：元素沿着主轴起边排列；\n\n\n\n * flex-end ：元素沿着主轴终边排列；\n   \n   \n\n * center ：元素居中排列；\n\n\n\n * space-around ：空白分布到元素两侧；\n\n\n\n * space-between ：空白均匀分布到元素间；\n\n\n\n * space-evenly ：空白分布到元素的单侧；\n\n\n\n\n# 辅轴属性\n\n辅轴的对齐：\nalign-items ：元素在辅轴上的对齐方式：\n\n * stretch 默认值，将元素的长度设置为相同的值；\n * flex-start 元素不会拉伸，沿着辅轴起边对齐；\n * flex-end 沿着辅轴的终边对齐；\n * base-line 基线对齐；\n\n分配空白：\n\nalign-content ：分配辅轴的空白空间：\n\n * 属性值与 justify-content 类似；\n\n覆盖辅轴：\n\nalign-self ：用来覆盖当前弹性元素上的 align-items 属性；\n\n🌰 辅轴属性：\n\nsee the pen flex-example-5 by simon1uo (@simon1uo) on codepen.\n\n弹性容器的居中\n\n{\n  display: flex;\n  justify-content: center;\n\talign-items: center;\n}\n\n\n1\n2\n3\n4\n5\n\n\n弹性元素的属性：\n\n\n# 伸缩属性\n\nflex-grow 指定弹性元素的伸展系数：\n\n * 父元素有多余的空间时，子元素如何伸展；\n * 剩余的空间按照比例（指定系数）进行分配；\n\nflex-shrink 指定弹性元素的收缩系数：\n\n * 当父元素中的空间不足以容纳所有的子元素时，如何对子元素进行收缩\n\n * 缩减系数的计算方式比较复杂，缩减多少是根据 缩减系数 和 元素大小 来计算；\n\n\n# 基础长度\n\nflex-basis 元素在主轴上的基本长度：\n\n * 如果主轴是横向的，则该值指定的就是元素的宽度；\n\n * 如果主轴是纵向的，则该值指定的就是元素的高度；\n\n * 默认值是 auto ，表示参考元素自身的高度或宽度；\n\n * 如果传递了一个具体的数值，则以该值为准；\n\n\n# 简写属性\n\nflex: 可以设置弹性元素所有的三个样式：增长、缩减、基础长度：\n\n * initial ： flex: 0 1 auto ；\n\n * auto ： flex: 1 1 auto ；\n\n * none ： flex: 0 0 auto 弹性元素没有弹性；\n\n\n# 排列顺序\n\n使用 order 设定决定弹性元素的排列顺序：\n\nsee the pen flex-example-6 order by simon1uo (@simon1uo) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧾 CSS 列表布局示例",frontmatter:{title:"🧾 CSS 列表布局示例",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/8d9180/",categories:["🚶 前端入门基础","🎨 CSS","🪅 CSS 实用示例"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/110.%20%F0%9F%AA%85%20CSS%20%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B/10.%20%F0%9F%A7%BE%20CSS%20%E5%88%97%E8%A1%A8%E5%B8%83%E5%B1%80%E7%A4%BA%E4%BE%8B.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/10. 🧾 CSS 列表布局示例.md",key:"v-8458d62a",path:"/pages/8d9180/",headers:[{level:2,title:"1️⃣ 🖼 图片展示列表实例",slug:"🖼-图片展示列表实例",normalizedTitle:"1️⃣ 🖼 图片展示列表实例",charIndex:2},{level:3,title:"分析布局",slug:"分析布局",normalizedTitle:"分析布局",charIndex:22},{level:3,title:"基本结构",slug:"基本结构",normalizedTitle:"基本结构",charIndex:153},{level:3,title:"样式添加",slug:"样式添加",normalizedTitle:"样式添加",charIndex:430},{level:2,title:"2️⃣ 左侧商品分类导航栏列表",slug:"左侧商品分类导航栏列表",normalizedTitle:"2️⃣ 左侧商品分类导航栏列表",charIndex:1055},{level:3,title:"分析布局",slug:"分析布局-2",normalizedTitle:"分析布局",charIndex:22},{level:2,title:"3️⃣ 📰 新闻图片列表布局实例",slug:"新闻图片列表布局实例",normalizedTitle:"3️⃣ 📰 新闻图片列表布局实例",charIndex:1734}],headersStr:"1️⃣ 🖼 图片展示列表实例 分析布局 基本结构 样式添加 2️⃣ 左侧商品分类导航栏列表 分析布局 3️⃣ 📰 新闻图片列表布局实例",content:'# 1️⃣ 🖼 图片展示列表实例\n\n\n# 分析布局\n\n设定图片列表一般使用：\n\n<ul>\n  <li> pics </li>\n  <li> pics </li>\n  <li> pics </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n某些网站针对样式有定制会用 <div>-<li> 模式；\n\n\n# 基本结构\n\n<ul>\n  <li><a href="javascript:;"><img src="http://placekitten.com/400/300"></a></li>\n  <li><a href="javascript:;"><img src="http://placekitten.com/400/300"></a></li>\n  <li><a href="javascript:;"><img src="http://placekitten.com/400/300"></a></li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 样式添加\n\n方法 1：\n\nul {\n    width: 190px;\n    height: 470px;\n}\n\nul>li img{\n    /* \n    这里其实只调整高度即可，因为我们下载的图片宽高比跟F12中调试的是一致的\n    而且一般情况下，不会固定或修改图片在网页中显示的宽高比\n    因为如果我们随意调整css中的宽高比，会导致图片变形 \n    这里任意只调整高度或宽度，图片可以保持原比例大小\n    */\n    /* width: 190px; */\n    height: 150px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n方法 2：\n\nul>li img {\n    /* height: 150px; */\n    width: 100%;\n}\n\n\n1\n2\n3\n4\n\n\n100% 是会按照父元素计算的， img 的父元素是 a ， a 的父元素是 li ， li 的父元素是 ul 。没有给 a 和 li 单独设置样式，因此 img 最终会根据 ul 的宽度计算；\n\n而如果只调整图片的宽或高，图片是会保持原比例进行缩放的；所以这个时候就相当于给 img 设置了一个 width=190px 的属性值；\n\nSee the Pen css-example-1 picture-list by simon1uo (@simon1uo) on CodePen.\n\n\n# 2️⃣ 左侧商品分类导航栏列表\n\n\n# 分析布局\n\n * 整体使用 ul 和 li 元素；\n * li 中的每个元素：使用 a 包含文字超链接， span 包含斜杠\n\n存在问题\n\n * 多余的空格问题：\n   \n   在编写 HTML 代码时，每个 li 元素中的 a 的 span 标签都是换行的，而 HTML 中会将多个空格合并成一个，所以 a 的 span 之间都多了一个空格；\n   \n   解决方法：\n   \n   1. 调整 HTML 中的每一个 li 元素的代码，使之在一行；\n   2. 在样式表中给 ul 或者 li 元素设置 font-size: 0 ；\n   \n   ul>li {\n       height: 25px;\n       padding-left: 18px;\n       line-height: 25px;\n       /* 设置font-size */\n       font-size: 0;\n   }\n   \n   ul>li span {\n       /* 设置斜杠左右内边距 */\n       padding: 0 2px;\n       font-size: 12px;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\nSee the Pen css-example-2 nav-bar by simon1uo (@simon1uo) on CodePen.\n\n\n# 3️⃣ 📰 新闻图片列表布局实例\n\nSee the Pen css-example-3 news-list by simon1uo (@simon1uo) on CodePen.',normalizedContent:'# 1️⃣ 🖼 图片展示列表实例\n\n\n# 分析布局\n\n设定图片列表一般使用：\n\n<ul>\n  <li> pics </li>\n  <li> pics </li>\n  <li> pics </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n某些网站针对样式有定制会用 <div>-<li> 模式；\n\n\n# 基本结构\n\n<ul>\n  <li><a href="javascript:;"><img src="http://placekitten.com/400/300"></a></li>\n  <li><a href="javascript:;"><img src="http://placekitten.com/400/300"></a></li>\n  <li><a href="javascript:;"><img src="http://placekitten.com/400/300"></a></li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 样式添加\n\n方法 1：\n\nul {\n    width: 190px;\n    height: 470px;\n}\n\nul>li img{\n    /* \n    这里其实只调整高度即可，因为我们下载的图片宽高比跟f12中调试的是一致的\n    而且一般情况下，不会固定或修改图片在网页中显示的宽高比\n    因为如果我们随意调整css中的宽高比，会导致图片变形 \n    这里任意只调整高度或宽度，图片可以保持原比例大小\n    */\n    /* width: 190px; */\n    height: 150px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n方法 2：\n\nul>li img {\n    /* height: 150px; */\n    width: 100%;\n}\n\n\n1\n2\n3\n4\n\n\n100% 是会按照父元素计算的， img 的父元素是 a ， a 的父元素是 li ， li 的父元素是 ul 。没有给 a 和 li 单独设置样式，因此 img 最终会根据 ul 的宽度计算；\n\n而如果只调整图片的宽或高，图片是会保持原比例进行缩放的；所以这个时候就相当于给 img 设置了一个 width=190px 的属性值；\n\nsee the pen css-example-1 picture-list by simon1uo (@simon1uo) on codepen.\n\n\n# 2️⃣ 左侧商品分类导航栏列表\n\n\n# 分析布局\n\n * 整体使用 ul 和 li 元素；\n * li 中的每个元素：使用 a 包含文字超链接， span 包含斜杠\n\n存在问题\n\n * 多余的空格问题：\n   \n   在编写 html 代码时，每个 li 元素中的 a 的 span 标签都是换行的，而 html 中会将多个空格合并成一个，所以 a 的 span 之间都多了一个空格；\n   \n   解决方法：\n   \n   1. 调整 html 中的每一个 li 元素的代码，使之在一行；\n   2. 在样式表中给 ul 或者 li 元素设置 font-size: 0 ；\n   \n   ul>li {\n       height: 25px;\n       padding-left: 18px;\n       line-height: 25px;\n       /* 设置font-size */\n       font-size: 0;\n   }\n   \n   ul>li span {\n       /* 设置斜杠左右内边距 */\n       padding: 0 2px;\n       font-size: 12px;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\nsee the pen css-example-2 nav-bar by simon1uo (@simon1uo) on codepen.\n\n\n# 3️⃣ 📰 新闻图片列表布局实例\n\nsee the pen css-example-3 news-list by simon1uo (@simon1uo) on codepen.',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌬 CSS 浮动布局示例",frontmatter:{title:"🌬 CSS 浮动布局示例",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/a6e1ef/",categories:["🚶 前端入门基础","🎨 CSS","🪅 CSS 实用示例"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/110.%20%F0%9F%AA%85%20CSS%20%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B/20.%20%F0%9F%8C%AC%20CSS%20%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80%E7%A4%BA%E4%BE%8B.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/20. 🌬 CSS 浮动布局示例.md",key:"v-5c2e274a",path:"/pages/a6e1ef/",headers:[{level:2,title:"1️⃣ 网页布局实例",slug:"网页布局实例",normalizedTitle:"1️⃣ 网页布局实例",charIndex:2},{level:2,title:"2️⃣ 导航条实例",slug:"导航条实例",normalizedTitle:"2️⃣ 导航条实例",charIndex:75}],headersStr:"1️⃣ 网页布局实例 2️⃣ 导航条实例",content:"# 1️⃣ 网页布局实例\n\n🌰 codepen 地址：float-example-3 layout-test (codepen.io)\n\n\n\n\n# 2️⃣ 导航条实例\n\n🌰 codepen 地址：float-example-4 navbar (codepen.io)\n\n\n\n（新增 粘滞定位特性 position: sticky ）",normalizedContent:"# 1️⃣ 网页布局实例\n\n🌰 codepen 地址：float-example-3 layout-test (codepen.io)\n\n\n\n\n# 2️⃣ 导航条实例\n\n🌰 codepen 地址：float-example-4 navbar (codepen.io)\n\n\n\n（新增 粘滞定位特性 position: sticky ）",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚏 CSS 定位实例",frontmatter:{title:"🚏 CSS 定位实例",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/bf8c69/",categories:["🚶 前端入门基础","🎨 CSS","🪅 CSS 实用示例"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/110.%20%F0%9F%AA%85%20CSS%20%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B/30.%20%F0%9F%9A%8F%20CSS%20%E5%AE%9A%E4%BD%8D%E5%AE%9E%E4%BE%8B.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/30. 🚏 CSS 定位实例.md",key:"v-f3a6bcd4",path:"/pages/bf8c69/",headers:[{level:2,title:"1️⃣ 幻灯片轮播图实例",slug:"幻灯片轮播图实例",normalizedTitle:"1️⃣ 幻灯片轮播图实例",charIndex:2}],headersStr:"1️⃣ 幻灯片轮播图实例",content:"# 1️⃣ 幻灯片轮播图实例\n\n🌰 codepen 地址：position-example-5 picture (codepen.io)\n\n",normalizedContent:"# 1️⃣ 幻灯片轮播图实例\n\n🌰 codepen 地址：position-example-5 picture (codepen.io)\n\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📦 CSS 弹性盒布局实例",frontmatter:{title:"📦 CSS 弹性盒布局实例",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/8f342b/",categories:["🚶 前端入门基础","🎨 CSS","🪅 CSS 实用示例"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/110.%20%F0%9F%AA%85%20CSS%20%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B/40.%20%F0%9F%93%A6%20CSS%20%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E5%AE%9E%E4%BE%8B.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/40. 📦 CSS 弹性盒布局实例.md",key:"v-f80fbb16",path:"/pages/8f342b/",headers:[{level:3,title:"导航栏",slug:"导航栏",normalizedTitle:"导航栏",charIndex:2}],headersStr:"导航栏",content:"# 导航栏\n\n使用 display: flex 和伸展属性 flex-grow ，不用再设置每个项目的宽度，自适应分配宽度；\n\n🌰：flex-example-3 navbar update (codepen.io)\n\n",normalizedContent:"# 导航栏\n\n使用 display: flex 和伸展属性 flex-grow ，不用再设置每个项目的宽度，自适应分配宽度；\n\n🌰：flex-example-3 navbar update (codepen.io)\n\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"💙 使用 CSS 绘制图形",frontmatter:{title:"💙 使用 CSS 绘制图形",date:"2022-04-27T21:53:42.000Z",permalink:"/pages/508db5/",categories:["🚶 前端入门基础","🎨 CSS","🪅 CSS 实用示例"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/110.%20%F0%9F%AA%85%20CSS%20%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B/50.%20%F0%9F%92%99%20%E4%BD%BF%E7%94%A8%20CSS%20%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/50. 💙 使用 CSS 绘制图形.md",key:"v-943d629a",path:"/pages/508db5/",headers:[{level:2,title:"🌛 CSS 绘制月牙图形",slug:"🌛-css-绘制月牙图形",normalizedTitle:"🌛 css 绘制月牙图形",charIndex:2},{level:2,title:"❤️ CSS 绘制心形",slug:"❤️-css-绘制心形",normalizedTitle:"❤️ css 绘制心形",charIndex:404}],headersStr:"🌛 CSS 绘制月牙图形 ❤️ CSS 绘制心形",content:'# 🌛 CSS 绘制月牙图形\n\n<style>\n  .center {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    width: 100px;\n    height: 100px;\n    background-color: transparent;\n    border-radius: 50%;\n    box-shadow: 25px 10px 0 0 yellow;\n  }\n\n</style>\n<div class="center"></div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfrom: 应用视觉设计：使用 CSS 创建一个图形 | freeCodeCamp.org\n\n\n# ❤️ CSS 绘制心形\n\n<style>\n  .heart {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: pink;\n    height: 50px;\n    width: 50px;\n    transform: rotate(-45deg);\n  }\n  .heart::after {\n    background-color: pink;\n    content: "";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: 0px;\n    left: 25px;\n  }\n  .heart::before {\n    content: \'\';\n    background-color: pink;\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: -25px;\n    left: 0px;\n  }\n</style>\n<div class="heart"></div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nfrom：应用视觉设计：使用 CSS 和 HTML 创建更复杂的形状 | freeCodeCamp.org',normalizedContent:'# 🌛 css 绘制月牙图形\n\n<style>\n  .center {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    width: 100px;\n    height: 100px;\n    background-color: transparent;\n    border-radius: 50%;\n    box-shadow: 25px 10px 0 0 yellow;\n  }\n\n</style>\n<div class="center"></div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfrom: 应用视觉设计：使用 css 创建一个图形 | freecodecamp.org\n\n\n# ❤️ css 绘制心形\n\n<style>\n  .heart {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: pink;\n    height: 50px;\n    width: 50px;\n    transform: rotate(-45deg);\n  }\n  .heart::after {\n    background-color: pink;\n    content: "";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: 0px;\n    left: 25px;\n  }\n  .heart::before {\n    content: \'\';\n    background-color: pink;\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: -25px;\n    left: 0px;\n  }\n</style>\n<div class="heart"></div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nfrom：应用视觉设计：使用 css 和 html 创建更复杂的形状 | freecodecamp.org',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"❤️ CSS 动画示例",frontmatter:{title:"❤️ CSS 动画示例",date:"2022-04-27T21:53:42.000Z",permalink:"/pages/74c5a0/",categories:["🚶 前端入门基础","🎨 CSS","🪅 CSS 实用示例"],tags:[null]},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/110.%20%F0%9F%AA%85%20CSS%20%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B/60.%20%E2%9D%A4%EF%B8%8F%20CSS%20%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/110. 🪅 CSS 实用示例/60. ❤️ CSS 动画示例.md",key:"v-7aced672",path:"/pages/74c5a0/",headers:[{level:2,title:"❤️ 制作心跳动画",slug:"❤️-制作心跳动画",normalizedTitle:"❤️ 制作心跳动画",charIndex:2},{level:2,title:"✨ 两种方法调节动画的频率",slug:"✨-两种方法调节动画的频率",normalizedTitle:"✨ 两种方法调节动画的频率",charIndex:1435},{level:2,title:"🌊 曲线动画",slug:"🌊-曲线动画",normalizedTitle:"🌊 曲线动画",charIndex:1542}],headersStr:"❤️ 制作心跳动画 ✨ 两种方法调节动画的频率 🌊 曲线动画",content:'# ❤️ 制作心跳动画\n\n<html>\n  <div id="demoback"></div>\n\t<div id="heart"></div>\n</html>\n<style>\n  #demoback {\n    position: fixed;\n    padding: 0;\n    margin: 0;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: white;\n    animation-name: backdiv;\n    animation-duration: 1s;\n    animation-iteration-count: infinite;\n  }\n\n  #heart {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: pink;\n    height: 50px;\n    width: 50px;\n    transform: rotate(-45deg);\n    animation-name: beat;\n    animation-duration: 1s;\n    animation-iteration-count: infinite;\n  }\n  #heart:after {\n    background-color: pink;\n    content: "";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: 0px;\n    left: 25px;\n  }\n  #heart:before {\n    background-color: pink;\n    content: "";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: -25px;\n    left: 0px;\n  }\n\n  @keyframes backdiv {\n    50% {\n      background: #ffe6f2;\n    }\n  }\n\n  @keyframes beat {\n    0% {\n      transform: scale(1) rotate(-45deg);\n    }\n    50% {\n      transform: scale(0.6) rotate(-45deg);\n    }\n  }\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n\n# ✨ 两种方法调节动画的频率\n\n * 应用视觉设计：以可变速率来给元素添加动画 | freeCodeCamp.org\n * 应用视觉设计：以可变速率来给多个元素添加动画 | freeCodeCamp.org\n\n\n# 🌊 曲线动画\n\n * 应用视觉设计：使用关键字更改动画定时器 | freeCodeCamp.org\n * 应用视觉设计：学习贝塞尔曲线的原理 | freeCodeCamp.org\n * 应用视觉设计：使用贝塞尔曲线移动图形 | freeCodeCamp.org\n * 应用视觉设计：使用贝塞尔曲线让运动更加自然 | freeCodeCamp.org',normalizedContent:'# ❤️ 制作心跳动画\n\n<html>\n  <div id="demoback"></div>\n\t<div id="heart"></div>\n</html>\n<style>\n  #demoback {\n    position: fixed;\n    padding: 0;\n    margin: 0;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: white;\n    animation-name: backdiv;\n    animation-duration: 1s;\n    animation-iteration-count: infinite;\n  }\n\n  #heart {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: pink;\n    height: 50px;\n    width: 50px;\n    transform: rotate(-45deg);\n    animation-name: beat;\n    animation-duration: 1s;\n    animation-iteration-count: infinite;\n  }\n  #heart:after {\n    background-color: pink;\n    content: "";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: 0px;\n    left: 25px;\n  }\n  #heart:before {\n    background-color: pink;\n    content: "";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: -25px;\n    left: 0px;\n  }\n\n  @keyframes backdiv {\n    50% {\n      background: #ffe6f2;\n    }\n  }\n\n  @keyframes beat {\n    0% {\n      transform: scale(1) rotate(-45deg);\n    }\n    50% {\n      transform: scale(0.6) rotate(-45deg);\n    }\n  }\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n\n# ✨ 两种方法调节动画的频率\n\n * 应用视觉设计：以可变速率来给元素添加动画 | freecodecamp.org\n * 应用视觉设计：以可变速率来给多个元素添加动画 | freecodecamp.org\n\n\n# 🌊 曲线动画\n\n * 应用视觉设计：使用关键字更改动画定时器 | freecodecamp.org\n * 应用视觉设计：学习贝塞尔曲线的原理 | freecodecamp.org\n * 应用视觉设计：使用贝塞尔曲线移动图形 | freecodecamp.org\n * 应用视觉设计：使用贝塞尔曲线让运动更加自然 | freecodecamp.org',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🎮 CSS 选择器",frontmatter:{title:"🎮 CSS 选择器",date:"2022-02-11T14:51:49.000Z",permalink:"/pages/59c3c4/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/20.%20%F0%9F%8E%AE%20CSS%20%E9%80%89%E6%8B%A9%E5%99%A8.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/20. 🎮 CSS 选择器.md",key:"v-6e17c6b9",path:"/pages/59c3c4/",headers:[{level:2,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:2},{level:3,title:"通配选择器",slug:"通配选择器",normalizedTitle:"通配选择器",charIndex:10},{level:3,title:"元素选择器",slug:"元素选择器",normalizedTitle:"元素选择器",charIndex:89},{level:3,title:"id 选择器",slug:"id-选择器",normalizedTitle:"id 选择器",charIndex:181},{level:3,title:"class 选择器",slug:"class-选择器",normalizedTitle:"class 选择器",charIndex:362},{level:3,title:"属性选择器",slug:"属性选择器",normalizedTitle:"属性选择器",charIndex:744},{level:3,title:"复合选择器",slug:"复合选择器",normalizedTitle:"复合选择器",charIndex:1190},{level:3,title:"关系选择器",slug:"关系选择器",normalizedTitle:"关系选择器",charIndex:1545},{level:3,title:"伪类选择器",slug:"伪类选择器",normalizedTitle:"伪类选择器",charIndex:2253},{level:3,title:"伪元素选择器",slug:"伪元素选择器",normalizedTitle:"伪元素选择器",charIndex:2919}],headersStr:"选择器 通配选择器 元素选择器 id 选择器 class 选择器 属性选择器 复合选择器 关系选择器 伪类选择器 伪元素选择器",content:'# 选择器\n\n\n# 通配选择器\n\n使用 * ，选中 HTML 页面中所有的元素，将样式应用到所有的元素：\n\n* {  /* example style */}\n\n\n1\n\n\n\n# 元素选择器\n\n类型、标签选择器，根据标签名来选中指定的元素：\n\np {  /* 样式应用于所有的p标签 */}\nh1{  /* 样式应用于所有的h1标签 */}\n\n\n1\n2\n\n\n\n# id 选择器\n\nid 选择器可以为标有特定 id 的 HTML 元素指定特定的样式（一般只使用一次）；\n\nHTML 中元素使用 id 属性设置 id 选择器，在 CSS 中 使用 # 来定义：\n\n以下对应元素属性 id=“para1”\n\n#para1\n{\n  text-align:center;\n  color:red;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# class 选择器\n\n有别于 id 选择器，cclass 选择器用于描述一组元素的样式：\n\n * 可以重复使用；\n\n * 可以通过 class 属性来为元素分组；\n\n * 可以同时为一个元素指定多个 class 属性；\n   \n   HTML 中元素使用 class 属性设置 id 选择器，在 CSS 中 使用 . 来定义：\n\n<p class="center"> test para</p>\n\n\n1\n\n\n.center {\ttext-align:center;}\n\n\n1\n\n * 🌰 指定特定的 HTML 元素使用 class：\n\n所有的 p 元素使用 class="center" 让该元素的文本居中:\n\np.center{  text-align: center;}\n\n\n1\n\n\n⚠️命名注意：id 属性名称和 class 名称不能以数字开头；\n\n\n# 属性选择器\n\n可以根据元素的属性值选中一组元素：\n\n * 语法 1： [属性名] 选择含有指定属性的元素；\n\n * 语法 2： [属性名=属性值] 选择含有指定属性和属性值的元素；\n\n * 语法 3： [属性名^=属性值] 选择属性值以指定值开头的元素；\n\n * 语法 4： [属性名$=属性值] 选择属性值以指定值结尾的元素；\n\n * 语法 5： [属性名*=属性值] 选择属性值中含有某值的元素；\n\n * 🌰：\n\np[title]\n{\n  color: orange;\n}\n\np[title=e]\n{\n  color: orange;\n}\n\np[title^=e]\n{\n  color: orange;\n}\n\np[title$=e]\n{\n  color: orange;\n}\n\np[title*=e]\n{ \n  color: orange;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 复合选择器\n\n交集选择器：可同时复合多个条件的元素；\n\n * 语法： 元素选择器选择器1选择器2 { } ；\n\n * 注意：如果有元素选择器，必须元素选择器为开头；\n   \n   🌰：\n\n<div>  ...</div><div class="red">  </div>\n\n\n1\n\n\ndiv.red{  font-size: 30px;}\n.a.b.c{    color: blue;}\n\n\n1\n2\n\n\n并集选择器：同时选择多个选择器对应的元素；\n\n * 语法：使用 , 隔开： 选择器1,选择器2,选择器3,选择器n { } ；\n   \n   🌰：\n\n<h1> ... </h1><span> ... </span>\n\n\n1\n\n\nh1,span{    color: green;}\n\n\n1\n\n\n\n# 关系选择器\n\n子元素选择器 Child Combinator：选中指定父元素的指定子元素；（直接被父元素包含的元素是子元素）\n\n * 语法： 父元素 > 子元素 ；\n\n🌰 例子：\n\nSee the Pen child combinator by simon1uo (@siimon1uo) on CodePen.\n\n后代元素选择器 Descendant Combinator：选中指定元素内的指定后代元素；（直接或间接被祖先元素包含的元素叫做后代元素；子元素也是后代元素；）\n\n * 语法： 祖先 后代 ；\n\n🌰 例子：\n\nSee the Pen descendant combinator by simon1uo (@simon1uo) on CodePen.\n\n兄弟元素选择器 Sibling combinator：选择兄弟元素（拥有相同父元素的元素是兄弟元素）\n\n * 语法：\n   \n   相邻兄弟选择器： former_element + target_element { style properties } ：元素之间必须相邻，选中后一个元素；\n   \n   通用兄弟选择器：位置无须紧邻，只须同层级， A~B 选择 A 元素之后所有同层级 B 元素： former_element ~ target_element { style properties }\n   \n   🌰 例子 ： sibling combinator (codepen.io)\n\nSee the Pen sibling combinator by simon1uo (@simon1uo) on CodePen.\n\n\n# 伪类选择器\n\n伪类：不存在的类，特殊的类。使用于描述元素的特殊状态，如：第一个子元素、被点击的元素、鼠标移入的元素.…；伪类一般情况下都是使用 : 开头：\n\n> 根据子元素排序：\n> \n>  * :first-child 第一个子元素\n>  * :last-child 最后一个子元素\n>  * :nth-child() 选中第 n 个子元素\n>    * n：第 n 个，n 的范围 0 到正无穷\n>    * 2n 或 even：选中偶数位的元素\n>    * 2n+1 或 odd：选中奇数位的元素\n> \n> 根据同类型元素排序：\n> \n>  * :first-of-type 同类型中的第一个子元素\n>  * :last-of-type 同类型中的最后一个子元素\n>  * :nth-of-type() 选中同类型中的第 n 个子元素\n> \n> 特殊伪类：\n> \n>  * :not() 否定伪类，将符合条件的元素从选择器中去除；\n> \n>  * :link 未访问的链接\n> \n>  * :visited 已访问的链接（由于隐私的原因，所以 visited 这个伪类只能修改链接的颜色）\n> \n>  * :hover 鼠标悬停的链接\n> \n>  * :active 鼠标点击的链接\n> \n> 更多：伪类 - CSS（层叠样式表） | MDN (mozilla.org)\n\n🌰：例子：\n\nSee the Pen Pseudo-classes by simon1uo (@simon1uo) on CodePen.\n\n\n# 伪元素选择器\n\n伪元素：表示页面中一些特殊的并不真实的存在的元素（特殊的位置）；伪元素使用 :: 开头；\n\n>  * 必须结合 content 元素使用：\n>    \n>    * ::before 元素的开始\n>    * ::after 元素的最后\n> \n>  * ::first-letter 表示第一个字母\n> \n>  * ::first-line 表示第一行\n> \n>  * ::selection 表示选中的内容\n\n⭐️🎮 选择器复习用游戏：CSS Diner - Where we feast on CSS Selectors! (flukeout.github.io)',normalizedContent:'# 选择器\n\n\n# 通配选择器\n\n使用 * ，选中 html 页面中所有的元素，将样式应用到所有的元素：\n\n* {  /* example style */}\n\n\n1\n\n\n\n# 元素选择器\n\n类型、标签选择器，根据标签名来选中指定的元素：\n\np {  /* 样式应用于所有的p标签 */}\nh1{  /* 样式应用于所有的h1标签 */}\n\n\n1\n2\n\n\n\n# id 选择器\n\nid 选择器可以为标有特定 id 的 html 元素指定特定的样式（一般只使用一次）；\n\nhtml 中元素使用 id 属性设置 id 选择器，在 css 中 使用 # 来定义：\n\n以下对应元素属性 id=“para1”\n\n#para1\n{\n  text-align:center;\n  color:red;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# class 选择器\n\n有别于 id 选择器，cclass 选择器用于描述一组元素的样式：\n\n * 可以重复使用；\n\n * 可以通过 class 属性来为元素分组；\n\n * 可以同时为一个元素指定多个 class 属性；\n   \n   html 中元素使用 class 属性设置 id 选择器，在 css 中 使用 . 来定义：\n\n<p class="center"> test para</p>\n\n\n1\n\n\n.center {\ttext-align:center;}\n\n\n1\n\n * 🌰 指定特定的 html 元素使用 class：\n\n所有的 p 元素使用 class="center" 让该元素的文本居中:\n\np.center{  text-align: center;}\n\n\n1\n\n\n⚠️命名注意：id 属性名称和 class 名称不能以数字开头；\n\n\n# 属性选择器\n\n可以根据元素的属性值选中一组元素：\n\n * 语法 1： [属性名] 选择含有指定属性的元素；\n\n * 语法 2： [属性名=属性值] 选择含有指定属性和属性值的元素；\n\n * 语法 3： [属性名^=属性值] 选择属性值以指定值开头的元素；\n\n * 语法 4： [属性名$=属性值] 选择属性值以指定值结尾的元素；\n\n * 语法 5： [属性名*=属性值] 选择属性值中含有某值的元素；\n\n * 🌰：\n\np[title]\n{\n  color: orange;\n}\n\np[title=e]\n{\n  color: orange;\n}\n\np[title^=e]\n{\n  color: orange;\n}\n\np[title$=e]\n{\n  color: orange;\n}\n\np[title*=e]\n{ \n  color: orange;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 复合选择器\n\n交集选择器：可同时复合多个条件的元素；\n\n * 语法： 元素选择器选择器1选择器2 { } ；\n\n * 注意：如果有元素选择器，必须元素选择器为开头；\n   \n   🌰：\n\n<div>  ...</div><div class="red">  </div>\n\n\n1\n\n\ndiv.red{  font-size: 30px;}\n.a.b.c{    color: blue;}\n\n\n1\n2\n\n\n并集选择器：同时选择多个选择器对应的元素；\n\n * 语法：使用 , 隔开： 选择器1,选择器2,选择器3,选择器n { } ；\n   \n   🌰：\n\n<h1> ... </h1><span> ... </span>\n\n\n1\n\n\nh1,span{    color: green;}\n\n\n1\n\n\n\n# 关系选择器\n\n子元素选择器 child combinator：选中指定父元素的指定子元素；（直接被父元素包含的元素是子元素）\n\n * 语法： 父元素 > 子元素 ；\n\n🌰 例子：\n\nsee the pen child combinator by simon1uo (@siimon1uo) on codepen.\n\n后代元素选择器 descendant combinator：选中指定元素内的指定后代元素；（直接或间接被祖先元素包含的元素叫做后代元素；子元素也是后代元素；）\n\n * 语法： 祖先 后代 ；\n\n🌰 例子：\n\nsee the pen descendant combinator by simon1uo (@simon1uo) on codepen.\n\n兄弟元素选择器 sibling combinator：选择兄弟元素（拥有相同父元素的元素是兄弟元素）\n\n * 语法：\n   \n   相邻兄弟选择器： former_element + target_element { style properties } ：元素之间必须相邻，选中后一个元素；\n   \n   通用兄弟选择器：位置无须紧邻，只须同层级， a~b 选择 a 元素之后所有同层级 b 元素： former_element ~ target_element { style properties }\n   \n   🌰 例子 ： sibling combinator (codepen.io)\n\nsee the pen sibling combinator by simon1uo (@simon1uo) on codepen.\n\n\n# 伪类选择器\n\n伪类：不存在的类，特殊的类。使用于描述元素的特殊状态，如：第一个子元素、被点击的元素、鼠标移入的元素.…；伪类一般情况下都是使用 : 开头：\n\n> 根据子元素排序：\n> \n>  * :first-child 第一个子元素\n>  * :last-child 最后一个子元素\n>  * :nth-child() 选中第 n 个子元素\n>    * n：第 n 个，n 的范围 0 到正无穷\n>    * 2n 或 even：选中偶数位的元素\n>    * 2n+1 或 odd：选中奇数位的元素\n> \n> 根据同类型元素排序：\n> \n>  * :first-of-type 同类型中的第一个子元素\n>  * :last-of-type 同类型中的最后一个子元素\n>  * :nth-of-type() 选中同类型中的第 n 个子元素\n> \n> 特殊伪类：\n> \n>  * :not() 否定伪类，将符合条件的元素从选择器中去除；\n> \n>  * :link 未访问的链接\n> \n>  * :visited 已访问的链接（由于隐私的原因，所以 visited 这个伪类只能修改链接的颜色）\n> \n>  * :hover 鼠标悬停的链接\n> \n>  * :active 鼠标点击的链接\n> \n> 更多：伪类 - css（层叠样式表） | mdn (mozilla.org)\n\n🌰：例子：\n\nsee the pen pseudo-classes by simon1uo (@simon1uo) on codepen.\n\n\n# 伪元素选择器\n\n伪元素：表示页面中一些特殊的并不真实的存在的元素（特殊的位置）；伪元素使用 :: 开头；\n\n>  * 必须结合 content 元素使用：\n>    \n>    * ::before 元素的开始\n>    * ::after 元素的最后\n> \n>  * ::first-letter 表示第一个字母\n> \n>  * ::first-line 表示第一行\n> \n>  * ::selection 表示选中的内容\n\n⭐️🎮 选择器复习用游戏：css diner - where we feast on css selectors! (flukeout.github.io)',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🎁 CSS 盒子模型",frontmatter:{title:"🎁 CSS 盒子模型",date:"2022-02-11T15:10:22.000Z",permalink:"/pages/33f36d/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/30.%20%F0%9F%8E%81%20CSS%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/30. 🎁 CSS 盒子模型.md",key:"v-2a227a05",path:"/pages/33f36d/",headers:[{level:2,title:"盒子模型",slug:"盒子模型",normalizedTitle:"盒子模型",charIndex:2},{level:3,title:"内容区 Content",slug:"内容区-content",normalizedTitle:"内容区 content",charIndex:389},{level:3,title:"边框 Border",slug:"边框-border",normalizedTitle:"边框 border",charIndex:414},{level:3,title:"内边距 Padding",slug:"内边距-padding",normalizedTitle:"内边距 padding",charIndex:402},{level:3,title:"外边距 Margin",slug:"外边距-margin",normalizedTitle:"外边距 margin",charIndex:424},{level:3,title:"水平方向布局",slug:"水平方向布局",normalizedTitle:"水平方向布局",charIndex:2169},{level:3,title:"元素溢出",slug:"元素溢出",normalizedTitle:"元素溢出",charIndex:3705},{level:3,title:"边距折叠",slug:"边距折叠",normalizedTitle:"边距折叠",charIndex:4069},{level:3,title:"行内元素",slug:"行内元素",normalizedTitle:"行内元素",charIndex:198},{level:3,title:"浏览器的默认样式",slug:"浏览器的默认样式",normalizedTitle:"浏览器的默认样式",charIndex:5304},{level:3,title:"盒子模型补充概念",slug:"盒子模型补充概念",normalizedTitle:"盒子模型补充概念",charIndex:5956}],headersStr:"盒子模型 内容区 Content 边框 Border 内边距 Padding 外边距 Margin 水平方向布局 元素溢出 边距折叠 行内元素 浏览器的默认样式 盒子模型补充概念",content:'# 盒子模型\n\n文档流 Normalflow：HTML 网页所创建的元素默认在文档流中排序；\n\n * 元素的两个状态：在文档流中 / 不在文档流中；\n\n * 通过 CSS 为每一层网页结构设置样式，通常用户只能看到最顶层。\n\n块元素 Block Element：\n\n * 块元素会在页面中独占一行；\n\n * 默认宽度是父元素的全部（会把父元素撑满）；\n\n * 默认高度是被内容撑开（子元素）；\n\n行内元素 Inline Element：\n\n * 行内元素不会独占页面的一行，只占自身的大小；\n\n * 行内元素在页面中左向右水平排列；\n\n * 如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列；\n\n * 行内元素的默认宽度和高度都是被内容撑开；\n\n盒子模型 Box Model：\n\nCSS 盒子模型将页面的所有元素都设置为一个矩形的盒子，具备以下的部分： 内容区 Content、 内边距 Padding、边框 Border、外边距 Margin；\n\n\n\n\n# 内容区 Content\n\n是主要信息内容，元素中的所有子元素和文本内容都在内容区；\n\n设置排列内容区的大小：\n\n * width 设置内容区的宽度\n\n * height 设置内容区的高度\n\n\n# 边框 Border\n\n属于盒子的边缘，边框里属于盒子内部，边框外都是盒子外部；\n\n⚠️注意：边框的大小会影响整个盒子的大小；\n\n设置边框的属性：\n\n * border-width 边框的宽度：默认 3px\n\n * * border-top-width 上边框的宽度\n * * border-right-width 右边框的宽度\n * * border-bottom-width 下边框的宽度\n * * border-left-width 左边框的宽度\n\n * border-color 边框的颜色：默认使用 color 的颜色值\n   \n   * border-top-color 上边框的颜色\n   * border-right-color 右边框的颜色\n   * border-bottom-color 下边框的颜色\n   * border-left-color 左边框的颜色\n\n * border-style 边框的样式：没有默认值，必须指定；\n   \n   > solid 实线\n   > \n   > dotted 点状虚线\n   > \n   > dashed 虚线\n   > \n   > double 双线\n\n * * border-top-style 上边框的样式\n * * border-right-style 右边框的样式\n * * border-bottom-style 下边框的样式\n * * border-left-style 左边框的样式\n\n * border 简写属性，同时设置边框的所有相关属性，没有顺序要求：\n   \n   一般顺序是 宽度 颜色 样式 ；\n\n\n# 内边距 Padding\n\n也叫填充，是内容区和边框的空间：\n\n * padding-top 上内边距\n\n * padding-right 右内边距\n\n * padding-bottom 下内边距\n\n * padding-left 左内边距\n\n * padding 同时指定四个方向的内边距\n\n🌰 例子：\n\nSee the Pen box model-1 by simon1uo (@simon1uo) on CodePen.\n\n当内外的 div 盒子宽度和高度一样时， 由于 .outer 设置了 padding 属性，其盒子大小被撑大了；\n\n盒子可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算；\n\n\n# 外边距 Margin\n\n叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是 CSS 布局的一个重要手段；\n\n⚠️注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间；\n\n * margin-top 上外边距\n\n * * 设置正值，元素自身向下移动\n   * 设置负值，元素自身向上移动\n\n * margin-right 右外边距\n\n * * 设置正值，其右边的元素向右移动\n   * 设置负值，其右边的元素向左移动\n * * 对于块元素，设置 margin-right 不会产生任何效果\n\n * margin-bottom 下外边距\n\n * * 设置正值，其下边的元素向下移动\n * * 设置负值，其下边的元素向上移动\n * * 对于块元素，会有垂直方向上的边距重叠问题\n\n * margin-left 左外边距\n\n * * 设置正值，元素自身向右移动\n * * 设置负值，元素自身向左移动\n\n🌰 例子：\n\nSee the Pen box model-2 by simon1uo (@simon1uo) on CodePen.\n\n按照顺时针的方向和盒子对称，通过同时设置指定对应方向的宽度、颜色或样式：\n\n * 四个值： 上 右 下 左\n\n * 三个值： 上 左右 下\n\n * 两个值： 上下 左右\n\n * 一个值： 上下左右\n\n\n# 水平方向布局\n\n元素在水平方向的位置通过 左右内边距、左右边框、左右外边距、宽度决定；\n\n一个元素在其父元素中，水平布局必须要满足以下的等式：\n\n左外边距 + 左边框宽度 + 左内边距 + 内容宽度 + 右内边距 + 右边框宽度 + 右外边距 = 父元素的宽度 （ margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素的宽度 ）\n\n以上等式必须满足，当上述等式相加结果不成立，则有过度约束自动调整：\n\n * 如果这七个值中没有 auto 的情况，则浏览器会自动调整 margin-right 值以使等式满足\n   \n   100 + 0 + 0 + 200 + 0 + 0 + 0 = 800 ==>\n   \n   100 + 0 + 0 + 200 + 0 + 0 + 500 = 800\n\n * 如果这七个值中有 auto 的情况，则会自动调整 auto 值以使等式成立\n   左右外边距和宽度可以设置为 auto ： width 、 margin-left 、 margin-right ：\n   \n   * 如果某个值为 auto ，则会自动调整 auto 的那个值以使等式成立：\n     \n     200 + 0 + 0 + auto + 0 + 0 + 200 = 600 ==>\n     \n     200 + 0 + 0 + 400 + 0 + 0 + 200 = 800 ；\n     \n     auto + 0 + 0 + 200 + 0 + 0 + 200 = 600 ==>\n     \n     400 + 0 + 0 + 200 + 0 + 0 + 200 = 800 ；\n     \n     200 + 0 + 0 + 200 + 0 + 0 + auto = 600 ==>\n     \n     200 + 0 + 0 + 200 + 0 + 0 + 400 = 800 ；\n   \n   * 如果宽度为 auto ，则宽度会调整到最大，其他 auto 的外边距会自动设置为 0 ：\n     \n     auto + 0 + 0 + auto + 0 + 0 + 200 = 600 ==>\n     \n     0 + 0 + 0 + 600 + 0 + 0 + 200 = 800\n     \n     200 + 0 + 0 + auto + 0 + 0 + auto = 600 ==>\n     \n     200 + 0 + 0 + 600 + 0 + 0 + 0 = 800\n     \n     auto + 0 + 0 + auto + 0 + 0 + auto = 600 ==>\n     \n     0 + 0 + 0 + 800 + 0 + 0 + 0 = 800\n   \n   * 如果外边距都为 auto ，则 auto 的外边距会自动均分以使等式成立\n     \n     常用于水平居中： margin: 0 auto; /* 设置左右外边距为 auto */\n     \n     auto + 0 + 0 + 200 + 0 + 0 + auto = 600 ==>\n     \n     300 + 0 + 0 + 200 + 0 + 0 + 300 = 800\n\n🌰 例子 / 过度约束实现水平居中：\n\nSee the Pen box model-3 by simon1uo (@simon1uo) on CodePen.\n\n\n# 元素溢出\n\n子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出；\n\n * 使用 overflow / overflow-x / overflow-y 属性来设置父元素如何处理溢出的子元素；\n * 可选值： visible / hidden / scroll / auto ：\n   * visible 溢出内容会在父元素外部位置显示，默认值；\n   * hidden 溢出内容会被裁剪，不会显示；\n   * scroll 生成两个滚动条，通过滚动条来查看完整的内容；\n   * auto 根据需要生成滚动条；\n\n🌰 例子：\n\nSee the Pen box model-4 element overflow by simon1uo (@simon1uo) on CodePen.\n\n\n# 边距折叠\n\n垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象；\n\n对于兄弟元素：兄弟元素间的相邻，垂直外边距会取两者之间的较大值（两者都是正值）；兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理；\n\n> 特殊情况：\n> \n>  * 如果相邻的外边距一正一负，则取两者的和\n> \n>  * 如果相邻的外边距都是负值，则取两者中绝对值较大的\n\n对于父子元素：父子元素间相邻外边距，子元素会传递给父元素（上外边距）;\n\n父子外边距的折叠会影响到页面的布局，必须要进行处理：\n\n * 转换思路，将对子元素的调整转为对父元素的调整：\n   \n   子元素中的 margin-top 转化为父元素的 padding-top ，但是调整 padding 会影响元素的大小，所以需要手动计算调整父元素的高度 height ；\n\n * 仍然保留子元素的 margin-top 属性，但是给父元素加一个上边框 border-top ：\n   \n   但是因为增加了边框的宽度，所以需要手动调整父元素的高度 height ；同时子元素会因为仍相对于父元素调整的 margin-top 而下移，所以也需要调整 margin-top\n   \n   > 脱离文档流问题\n   > \n   > 上述父子元素的边距折叠问题中，父元素使用了 border 属性调整，就让子元素的外边距不传递给父元素了，这是导致 `\n\n🌰 例子：\n\nSee the Pen box model-5 by simon1uo (@simon1uo) on CodePen.\n\n\n# 行内元素\n\n * 行内元素不支持设定宽度 weight 、高度 height ；\n * 行内元素可以设置 border ，垂直方向的 border 不会影响页面的布局；\n * 行内元素可以设置 padding ，垂直方向 padding 不会影响页面的布局 ；\n * 行内元素可以设置 margin ，垂直方向的 margin 不会影响页面的布局 ；\n\n将行内元素修改为可以对页面布局产生影响，使用 dispaly 属性修改元素显示的类型：\n\n * inline 将元素设置为行内元素；\n * block 将元素设置为块元素；\n * inline-block 将元素设置为行内块元素行内块，既可以设置宽度和高度又不会独占一行 ；\n * table 将元素设置为一个表格；\n\n * none 元素不在页面中显示，但是不占位；\n   \n   visibility 用来设置元素的显示状态：\n   \n   * visible 默认值，元素在页面中正常显示；\n   \n   * hidden 元素在页面中隐藏不显示，但是依然占据页面的位置；\n\n🌰 例子：\n\nSee the Pen box model-6 inline element by simon1uo (@simon1uo) on CodePen.\n\n\n# 浏览器的默认样式\n\n通常情况，浏览器都会为元素设置一些默认样式；\n\n利用 CSS 重设： 先定义好一些 CSS 样式，来让所有浏览器都按照同样的规则解释 CSS，这样就能避免发生这种问题：\n\n * Reset 样式：引入外部样式表\n   \n   <link rel="stylesheet" href="assets/reset.css">\n   \n   \n   1\n   \n\n * Normalize 样式：将所有默认样式统一，这样在不同的浏览器里显示效果也是统一的：\n   \n   <link rel="stylesheet" href="assets/normalize.css">\n   \n   \n   1\n   \n\n * 更多的 CSS 重设方法：目前比较全的 CSS 重设 (reset) 方法总结 - 寒意 - 博客园 (cnblogs.com)\n\n> 🌟 关于 CSS Reset 那些事（一）之 历史演变与 Normalize.css - SegmentFault 思否\n> \n> 🌟 Normalize-ZH.css Alsiso/normalize-zh: Normalize.css 中文文档与源码解读 (github.com)\n> \n> 🌟 normalize.css 入门和下载 - SegmentFault 思否\n> \n> 🌟 在 codepen 中使用 Normalize 或者 Reset CSS 预设：进入 ⚙️ Pen Settings > CSS\n\n\n# 盒子模型补充概念\n\n盒子大小 box-sizing 用来设置盒子尺寸的计算方式，通过设置 width 和 height 作用；可选值：\n\n * content-box ： 默认值， width 和 height 设置内容区的大小；\n * border-box ： width 和 height 设置整个盒子可见框的大小；\n   * width 和 height 指的是内容区、内边距、边框的总大小；\n\n轮廓 outlne 用来设置元素的轮廓线，与 border 的作用一样，但是 outline 不会影响可见框的大小，即不会影响页面的布局；\n\n盒子阴影 box-shadow ：设置元素的阴影效果，阴影不会影响页面布局；\n\n * 第一个值：水平偏移量，设置阴影的水平位置\n   * 正值向右移动\n   * 负值向左移动\n * 第二个值：垂直偏移量，设置阴影的垂直位置\n   * 正值向下移动\n   * 负值向上移动\n * 第三个值：阴影的模糊半径\n * 第四个值：阴影的颜色\n\n🍞 阴影 CSS 参考：https://getcssscan.com/css-box-shadow-examples\n\n圆角 border-radius ：设置圆角，圆角设置的是圆的半径大小；\n\n * border-top-left-radius\n * border-top-right-radius\n * border-bottom-left-radius\n * border-bottom-right-radius\n\n圆：设置四个圆角半径为正方形宽的一半；\n\n🌰 例子：\n\nSee the Pen box model-7 box-sizing by simon1uo (@simon1uo) on CodePen.',normalizedContent:'# 盒子模型\n\n文档流 normalflow：html 网页所创建的元素默认在文档流中排序；\n\n * 元素的两个状态：在文档流中 / 不在文档流中；\n\n * 通过 css 为每一层网页结构设置样式，通常用户只能看到最顶层。\n\n块元素 block element：\n\n * 块元素会在页面中独占一行；\n\n * 默认宽度是父元素的全部（会把父元素撑满）；\n\n * 默认高度是被内容撑开（子元素）；\n\n行内元素 inline element：\n\n * 行内元素不会独占页面的一行，只占自身的大小；\n\n * 行内元素在页面中左向右水平排列；\n\n * 如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列；\n\n * 行内元素的默认宽度和高度都是被内容撑开；\n\n盒子模型 box model：\n\ncss 盒子模型将页面的所有元素都设置为一个矩形的盒子，具备以下的部分： 内容区 content、 内边距 padding、边框 border、外边距 margin；\n\n\n\n\n# 内容区 content\n\n是主要信息内容，元素中的所有子元素和文本内容都在内容区；\n\n设置排列内容区的大小：\n\n * width 设置内容区的宽度\n\n * height 设置内容区的高度\n\n\n# 边框 border\n\n属于盒子的边缘，边框里属于盒子内部，边框外都是盒子外部；\n\n⚠️注意：边框的大小会影响整个盒子的大小；\n\n设置边框的属性：\n\n * border-width 边框的宽度：默认 3px\n\n * * border-top-width 上边框的宽度\n * * border-right-width 右边框的宽度\n * * border-bottom-width 下边框的宽度\n * * border-left-width 左边框的宽度\n\n * border-color 边框的颜色：默认使用 color 的颜色值\n   \n   * border-top-color 上边框的颜色\n   * border-right-color 右边框的颜色\n   * border-bottom-color 下边框的颜色\n   * border-left-color 左边框的颜色\n\n * border-style 边框的样式：没有默认值，必须指定；\n   \n   > solid 实线\n   > \n   > dotted 点状虚线\n   > \n   > dashed 虚线\n   > \n   > double 双线\n\n * * border-top-style 上边框的样式\n * * border-right-style 右边框的样式\n * * border-bottom-style 下边框的样式\n * * border-left-style 左边框的样式\n\n * border 简写属性，同时设置边框的所有相关属性，没有顺序要求：\n   \n   一般顺序是 宽度 颜色 样式 ；\n\n\n# 内边距 padding\n\n也叫填充，是内容区和边框的空间：\n\n * padding-top 上内边距\n\n * padding-right 右内边距\n\n * padding-bottom 下内边距\n\n * padding-left 左内边距\n\n * padding 同时指定四个方向的内边距\n\n🌰 例子：\n\nsee the pen box model-1 by simon1uo (@simon1uo) on codepen.\n\n当内外的 div 盒子宽度和高度一样时， 由于 .outer 设置了 padding 属性，其盒子大小被撑大了；\n\n盒子可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算；\n\n\n# 外边距 margin\n\n叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是 css 布局的一个重要手段；\n\n⚠️注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间；\n\n * margin-top 上外边距\n\n * * 设置正值，元素自身向下移动\n   * 设置负值，元素自身向上移动\n\n * margin-right 右外边距\n\n * * 设置正值，其右边的元素向右移动\n   * 设置负值，其右边的元素向左移动\n * * 对于块元素，设置 margin-right 不会产生任何效果\n\n * margin-bottom 下外边距\n\n * * 设置正值，其下边的元素向下移动\n * * 设置负值，其下边的元素向上移动\n * * 对于块元素，会有垂直方向上的边距重叠问题\n\n * margin-left 左外边距\n\n * * 设置正值，元素自身向右移动\n * * 设置负值，元素自身向左移动\n\n🌰 例子：\n\nsee the pen box model-2 by simon1uo (@simon1uo) on codepen.\n\n按照顺时针的方向和盒子对称，通过同时设置指定对应方向的宽度、颜色或样式：\n\n * 四个值： 上 右 下 左\n\n * 三个值： 上 左右 下\n\n * 两个值： 上下 左右\n\n * 一个值： 上下左右\n\n\n# 水平方向布局\n\n元素在水平方向的位置通过 左右内边距、左右边框、左右外边距、宽度决定；\n\n一个元素在其父元素中，水平布局必须要满足以下的等式：\n\n左外边距 + 左边框宽度 + 左内边距 + 内容宽度 + 右内边距 + 右边框宽度 + 右外边距 = 父元素的宽度 （ margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素的宽度 ）\n\n以上等式必须满足，当上述等式相加结果不成立，则有过度约束自动调整：\n\n * 如果这七个值中没有 auto 的情况，则浏览器会自动调整 margin-right 值以使等式满足\n   \n   100 + 0 + 0 + 200 + 0 + 0 + 0 = 800 ==>\n   \n   100 + 0 + 0 + 200 + 0 + 0 + 500 = 800\n\n * 如果这七个值中有 auto 的情况，则会自动调整 auto 值以使等式成立\n   左右外边距和宽度可以设置为 auto ： width 、 margin-left 、 margin-right ：\n   \n   * 如果某个值为 auto ，则会自动调整 auto 的那个值以使等式成立：\n     \n     200 + 0 + 0 + auto + 0 + 0 + 200 = 600 ==>\n     \n     200 + 0 + 0 + 400 + 0 + 0 + 200 = 800 ；\n     \n     auto + 0 + 0 + 200 + 0 + 0 + 200 = 600 ==>\n     \n     400 + 0 + 0 + 200 + 0 + 0 + 200 = 800 ；\n     \n     200 + 0 + 0 + 200 + 0 + 0 + auto = 600 ==>\n     \n     200 + 0 + 0 + 200 + 0 + 0 + 400 = 800 ；\n   \n   * 如果宽度为 auto ，则宽度会调整到最大，其他 auto 的外边距会自动设置为 0 ：\n     \n     auto + 0 + 0 + auto + 0 + 0 + 200 = 600 ==>\n     \n     0 + 0 + 0 + 600 + 0 + 0 + 200 = 800\n     \n     200 + 0 + 0 + auto + 0 + 0 + auto = 600 ==>\n     \n     200 + 0 + 0 + 600 + 0 + 0 + 0 = 800\n     \n     auto + 0 + 0 + auto + 0 + 0 + auto = 600 ==>\n     \n     0 + 0 + 0 + 800 + 0 + 0 + 0 = 800\n   \n   * 如果外边距都为 auto ，则 auto 的外边距会自动均分以使等式成立\n     \n     常用于水平居中： margin: 0 auto; /* 设置左右外边距为 auto */\n     \n     auto + 0 + 0 + 200 + 0 + 0 + auto = 600 ==>\n     \n     300 + 0 + 0 + 200 + 0 + 0 + 300 = 800\n\n🌰 例子 / 过度约束实现水平居中：\n\nsee the pen box model-3 by simon1uo (@simon1uo) on codepen.\n\n\n# 元素溢出\n\n子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出；\n\n * 使用 overflow / overflow-x / overflow-y 属性来设置父元素如何处理溢出的子元素；\n * 可选值： visible / hidden / scroll / auto ：\n   * visible 溢出内容会在父元素外部位置显示，默认值；\n   * hidden 溢出内容会被裁剪，不会显示；\n   * scroll 生成两个滚动条，通过滚动条来查看完整的内容；\n   * auto 根据需要生成滚动条；\n\n🌰 例子：\n\nsee the pen box model-4 element overflow by simon1uo (@simon1uo) on codepen.\n\n\n# 边距折叠\n\n垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象；\n\n对于兄弟元素：兄弟元素间的相邻，垂直外边距会取两者之间的较大值（两者都是正值）；兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理；\n\n> 特殊情况：\n> \n>  * 如果相邻的外边距一正一负，则取两者的和\n> \n>  * 如果相邻的外边距都是负值，则取两者中绝对值较大的\n\n对于父子元素：父子元素间相邻外边距，子元素会传递给父元素（上外边距）;\n\n父子外边距的折叠会影响到页面的布局，必须要进行处理：\n\n * 转换思路，将对子元素的调整转为对父元素的调整：\n   \n   子元素中的 margin-top 转化为父元素的 padding-top ，但是调整 padding 会影响元素的大小，所以需要手动计算调整父元素的高度 height ；\n\n * 仍然保留子元素的 margin-top 属性，但是给父元素加一个上边框 border-top ：\n   \n   但是因为增加了边框的宽度，所以需要手动调整父元素的高度 height ；同时子元素会因为仍相对于父元素调整的 margin-top 而下移，所以也需要调整 margin-top\n   \n   > 脱离文档流问题\n   > \n   > 上述父子元素的边距折叠问题中，父元素使用了 border 属性调整，就让子元素的外边距不传递给父元素了，这是导致 `\n\n🌰 例子：\n\nsee the pen box model-5 by simon1uo (@simon1uo) on codepen.\n\n\n# 行内元素\n\n * 行内元素不支持设定宽度 weight 、高度 height ；\n * 行内元素可以设置 border ，垂直方向的 border 不会影响页面的布局；\n * 行内元素可以设置 padding ，垂直方向 padding 不会影响页面的布局 ；\n * 行内元素可以设置 margin ，垂直方向的 margin 不会影响页面的布局 ；\n\n将行内元素修改为可以对页面布局产生影响，使用 dispaly 属性修改元素显示的类型：\n\n * inline 将元素设置为行内元素；\n * block 将元素设置为块元素；\n * inline-block 将元素设置为行内块元素行内块，既可以设置宽度和高度又不会独占一行 ；\n * table 将元素设置为一个表格；\n\n * none 元素不在页面中显示，但是不占位；\n   \n   visibility 用来设置元素的显示状态：\n   \n   * visible 默认值，元素在页面中正常显示；\n   \n   * hidden 元素在页面中隐藏不显示，但是依然占据页面的位置；\n\n🌰 例子：\n\nsee the pen box model-6 inline element by simon1uo (@simon1uo) on codepen.\n\n\n# 浏览器的默认样式\n\n通常情况，浏览器都会为元素设置一些默认样式；\n\n利用 css 重设： 先定义好一些 css 样式，来让所有浏览器都按照同样的规则解释 css，这样就能避免发生这种问题：\n\n * reset 样式：引入外部样式表\n   \n   <link rel="stylesheet" href="assets/reset.css">\n   \n   \n   1\n   \n\n * normalize 样式：将所有默认样式统一，这样在不同的浏览器里显示效果也是统一的：\n   \n   <link rel="stylesheet" href="assets/normalize.css">\n   \n   \n   1\n   \n\n * 更多的 css 重设方法：目前比较全的 css 重设 (reset) 方法总结 - 寒意 - 博客园 (cnblogs.com)\n\n> 🌟 关于 css reset 那些事（一）之 历史演变与 normalize.css - segmentfault 思否\n> \n> 🌟 normalize-zh.css alsiso/normalize-zh: normalize.css 中文文档与源码解读 (github.com)\n> \n> 🌟 normalize.css 入门和下载 - segmentfault 思否\n> \n> 🌟 在 codepen 中使用 normalize 或者 reset css 预设：进入 ⚙️ pen settings > css\n\n\n# 盒子模型补充概念\n\n盒子大小 box-sizing 用来设置盒子尺寸的计算方式，通过设置 width 和 height 作用；可选值：\n\n * content-box ： 默认值， width 和 height 设置内容区的大小；\n * border-box ： width 和 height 设置整个盒子可见框的大小；\n   * width 和 height 指的是内容区、内边距、边框的总大小；\n\n轮廓 outlne 用来设置元素的轮廓线，与 border 的作用一样，但是 outline 不会影响可见框的大小，即不会影响页面的布局；\n\n盒子阴影 box-shadow ：设置元素的阴影效果，阴影不会影响页面布局；\n\n * 第一个值：水平偏移量，设置阴影的水平位置\n   * 正值向右移动\n   * 负值向左移动\n * 第二个值：垂直偏移量，设置阴影的垂直位置\n   * 正值向下移动\n   * 负值向上移动\n * 第三个值：阴影的模糊半径\n * 第四个值：阴影的颜色\n\n🍞 阴影 css 参考：https://getcssscan.com/css-box-shadow-examples\n\n圆角 border-radius ：设置圆角，圆角设置的是圆的半径大小；\n\n * border-top-left-radius\n * border-top-right-radius\n * border-bottom-left-radius\n * border-bottom-right-radius\n\n圆：设置四个圆角半径为正方形宽的一半；\n\n🌰 例子：\n\nsee the pen box model-7 box-sizing by simon1uo (@simon1uo) on codepen.',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🪁 CSS 浮动",frontmatter:{title:"🪁 CSS 浮动",date:"2022-02-11T15:11:57.000Z",permalink:"/pages/a8f349/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/40.%20%F0%9F%AA%81%20CSS%20%E6%B5%AE%E5%8A%A8.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/40. 🪁 CSS 浮动.md",key:"v-ac317b20",path:"/pages/a8f349/",headers:[{level:2,title:"Float",slug:"float",normalizedTitle:"float",charIndex:2},{level:3,title:"浮动特点",slug:"浮动特点",normalizedTitle:"浮动特点",charIndex:203},{level:2,title:"高度塌陷",slug:"高度塌陷",normalizedTitle:"高度塌陷",charIndex:726},{level:3,title:"BFC",slug:"bfc",normalizedTitle:"bfc",charIndex:892},{level:3,title:"清除浮动",slug:"清除浮动",normalizedTitle:"清除浮动",charIndex:904},{level:3,title:"clearfix",slug:"clearfix",normalizedTitle:"clearfix",charIndex:1917}],headersStr:"Float 浮动特点 高度塌陷 BFC 清除浮动 clearfix",content:"# Float\n\n通过 float 可以使元素向 父元素 的左侧或者右侧移动：\n\n * none ：默认值，不浮动；\n * left ：向左浮动；\n * right ：向右浮动；\n\n使用 float 需要注意以下事项：\n\n * 元素设置浮动以后，水平布局的等式便不需要强制成立；\n * 元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动；\n\n\n# 浮动特点\n\n 1. 浮动元素会完全脱离文档流，不再占据文档流中的位置 ；\n 2. 设置浮动以后，元素会向父元素的左侧或右侧移动；\n 3. 浮动元素默认不会从父元素中移出；\n 4. 按照先来后到的顺序，浮动元素向左或向右移动时，不会超过前边的浮动元素；\n 5. 浮动元素不会超过上边的浮动的兄弟元素，最多就是和它一样高；\n 6. 如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移；\n 7. 利用浮动来设置文字环绕图片的效果：浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围；\n\n🌰 例子：\n\nSee the Pen float-example-1 by simon1uo (@simon1uo) on CodePen.\n\n总结：\n\n * 主要作用就是让页面中的元素可以水平排列，通过浮动进行水平方向的布局；\n * 元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化；\n\n脱离文档流后的特点\n\n对于块元素：\n\n * 块元素不再独占页面的一行；\n * 脱离文档流以后，块元素的宽度和高度默认都被内容撑开；\n\n对于行内元素：脱离文档流之后，会拥有块元素的特点，很像 inline-block ；\n\n\n# 高度塌陷\n\n浮动布局中，父元素的高度默认由子元素撑起。当子元素浮动后脱离文档流后，无法撑起父元素的高度会导致父元素的高度丢失，导致布局混乱。\n\n🌰 例子：\n\nSee the Pen float-example-5 by simon1uo (@simon1uo) on CodePen.\n\n> 解决方法：\n> \n>  * 通过开启 BFC；\n>  * 通过清除浮动；\n>  * 通过伪元素选择器 ::after ；\n\n\n# BFC\n\nBFC Block Formatting Context 块级格式化环境：\n\n * 是一个 CSS 中的一个隐含的属性，可以为一个元素开启 BFC；\n * 开启后，元素会变成一个独立的布局区域；\n\n元素开启 BFC 后的特点：\n\n * 不会被浮动元素覆盖；\n * 父子元素外边距不会重叠；\n * 可以包含浮动的元素；\n\n开启 BFC 的方法：\n\n * 设置父元素为浮动：\n * 设置父元素为行内块元素；\n * 设置 overflow 为非 visible 值：既没有覆盖元素，也保持了独占一方的特性（保持了宽度），与下方元素也保持了最初的间隙；\n   * hidden （或 auto ） 开启其 BFC， 以使其可以包含浮动元素；\n   * scroll 会有滚动条；\n * 更多：块格式化上下文 - Web 开发者指南 | MDN (mozilla.org)\n\n🌰 例子 / 开启 BFC 消除高度塌陷：\n\nSee the Pen float-example-6 by simon1uo (@simon1uo) on CodePen.\n\n\n# 清除浮动\n\n通过 clear 属性来清除浮动元素对当前元素所产生的影响（当某个元素因为其他元素浮动的影响而改变位置）：\n\n * left 清除左侧浮动元素对当前元素的影响；\n * right 清除右侧浮动元素对当前元素的影响；\n * both 清除两侧中影响较大一侧元素的影响（注意，这里不是同时清除两侧的影响）；\n\n🌰 例子 / 清除浮动 + 通过清除浮动消除高度塌陷：\n\nSee the Pen float-example-7 clear by simon1uo (@simon1uo) on CodePen.\n\n通过伪元素选择器 ::after 消除高度塌陷：\n\nSee the Pen float-example-8 after by simon1uo (@simon1uo) on CodePen.\n * 与 float-example-7 直接在 box2 后面添加 box3 不同（结构添加），使用伪元素选择器（属于表现）；\n * 高度塌陷属于表现问题，使用伪元素选择器更符合网页的编程思想；\n * 由于 ::after 伪元素是行内元素，转换为块元素才能撑起元素的高度；\n\n\n# clearfix\n\n参照上面的例子，同样使用伪元素选择器消除前面 盒子模型 中出现的 垂直布局边距重叠的问题。\n\n> 详细思路参考：10 - 高度塌陷与 BFC・语雀 (yuque.com)\n\n总结:\n\n * 高度塌陷问题，一般用 ::after ;\n * 外边距重叠问题，一般用 ::before ；\n\nclearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题：\n\n🌰 例子：\n\nSee the Pen float-example-9 clearfix by simon1uo (@simon1uo) on CodePen.",normalizedContent:"# float\n\n通过 float 可以使元素向 父元素 的左侧或者右侧移动：\n\n * none ：默认值，不浮动；\n * left ：向左浮动；\n * right ：向右浮动；\n\n使用 float 需要注意以下事项：\n\n * 元素设置浮动以后，水平布局的等式便不需要强制成立；\n * 元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动；\n\n\n# 浮动特点\n\n 1. 浮动元素会完全脱离文档流，不再占据文档流中的位置 ；\n 2. 设置浮动以后，元素会向父元素的左侧或右侧移动；\n 3. 浮动元素默认不会从父元素中移出；\n 4. 按照先来后到的顺序，浮动元素向左或向右移动时，不会超过前边的浮动元素；\n 5. 浮动元素不会超过上边的浮动的兄弟元素，最多就是和它一样高；\n 6. 如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移；\n 7. 利用浮动来设置文字环绕图片的效果：浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围；\n\n🌰 例子：\n\nsee the pen float-example-1 by simon1uo (@simon1uo) on codepen.\n\n总结：\n\n * 主要作用就是让页面中的元素可以水平排列，通过浮动进行水平方向的布局；\n * 元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化；\n\n脱离文档流后的特点\n\n对于块元素：\n\n * 块元素不再独占页面的一行；\n * 脱离文档流以后，块元素的宽度和高度默认都被内容撑开；\n\n对于行内元素：脱离文档流之后，会拥有块元素的特点，很像 inline-block ；\n\n\n# 高度塌陷\n\n浮动布局中，父元素的高度默认由子元素撑起。当子元素浮动后脱离文档流后，无法撑起父元素的高度会导致父元素的高度丢失，导致布局混乱。\n\n🌰 例子：\n\nsee the pen float-example-5 by simon1uo (@simon1uo) on codepen.\n\n> 解决方法：\n> \n>  * 通过开启 bfc；\n>  * 通过清除浮动；\n>  * 通过伪元素选择器 ::after ；\n\n\n# bfc\n\nbfc block formatting context 块级格式化环境：\n\n * 是一个 css 中的一个隐含的属性，可以为一个元素开启 bfc；\n * 开启后，元素会变成一个独立的布局区域；\n\n元素开启 bfc 后的特点：\n\n * 不会被浮动元素覆盖；\n * 父子元素外边距不会重叠；\n * 可以包含浮动的元素；\n\n开启 bfc 的方法：\n\n * 设置父元素为浮动：\n * 设置父元素为行内块元素；\n * 设置 overflow 为非 visible 值：既没有覆盖元素，也保持了独占一方的特性（保持了宽度），与下方元素也保持了最初的间隙；\n   * hidden （或 auto ） 开启其 bfc， 以使其可以包含浮动元素；\n   * scroll 会有滚动条；\n * 更多：块格式化上下文 - web 开发者指南 | mdn (mozilla.org)\n\n🌰 例子 / 开启 bfc 消除高度塌陷：\n\nsee the pen float-example-6 by simon1uo (@simon1uo) on codepen.\n\n\n# 清除浮动\n\n通过 clear 属性来清除浮动元素对当前元素所产生的影响（当某个元素因为其他元素浮动的影响而改变位置）：\n\n * left 清除左侧浮动元素对当前元素的影响；\n * right 清除右侧浮动元素对当前元素的影响；\n * both 清除两侧中影响较大一侧元素的影响（注意，这里不是同时清除两侧的影响）；\n\n🌰 例子 / 清除浮动 + 通过清除浮动消除高度塌陷：\n\nsee the pen float-example-7 clear by simon1uo (@simon1uo) on codepen.\n\n通过伪元素选择器 ::after 消除高度塌陷：\n\nsee the pen float-example-8 after by simon1uo (@simon1uo) on codepen.\n * 与 float-example-7 直接在 box2 后面添加 box3 不同（结构添加），使用伪元素选择器（属于表现）；\n * 高度塌陷属于表现问题，使用伪元素选择器更符合网页的编程思想；\n * 由于 ::after 伪元素是行内元素，转换为块元素才能撑起元素的高度；\n\n\n# clearfix\n\n参照上面的例子，同样使用伪元素选择器消除前面 盒子模型 中出现的 垂直布局边距重叠的问题。\n\n> 详细思路参考：10 - 高度塌陷与 bfc・语雀 (yuque.com)\n\n总结:\n\n * 高度塌陷问题，一般用 ::after ;\n * 外边距重叠问题，一般用 ::before ；\n\nclearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题：\n\n🌰 例子：\n\nsee the pen float-example-9 clearfix by simon1uo (@simon1uo) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧭 CSS 定位",frontmatter:{title:"🧭 CSS 定位",date:"2022-02-11T15:14:17.000Z",permalink:"/pages/3fa9cc/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/50.%20%F0%9F%A7%AD%20CSS%20%E5%AE%9A%E4%BD%8D.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/50. 🧭 CSS 定位.md",key:"v-1d792e48",path:"/pages/3fa9cc/",headers:[{level:2,title:"position",slug:"position",normalizedTitle:"position",charIndex:2},{level:2,title:"相对定位 relative",slug:"相对定位-relative",normalizedTitle:"相对定位 relative",charIndex:154},{level:2,title:"绝对定位 absolute",slug:"绝对定位-absolute",normalizedTitle:"绝对定位 absolute",charIndex:1040},{level:2,title:"固定定位 fixed",slug:"固定定位-fixed",normalizedTitle:"固定定位 fixed",charIndex:2146},{level:3,title:"粘滞定位 sticky",slug:"粘滞定位-sticky",normalizedTitle:"粘滞定位 sticky",charIndex:2363},{level:3,title:"元素层级",slug:"元素层级",normalizedTitle:"元素层级",charIndex:2699}],headersStr:"position 相对定位 relative 绝对定位 absolute 固定定位 fixed 粘滞定位 sticky 元素层级",content:'# position\n\n通过定位可以将元素摆放到页面的任意位置，设置 position 属性设置定位：\n\n * static 默认值，不开启定位，元素静止；\n * relative ：相对定位；\n * absolute ：绝对定位；\n * fixed ：固定定位；\n * sticky ：粘滞定位；\n\n\n# 相对定位 relative\n\n开启相对定位后，通过 偏移量 offset 来设置元素的位置：\n\n定位元素的垂直方向：\n\n * top ：定位元素和定位位置的上边距离，越大越靠下；\n * bottom ：定位元素和定位位置的下边距离，越大越靠上；\n\n定位元素的水平方向：\n\n * left ：定位元素和定位位置的左边距离，越大越靠右；\n * right ：定位元素和定位位置的右边距离，越大越靠左；\n\n🌰 例子：\n\n相对定位的特点：\n\n * 开启相对定位以后，如果不设置偏移量元素，则元素不会发生任何变化；\n * 相对定位是参照于元素在文档流中的位置进行定位的（可以理解为相对于自身原始位置）；\n * 相对定位会提升元素的层级（表现为可以覆盖其他元素）；\n * 相对定位不会改变元素的性质：块还是块，行内还是行内；（⭐️ 行内元素可以使用相对定位）\n\n> ⭐️ Q1: 给 example 中的 三个 div 都设置相对定位，层级关系：在页面文档流中，越靠下的元素开启相对定位后，其层级越高；（没有设置层级或层级 z-index 设置相同值时，优先显示靠下的元素）\n> \n> ⭐️ Q2： 与浮动定位对比：\n> \n>  * 参考系：浮动的参考系是父元素；相对定位参考系是其自身；\n> \n>  * 可移动的方向：浮动只能左右移动；相对定位课上下左右移动；\n> \n>  * 影响：浮动只会影响页面布局（下方元素位置、高度塌陷）；\n>    \n>    相对定位不会影响页面布局；\n> \n>  * 性质不同：浮动会改变元素的性质（不再独占一行，其宽高都会被内容撑开）；相对定位不会改变元素的性质；\n> \n>  * 文字环绕：浮动不会覆盖文字；相对定位可以覆盖文字；\n> \n>  * 相对定位没有脱离文档流；\n> \n> 浮动和相对定位都不会从父元素中移出。\n> \n> ⭐️ Q3：相对定位不会改变元素的性质：\n> \n> 相比于浮动元素的特点，相对定位的元素位置发生改变以后，布局并没有产生影响，因为它的肉体（结构）仍然占据着原来的那个位置。只是其灵魂（内容）发生了移动。\n\n\n# 绝对定位 absolute\n\nposition 属性值为 absolute ：\n\n绝对定位的特点：\n\n * 不设置偏移量，元素的位置不会发生变化；\n * 开启绝对定位后，元素会从文档流中脱离；\n * 绝对定位会改变元素的性质：行内变成块，块的宽高被内容撑开（与相对定位相反）；\n * 绝对定位会使元素提升一个层级；\n * 参考系：绝对定位元素是相对于其包含块进行定位的（与相对定位不同）\n\n包含块 Containing Block\n\n * 包含块就是离当前元素最近的开启了定位的祖先块元素；\n\n * 如果所有的祖先元素都没有开启定位，则 HTML 根元素就是它的包含块；\n   \n   \x3c!-- 如果box1开启定位，则box2的包含块是box1，否则就是body --\x3e\n   <div class="box1">\n     <div class="box2"></div>\n   </div>\n   \n   \x3c!-- 如果box3开启定位，则em的包含块是box3，否则就是body --\x3e\n   <div class="box3">\n     <span>\n       <em>hello</em>\n     </span>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   （必要条件）开启定位指只要 position 的值不为 static 即可；\n\n水平方向 / 垂直的布局\n\n利用包含块，子元素在父元素內实现水平方向垂直方向的居中；\n\n * 水平布局等式： left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 其父元素的宽度 ；\n * 垂直布局等式： top + margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom + top = 其父元素的高度 ；\n * 只是在没有 auto 时，会自动调整 top / bottom / left / right ；\n\n🌰 例子：\n\nSee the Pen position-example-2 absolute element-align by simon1uo (@simon1uo) on CodePen.\n\n\n# 固定定位 fixed\n\n将 position 属性设置为 fixed；\n\n固定定位的特点：\n\n * 大部分特点都和绝对定位一样；\n * 固定定位永远参照于 ** 浏览器的可视窗口（viewport）** 进行定位，不会随网页的滚动条滚动 —— 置顶于可视窗口；\n\n🌰 例子：\n\nSee the Pen position-example-3 fixed by simon1uo (@simon1uo) on CodePen.\n\n\n# 粘滞定位 sticky\n\nposition 属性设置为 sticky ；\n\n粘滞定位的特点：\n\n * 该元素是根据文档流进行定位的，即相对于包含块进行偏移；\n * 偏移量不会影响任何其他元素的位置；\n * 与固定定位相似，但粘滞定位可以在元素达到魔偶个位置时固定；（不常置顶）；\n * 粘性元素总是 “粘” 到其最近的具有 “滚动机制” 的祖先元素（当 overflow 为 hidden 、 scroll 、 auto 、 overlay 时创建），即使该祖先不是最近的实际滚动祖先元素；\n\n🌰 例子 / 导航栏：\n\nSee the Pen float-example-4 navbar by simon1uo (@simon1uo) on CodePen.\n\n\n# 元素层级\n\n对于开启了定位元素，可以通过 z-index 属性来指定元素的层级：\n\n * z-index 需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示；\n * 如果元素的层级一样，则优先显示靠下的元素；\n * 祖先的元素的层级再高，也不会盖住后代元素；\n\n浮动定位使用层级定位：\n\n * 给 float 设置 z-index 无效；\n\n * 默认情况，没有设置 z-index 或设置 z-index 大小 ≥ 0 时，浮动层级没有定位的层级高；\n\n * 设置 z-index < 0 时，浮动层级可以定位的层级高；',normalizedContent:'# position\n\n通过定位可以将元素摆放到页面的任意位置，设置 position 属性设置定位：\n\n * static 默认值，不开启定位，元素静止；\n * relative ：相对定位；\n * absolute ：绝对定位；\n * fixed ：固定定位；\n * sticky ：粘滞定位；\n\n\n# 相对定位 relative\n\n开启相对定位后，通过 偏移量 offset 来设置元素的位置：\n\n定位元素的垂直方向：\n\n * top ：定位元素和定位位置的上边距离，越大越靠下；\n * bottom ：定位元素和定位位置的下边距离，越大越靠上；\n\n定位元素的水平方向：\n\n * left ：定位元素和定位位置的左边距离，越大越靠右；\n * right ：定位元素和定位位置的右边距离，越大越靠左；\n\n🌰 例子：\n\n相对定位的特点：\n\n * 开启相对定位以后，如果不设置偏移量元素，则元素不会发生任何变化；\n * 相对定位是参照于元素在文档流中的位置进行定位的（可以理解为相对于自身原始位置）；\n * 相对定位会提升元素的层级（表现为可以覆盖其他元素）；\n * 相对定位不会改变元素的性质：块还是块，行内还是行内；（⭐️ 行内元素可以使用相对定位）\n\n> ⭐️ q1: 给 example 中的 三个 div 都设置相对定位，层级关系：在页面文档流中，越靠下的元素开启相对定位后，其层级越高；（没有设置层级或层级 z-index 设置相同值时，优先显示靠下的元素）\n> \n> ⭐️ q2： 与浮动定位对比：\n> \n>  * 参考系：浮动的参考系是父元素；相对定位参考系是其自身；\n> \n>  * 可移动的方向：浮动只能左右移动；相对定位课上下左右移动；\n> \n>  * 影响：浮动只会影响页面布局（下方元素位置、高度塌陷）；\n>    \n>    相对定位不会影响页面布局；\n> \n>  * 性质不同：浮动会改变元素的性质（不再独占一行，其宽高都会被内容撑开）；相对定位不会改变元素的性质；\n> \n>  * 文字环绕：浮动不会覆盖文字；相对定位可以覆盖文字；\n> \n>  * 相对定位没有脱离文档流；\n> \n> 浮动和相对定位都不会从父元素中移出。\n> \n> ⭐️ q3：相对定位不会改变元素的性质：\n> \n> 相比于浮动元素的特点，相对定位的元素位置发生改变以后，布局并没有产生影响，因为它的肉体（结构）仍然占据着原来的那个位置。只是其灵魂（内容）发生了移动。\n\n\n# 绝对定位 absolute\n\nposition 属性值为 absolute ：\n\n绝对定位的特点：\n\n * 不设置偏移量，元素的位置不会发生变化；\n * 开启绝对定位后，元素会从文档流中脱离；\n * 绝对定位会改变元素的性质：行内变成块，块的宽高被内容撑开（与相对定位相反）；\n * 绝对定位会使元素提升一个层级；\n * 参考系：绝对定位元素是相对于其包含块进行定位的（与相对定位不同）\n\n包含块 containing block\n\n * 包含块就是离当前元素最近的开启了定位的祖先块元素；\n\n * 如果所有的祖先元素都没有开启定位，则 html 根元素就是它的包含块；\n   \n   \x3c!-- 如果box1开启定位，则box2的包含块是box1，否则就是body --\x3e\n   <div class="box1">\n     <div class="box2"></div>\n   </div>\n   \n   \x3c!-- 如果box3开启定位，则em的包含块是box3，否则就是body --\x3e\n   <div class="box3">\n     <span>\n       <em>hello</em>\n     </span>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   （必要条件）开启定位指只要 position 的值不为 static 即可；\n\n水平方向 / 垂直的布局\n\n利用包含块，子元素在父元素內实现水平方向垂直方向的居中；\n\n * 水平布局等式： left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 其父元素的宽度 ；\n * 垂直布局等式： top + margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom + top = 其父元素的高度 ；\n * 只是在没有 auto 时，会自动调整 top / bottom / left / right ；\n\n🌰 例子：\n\nsee the pen position-example-2 absolute element-align by simon1uo (@simon1uo) on codepen.\n\n\n# 固定定位 fixed\n\n将 position 属性设置为 fixed；\n\n固定定位的特点：\n\n * 大部分特点都和绝对定位一样；\n * 固定定位永远参照于 ** 浏览器的可视窗口（viewport）** 进行定位，不会随网页的滚动条滚动 —— 置顶于可视窗口；\n\n🌰 例子：\n\nsee the pen position-example-3 fixed by simon1uo (@simon1uo) on codepen.\n\n\n# 粘滞定位 sticky\n\nposition 属性设置为 sticky ；\n\n粘滞定位的特点：\n\n * 该元素是根据文档流进行定位的，即相对于包含块进行偏移；\n * 偏移量不会影响任何其他元素的位置；\n * 与固定定位相似，但粘滞定位可以在元素达到魔偶个位置时固定；（不常置顶）；\n * 粘性元素总是 “粘” 到其最近的具有 “滚动机制” 的祖先元素（当 overflow 为 hidden 、 scroll 、 auto 、 overlay 时创建），即使该祖先不是最近的实际滚动祖先元素；\n\n🌰 例子 / 导航栏：\n\nsee the pen float-example-4 navbar by simon1uo (@simon1uo) on codepen.\n\n\n# 元素层级\n\n对于开启了定位元素，可以通过 z-index 属性来指定元素的层级：\n\n * z-index 需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示；\n * 如果元素的层级一样，则优先显示靠下的元素；\n * 祖先的元素的层级再高，也不会盖住后代元素；\n\n浮动定位使用层级定位：\n\n * 给 float 设置 z-index 无效；\n\n * 默认情况，没有设置 z-index 或设置 z-index 大小 ≥ 0 时，浮动层级没有定位的层级高；\n\n * 设置 z-index < 0 时，浮动层级可以定位的层级高；',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗚 CSS 字体",frontmatter:{title:"🗚 CSS 字体",date:"2022-02-11T15:16:02.000Z",permalink:"/pages/27df4e/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/60.%20%F0%9F%97%9A%20CSS%20%E5%AD%97%E4%BD%93.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/60. 🗚 CSS 字体.md",key:"v-49aa8c49",path:"/pages/27df4e/",headers:[{level:2,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:2},{level:3,title:"font-family",slug:"font-family",normalizedTitle:"font-family",charIndex:21},{level:3,title:"@font-face",slug:"font-face",normalizedTitle:"@font-face",charIndex:136},{level:3,title:"line height",slug:"line-height",normalizedTitle:"line height",charIndex:608},{level:3,title:"相关的简写属性",slug:"相关的简写属性",normalizedTitle:"相关的简写属性",charIndex:810},{level:3,title:"文本对齐方式",slug:"文本对齐方式",normalizedTitle:"文本对齐方式",charIndex:1e3}],headersStr:"字体 font-family @font-face line height 相关的简写属性 文本对齐方式",content:"# 字体\n\n与字体的有关的属性：\n\n\n# font-family\n\n指定字体的类别，浏览器会自动使用该类别下的字体 font-family ：\n\n * 可以同时指定多个字体，多个字体间使用 ， 隔开；\n * 优先使用第一个，第一个无法使用则使用第二个，以此类推；\n\n\n# @font-face\n\n@font-face 将服务器中的字体直接提供给用户去使用：\n\n@font-face { \n  /* 指定字体名字 */    \n  font-family: 'myFont1';    \n  /* 服务器中字体路径 */    \n  src: url('/font/ZCOOLKuaiLe-Regular.woff'),url('/font/ZCOOLKuaiLe-Regular.otf'),url('/font/ZCOOLKuaiLe-Regular.ttf') format('truetype');\n  /* 指定字体格式，一般不写 */\n}\n\np {\n  font-size: 30px;\n  color: salmon;  \n  font-family: myFont1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 使用 @font-face ：需要注意的问题：\n> \n>  1. 字体加载速度；\n>  2. 字体版权；\n>  3. 字体格式：网站浏览器兼容性；\n\n\n# line height\n\n行高，文字占有的实际高度：\n\n * 可以直接指定一个大小 px / em ；\n * 也可以直接为行高设置一个小数（字体大小的倍数）；\n\n行高经常还用来设置文字的行间距： 行间距 = 行高 - 字体大小\n\n🌰 例子：\n\nSee the Pen font-example-1 line-height by simon1uo (@simon1uo) on CodePen.\n\n\n# 相关的简写属性\n\n按照顺序： font: font-style font-variant font-weight font-size/line-height font-family; ：\n\n🌰 例子\n\n{\n  font: bold small-caps italic 50px 'Courier New', Courier, monospace;\n}\n\n\n1\n2\n3\n\n\n\n# 文本对齐方式\n\n水平对齐 text-align ：\n\n * left ：左侧对齐；\n * right ：右侧对齐；\n * center ：居中对齐；\n * justify ： 两端适应对齐；\n\n垂直对齐 vertical-align\n\n * baseline 基线对齐；\n * top 顶部对齐；\n * bottom 底部对齐；\n * middle 居中对齐；\n\n🌰 例子：\n\nSee the Pen font-example-2 align by simon1uo (@simon1uo) on CodePen.",normalizedContent:"# 字体\n\n与字体的有关的属性：\n\n\n# font-family\n\n指定字体的类别，浏览器会自动使用该类别下的字体 font-family ：\n\n * 可以同时指定多个字体，多个字体间使用 ， 隔开；\n * 优先使用第一个，第一个无法使用则使用第二个，以此类推；\n\n\n# @font-face\n\n@font-face 将服务器中的字体直接提供给用户去使用：\n\n@font-face { \n  /* 指定字体名字 */    \n  font-family: 'myfont1';    \n  /* 服务器中字体路径 */    \n  src: url('/font/zcoolkuaile-regular.woff'),url('/font/zcoolkuaile-regular.otf'),url('/font/zcoolkuaile-regular.ttf') format('truetype');\n  /* 指定字体格式，一般不写 */\n}\n\np {\n  font-size: 30px;\n  color: salmon;  \n  font-family: myfont1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 使用 @font-face ：需要注意的问题：\n> \n>  1. 字体加载速度；\n>  2. 字体版权；\n>  3. 字体格式：网站浏览器兼容性；\n\n\n# line height\n\n行高，文字占有的实际高度：\n\n * 可以直接指定一个大小 px / em ；\n * 也可以直接为行高设置一个小数（字体大小的倍数）；\n\n行高经常还用来设置文字的行间距： 行间距 = 行高 - 字体大小\n\n🌰 例子：\n\nsee the pen font-example-1 line-height by simon1uo (@simon1uo) on codepen.\n\n\n# 相关的简写属性\n\n按照顺序： font: font-style font-variant font-weight font-size/line-height font-family; ：\n\n🌰 例子\n\n{\n  font: bold small-caps italic 50px 'courier new', courier, monospace;\n}\n\n\n1\n2\n3\n\n\n\n# 文本对齐方式\n\n水平对齐 text-align ：\n\n * left ：左侧对齐；\n * right ：右侧对齐；\n * center ：居中对齐；\n * justify ： 两端适应对齐；\n\n垂直对齐 vertical-align\n\n * baseline 基线对齐；\n * top 顶部对齐；\n * bottom 底部对齐；\n * middle 居中对齐；\n\n🌰 例子：\n\nsee the pen font-example-2 align by simon1uo (@simon1uo) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🖼 CSS 背景",frontmatter:{title:"🖼 CSS 背景",date:"2022-02-11T15:18:12.000Z",permalink:"/pages/ef3d83/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/70.%20%F0%9F%96%BC%20CSS%20%E8%83%8C%E6%99%AF.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/70. 🖼 CSS 背景.md",key:"v-1572ebde",path:"/pages/ef3d83/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:3,title:"渐变",slug:"渐变",normalizedTitle:"渐变",charIndex:1361}],headersStr:"背景 渐变",content:"# 背景\n\n背景相关的样式属性：\n\n * background-color 设置背景颜色的属性。\n\n * background-image 设置背景图片的属性。\n   \n   * 如果背景图片大小小于元素，则背景图片会自动在元素中平铺将元素铺满；\n   * 如果背景图片大小大于元素，则背景图片一部分会无法完全显示；\n   * 如果背景图片大小等于元素，则背景图片会直接正常显示；\n\n * background-repeat 设置背景图片的重复方式：\n   \n   * repeat ：默认值，背景图片沿着 x 轴和 y 轴双方向重复；\n   * repeat-x ：背景图片沿着 x 轴方向重复；\n   * repeat-y ：背景图片沿着 y 轴方向重复；\n   * no-repeat ：背景图片不重复；\n\n * background-position 设置背景图片的位置 ：\n   \n   * 通过 top left right bottom center 几个表示方位的词来设置背景图片的位置：使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是 center ；\n   * 通过偏移量来指定背景图片的位置：水平方向偏移量、垂直方向变量；\n\n * background-clip 设置背景的范围：\n   \n   * border-box ：默认值，背景会出现在边框的下边；\n   * padding-box ：背景不会出现在边框，只出现在内容区和内边距；\n   * content-box ：背景只会出现在内容区；\n\n * background-origin 背景图片的偏移量计算的原点：\n   \n   * border-box ：背景图片的变量从边框处开始计算；\n   * padding-box ：默认值， background-position 从内边距处开始计算；\n   * content-box ：背景图片的偏移量从内容区处计算；\n\n * background-size 设置背景图片的大小：\n   \n   * 第一个值表示宽度，第二个值表示高度；如果只写一个，则第二个值默认是 auto ；\n   * cover ：图片的比例不变，将元素铺满；\n   * contain ：图片比例不变，将图片在元素中完整显示；\n\n * background-attachment 背景图片是否跟随元素移动 ：\n   \n   * scroll ：默认值，背景图片会跟随元素移动；\n   * fixed ：背景会固定在页面中，不会随元素移动；\n\n🌰 例子：\n\nSee the Pen background-example-1 by simon1uo (@simon1uo) on CodePen.\n\nbackgound 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置并且该样式没有顺序要求，也没有哪个属性是必须写的；\n\n⚠️ 简写时的注意事项：\n\n * background-size 必须写在 background-position 后，使用 / 隔开；\n * background-origin background-clip 两个样式， orgin 要在 clip 的前边；\n\n\n# 渐变\n\n线性渐变 linear-gradient ：（表示渐变的方向）\n\n * to left\n * to right\n * to bottom\n * to top\n * deg 表示度数 (单位为 deg )\n * turn 表示圈\n\n{\n  background-image: linear-gradient(to left, red, yellow);\n\tbackground-image: linear-gradient(to right, red, yellow);\n\tbackground-image: linear-gradient(to top, red, yellow);\n\tbackground-image: linear-gradient(to bottom, red, yellow);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n径向渐变 radial-gradient ：\n\n可以设定形状、位置、大小 …\n\n🌰 例子：\n\nSee the Pen background-example-2 gradient by simon1uo (@simon1uo) on CodePen.",normalizedContent:"# 背景\n\n背景相关的样式属性：\n\n * background-color 设置背景颜色的属性。\n\n * background-image 设置背景图片的属性。\n   \n   * 如果背景图片大小小于元素，则背景图片会自动在元素中平铺将元素铺满；\n   * 如果背景图片大小大于元素，则背景图片一部分会无法完全显示；\n   * 如果背景图片大小等于元素，则背景图片会直接正常显示；\n\n * background-repeat 设置背景图片的重复方式：\n   \n   * repeat ：默认值，背景图片沿着 x 轴和 y 轴双方向重复；\n   * repeat-x ：背景图片沿着 x 轴方向重复；\n   * repeat-y ：背景图片沿着 y 轴方向重复；\n   * no-repeat ：背景图片不重复；\n\n * background-position 设置背景图片的位置 ：\n   \n   * 通过 top left right bottom center 几个表示方位的词来设置背景图片的位置：使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是 center ；\n   * 通过偏移量来指定背景图片的位置：水平方向偏移量、垂直方向变量；\n\n * background-clip 设置背景的范围：\n   \n   * border-box ：默认值，背景会出现在边框的下边；\n   * padding-box ：背景不会出现在边框，只出现在内容区和内边距；\n   * content-box ：背景只会出现在内容区；\n\n * background-origin 背景图片的偏移量计算的原点：\n   \n   * border-box ：背景图片的变量从边框处开始计算；\n   * padding-box ：默认值， background-position 从内边距处开始计算；\n   * content-box ：背景图片的偏移量从内容区处计算；\n\n * background-size 设置背景图片的大小：\n   \n   * 第一个值表示宽度，第二个值表示高度；如果只写一个，则第二个值默认是 auto ；\n   * cover ：图片的比例不变，将元素铺满；\n   * contain ：图片比例不变，将图片在元素中完整显示；\n\n * background-attachment 背景图片是否跟随元素移动 ：\n   \n   * scroll ：默认值，背景图片会跟随元素移动；\n   * fixed ：背景会固定在页面中，不会随元素移动；\n\n🌰 例子：\n\nsee the pen background-example-1 by simon1uo (@simon1uo) on codepen.\n\nbackgound 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置并且该样式没有顺序要求，也没有哪个属性是必须写的；\n\n⚠️ 简写时的注意事项：\n\n * background-size 必须写在 background-position 后，使用 / 隔开；\n * background-origin background-clip 两个样式， orgin 要在 clip 的前边；\n\n\n# 渐变\n\n线性渐变 linear-gradient ：（表示渐变的方向）\n\n * to left\n * to right\n * to bottom\n * to top\n * deg 表示度数 (单位为 deg )\n * turn 表示圈\n\n{\n  background-image: linear-gradient(to left, red, yellow);\n\tbackground-image: linear-gradient(to right, red, yellow);\n\tbackground-image: linear-gradient(to top, red, yellow);\n\tbackground-image: linear-gradient(to bottom, red, yellow);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n径向渐变 radial-gradient ：\n\n可以设定形状、位置、大小 …\n\n🌰 例子：\n\nsee the pen background-example-2 gradient by simon1uo (@simon1uo) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔍 CSS 变形",frontmatter:{title:"🔍 CSS 变形",date:"2022-04-27T14:44:04.000Z",permalink:"/pages/9de79a/",categories:["🚶 前端入门基础","🎨 CSS"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/90.%20%F0%9F%94%8D%20CSS%20%E5%8F%98%E5%BD%A2.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/90. 🔍 CSS 变形.md",key:"v-13f3c2ee",path:"/pages/9de79a/",headers:[{level:2,title:"变形",slug:"变形",normalizedTitle:"变形",charIndex:2},{level:3,title:"平移",slug:"平移",normalizedTitle:"平移",charIndex:64},{level:3,title:"Z 轴平移",slug:"z-轴平移",normalizedTitle:"z 轴平移",charIndex:395},{level:3,title:"缩放",slug:"缩放",normalizedTitle:"缩放",charIndex:493}],headersStr:"变形 平移 Z 轴平移 缩放",content:"# 变形\n\n通过 CSS 来改变元素的形状或位置，不会影响页面的布局：\n\ntransform 用来设置元素的变形效果。\n\n\n# 平移\n\n * translateX() 沿着 x 轴方向平移\n * translateY() 沿着 y 轴方向平移\n * translateZ() 沿着 z 轴方向平移\n\n括号内的百分比是相对于自身计算的；\n\n🌰 例子 / 三种元素居中方法对比：\n\nSee the Pen transform-example-1 center by simon1uo (@simon1uo) on CodePen.\n * 绝对定位法：适用于元素的大小确定时；\n * table-cell 法：具有一定的局限性；\n\n🌰 例子 ：\n\nSee the Pen transform-example-2 by simon1uo (@simon1uo) on CodePen.\n\n\n# Z 轴平移\n\ntransformZ()\n\n旋转\n\n通过旋转可以使元素沿着 x、 y 或 z 旋转指定的角度\n\n * rotateX()\n * rotateY()\n * rotateZ()\n\n\n# 缩放\n\n对元素进行缩放的函数：\n\n * scalex() 水平方向缩放\n\n * scaleY() 垂直方向缩放\n\n * scale() 双方向的缩放\n\n🌰 例子：\n\nSee the Pen transform-example-4 scale by simon1uo (@simon1uo) on CodePen.",normalizedContent:"# 变形\n\n通过 css 来改变元素的形状或位置，不会影响页面的布局：\n\ntransform 用来设置元素的变形效果。\n\n\n# 平移\n\n * translatex() 沿着 x 轴方向平移\n * translatey() 沿着 y 轴方向平移\n * translatez() 沿着 z 轴方向平移\n\n括号内的百分比是相对于自身计算的；\n\n🌰 例子 / 三种元素居中方法对比：\n\nsee the pen transform-example-1 center by simon1uo (@simon1uo) on codepen.\n * 绝对定位法：适用于元素的大小确定时；\n * table-cell 法：具有一定的局限性；\n\n🌰 例子 ：\n\nsee the pen transform-example-2 by simon1uo (@simon1uo) on codepen.\n\n\n# z 轴平移\n\ntransformz()\n\n旋转\n\n通过旋转可以使元素沿着 x、 y 或 z 旋转指定的角度\n\n * rotatex()\n * rotatey()\n * rotatez()\n\n\n# 缩放\n\n对元素进行缩放的函数：\n\n * scalex() 水平方向缩放\n\n * scaley() 垂直方向缩放\n\n * scale() 双方向的缩放\n\n🌰 例子：\n\nsee the pen transform-example-4 scale by simon1uo (@simon1uo) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🐈 CSS 过渡与动画",frontmatter:{title:"🐈 CSS 过渡与动画",date:"2022-02-11T15:30:33.000Z",permalink:"/pages/c46d43/",categories:["🚶 前端入门基础","🎨 CSS"],tags:["CSS"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8E%A8%20CSS/80.%20%F0%9F%90%88%20CSS%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html",relativePath:"100. 🚶 前端入门基础/20. 🎨 CSS/80. 🐈 CSS 过渡与动画.md",key:"v-c3cc3544",path:"/pages/c46d43/",headers:[{level:2,title:"过渡和动画",slug:"过渡和动画",normalizedTitle:"过渡和动画",charIndex:2},{level:3,title:"过渡 Transition",slug:"过渡-transition",normalizedTitle:"过渡 transition",charIndex:12},{level:3,title:"动画 Animation",slug:"动画-animation",normalizedTitle:"动画 animation",charIndex:713}],headersStr:"过渡和动画 过渡 Transition 动画 Animation",content:"# 过渡和动画\n\n\n# 过渡 Transition\n\n * 可以指定一个属性发生变化时的切换方式；\n\n属性值：\n\n * transition-property ：指定要执行过渡的属性：\n   \n   * 多个属性间使用 , 隔开；\n   \n   * 如果所有属性都需要过渡，则使用 all 关键字；\n   \n   * 大部分属性都支持过渡效果；\n   \n   * 注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡；\n\n * transition-duration ：指定过渡效果的持续时间：\n   \n   * 时间单位：s 和 ms（1 s = 1000 ms）；\n\n * transition-delay ：过渡效果的延迟时间；\n\n * transition-timing-function ：过渡的时序函数：\n   \n   * linear 线性匀速运动\n   \n   * ease 默认值，慢速开始，先加速后减速\n   \n   * ease-in 加速运动\n   \n   * ease-out 减速运动\n   \n   * ease-in-out 先加速后减速\n   \n   * cubic-bezier() 来指定时序函数 https://cubic-bezier.com\n   \n   * steps() 分步执行过渡效果，可以设置第二个值：\n   \n   * * end ，在时间结束时执行过渡（默认值）\n   * * start ，在时间开始时执行过渡\n\n * transition ：可以同时设置过渡相关的所有属性：\n   \n   * 添加延迟，则两个时间中第一个是持续时间，第二个是延迟时间；\n\n\n# 动画 Animation\n\n动画和过渡类似，都是可以实现一些动态的效果，不同的是：\n\n * 过渡需要在某个属性发生变化时才会触发；\n * 动画可以自动触发动态效果；\n\n设置动画效果，必须先要设置一个关键帧，关键帧设置了动画执行每一个步骤：\n\n@keyframes test {    \n  from {\n    margin-left: 0; \n  }    \n  to {\n    margin-left: 900px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n属性值：\n\n * animation-name ：指定动画的关键帧名称；\n\n * animation-duration ：指定动画效果的持续时间；\n\n * animation-delay ：动画效果的延迟，等待一段时间后在执行动画；\n\n * animation-timing-function ：动画的时序函数；\n\n * animation-iteration-count ： 动画执行的次数；\n   \n   * infinite 无限次执行；\n\n * animation-direction ：指定动画运行的方向：\n   \n   * normal 从 from 向 to 运行， 每次执行；\n   \n   * reverse 从 to 向 from 运行，每次执行；\n   \n   * alternate 从 from 向 to 运行： 重复执行动画时反向执行；\n   \n   * alternate-reverse 从 to 向 from 运行，重复执行动画时反向执行；\n\n * animation-play-state ：设置动画的执行状态：\n   \n   * running 动画执行，默认值\n   \n   * paused 动画暂停\n\n * animation-fill-mode ：动画的填充模式。指定了在动画结束时元素的样式。\n   \n   * none 动画执行完毕，元素回到原来位置，默认值\n   \n   * forwards 动画执行完毕，元素会停止在动画结束的位置\n   \n   * backwards 动画延时等待时，元素就会处于开始位置\n   \n   * both 结合了 forwards 和 backwards",normalizedContent:"# 过渡和动画\n\n\n# 过渡 transition\n\n * 可以指定一个属性发生变化时的切换方式；\n\n属性值：\n\n * transition-property ：指定要执行过渡的属性：\n   \n   * 多个属性间使用 , 隔开；\n   \n   * 如果所有属性都需要过渡，则使用 all 关键字；\n   \n   * 大部分属性都支持过渡效果；\n   \n   * 注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡；\n\n * transition-duration ：指定过渡效果的持续时间：\n   \n   * 时间单位：s 和 ms（1 s = 1000 ms）；\n\n * transition-delay ：过渡效果的延迟时间；\n\n * transition-timing-function ：过渡的时序函数：\n   \n   * linear 线性匀速运动\n   \n   * ease 默认值，慢速开始，先加速后减速\n   \n   * ease-in 加速运动\n   \n   * ease-out 减速运动\n   \n   * ease-in-out 先加速后减速\n   \n   * cubic-bezier() 来指定时序函数 https://cubic-bezier.com\n   \n   * steps() 分步执行过渡效果，可以设置第二个值：\n   \n   * * end ，在时间结束时执行过渡（默认值）\n   * * start ，在时间开始时执行过渡\n\n * transition ：可以同时设置过渡相关的所有属性：\n   \n   * 添加延迟，则两个时间中第一个是持续时间，第二个是延迟时间；\n\n\n# 动画 animation\n\n动画和过渡类似，都是可以实现一些动态的效果，不同的是：\n\n * 过渡需要在某个属性发生变化时才会触发；\n * 动画可以自动触发动态效果；\n\n设置动画效果，必须先要设置一个关键帧，关键帧设置了动画执行每一个步骤：\n\n@keyframes test {    \n  from {\n    margin-left: 0; \n  }    \n  to {\n    margin-left: 900px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n属性值：\n\n * animation-name ：指定动画的关键帧名称；\n\n * animation-duration ：指定动画效果的持续时间；\n\n * animation-delay ：动画效果的延迟，等待一段时间后在执行动画；\n\n * animation-timing-function ：动画的时序函数；\n\n * animation-iteration-count ： 动画执行的次数；\n   \n   * infinite 无限次执行；\n\n * animation-direction ：指定动画运行的方向：\n   \n   * normal 从 from 向 to 运行， 每次执行；\n   \n   * reverse 从 to 向 from 运行，每次执行；\n   \n   * alternate 从 from 向 to 运行： 重复执行动画时反向执行；\n   \n   * alternate-reverse 从 to 向 from 运行，重复执行动画时反向执行；\n\n * animation-play-state ：设置动画的执行状态：\n   \n   * running 动画执行，默认值\n   \n   * paused 动画暂停\n\n * animation-fill-mode ：动画的填充模式。指定了在动画结束时元素的样式。\n   \n   * none 动画执行完毕，元素回到原来位置，默认值\n   \n   * forwards 动画执行完毕，元素会停止在动画结束的位置\n   \n   * backwards 动画延时等待时，元素就会处于开始位置\n   \n   * both 结合了 forwards 和 backwards",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌱 JavaScript 基本使用",frontmatter:{title:"🌱 JavaScript 基本使用",date:"2022-03-10T09:51:01.000Z",permalink:"/pages/d84d57/",categories:["🚶 前端入门基础","🍪 JavaScript"],tags:["JavaScript基础"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/30.%20%F0%9F%8D%AA%20JavaScript/01.%20%F0%9F%8C%B1%20JavaScript%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html",relativePath:"100. 🚶 前端入门基础/30. 🍪 JavaScript/01. 🌱 JavaScript 基本使用.md",key:"v-49546196",path:"/pages/d84d57/",headers:[{level:2,title:"JavaScript 用法",slug:"javascript-用法",normalizedTitle:"javascript 用法",charIndex:554},{level:2,title:"JavaScript 输出",slug:"javascript-输出",normalizedTitle:"javascript 输出",charIndex:973},{level:2,title:"JavaScript 基本语法",slug:"javascript-基本语法",normalizedTitle:"javascript 基本语法",charIndex:1232},{level:3,title:"分号的用法",slug:"分号的用法",normalizedTitle:"分号的用法",charIndex:1252},{level:3,title:"注释的方法",slug:"注释的方法",normalizedTitle:"注释的方法",charIndex:1691},{level:3,title:"区分大小写",slug:"区分大小写",normalizedTitle:"区分大小写",charIndex:1781},{level:3,title:"保留关键字",slug:"保留关键字",normalizedTitle:"保留关键字",charIndex:1940}],headersStr:"JavaScript 用法 JavaScript 输出 JavaScript 基本语法 分号的用法 注释的方法 区分大小写 保留关键字",content:'🔗 相关链接：\n\n * 🇨🇳 参考文档：JavaScript | MDN (mozilla.org)\n   * 🚶‍♀️ JavaScript 基础入门：JavaScript 基础 - 学习 Web 开发 | MDN (mozilla.org)\n   * 💾 JavaScript 参考资料：JavaScript 参考 - JavaScript | MDN (mozilla.org)\n\nJavaScript 是一门完备的 动态编程语言。当应用于 HTML 文档时，可为网站提供动态交互特性。应用场合极其广泛，简单到幻灯片、照片库、浮动布局和响应按钮点击，复杂到游戏、2D/3D 动画、大型数据库驱动程序等等。\n\nJavaScript 相当简洁，却非常灵活。开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：\n\n * 浏览器应用程序接口（API）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成 3D 图像与音频样本等等。\n * 第三方 API —— 让开发者可以在自己的站点中整合其它内容提供者提供的功能。\n * 第三方框架和库 —— 用来快速构建网站和应用。\n\n\n# JavaScript 用法\n\n 1. 在 HTML 标签的指定属性中使用脚本：\n\n<button onclick="alert(\'hello\');">我是按钮</button>  \n<a href="javascript:alert(\'aaa\');">超链接</a>  \n\n\n1\n2\n\n 2. script 标签中，可以位于 HTML 页面中的 <body> 和 <head> 部分中。\n\n<script>  \n\t//编写js代码  \n<\/script>  \n\n\n1\n2\n3\n\n\n> 老旧的实例可能会在 <script> 标签中使用 type="text/javascript"。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言。\n\n 3. 引入外部 js 文件\n\n<script type="text/javascript" src="文件路径"><\/script>  \n\n\n1\n\n\n\n# JavaScript 输出\n\n 1. ⚠️ 警告框 alert\n    \n    alert("example");  \n    \n    \n    1\n    \n\n 2. 写入到 HTML 页面的 body 标签中：\n    \n    document.write("example")\n    \n    \n    1\n    \n\n 3. 输出到开发工具的控制台： log + tab 快捷输入\n    \n    console.log("example");  \n    \n    \n    1\n    \n\n\n# JavaScript 基本语法\n\n\n# 分号的用法\n\n * 声明函数不需要使用 ; 分号\n   \n   function functionName(arg0,arg1,arg2){  \n   //函数声明  \n   }  \n   \n   \n   1\n   2\n   3\n   \n\n * ** 赋值语句需要使用 ; **\n   \n   var functionName = function(arg0,arg1,arg2){  \n   //函数表达式  \n   };(注意分号)  \n   \n   \n   1\n   2\n   3\n   \n   \n   > JS 中每条语句以分号结尾。如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写。\n   > \n   > JS 中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。\n   > \n   > 🔗 相关阅读：JavaScript 语句后应该加分号么？ - 尤雨溪的回答 - 知乎\n\n\n# 注释的方法\n\n * 单行注释使用 //\n\n * 多行注释使用\n   \n   /*\n   \texample\n   */\n   \n   \n   1\n   2\n   3\n   \n\n\n# 区分大小写\n\nJavaScript 对大小写是敏感的：例如，函数 getElementById 与 getElementbyID 是不同的。同样，变量 myVariable 与 MyVariable 也是不同的。\n\n提示\n\nJavaScript 常用的命名规则是驼峰法的命名规则。例如， lastName 。\n\n\n# 保留关键字\n\n*          *            *            *\nabstract   else         instanceof   super\nboolean    enum         int          switch\nbreak      export       interface    synchronized\nbyte       extends      let          this\ncase       false        long         throw\ncatch      final        native       throws\nchar       finally      new          transient\nclass      float        null         true\nconst      for          package      try\ncontinue   function     private      typeof\ndebugger   goto         protected    var\ndefault    if           public       void\ndelete     implements   return       volatile\ndo         import       short        while\ndouble     in           static       with',normalizedContent:'🔗 相关链接：\n\n * 🇨🇳 参考文档：javascript | mdn (mozilla.org)\n   * 🚶‍♀️ javascript 基础入门：javascript 基础 - 学习 web 开发 | mdn (mozilla.org)\n   * 💾 javascript 参考资料：javascript 参考 - javascript | mdn (mozilla.org)\n\njavascript 是一门完备的 动态编程语言。当应用于 html 文档时，可为网站提供动态交互特性。应用场合极其广泛，简单到幻灯片、照片库、浮动布局和响应按钮点击，复杂到游戏、2d/3d 动画、大型数据库驱动程序等等。\n\njavascript 相当简洁，却非常灵活。开发者们基于 javascript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：\n\n * 浏览器应用程序接口（api）—— 浏览器内置的 api 提供了丰富的功能，比如：动态创建 html 和设置 css 样式、从用户的摄像头采集处理视频流、生成 3d 图像与音频样本等等。\n * 第三方 api —— 让开发者可以在自己的站点中整合其它内容提供者提供的功能。\n * 第三方框架和库 —— 用来快速构建网站和应用。\n\n\n# javascript 用法\n\n 1. 在 html 标签的指定属性中使用脚本：\n\n<button onclick="alert(\'hello\');">我是按钮</button>  \n<a href="javascript:alert(\'aaa\');">超链接</a>  \n\n\n1\n2\n\n 2. script 标签中，可以位于 html 页面中的 <body> 和 <head> 部分中。\n\n<script>  \n\t//编写js代码  \n<\/script>  \n\n\n1\n2\n3\n\n\n> 老旧的实例可能会在 <script> 标签中使用 type="text/javascript"。现在已经不必这样做了。javascript 是所有现代浏览器以及 html5 中的默认脚本语言。\n\n 3. 引入外部 js 文件\n\n<script type="text/javascript" src="文件路径"><\/script>  \n\n\n1\n\n\n\n# javascript 输出\n\n 1. ⚠️ 警告框 alert\n    \n    alert("example");  \n    \n    \n    1\n    \n\n 2. 写入到 html 页面的 body 标签中：\n    \n    document.write("example")\n    \n    \n    1\n    \n\n 3. 输出到开发工具的控制台： log + tab 快捷输入\n    \n    console.log("example");  \n    \n    \n    1\n    \n\n\n# javascript 基本语法\n\n\n# 分号的用法\n\n * 声明函数不需要使用 ; 分号\n   \n   function functionname(arg0,arg1,arg2){  \n   //函数声明  \n   }  \n   \n   \n   1\n   2\n   3\n   \n\n * ** 赋值语句需要使用 ; **\n   \n   var functionname = function(arg0,arg1,arg2){  \n   //函数表达式  \n   };(注意分号)  \n   \n   \n   1\n   2\n   3\n   \n   \n   > js 中每条语句以分号结尾。如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写。\n   > \n   > js 中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。\n   > \n   > 🔗 相关阅读：javascript 语句后应该加分号么？ - 尤雨溪的回答 - 知乎\n\n\n# 注释的方法\n\n * 单行注释使用 //\n\n * 多行注释使用\n   \n   /*\n   \texample\n   */\n   \n   \n   1\n   2\n   3\n   \n\n\n# 区分大小写\n\njavascript 对大小写是敏感的：例如，函数 getelementbyid 与 getelementbyid 是不同的。同样，变量 myvariable 与 myvariable 也是不同的。\n\n提示\n\njavascript 常用的命名规则是驼峰法的命名规则。例如， lastname 。\n\n\n# 保留关键字\n\n*          *            *            *\nabstract   else         instanceof   super\nboolean    enum         int          switch\nbreak      export       interface    synchronized\nbyte       extends      let          this\ncase       false        long         throw\ncatch      final        native       throws\nchar       finally      new          transient\nclass      float        null         true\nconst      for          package      try\ncontinue   function     private      typeof\ndebugger   goto         protected    var\ndefault    if           public       void\ndelete     implements   return       volatile\ndo         import       short        while\ndouble     in           static       with',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗝 JavaScript 变量与数据类型",frontmatter:{title:"🗝 JavaScript 变量与数据类型",date:"2022-03-10T09:54:01.000Z",permalink:"/pages/b51680/",categories:["🚶 前端入门基础","🍪 JavaScript"],tags:["JavaScript基础"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/30.%20%F0%9F%8D%AA%20JavaScript/02.%20%F0%9F%97%9D%20JavaScript%20%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"100. 🚶 前端入门基础/30. 🍪 JavaScript/02. 🗝 JavaScript 变量与数据类型.md",key:"v-5bff9ca2",path:"/pages/b51680/",headers:[{level:2,title:"JavaScript 变量",slug:"javascript-变量",normalizedTitle:"javascript 变量",charIndex:2},{level:3,title:"字面量",slug:"字面量",normalizedTitle:"字面量",charIndex:20},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:13},{level:3,title:"标识符",slug:"标识符",normalizedTitle:"标识符",charIndex:1134},{level:3,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:1310},{level:3,title:"命名规范",slug:"命名规范",normalizedTitle:"命名规范",charIndex:1964},{level:2,title:"JavaScript 数据类型",slug:"javascript-数据类型",normalizedTitle:"javascript 数据类型",charIndex:2284},{level:3,title:"基本数据类型",slug:"基本数据类型",normalizedTitle:"基本数据类型",charIndex:2445},{level:4,title:"String 字符串",slug:"string-字符串",normalizedTitle:"string 字符串",charIndex:2563},{level:4,title:"Number 数值",slug:"number-数值",normalizedTitle:"number 数值",charIndex:3017},{level:4,title:"BigInt 类型",slug:"bigint-类型",normalizedTitle:"bigint 类型",charIndex:3633},{level:4,title:"Boolean 布尔值",slug:"boolean-布尔值",normalizedTitle:"boolean 布尔值",charIndex:3976},{level:4,title:"Undefined 未定义",slug:"undefined-未定义",normalizedTitle:"undefined 未定义",charIndex:4023},{level:4,title:"Null 空值",slug:"null-空值",normalizedTitle:"null 空值",charIndex:4292},{level:3,title:"引用（对象）类型",slug:"引用-对象-类型",normalizedTitle:"引用（对象）类型",charIndex:4484},{level:3,title:"数据类型的判断",slug:"数据类型的判断",normalizedTitle:"数据类型的判断",charIndex:4659},{level:3,title:"数据类型的转换",slug:"数据类型的转换",normalizedTitle:"数据类型的转换",charIndex:6148},{level:4,title:"转换为字符串 String",slug:"转换为字符串-string",normalizedTitle:"转换为字符串 string",charIndex:6159},{level:4,title:"转换为数字类型 Number",slug:"转换为数字类型-number",normalizedTitle:"转换为数字类型 number",charIndex:6552},{level:4,title:"转换为布尔值 Boolean:",slug:"转换为布尔值-boolean",normalizedTitle:"转换为布尔值 boolean:",charIndex:null},{level:3,title:"相关问题",slug:"相关问题",normalizedTitle:"相关问题",charIndex:8038},{level:2,title:"JavaScript 数组",slug:"javascript-数组",normalizedTitle:"javascript 数组",charIndex:8650},{level:3,title:"创建数组",slug:"创建数组",normalizedTitle:"创建数组",charIndex:8772},{level:3,title:"访问数组",slug:"访问数组",normalizedTitle:"访问数组",charIndex:8993},{level:3,title:"特殊的数组",slug:"特殊的数组",normalizedTitle:"特殊的数组",charIndex:9142},{level:3,title:"数组方法与属性",slug:"数组方法与属性",normalizedTitle:"数组方法与属性",charIndex:9281}],headersStr:"JavaScript 变量 字面量 变量 标识符 常量 命名规范 JavaScript 数据类型 基本数据类型 String 字符串 Number 数值 BigInt 类型 Boolean 布尔值 Undefined 未定义 Null 空值 引用（对象）类型 数据类型的判断 数据类型的转换 转换为字符串 String 转换为数字类型 Number 转换为布尔值 Boolean: 相关问题 JavaScript 数组 创建数组 访问数组 特殊的数组 数组方法与属性",content:'# JavaScript 变量\n\n\n# 字面量\n\n一些固定的值，不可以改变。很少使用，例如：\n\n1 2 3 4 true false null NaN "string"\n\n\n1\n\n\n\n# 变量\n\n用来保存任意的字面量。一般通过变量使用字面量，描述字面量。\n\n声明变量的方法： var 。\n\n在新版标准的 JavaScript 中，不再建议使用 var 。\n\n使用 let 关键字声明变量，例如 let message 。\n\n>  * 一次声明多个变量：\n>    \n>    let user = \'John\',\n>      age = 25,\n>      message = \'Hello\';\n>    \n>    \n>    1\n>    2\n>    3\n>    \n\n * 变量的修改：\n   \n   let message;\n   message = \'Hello!\';\n   message = \'World!\';\n   \n   alert(message);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 变量的拷贝：\n   \n   let hello = \'Hello world!\';\n   let message;\n   \n   // 将字符串 \'Hello world\' 从变量 hello 拷贝到 message\n   message = hello;\n   \n   // 现在两个变量保存着相同的数据\n   alert(hello); // Hello world!\n   alert(message); // Hello world!\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 但是一个变量只能被 let 声明一次，之后在不使用 let 的情况下对其引用，下面是错误的例子：\n   \n   let message = "This";\n   \n   // 重复 \'let\' 会导致 error\n   let message = "That"; // SyntaxError: \'message\' has already been declared\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 通常需要在使用一个变量前定义它。但是在早期，我们可以不使用 let 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 use strict 声明启用严格模式，这仍然可以正常工作，这是为了保持对旧脚本的兼容。 最好每次要使用变量之前都提前声明，以免造成不必要的出错。\n\n\n# 标识符\n\nJavaScript 中可以自主命名的内容。比如：变量名、函数名、属性名。\n\n标识符应该遵守规范：\n\n 1. 标识符中可以含有字母、数字、 _ 、 $ ；\n 2. 标识符不能以数字开头；\n 3. 标识符不能是 JavaScript 中的关键字和保留字；（保留字请可参看上一节笔记）\n 4. 标识符如果包含多个单词一般采用驼峰命名法；\n\n\n# 常量\n\n声明一个常数（不变）变量，可以使用 const 关键字，例如： const myBirthday = \'18.04.1982\'; 。使用 const 声明的变量称为「常量」。它们不能被修改，如果你尝试修改就会发现报错。\n\n * 如果是需要将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。使用大写字母和下划线来命名这些常量。例如：\n   \n   const COLOR_RED = "#F00";\n   const COLOR_GREEN = "#0F0";\n   const COLOR_BLUE = "#00F";\n   const COLOR_ORANGE = "#FF7F00";\n   \n   // ……当我们需要选择一个颜色\n   let color = COLOR_ORANGE;\n   alert(color); // #FF7F00\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   大写命名的常量仅用作「硬编码（hard-coded）」值的别名。\n\n * 而常规命名的常量，可能是在执行期间被「计算」出来，但初始赋值之后就不会改变，例如：\n   \n   const pageLoadTime = /* 网页加载所需的时间 */;\n   \n   \n   1\n   \n   \n   pageLoadTime 的值在页面加载之前是未知的，所以采用常规命名。但是它仍然是个常量，因为赋值之后不会改变。\n\n\n# 命名规范\n\n一个变量名应该有一个清晰、明显的含义，对其存储的数据进行描述。\n\n可以遵循的一个规则：\n\n * 使用易读的命名，比如 userName 或者 shoppingCart 。\n * 远离缩写和短名称！\n * 变量名在能够准确描述变量的同时要足够简洁。不好的例子就是 data 和 value ，这样的名称等于什么都没说。如果能够非常明显地从上下文知道数据和值所表达的含义，这样使用它们也是可以的。\n * 脑海中的术语要和团队保持一致。如果网站的访客称为「用户」，则我们采用相关的变量命名，比如 currentUser 或者 newUser ，而不要使用 currentVisitor 或者一个 newManInTown 。\n\n\n# JavaScript 数据类型\n\nJavaScript 中的值都具有特定的类型。我们可以将任何类型的值存入变量。例如，一个变量可以在前一刻是个字符串，下一刻就存储一个数字。\n\nJavaScript 是动态类型的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型。\n\n\n# 基本数据类型\n\nJavaScript 中有 5 个基本数据类型以及对象 object 类型：\n\n🌟 ES6 新增 symbol 和 bigInt 数据类型；所以共计为 8 种基本的数据类型（7 种原始类型和 1 种引用类型）。\n\n# String 字符串\n\nJavaScript 中的字符串是引号中的任意文本。可以使用单引号或双引号。最近的 JavaScript 版本中添加使用反引号 `` ，它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中。。\n\nlet str = "Hello";\nlet str2 = \'Single quotes are ok too\';\nlet phrase = `can embed another ${str}`;\n\n\n1\n2\n3\n\n\n> 反引号相关：\n> \n>  * ${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。\n>  * 这仅仅在反引号内有效，其他引号不允许这种嵌入。\n\n在 JavaScript 中没有这种类型。只有一种 string 类型，一个字符串可以包含零个（为空）、一个或多个字符。例如：\n\nlet str = \'\'\n\n\n1\n\n\n# Number 数值\n\n所有的整数和浮点数都是 Number 类型；\n\n// 最大表示的数值\nNumber.MAX_VALUE= 1.7976931348623157e+308\n// 特殊的数值\na = Infinity // 正无穷\na = -Infinity // 负无穷\nNaN // 非法数值\n\n0b...  // 表示二进制数值\n0... // 表示八进制数值\n0x... // 表示十六进制数值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n数字可以有很多操作，比如，乘法 * 、除法 / 、加法 + 、减法 - 等等。下一节运算符有介绍。\n\n在 JavaScript 中做数学运算是安全的，可以进行任何的数学运算包括除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，会得到 NaN 的结果。\n\n特殊的数值：\n\n * Infinity 代表无穷大 ∞。是一个比任何数字都大的特殊值。\n   \n   可以通过除以 0 来得到它。或者在代码中直接使用 Infinity 。\n\n * NaN 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果。\n   \n   NaN 是粘性的，任何对 NaN 的进一步数学运算都会返回 NaN 。所以，如果在数学表达式中有一个 NaN ，会被传播到最终结果（只有一个例外： NaN ** 0 结果为 1 ）。\n\n# BigInt 类型\n\n在 JavaScript 中， Number 类型无法表示大于 (2^53-1) （即 9007199254740991 ），或小于 -(2^53-1) 的整数。这是其内部表示形式导致的技术限制。\n\nBigInt 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。用于需要很大的数字，例如用于加密或微秒精度的时间戳。\n\n * 可以通过将 n 附加到整数字段的末尾来创建 BigInt 值，例如：\n   \n   // 尾部的 "n" 表示这是一个 BigInt 类型\n   const bigInt = 1234567890123456789012345678901234567890n;\n   \n   \n   1\n   2\n   \n\n# Boolean 布尔值\n\n用于逻辑的判断，只有两个值： true 或。 false 。\n\n# Undefined 未定义\n\n声明一个变量但没有赋值，此时变量的值为 undefined . 特殊值 undefined 和 null 一样自成类型。从技术上讲，可以显式地将 undefined 赋值给变量：\n\nlet age = 100;\n\n// 将值修改为 undefined\nage = undefined; // 不建议\n\n\n1\n2\n3\n4\n\n\n通常，使用 null 将一个「空」或者「未知」的值写入变量中，而 undefined 则保留作为未进行初始化的事物的默认初始值，所以不显示赋值也会自动为 undefined 。\n\n# Null 空值\n\n特殊的 null 值不属于上述任何一种类型。表示空的对象。使用 typeof 会返回 object ；\n\nJavaScript 中的 null 不是一个「对不存在的 object 的引用」或者 「null 指针」。JavaScript 中的 null 仅仅是一个代表「无」、「空」或「值未知」的特殊值。\n\n例如：\n\nlet age = null;\n\n\n1\n\n\n\n# 引用（对象）类型\n\nobject 类型是一个特殊的类型。其他所有的数据类型都被称为「原始类型」，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反， object 则用于储存数据集合和更复杂的实体。\n\nObject ：任意对象。\n\nFunction ：函数对象，是特殊的可以执行的对象。\n\nArray ：数组对象（内部数据有序）\n\n\n# 数据类型的判断\n\n 1. typeof 返回一个字符串（开头小写），表示未经计算的操作数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。\n    * 可以判断： undefined , 数值，字符串，布尔值， function\n    * ⭐️ 不能判断： null 与 object ， object 与 array （明确区分）\n\ntypeof undefined // "undefined"\n\ntypeof 0 // "number"\n\ntypeof 10n // "bigint"\n\ntypeof true // "boolean"\n\ntypeof "foo" // "string"\n\ntypeof Symbol("id") // "symbol"\n\ntypeof Math // "object"  (1)\n\ntypeof null // "object"  (2)\n\ntypeof alert // "function"  (3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n>  * 关于 null ： 这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。 null 绝对不是一个 object 。 null 有自己的类型，它是一个特殊值。 typeof 的行为在这里是错误的。\n\nvar a\nconsole.log(a, typeof a, typeof a === \'undefined\', a === undefined)\n// undefined \'undefined\' true true\n\n\n1\n2\n3\n\n 2. instanceof() ： 专门判断对象的具体类型。\n\nvar b1 = {\n  b2 : [1, \'abc\', console.log],\n  b3: function () {\n    console.log(\'b3\')\n    return function(){\n      return \'testFunction\'\n    }\n  }\n}\n\nconsole.log(b1 instanceof Object, b1 instanceof Array) // true false\nconsole.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true\nconsole.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true\n\nconsole.log(typeof b1.b3 === \'function\') // true \n\nconsole.log(typeof b1.b2[2] === \'function\') // true\nb1.b2[2](4) // 函数用加括号可以调用（表达式）\n\nconsole.log(b1.b3()()) // b3 // testFunction\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 3. === 全等：可以判断 undefined / null\n\nvar a\na = null\nconsole.log(typeof a, a===null) // object true \n\n\n1\n2\n3\n\n\n\n# 数据类型的转换\n\n# 转换为字符串 String\n\n 1. 调用被转换数据的 toString() 方法（强制类型转换）；\n\nvar a = 123;\na = a.toString();\nconsole.log(typeof(a)); // string\n\n\n1\n2\n3\n\n\n注：不适用于 null 和 undefined ；\n\n 2. 调用 String() 方法（强制类型转换）：\n\nvar a = 123;\na = String(a);\n\n\n1\n2\n\n\n注：对于 null 值，直接转换为字符串 "null" ，对于 undefined 直接转换为字符串 "undefined" ；\n\n 3. 添加空字符串：为任意的数据类型 + “” （隐式类型转换）：\n\nvar a = true;\na = a + "";\nconsole.log(typeof(a)); // string\n\n\n1\n2\n3\n\n\n# 转换为数字类型 Number\n\n 1. 调用转换函数 Number() （强制类型转换）：\n\nvar s = "123";\ns = Number(s);\n\n\n1\n2\n\n\n> 转换的情况：\n> \n>  1. 字符串 => 数字\n>     如果字符串是一个合法的数字，则直接转换为对应的数字\n>     如果字符串是一个非法的数字，则转换为 NaN\n>     如果是一个空串或纯空格的字符串，则转换为 0\n>  2. 布尔值 => 数字\n>     true 转换为 1\n>     false 转换为 0\n>  3. 空值 => 数字\n>     null 转换为 0\n>  4. 未定义 => 数字\n>     undefined 转换为 NaN\n\n * 2️⃣ 调用转换方法 parseInt() 或 parseFloat() （强制类型转换）：\n   \n   对于非完全数字的字符回将有效的数值为转换为相应的 Number ：\n   \n   var a = "3.14159 px";\n   b = parseInt(a);\n   console.log(b); // 3\n   \n   c = parseFloat(a);\n   console.log(c); // 3.14159\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 3️⃣ 使用一元 + （隐式类型转换）：\n   \n   原理与使用 Number() 相同。\n   \n   var a = "123";\n   a =+a;\n   \n   \n   1\n   2\n   \n\n# 转换为布尔值 Boolean :\n\n 1. 使用 Boolean() 函数 （强制类型转换）：\n\nvar s = \'false\';\ns = Boolean(s);\nconsole.log(s); // true\n\n\n1\n2\n3\n\n\n> 转换的情况：\n> \n>  1. 字符串 => 布尔：\n>     除了空串其余全是 true ；\n> \n>  2. 数值 => 布尔：\n>     除了 0 和 NaN 其余的全是 true ；\n> \n>  3. null、undefined => 布尔：\n>     都是 false\n> \n>  4. 对象 => 布尔：\n>     都是 true\n\n 2. 隐式类型转换：\n\n为任意的数据类型做两次非运算，即可将其转换为布尔值；\n\nvar a = "hello";\na = !!a; // true\n\n\n1\n2\n\n 3. 符号串的对比\n\nJavascript 字符串在进行大于 (小于) 比较时，会根据第一个不同的字符的 ASCII 值码进行比较，当数字与字符串进行比较大小时，会强制的将数字转换成字符串然后再进行比较：\n\n    console.log(\'13\'>\'3\'); // 输出：false\n    console.log(5>\'6\');  // 输出： false\n    console.log(\'d\'>\'ABDC\') // 输出： true\n    console.log(19>\'ssf\') // 输出 false\n    console.log(\'A\'>\'abcdef\') // 输出 false\n\n\n1\n2\n3\n4\n5\n\n\n手动转换为 ASCII 码，用正负数表示大小：\n\nsorter={(a:string,b:string)=> a.charCodeAt()-b.charCodeAt()}\n\n\n1\n\n\n\n# 相关问题\n\n * undefined 和 null 的区别：\n\nundefined 代表声明了变量但是没有赋值；\n\nnull 代表声明并且赋值了变量，值为 null ；\n\n * 将变量赋值为 null 的情况：\n   \n   1. 初始赋值，表明要赋值为对象，用作占位符。\n   2. 结束前，使对象成为垃圾对象。（使用垃圾回收器回收）\n   \n   var a = null; // 初始化，null作占位符\n   a = [\'test\',123]; // 确定为对象时，赋值\n   // ...\n   a = null; // 最后回收对象\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 严格区分变量类型和数据类型：\n   \n   * 数据的类型：基本类型与对象类型\n   * 变量的类型（变量内存值的类型）\n     * 基本类型：保存就是基本类型的数据\n     * 引用类型：保存的是地址值（对象类型）\n\n * 基本数据类型的数据，变量是直接保存的它的值。\n   变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。\n\n * 引用数据类型的数据，变量是保存的对象的引用（内存地址）。\n   如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。\n\n * 比较两个变量时，对于基本数据类型，比较的就是值，对于引用数据类型，比较的是地址，地址相同才相同；\n\n\n# JavaScript 数组\n\n数组对象的作用是：使用单独的变量名来存储一系列的有序的值。\n\n * 数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。\n * 数组中的每个元素都有自己的的标识，以便它可以很容易地被访问到。\n\n\n# 创建数组\n\n常规方法： new\n\nvar myCars = new Array();\nmyCars[0] = "Saab" \nmyCars[1] = "Volvo"\nmyCars[2] = "BMW"\n\n\n1\n2\n3\n4\n\n\n简洁方法：\n\nvar Cars = new Array("Saab", "Volvo", "BMW")\n\n\n1\n\n\n字面：\n\nvar myCars = ["Saab","Volvo","BMW"]\n\n\n1\n\n\n\n# 访问数组\n\n访问数组可以通过指定数组名或者索引，访问某个特定的值。\n\n * 获取值：\n   \n   var carName = myCars[0]\n   \n   \n   1\n   \n\n * 修改值：\n   \n   myCars[0] = "TOYOTA"\n   \n   \n   1\n   \n\n\n# 特殊的数组\n\n在 JavaScript 中，所有的变量都是对象，数组中可以有不同的变量类型，即数组可以包含对象元素、函数、数组：\n\nmyArray[0]=Date.now\nmyArray[1]=myFunction\nmyArray[2]=myCars\n\n\n1\n2\n3\n\n\n\n# 数组方法与属性\n\n> 📃 相关参考：数组 - 学习 Web 开发 | MDN (mozilla.org) | JavaScript Array 对象 | 菜鸟教程 (runoob.com)',normalizedContent:'# javascript 变量\n\n\n# 字面量\n\n一些固定的值，不可以改变。很少使用，例如：\n\n1 2 3 4 true false null nan "string"\n\n\n1\n\n\n\n# 变量\n\n用来保存任意的字面量。一般通过变量使用字面量，描述字面量。\n\n声明变量的方法： var 。\n\n在新版标准的 javascript 中，不再建议使用 var 。\n\n使用 let 关键字声明变量，例如 let message 。\n\n>  * 一次声明多个变量：\n>    \n>    let user = \'john\',\n>      age = 25,\n>      message = \'hello\';\n>    \n>    \n>    1\n>    2\n>    3\n>    \n\n * 变量的修改：\n   \n   let message;\n   message = \'hello!\';\n   message = \'world!\';\n   \n   alert(message);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 变量的拷贝：\n   \n   let hello = \'hello world!\';\n   let message;\n   \n   // 将字符串 \'hello world\' 从变量 hello 拷贝到 message\n   message = hello;\n   \n   // 现在两个变量保存着相同的数据\n   alert(hello); // hello world!\n   alert(message); // hello world!\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 但是一个变量只能被 let 声明一次，之后在不使用 let 的情况下对其引用，下面是错误的例子：\n   \n   let message = "this";\n   \n   // 重复 \'let\' 会导致 error\n   let message = "that"; // syntaxerror: \'message\' has already been declared\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 通常需要在使用一个变量前定义它。但是在早期，我们可以不使用 let 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 use strict 声明启用严格模式，这仍然可以正常工作，这是为了保持对旧脚本的兼容。 最好每次要使用变量之前都提前声明，以免造成不必要的出错。\n\n\n# 标识符\n\njavascript 中可以自主命名的内容。比如：变量名、函数名、属性名。\n\n标识符应该遵守规范：\n\n 1. 标识符中可以含有字母、数字、 _ 、 $ ；\n 2. 标识符不能以数字开头；\n 3. 标识符不能是 javascript 中的关键字和保留字；（保留字请可参看上一节笔记）\n 4. 标识符如果包含多个单词一般采用驼峰命名法；\n\n\n# 常量\n\n声明一个常数（不变）变量，可以使用 const 关键字，例如： const mybirthday = \'18.04.1982\'; 。使用 const 声明的变量称为「常量」。它们不能被修改，如果你尝试修改就会发现报错。\n\n * 如果是需要将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。使用大写字母和下划线来命名这些常量。例如：\n   \n   const color_red = "#f00";\n   const color_green = "#0f0";\n   const color_blue = "#00f";\n   const color_orange = "#ff7f00";\n   \n   // ……当我们需要选择一个颜色\n   let color = color_orange;\n   alert(color); // #ff7f00\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   大写命名的常量仅用作「硬编码（hard-coded）」值的别名。\n\n * 而常规命名的常量，可能是在执行期间被「计算」出来，但初始赋值之后就不会改变，例如：\n   \n   const pageloadtime = /* 网页加载所需的时间 */;\n   \n   \n   1\n   \n   \n   pageloadtime 的值在页面加载之前是未知的，所以采用常规命名。但是它仍然是个常量，因为赋值之后不会改变。\n\n\n# 命名规范\n\n一个变量名应该有一个清晰、明显的含义，对其存储的数据进行描述。\n\n可以遵循的一个规则：\n\n * 使用易读的命名，比如 username 或者 shoppingcart 。\n * 远离缩写和短名称！\n * 变量名在能够准确描述变量的同时要足够简洁。不好的例子就是 data 和 value ，这样的名称等于什么都没说。如果能够非常明显地从上下文知道数据和值所表达的含义，这样使用它们也是可以的。\n * 脑海中的术语要和团队保持一致。如果网站的访客称为「用户」，则我们采用相关的变量命名，比如 currentuser 或者 newuser ，而不要使用 currentvisitor 或者一个 newmanintown 。\n\n\n# javascript 数据类型\n\njavascript 中的值都具有特定的类型。我们可以将任何类型的值存入变量。例如，一个变量可以在前一刻是个字符串，下一刻就存储一个数字。\n\njavascript 是动态类型的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型。\n\n\n# 基本数据类型\n\njavascript 中有 5 个基本数据类型以及对象 object 类型：\n\n🌟 es6 新增 symbol 和 bigint 数据类型；所以共计为 8 种基本的数据类型（7 种原始类型和 1 种引用类型）。\n\n# string 字符串\n\njavascript 中的字符串是引号中的任意文本。可以使用单引号或双引号。最近的 javascript 版本中添加使用反引号 `` ，它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中。。\n\nlet str = "hello";\nlet str2 = \'single quotes are ok too\';\nlet phrase = `can embed another ${str}`;\n\n\n1\n2\n3\n\n\n> 反引号相关：\n> \n>  * ${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。\n>  * 这仅仅在反引号内有效，其他引号不允许这种嵌入。\n\n在 javascript 中没有这种类型。只有一种 string 类型，一个字符串可以包含零个（为空）、一个或多个字符。例如：\n\nlet str = \'\'\n\n\n1\n\n\n# number 数值\n\n所有的整数和浮点数都是 number 类型；\n\n// 最大表示的数值\nnumber.max_value= 1.7976931348623157e+308\n// 特殊的数值\na = infinity // 正无穷\na = -infinity // 负无穷\nnan // 非法数值\n\n0b...  // 表示二进制数值\n0... // 表示八进制数值\n0x... // 表示十六进制数值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n数字可以有很多操作，比如，乘法 * 、除法 / 、加法 + 、减法 - 等等。下一节运算符有介绍。\n\n在 javascript 中做数学运算是安全的，可以进行任何的数学运算包括除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，会得到 nan 的结果。\n\n特殊的数值：\n\n * infinity 代表无穷大 ∞。是一个比任何数字都大的特殊值。\n   \n   可以通过除以 0 来得到它。或者在代码中直接使用 infinity 。\n\n * nan 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果。\n   \n   nan 是粘性的，任何对 nan 的进一步数学运算都会返回 nan 。所以，如果在数学表达式中有一个 nan ，会被传播到最终结果（只有一个例外： nan ** 0 结果为 1 ）。\n\n# bigint 类型\n\n在 javascript 中， number 类型无法表示大于 (2^53-1) （即 9007199254740991 ），或小于 -(2^53-1) 的整数。这是其内部表示形式导致的技术限制。\n\nbigint 类型是最近被添加到 javascript 语言中的，用于表示任意长度的整数。用于需要很大的数字，例如用于加密或微秒精度的时间戳。\n\n * 可以通过将 n 附加到整数字段的末尾来创建 bigint 值，例如：\n   \n   // 尾部的 "n" 表示这是一个 bigint 类型\n   const bigint = 1234567890123456789012345678901234567890n;\n   \n   \n   1\n   2\n   \n\n# boolean 布尔值\n\n用于逻辑的判断，只有两个值： true 或。 false 。\n\n# undefined 未定义\n\n声明一个变量但没有赋值，此时变量的值为 undefined . 特殊值 undefined 和 null 一样自成类型。从技术上讲，可以显式地将 undefined 赋值给变量：\n\nlet age = 100;\n\n// 将值修改为 undefined\nage = undefined; // 不建议\n\n\n1\n2\n3\n4\n\n\n通常，使用 null 将一个「空」或者「未知」的值写入变量中，而 undefined 则保留作为未进行初始化的事物的默认初始值，所以不显示赋值也会自动为 undefined 。\n\n# null 空值\n\n特殊的 null 值不属于上述任何一种类型。表示空的对象。使用 typeof 会返回 object ；\n\njavascript 中的 null 不是一个「对不存在的 object 的引用」或者 「null 指针」。javascript 中的 null 仅仅是一个代表「无」、「空」或「值未知」的特殊值。\n\n例如：\n\nlet age = null;\n\n\n1\n\n\n\n# 引用（对象）类型\n\nobject 类型是一个特殊的类型。其他所有的数据类型都被称为「原始类型」，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反， object 则用于储存数据集合和更复杂的实体。\n\nobject ：任意对象。\n\nfunction ：函数对象，是特殊的可以执行的对象。\n\narray ：数组对象（内部数据有序）\n\n\n# 数据类型的判断\n\n 1. typeof 返回一个字符串（开头小写），表示未经计算的操作数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。\n    * 可以判断： undefined , 数值，字符串，布尔值， function\n    * ⭐️ 不能判断： null 与 object ， object 与 array （明确区分）\n\ntypeof undefined // "undefined"\n\ntypeof 0 // "number"\n\ntypeof 10n // "bigint"\n\ntypeof true // "boolean"\n\ntypeof "foo" // "string"\n\ntypeof symbol("id") // "symbol"\n\ntypeof math // "object"  (1)\n\ntypeof null // "object"  (2)\n\ntypeof alert // "function"  (3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n>  * 关于 null ： 这是官方承认的 typeof 的错误，这个问题来自于 javascript 语言的早期阶段，并为了兼容性而保留了下来。 null 绝对不是一个 object 。 null 有自己的类型，它是一个特殊值。 typeof 的行为在这里是错误的。\n\nvar a\nconsole.log(a, typeof a, typeof a === \'undefined\', a === undefined)\n// undefined \'undefined\' true true\n\n\n1\n2\n3\n\n 2. instanceof() ： 专门判断对象的具体类型。\n\nvar b1 = {\n  b2 : [1, \'abc\', console.log],\n  b3: function () {\n    console.log(\'b3\')\n    return function(){\n      return \'testfunction\'\n    }\n  }\n}\n\nconsole.log(b1 instanceof object, b1 instanceof array) // true false\nconsole.log(b1.b2 instanceof array, b1.b2 instanceof object) // true true\nconsole.log(b1.b3 instanceof function, b1.b3 instanceof object) // true true\n\nconsole.log(typeof b1.b3 === \'function\') // true \n\nconsole.log(typeof b1.b2[2] === \'function\') // true\nb1.b2[2](4) // 函数用加括号可以调用（表达式）\n\nconsole.log(b1.b3()()) // b3 // testfunction\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 3. === 全等：可以判断 undefined / null\n\nvar a\na = null\nconsole.log(typeof a, a===null) // object true \n\n\n1\n2\n3\n\n\n\n# 数据类型的转换\n\n# 转换为字符串 string\n\n 1. 调用被转换数据的 tostring() 方法（强制类型转换）；\n\nvar a = 123;\na = a.tostring();\nconsole.log(typeof(a)); // string\n\n\n1\n2\n3\n\n\n注：不适用于 null 和 undefined ；\n\n 2. 调用 string() 方法（强制类型转换）：\n\nvar a = 123;\na = string(a);\n\n\n1\n2\n\n\n注：对于 null 值，直接转换为字符串 "null" ，对于 undefined 直接转换为字符串 "undefined" ；\n\n 3. 添加空字符串：为任意的数据类型 + “” （隐式类型转换）：\n\nvar a = true;\na = a + "";\nconsole.log(typeof(a)); // string\n\n\n1\n2\n3\n\n\n# 转换为数字类型 number\n\n 1. 调用转换函数 number() （强制类型转换）：\n\nvar s = "123";\ns = number(s);\n\n\n1\n2\n\n\n> 转换的情况：\n> \n>  1. 字符串 => 数字\n>     如果字符串是一个合法的数字，则直接转换为对应的数字\n>     如果字符串是一个非法的数字，则转换为 nan\n>     如果是一个空串或纯空格的字符串，则转换为 0\n>  2. 布尔值 => 数字\n>     true 转换为 1\n>     false 转换为 0\n>  3. 空值 => 数字\n>     null 转换为 0\n>  4. 未定义 => 数字\n>     undefined 转换为 nan\n\n * 2️⃣ 调用转换方法 parseint() 或 parsefloat() （强制类型转换）：\n   \n   对于非完全数字的字符回将有效的数值为转换为相应的 number ：\n   \n   var a = "3.14159 px";\n   b = parseint(a);\n   console.log(b); // 3\n   \n   c = parsefloat(a);\n   console.log(c); // 3.14159\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 3️⃣ 使用一元 + （隐式类型转换）：\n   \n   原理与使用 number() 相同。\n   \n   var a = "123";\n   a =+a;\n   \n   \n   1\n   2\n   \n\n# 转换为布尔值 boolean :\n\n 1. 使用 boolean() 函数 （强制类型转换）：\n\nvar s = \'false\';\ns = boolean(s);\nconsole.log(s); // true\n\n\n1\n2\n3\n\n\n> 转换的情况：\n> \n>  1. 字符串 => 布尔：\n>     除了空串其余全是 true ；\n> \n>  2. 数值 => 布尔：\n>     除了 0 和 nan 其余的全是 true ；\n> \n>  3. null、undefined => 布尔：\n>     都是 false\n> \n>  4. 对象 => 布尔：\n>     都是 true\n\n 2. 隐式类型转换：\n\n为任意的数据类型做两次非运算，即可将其转换为布尔值；\n\nvar a = "hello";\na = !!a; // true\n\n\n1\n2\n\n 3. 符号串的对比\n\njavascript 字符串在进行大于 (小于) 比较时，会根据第一个不同的字符的 ascii 值码进行比较，当数字与字符串进行比较大小时，会强制的将数字转换成字符串然后再进行比较：\n\n    console.log(\'13\'>\'3\'); // 输出：false\n    console.log(5>\'6\');  // 输出： false\n    console.log(\'d\'>\'abdc\') // 输出： true\n    console.log(19>\'ssf\') // 输出 false\n    console.log(\'a\'>\'abcdef\') // 输出 false\n\n\n1\n2\n3\n4\n5\n\n\n手动转换为 ascii 码，用正负数表示大小：\n\nsorter={(a:string,b:string)=> a.charcodeat()-b.charcodeat()}\n\n\n1\n\n\n\n# 相关问题\n\n * undefined 和 null 的区别：\n\nundefined 代表声明了变量但是没有赋值；\n\nnull 代表声明并且赋值了变量，值为 null ；\n\n * 将变量赋值为 null 的情况：\n   \n   1. 初始赋值，表明要赋值为对象，用作占位符。\n   2. 结束前，使对象成为垃圾对象。（使用垃圾回收器回收）\n   \n   var a = null; // 初始化，null作占位符\n   a = [\'test\',123]; // 确定为对象时，赋值\n   // ...\n   a = null; // 最后回收对象\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 严格区分变量类型和数据类型：\n   \n   * 数据的类型：基本类型与对象类型\n   * 变量的类型（变量内存值的类型）\n     * 基本类型：保存就是基本类型的数据\n     * 引用类型：保存的是地址值（对象类型）\n\n * 基本数据类型的数据，变量是直接保存的它的值。\n   变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。\n\n * 引用数据类型的数据，变量是保存的对象的引用（内存地址）。\n   如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。\n\n * 比较两个变量时，对于基本数据类型，比较的就是值，对于引用数据类型，比较的是地址，地址相同才相同；\n\n\n# javascript 数组\n\n数组对象的作用是：使用单独的变量名来存储一系列的有序的值。\n\n * 数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。\n * 数组中的每个元素都有自己的的标识，以便它可以很容易地被访问到。\n\n\n# 创建数组\n\n常规方法： new\n\nvar mycars = new array();\nmycars[0] = "saab" \nmycars[1] = "volvo"\nmycars[2] = "bmw"\n\n\n1\n2\n3\n4\n\n\n简洁方法：\n\nvar cars = new array("saab", "volvo", "bmw")\n\n\n1\n\n\n字面：\n\nvar mycars = ["saab","volvo","bmw"]\n\n\n1\n\n\n\n# 访问数组\n\n访问数组可以通过指定数组名或者索引，访问某个特定的值。\n\n * 获取值：\n   \n   var carname = mycars[0]\n   \n   \n   1\n   \n\n * 修改值：\n   \n   mycars[0] = "toyota"\n   \n   \n   1\n   \n\n\n# 特殊的数组\n\n在 javascript 中，所有的变量都是对象，数组中可以有不同的变量类型，即数组可以包含对象元素、函数、数组：\n\nmyarray[0]=date.now\nmyarray[1]=myfunction\nmyarray[2]=mycars\n\n\n1\n2\n3\n\n\n\n# 数组方法与属性\n\n> 📃 相关参考：数组 - 学习 web 开发 | mdn (mozilla.org) | javascript array 对象 | 菜鸟教程 (runoob.com)',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧮 JavaScript 运算符",frontmatter:{title:"🧮 JavaScript 运算符",date:"2022-03-10T10:16:48.000Z",permalink:"/pages/f8003b/",categories:["🚶 前端入门基础","🍪 JavaScript"],tags:["JavaScript基础"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/30.%20%F0%9F%8D%AA%20JavaScript/03.%20%F0%9F%A7%AE%20JavaScript%20%E8%BF%90%E7%AE%97%E7%AC%A6.html",relativePath:"100. 🚶 前端入门基础/30. 🍪 JavaScript/03. 🧮 JavaScript 运算符.md",key:"v-3baa6731",path:"/pages/f8003b/",headers:[{level:3,title:"算术运算符",slug:"算术运算符",normalizedTitle:"算术运算符",charIndex:31},{level:3,title:"一元运算符",slug:"一元运算符",normalizedTitle:"一元运算符",charIndex:2100},{level:3,title:"运算符优先级",slug:"运算符优先级",normalizedTitle:"运算符优先级",charIndex:2806},{level:3,title:"逻辑运算符",slug:"逻辑运算符",normalizedTitle:"逻辑运算符",charIndex:2902},{level:4,title:"??空值合并",slug:"空值合并",normalizedTitle:"?? 空值合并",charIndex:4513},{level:3,title:"赋值运算符",slug:"赋值运算符",normalizedTitle:"赋值运算符",charIndex:5575},{level:3,title:"关系运算符",slug:"关系运算符",normalizedTitle:"关系运算符",charIndex:5977},{level:3,title:"三元运算符",slug:"三元运算符",normalizedTitle:"三元运算符",charIndex:6944},{level:3,title:"逗号运算符",slug:"逗号运算符",normalizedTitle:"逗号运算符",charIndex:7054}],headersStr:"算术运算符 一元运算符 运算符优先级 逻辑运算符 ??空值合并 赋值运算符 关系运算符 三元运算符 逗号运算符",content:'运算符也称为操作符，对一个或多个值进行运算或者操作。\n\n\n# 算术运算符\n\n运算符   描述   例子       X 结果   Y 结果\n+     加法   x=y+2    7      5\n-     减法   x=y-2    3      5\n*     乘法   x=y*2    10     5\n/     除法   x=y/2    2.5    5\n%     取模   x=y%2    1      5\n**    求幂   x=y**2   25     5\n++    自增   x=++y    6      6\n           x=y++    5      6\n--    自减   x=--y    4      4\n           x=y--    5      4\n\n * 特殊的二元运算：除了加法以外，对非 Number 类型的值进行运算时，都会先转换为 Number 然后在做运算。\n   \n   x = 6 - \'2\' // 4\n   y = \'6\' / \'2\' // 3\n   \n   \n   1\n   2\n   \n\n * 对于加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。任何值和字符串做加法，都会先转换为字符串，然后再拼串。二元 + 是唯一一个以这种方式支持字符串的运算符。\n   \n   x = 5 + 5;\n   y = "5" + 5; // \'55\'\n   z = "hello" + 5; // \'hello5\'\n   \n   // 特别地，\n   a = 2 + 2 + \'1\' // \'41\'\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 注意：自增 / 自减只能应用于变量。试一下，将其应用于数值（比如 5++ ）则会报错。\n\n * 运算符 ++ 和 -- 可以置于变量前，也可以置于变量后。\n   \n   * 当运算符置于变量后，被称为「后置形式」： counter++ 。\n   * 当运算符置于变量前，被称为「前置形式」： ++counter 。\n   \n   > 所有的运算符都有返回值。自增 / 自减也不例外。前置形式返回一个新的值，但后置返回原来的值（做加法 / 减法之前的值）。\n   > \n   >  * 前置形式：对 counter 做自增运算，返回的是新的值 2 。因此 alert 显示的是 2 。\n   > \n   > let counter = 1;\n   > let a = ++counter; // (*)\n   > \n   > alert(a); // 2\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   >  * 后置形式：它同样对 counter 做加法，但是返回的是 旧值（做加法之前的值）。因此 alert 显示的是 1 。\n   > \n   > let counter = 1;\n   > let a = counter++;\n   > \n   > alert(a); // 1\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   >  * 但是如果自增 / 自减的值不会被使用，那么两者形式没有区别：\n   > \n   > let counter = 0;\n   > counter++;\n   > ++counter;\n   > alert( counter );\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   >  * 对变量进行自增操作，并且 需要立刻使用自增后的值，那么我们需要使用前置形式： alert(++counter); // 1 ；想要将一个数加一，但是想使用其自增之前的值，那么需要使用后置形式： alert( counter++ ); // 0 。\n   \n   > 自增 / 自减和其它运算符的对比： ++/-- 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。\n   > \n   > let counter = 1;\n   > alert( 2 * ++counter ); // 4\n   > \n   > \n   > 1\n   > 2\n   > \n   > \n   > let counter = 1;\n   > alert( 2 * counter++ ); // 2\n   > \n   > \n   > 1\n   > 2\n   > \n   > \n   > > 上述列子降低了代码的可读性，并不推荐。还是建议依照「一行一个行为」的原则。\n   > > \n   > > let counter = 1;\n   > > alert( 2 * counter );\n   > > counter++;\n   > > \n   > > \n   > > 1\n   > > 2\n   > > 3\n\n\n# 一元运算符\n\n表示运算时操作数只要一个：\n\n * + 正号，不会对数字值产生任何影响，但是可以 ** 将一个非数字转换为数字：** 它的效果和 Number(...) 相同，但是更加简短。\n   \n   let a = true;  \n   a = +a;  // 1\n   \n   let b = ""\n   b = +"" // 0\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 经常会有将字符串转化为数字的需求。比如，如果我们正在从 HTML 表单中取值，通常得到的都是字符串。如果我们想对它们求和：\n   > \n   > let apples = "2";\n   > let oranges = "3";\n   > // 在二元运算符加号起作用之前，所有的值都被转化为了数字\n   > alert( +apples + +oranges ); // 5\n   > \n   > // 更长的写法\n   > // alert( Number(apples) + Number(oranges) ); // 5\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > \n   > \n   > > 也可以从上面例子看出，一元运算符先于二元运算符作用于运算元。\n\n * - 符号，对一个数字进行符号位取反：\n   \n   var a = true;  \n   a = -a;  // -0\n   \n   \n   1\n   2\n   \n   \n   对字符串运用会得到结果 NaN ；\n\n\n# 运算符优先级\n\n在 JavaScript 中有众多运算符。每个运算符都有对应的优先级数字。** 数字越大，越先执行。** 如果优先级相同，则按照由左至右的顺序执行。\n\n运算符优先级表\n\n\n# 逻辑运算符\n\n逻辑运算符 (javascript.info)\n\n逻辑运算符用于测定变量或值之间的逻辑。\n\n运算符   描述            例子\n&&    and 所有为真才为真   (x < 10 && y> 1) 为 true\n||    or 有一个为真即为真   (x==5 || y==5) 为 false\n!     not           !(x==y) 为 true\n\n * 或 || 运算符的应用：大多数情况下，逻辑或 || 会被用在 if 语句中，用来测试是否有 任何 给定的条件为 true 。\n   \n   let hour = 9;\n   \n   if (hour < 10 || hour > 18) {\n     alert( \'The office is closed.\' );\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 或运算寻找第一个真值：一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。\n   \n   * 获取变量列表或者表达式中的第一个真值。：\n     \n     let firstName = "";\n     let lastName = "";\n     let nickName = "SuperCoder";\n     \n     alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n   \n   * 短路求值： || 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数。如果操作数不仅仅是一个值，而是一个有副作用的表达式，例如变量赋值或函数调用，那么这一特性的重要性就变得显而易见了。\n     \n     true || alert("not printed"); // alert没有被运行\n     false || alert("printed");\n     \n     \n     1\n     2\n     \n\n * 与运算寻找第一个假值：与和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。\n   \n   // 如果第一个操作数是真值，\n   // 与运算返回第二个操作数：\n   alert( 1 && 0 ); // 0\n   alert( 1 && 5 ); // 5\n   \n   // 如果第一个操作数是假值，\n   // 与运算将直接返回它。第二个操作数会被忽略\n   alert( null && 5 ); // null\n   alert( 0 && "no matter what" ); // 0\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   * 如果所有的值都是真值，最后一个值将会被返回：\n     \n     alert( 1 && 2 && 3 ); // 3，最后一个值\n     \n     \n     1\n     \n\n * 与运算 && 在或运算 || 之前进行：与运算 && 的优先级比或运算 || 要高。所以代码 a && b || c && d 跟 && 表达式加了括号完全一样： (a && b) || (c && d) 。\n\n * 使用非运算 !! 有时候用来将某个值转化为布尔类型：\n   \n   alert( !!"non-empty string" ); // true\n   alert( !!null ); // false\n   \n   \n   1\n   2\n   \n\n# ?? 空值合并\n\n> a ?? b 的结果是：\n> \n>  * 如果 a 是已定义的，则结果为 a ，\n>  * 如果 a 不是已定义的，则结果为 b 。\n\n如果第一个参数不是 null/undefined ，则 ?? 返回第一个参数。否则，返回第二个参数。\n\n应用场景：\n\n * 提供默认值：如果 user 的值不为 null/undefined 则显示 user ，否则显示 匿名 ：\n   \n   let user;\n   alert(user ?? "匿名");\n   \n   \n   1\n   2\n   \n   \n   let user = "John";\n   alert(user ?? "匿名");\n   \n   \n   1\n   2\n   \n\n * 选择出第一个非 null/undefined 的值。\n   \n   let firstName = null;\n   let lastName = null;\n   let nickName = "Supercoder";\n   \n   // 显示第一个已定义的值：\n   alert(firstName ?? lastName ?? nickName ?? "匿名"); // Supercoder\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n> ?? 与 || 比较：\n> \n>  * 或运算符 || 可以以与 ?? 运算符相同的方式使用。（ alert(firstName || lastName || nickName || "Anonymous"); 同理）\n>  * 但是，或 || 运算符先于 ?? 出现，它自 JavaScript 诞生就存在。空值合并运算符 ?? 是最近才被添加到 JavaScript 中的。\n>  * || 返回第一个 真 值。 ?? 返回第一个 已定义的 值。\n>    * || 无法区分 false 、 0 、空字符串 "" 和 null/undefined 。它们都一样 —— 假值（falsy values）。如果其中任何一个是 || 的第一个参数，那么我们将得到第二个参数作为结果。\n>  * 优先级： ?? 运算符的优先级与 || 相同。空值合并运算符在 = 和 ? 运算前计算，但在大多数其他运算（例如 + 和 * ）之后计算。\n>  * 不能将 ?? 与 || 或 && 一起使用，JavaSript 会触发语法错误。除非使用括号明确指定了优先级。\n\n\n# 赋值运算符\n\n若 x=10 和 y=5：\n\n运算符   例子     等同于     运算结果\n=     x=y            x=5\n+=    x+=y   x=x+y   x=15\n-=    x-=y   x=x-y   x=5\n*=    x*=y   x=x*y   x=50\n/=    x/=y   x=x/y   x=2\n%=    x%=y   x=x%y   x=0\n\n * 链式赋值：\n   \n   let a, b, c;\n   \n   a = b = c = 2 + 2;\n   // a = 4, b = 4, c = 4\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   最好写为可读性更强的：\n   \n   c = 2 + 2;\n   b = c;\n   a = c;\n   \n   \n   1\n   2\n   3\n   \n\n\n# 关系运算符\n\n值的比较 (javascript.info)\n\n比较值之间的关系：\n\n * 如果关系成立则返回 true ，关系不成立则返回 false 。\n * 如果比较的两个值是非数值，会将其转换为 Number 然后再比较。\n * 如果比较的两个值都是字符串，此时会比较字符串的 Unicode 编码，而不会转换为 Number 。\n\n运算符   描述                           比较        返回值\n==    等于                           x==8      false\n                                   x==5      true\n===   绝对等于（值和类型均相等）                x==="5"   false\n                                   x===5     true\n!=     不等于                         x!=8      true\n!==    不绝对等于（值和类型有一个不相等，或两个都不相等）   x!=="5"   true\n                                   x!==5     false\n>      大于                          x>8       false\n<      小于                          x<8       true\n>=     大于或等于                       x>=8      false\n<=     小于或等于                       x<=8      true\n\n特殊的值：\n\n * NaN 和 Undefined ：由于 undefined 衍生自 null ，所以 null == undefined 会返回 true 。 但是 null === undefined 会返回 false ；\n * NaN 和任何数值都不相等，自身 NaN == NaN 为 false ；\n * 判断一个值是否 NaN ，使用 isNaN() 函数；\n\n\n# 三元运算符\n\n先对条件表达式求值判断，如果判断结果为 true ，则执行语句 1，并返回执行结果；如果判断结果为 false ，则执行语句 2，并返回执行结果；\n\n条件表达式 ? 语句1 : 语句2;\n\n\n1\n\n\n\n# 逗号运算符\n\n逗号运算符 , 是最少见最不常使用的运算符之一。逗号运算符能让我们处理多个语句，使用 , 将它们分开。** 每个语句都运行了，但是只有最后的语句的结果会被返回。** 例如：\n\nlet a = (1 + 2, 3 + 4); // 只有 3 + 4 运行, 1 + 2 的结果被丢弃\n\nalert( a );\n\n\n1\n2\n3\n\n\n> 逗号运算符的优先级：逗号运算符的优先级非常低，比 = 还要低，因此上面你的例子中圆括号非常重要。如果没有圆括号： a = 1 + 2, 3 + 4 会先执行 + ，将数值相加得到 a = 3, 7 ，然后赋值运算符 = 执行 a = 3 ，然后逗号之后的数值 7 不会再执行，它被忽略掉了。相当于 (a = 1 + 2), 3 + 4',normalizedContent:'运算符也称为操作符，对一个或多个值进行运算或者操作。\n\n\n# 算术运算符\n\n运算符   描述   例子       x 结果   y 结果\n+     加法   x=y+2    7      5\n-     减法   x=y-2    3      5\n*     乘法   x=y*2    10     5\n/     除法   x=y/2    2.5    5\n%     取模   x=y%2    1      5\n**    求幂   x=y**2   25     5\n++    自增   x=++y    6      6\n           x=y++    5      6\n--    自减   x=--y    4      4\n           x=y--    5      4\n\n * 特殊的二元运算：除了加法以外，对非 number 类型的值进行运算时，都会先转换为 number 然后在做运算。\n   \n   x = 6 - \'2\' // 4\n   y = \'6\' / \'2\' // 3\n   \n   \n   1\n   2\n   \n\n * 对于加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。任何值和字符串做加法，都会先转换为字符串，然后再拼串。二元 + 是唯一一个以这种方式支持字符串的运算符。\n   \n   x = 5 + 5;\n   y = "5" + 5; // \'55\'\n   z = "hello" + 5; // \'hello5\'\n   \n   // 特别地，\n   a = 2 + 2 + \'1\' // \'41\'\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 注意：自增 / 自减只能应用于变量。试一下，将其应用于数值（比如 5++ ）则会报错。\n\n * 运算符 ++ 和 -- 可以置于变量前，也可以置于变量后。\n   \n   * 当运算符置于变量后，被称为「后置形式」： counter++ 。\n   * 当运算符置于变量前，被称为「前置形式」： ++counter 。\n   \n   > 所有的运算符都有返回值。自增 / 自减也不例外。前置形式返回一个新的值，但后置返回原来的值（做加法 / 减法之前的值）。\n   > \n   >  * 前置形式：对 counter 做自增运算，返回的是新的值 2 。因此 alert 显示的是 2 。\n   > \n   > let counter = 1;\n   > let a = ++counter; // (*)\n   > \n   > alert(a); // 2\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   >  * 后置形式：它同样对 counter 做加法，但是返回的是 旧值（做加法之前的值）。因此 alert 显示的是 1 。\n   > \n   > let counter = 1;\n   > let a = counter++;\n   > \n   > alert(a); // 1\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   >  * 但是如果自增 / 自减的值不会被使用，那么两者形式没有区别：\n   > \n   > let counter = 0;\n   > counter++;\n   > ++counter;\n   > alert( counter );\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   >  * 对变量进行自增操作，并且 需要立刻使用自增后的值，那么我们需要使用前置形式： alert(++counter); // 1 ；想要将一个数加一，但是想使用其自增之前的值，那么需要使用后置形式： alert( counter++ ); // 0 。\n   \n   > 自增 / 自减和其它运算符的对比： ++/-- 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。\n   > \n   > let counter = 1;\n   > alert( 2 * ++counter ); // 4\n   > \n   > \n   > 1\n   > 2\n   > \n   > \n   > let counter = 1;\n   > alert( 2 * counter++ ); // 2\n   > \n   > \n   > 1\n   > 2\n   > \n   > \n   > > 上述列子降低了代码的可读性，并不推荐。还是建议依照「一行一个行为」的原则。\n   > > \n   > > let counter = 1;\n   > > alert( 2 * counter );\n   > > counter++;\n   > > \n   > > \n   > > 1\n   > > 2\n   > > 3\n\n\n# 一元运算符\n\n表示运算时操作数只要一个：\n\n * + 正号，不会对数字值产生任何影响，但是可以 ** 将一个非数字转换为数字：** 它的效果和 number(...) 相同，但是更加简短。\n   \n   let a = true;  \n   a = +a;  // 1\n   \n   let b = ""\n   b = +"" // 0\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 经常会有将字符串转化为数字的需求。比如，如果我们正在从 html 表单中取值，通常得到的都是字符串。如果我们想对它们求和：\n   > \n   > let apples = "2";\n   > let oranges = "3";\n   > // 在二元运算符加号起作用之前，所有的值都被转化为了数字\n   > alert( +apples + +oranges ); // 5\n   > \n   > // 更长的写法\n   > // alert( number(apples) + number(oranges) ); // 5\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > \n   > \n   > > 也可以从上面例子看出，一元运算符先于二元运算符作用于运算元。\n\n * - 符号，对一个数字进行符号位取反：\n   \n   var a = true;  \n   a = -a;  // -0\n   \n   \n   1\n   2\n   \n   \n   对字符串运用会得到结果 nan ；\n\n\n# 运算符优先级\n\n在 javascript 中有众多运算符。每个运算符都有对应的优先级数字。** 数字越大，越先执行。** 如果优先级相同，则按照由左至右的顺序执行。\n\n运算符优先级表\n\n\n# 逻辑运算符\n\n逻辑运算符 (javascript.info)\n\n逻辑运算符用于测定变量或值之间的逻辑。\n\n运算符   描述            例子\n&&    and 所有为真才为真   (x < 10 && y> 1) 为 true\n||    or 有一个为真即为真   (x==5 || y==5) 为 false\n!     not           !(x==y) 为 true\n\n * 或 || 运算符的应用：大多数情况下，逻辑或 || 会被用在 if 语句中，用来测试是否有 任何 给定的条件为 true 。\n   \n   let hour = 9;\n   \n   if (hour < 10 || hour > 18) {\n     alert( \'the office is closed.\' );\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 或运算寻找第一个真值：一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。\n   \n   * 获取变量列表或者表达式中的第一个真值。：\n     \n     let firstname = "";\n     let lastname = "";\n     let nickname = "supercoder";\n     \n     alert( firstname || lastname || nickname || "anonymous"); // supercoder\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n   \n   * 短路求值： || 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数。如果操作数不仅仅是一个值，而是一个有副作用的表达式，例如变量赋值或函数调用，那么这一特性的重要性就变得显而易见了。\n     \n     true || alert("not printed"); // alert没有被运行\n     false || alert("printed");\n     \n     \n     1\n     2\n     \n\n * 与运算寻找第一个假值：与和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。\n   \n   // 如果第一个操作数是真值，\n   // 与运算返回第二个操作数：\n   alert( 1 && 0 ); // 0\n   alert( 1 && 5 ); // 5\n   \n   // 如果第一个操作数是假值，\n   // 与运算将直接返回它。第二个操作数会被忽略\n   alert( null && 5 ); // null\n   alert( 0 && "no matter what" ); // 0\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   * 如果所有的值都是真值，最后一个值将会被返回：\n     \n     alert( 1 && 2 && 3 ); // 3，最后一个值\n     \n     \n     1\n     \n\n * 与运算 && 在或运算 || 之前进行：与运算 && 的优先级比或运算 || 要高。所以代码 a && b || c && d 跟 && 表达式加了括号完全一样： (a && b) || (c && d) 。\n\n * 使用非运算 !! 有时候用来将某个值转化为布尔类型：\n   \n   alert( !!"non-empty string" ); // true\n   alert( !!null ); // false\n   \n   \n   1\n   2\n   \n\n# ?? 空值合并\n\n> a ?? b 的结果是：\n> \n>  * 如果 a 是已定义的，则结果为 a ，\n>  * 如果 a 不是已定义的，则结果为 b 。\n\n如果第一个参数不是 null/undefined ，则 ?? 返回第一个参数。否则，返回第二个参数。\n\n应用场景：\n\n * 提供默认值：如果 user 的值不为 null/undefined 则显示 user ，否则显示 匿名 ：\n   \n   let user;\n   alert(user ?? "匿名");\n   \n   \n   1\n   2\n   \n   \n   let user = "john";\n   alert(user ?? "匿名");\n   \n   \n   1\n   2\n   \n\n * 选择出第一个非 null/undefined 的值。\n   \n   let firstname = null;\n   let lastname = null;\n   let nickname = "supercoder";\n   \n   // 显示第一个已定义的值：\n   alert(firstname ?? lastname ?? nickname ?? "匿名"); // supercoder\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n> ?? 与 || 比较：\n> \n>  * 或运算符 || 可以以与 ?? 运算符相同的方式使用。（ alert(firstname || lastname || nickname || "anonymous"); 同理）\n>  * 但是，或 || 运算符先于 ?? 出现，它自 javascript 诞生就存在。空值合并运算符 ?? 是最近才被添加到 javascript 中的。\n>  * || 返回第一个 真 值。 ?? 返回第一个 已定义的 值。\n>    * || 无法区分 false 、 0 、空字符串 "" 和 null/undefined 。它们都一样 —— 假值（falsy values）。如果其中任何一个是 || 的第一个参数，那么我们将得到第二个参数作为结果。\n>  * 优先级： ?? 运算符的优先级与 || 相同。空值合并运算符在 = 和 ? 运算前计算，但在大多数其他运算（例如 + 和 * ）之后计算。\n>  * 不能将 ?? 与 || 或 && 一起使用，javasript 会触发语法错误。除非使用括号明确指定了优先级。\n\n\n# 赋值运算符\n\n若 x=10 和 y=5：\n\n运算符   例子     等同于     运算结果\n=     x=y            x=5\n+=    x+=y   x=x+y   x=15\n-=    x-=y   x=x-y   x=5\n*=    x*=y   x=x*y   x=50\n/=    x/=y   x=x/y   x=2\n%=    x%=y   x=x%y   x=0\n\n * 链式赋值：\n   \n   let a, b, c;\n   \n   a = b = c = 2 + 2;\n   // a = 4, b = 4, c = 4\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   最好写为可读性更强的：\n   \n   c = 2 + 2;\n   b = c;\n   a = c;\n   \n   \n   1\n   2\n   3\n   \n\n\n# 关系运算符\n\n值的比较 (javascript.info)\n\n比较值之间的关系：\n\n * 如果关系成立则返回 true ，关系不成立则返回 false 。\n * 如果比较的两个值是非数值，会将其转换为 number 然后再比较。\n * 如果比较的两个值都是字符串，此时会比较字符串的 unicode 编码，而不会转换为 number 。\n\n运算符   描述                           比较        返回值\n==    等于                           x==8      false\n                                   x==5      true\n===   绝对等于（值和类型均相等）                x==="5"   false\n                                   x===5     true\n!=     不等于                         x!=8      true\n!==    不绝对等于（值和类型有一个不相等，或两个都不相等）   x!=="5"   true\n                                   x!==5     false\n>      大于                          x>8       false\n<      小于                          x<8       true\n>=     大于或等于                       x>=8      false\n<=     小于或等于                       x<=8      true\n\n特殊的值：\n\n * nan 和 undefined ：由于 undefined 衍生自 null ，所以 null == undefined 会返回 true 。 但是 null === undefined 会返回 false ；\n * nan 和任何数值都不相等，自身 nan == nan 为 false ；\n * 判断一个值是否 nan ，使用 isnan() 函数；\n\n\n# 三元运算符\n\n先对条件表达式求值判断，如果判断结果为 true ，则执行语句 1，并返回执行结果；如果判断结果为 false ，则执行语句 2，并返回执行结果；\n\n条件表达式 ? 语句1 : 语句2;\n\n\n1\n\n\n\n# 逗号运算符\n\n逗号运算符 , 是最少见最不常使用的运算符之一。逗号运算符能让我们处理多个语句，使用 , 将它们分开。** 每个语句都运行了，但是只有最后的语句的结果会被返回。** 例如：\n\nlet a = (1 + 2, 3 + 4); // 只有 3 + 4 运行, 1 + 2 的结果被丢弃\n\nalert( a );\n\n\n1\n2\n3\n\n\n> 逗号运算符的优先级：逗号运算符的优先级非常低，比 = 还要低，因此上面你的例子中圆括号非常重要。如果没有圆括号： a = 1 + 2, 3 + 4 会先执行 + ，将数值相加得到 a = 3, 7 ，然后赋值运算符 = 执行 a = 3 ，然后逗号之后的数值 7 不会再执行，它被忽略掉了。相当于 (a = 1 + 2), 3 + 4',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚰 JavaScript 流程控制",frontmatter:{title:"🚰 JavaScript 流程控制",date:"2022-03-10T10:27:37.000Z",permalink:"/pages/54cab4/",categories:["🚶 前端入门基础","🍪 JavaScript"],tags:["JavaScript基础"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/30.%20%F0%9F%8D%AA%20JavaScript/04.%20%F0%9F%9A%B0%20JavaScript%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html",relativePath:"100. 🚶 前端入门基础/30. 🍪 JavaScript/04. 🚰 JavaScript 流程控制.md",key:"v-43c073c8",path:"/pages/54cab4/",headers:[{level:2,title:"if-else",slug:"if-else",normalizedTitle:"if-else",charIndex:57},{level:2,title:"switch",slug:"switch",normalizedTitle:"switch",charIndex:468},{level:2,title:"循环",slug:"循环",normalizedTitle:"循环",charIndex:2272},{level:3,title:"for 循环",slug:"for-循环",normalizedTitle:"for 循环",charIndex:2401},{level:3,title:"for/in 循环",slug:"for-in-循环",normalizedTitle:"for/in 循环",charIndex:2698},{level:3,title:"while 循环",slug:"while-循环",normalizedTitle:"while 循环",charIndex:2862},{level:3,title:"do-while 循环",slug:"do-while-循环",normalizedTitle:"do-while 循环",charIndex:3069},{level:2,title:"跳出循环",slug:"跳出循环",normalizedTitle:"跳出循环",charIndex:3297},{level:3,title:"break",slug:"break",normalizedTitle:"break",charIndex:584},{level:3,title:"continue",slug:"continue",normalizedTitle:"continue",charIndex:3469},{level:3,title:"break/continue 标签",slug:"break-continue-标签",normalizedTitle:"break/continue 标签",charIndex:4251}],headersStr:"if-else switch 循环 for 循环 for/in 循环 while 循环 do-while 循环 跳出循环 break continue break/continue 标签",content:'> 🔗 相关链接：流程控制与错误处理 - JavaScript | MDN (mozilla.org)\n\n\n# if-else\n\n只有当指定条件为 true 时，该语句才会执行代码。在条件为 false 时执行其他代码。\n\nif (condition)\n{\n  // 当条件为 true 时执行的代码\n}\nelse\n{\n    当条件不为 true 时执行的代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nif-else if-else\n\n使用 if....else if...else 语句来选择多个代码块之一来执行。\n\n🌰 例子：\n\nif (time<10)\n{\n    document.write("<b>早上好</b>");\n}\nelse if (time>=10 && time<20)\n{\n    document.write("<b>日安</b>");\n}\nelse\n{\n    document.write("<b>晚上好!</b>");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# switch\n\n使用 switch 语句来选择要执行的多个代码块之一，使用 default 关键词来规定匹配不存在时做的事情：\n\nswitch(n)\n{\n    case 1:\n        // 执行代码块 1\n        break;\n    case 2:\n        // 执行代码块 2\n        break;\n    default:\n        // 与 case 1 和 case 2 不同时执行的代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子：\n\nvar d=new Date().getDay();\nswitch (d)\n{\n    case 6:\n    \tx="今天是星期六";\n    \tbreak;\n    case 0:\n    \tx="今天是星期日";\n    \tbreak;\n    default:\n   \t x="期待周末";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * 表达式都可以成为 switch/case 的参数： switch 和 case 都允许任意表达式。\n   \n   let a = "1";\n   let b = 0;\n   \n   switch (+a) {\n     case b + 1:\n       alert("this runs, because +a is 1, exactly equals b+1");\n       break;\n   \n     default:\n       alert("this doesn\'t run");\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * case 分组：共享同一段代码的几个 case 分支可以被分为一组：\n   \n   let a = 3;\n   \n   switch (a) {\n     case 4:\n       alert(\'Right!\');\n       break;\n   \n     case 3: // (*) 下面这两个 case 被分在一组\n     case 5:\n       alert(\'Wrong!\');\n       alert("Why don\'t you take a math class?");\n       break;\n   \n     default:\n       alert(\'The result is strange. Really.\');\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n   \n   其实是 switch 语句没有 break 时的副作用。因为没有 break ， case 3 会从 (*) 行执行到 case 5 。\n\n * case 中的相等是严格相等：被比较的值必须是相同的类型才能进行匹配。\n   \n   let arg = prompt("Enter a value?")\n   switch (arg) {\n     case \'0\':\n     case \'1\':\n       alert( \'One or zero\' );\n       break;\n   \n     case \'2\':\n       alert( \'Two\' );\n       break;\n   \n     case 3:\n       alert( \'Never executes!\' );\n       break;\n     default:\n       alert( \'An unknown value\' )\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   \n   由于输入的值类型为字符串，所以当输入 3 时，结果返回为 ‘3’ ，所以 case 3 不会被执行。\n\n\n# 循环\n\n不同类型的循环\n\n * for ： 循环代码块一定的次数\n * for/in ：循环遍历对象的属性\n * while ：当指定的条件为 true 时循环指定的代码块\n * do/while ：同样当指定的条件为 true 时循环指定的代码块\n\n\n# for 循环\n\n * 语句 1 初始化循环中所用的变量，是可选的，可以在语句 1 初始化任意（或者多个）值。\n * 语句 2 用于评估初始变量的条件。语句 2 同样是可选的。语句 2 返回 true，则循环再次开始，如果返回 false，则循环将结束。\n * 语句 3 会增加初始变量的值。有多种用法。增量可以是负数 ( i-- )，或者更大 ( i=i+15 )。语句 3 也可以省略（比如当循环内部有相应的代码时）。\n\n🌰 例子：\n\nfor (var i=0; i<5; i++)\n{\n      x=x + "该数字为 " + i + "<br>";\n}\n\n\n1\n2\n3\n4\n\n\n\n# for/in 循环\n\n一般用于循环遍历对象的属性：\n\n🌰 例子：\n\nvar person={fname:"Bill",lname:"Gates",age:56}; \n \nfor (x in person)  // x 为属性名\n{\n    txt = txt + person[x]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# while 循环\n\n只要指定条件为 true，循环就可以一直执行代码块。\n\nwhile (condition)\n{\n    // 需要执行的代码\n}\n\n\n1\n2\n3\n4\n\n\n注意\n\n如果设定的值陷入死循环，可能会导致浏览器崩溃。\n\n🌰 例子：\n\nwhile (i<5)\n{\n    x = x + "The number is " + i + "<br>"\n    i++\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# do-while 循环\n\ndo-while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。（该循环至少会执行一次，即使条件为 false 它也会执行一次，因为代码块会在条件被测试前执行）\n\n🌰 例子：\n\ndo\n{\n    x=x + "The number is " + i + "<br>";\n    i++;\n}\nwhile (i<5);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 跳出循环\n\n\n# break\n\nbreak 语句可用于跳出循环。 break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）：\n\nfor (i=0;i<10;i++)\n{\n    if (i==3) break;\n    x=x + "The number is " + i + "<br>";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# continue\n\ncontinue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代。\n\n🌰 例子：在 for 循环中，例子在值为 3 时，直接跳过：\n\n:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"\n\n::: tab javascript\n\nfunction myFunction(){\n\tvar x="",i=0;\n\tfor (i = 0; i < 10; i++){\n  \t\tif (i == 3){\n    \t\tcontinue;\n    \t}\n\t\tx = x + "该数字为 " + i + "<br>";\n  }\n\tdocument.getElementById("demo").innerHTML=x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n:::\n\n::: tab result\n\n该数字为 0\n该数字为 1\n该数字为 2\n该数字为 4\n该数字为 5\n该数字为 6\n该数字为 7\n该数字为 8\n该数字为 9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n:::\n\n::::\n\n🌰 例子：在 while 循环中：\n\nwhile (i < 10){\n  if (i == 3){\n    i++;    //加入i++不会进入死循环\n    continue;\n  }\n  x= x + "该数字为 " + i + "<br>";\n  i++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n * continue 语句（带有或不带标签引用）只能用在循环中。\n\n * break 语句（不带标签引用），只能用在循环或 switch 中。\n\n换句话说，禁止 break/continue 在 ? 三元运算的右边。\n\n\n# break/continue 标签\n\n有时候我们需要一次从多层嵌套的循环中跳出来。在 input 之后的普通 break 只会打破内部循环。标签可以实现这一功能！\n\n标签 是在循环之前带有冒号的标识符：\n\nlabelName: for (...) {\n  ...\n}\n\n\n1\n2\n3\n\n\n例如：\n\nouter: for (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, \'\');\n\n    // 如果是空字符串或被取消，则中断并跳出这两个循环。\n    if (!input) break outer; // (*)\n\n    // 用得到的值做些事……\n  }\n}\nalert(\'Done!\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 上述代码中， break outer 向上寻找名为 outer 的标签并跳出当前循环。\n> \n> 因此，控制权直接从 (*) 转至 alert(\'Done!\') 。\n\ncontinue 指令也可以与标签一起使用。在这种情况下，执行跳转到标记循环的下一次迭代。\n\n注意\n\n标签并不允许「跳到」所有位置：标签不允许我们跳到代码的任意位置。\n\n例如： break 指令必须在代码块内。\n\nbreak label;  // 跳转至下面的 label 处（无效）\n\nlabel: for (...)\n\n\n1\n2\n3\n\n\n从技术上讲，任何被标记的代码块都有效，例如：\n\nlabel: {\n  // ...\n  break label; // 有效\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'> 🔗 相关链接：流程控制与错误处理 - javascript | mdn (mozilla.org)\n\n\n# if-else\n\n只有当指定条件为 true 时，该语句才会执行代码。在条件为 false 时执行其他代码。\n\nif (condition)\n{\n  // 当条件为 true 时执行的代码\n}\nelse\n{\n    当条件不为 true 时执行的代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nif-else if-else\n\n使用 if....else if...else 语句来选择多个代码块之一来执行。\n\n🌰 例子：\n\nif (time<10)\n{\n    document.write("<b>早上好</b>");\n}\nelse if (time>=10 && time<20)\n{\n    document.write("<b>日安</b>");\n}\nelse\n{\n    document.write("<b>晚上好!</b>");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# switch\n\n使用 switch 语句来选择要执行的多个代码块之一，使用 default 关键词来规定匹配不存在时做的事情：\n\nswitch(n)\n{\n    case 1:\n        // 执行代码块 1\n        break;\n    case 2:\n        // 执行代码块 2\n        break;\n    default:\n        // 与 case 1 和 case 2 不同时执行的代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子：\n\nvar d=new date().getday();\nswitch (d)\n{\n    case 6:\n    \tx="今天是星期六";\n    \tbreak;\n    case 0:\n    \tx="今天是星期日";\n    \tbreak;\n    default:\n   \t x="期待周末";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * 表达式都可以成为 switch/case 的参数： switch 和 case 都允许任意表达式。\n   \n   let a = "1";\n   let b = 0;\n   \n   switch (+a) {\n     case b + 1:\n       alert("this runs, because +a is 1, exactly equals b+1");\n       break;\n   \n     default:\n       alert("this doesn\'t run");\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * case 分组：共享同一段代码的几个 case 分支可以被分为一组：\n   \n   let a = 3;\n   \n   switch (a) {\n     case 4:\n       alert(\'right!\');\n       break;\n   \n     case 3: // (*) 下面这两个 case 被分在一组\n     case 5:\n       alert(\'wrong!\');\n       alert("why don\'t you take a math class?");\n       break;\n   \n     default:\n       alert(\'the result is strange. really.\');\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n   \n   其实是 switch 语句没有 break 时的副作用。因为没有 break ， case 3 会从 (*) 行执行到 case 5 。\n\n * case 中的相等是严格相等：被比较的值必须是相同的类型才能进行匹配。\n   \n   let arg = prompt("enter a value?")\n   switch (arg) {\n     case \'0\':\n     case \'1\':\n       alert( \'one or zero\' );\n       break;\n   \n     case \'2\':\n       alert( \'two\' );\n       break;\n   \n     case 3:\n       alert( \'never executes!\' );\n       break;\n     default:\n       alert( \'an unknown value\' )\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   \n   由于输入的值类型为字符串，所以当输入 3 时，结果返回为 ‘3’ ，所以 case 3 不会被执行。\n\n\n# 循环\n\n不同类型的循环\n\n * for ： 循环代码块一定的次数\n * for/in ：循环遍历对象的属性\n * while ：当指定的条件为 true 时循环指定的代码块\n * do/while ：同样当指定的条件为 true 时循环指定的代码块\n\n\n# for 循环\n\n * 语句 1 初始化循环中所用的变量，是可选的，可以在语句 1 初始化任意（或者多个）值。\n * 语句 2 用于评估初始变量的条件。语句 2 同样是可选的。语句 2 返回 true，则循环再次开始，如果返回 false，则循环将结束。\n * 语句 3 会增加初始变量的值。有多种用法。增量可以是负数 ( i-- )，或者更大 ( i=i+15 )。语句 3 也可以省略（比如当循环内部有相应的代码时）。\n\n🌰 例子：\n\nfor (var i=0; i<5; i++)\n{\n      x=x + "该数字为 " + i + "<br>";\n}\n\n\n1\n2\n3\n4\n\n\n\n# for/in 循环\n\n一般用于循环遍历对象的属性：\n\n🌰 例子：\n\nvar person={fname:"bill",lname:"gates",age:56}; \n \nfor (x in person)  // x 为属性名\n{\n    txt = txt + person[x]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# while 循环\n\n只要指定条件为 true，循环就可以一直执行代码块。\n\nwhile (condition)\n{\n    // 需要执行的代码\n}\n\n\n1\n2\n3\n4\n\n\n注意\n\n如果设定的值陷入死循环，可能会导致浏览器崩溃。\n\n🌰 例子：\n\nwhile (i<5)\n{\n    x = x + "the number is " + i + "<br>"\n    i++\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# do-while 循环\n\ndo-while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。（该循环至少会执行一次，即使条件为 false 它也会执行一次，因为代码块会在条件被测试前执行）\n\n🌰 例子：\n\ndo\n{\n    x=x + "the number is " + i + "<br>";\n    i++;\n}\nwhile (i<5);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 跳出循环\n\n\n# break\n\nbreak 语句可用于跳出循环。 break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）：\n\nfor (i=0;i<10;i++)\n{\n    if (i==3) break;\n    x=x + "the number is " + i + "<br>";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# continue\n\ncontinue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代。\n\n🌰 例子：在 for 循环中，例子在值为 3 时，直接跳过：\n\n:::: tabs cache-lifetime="5" :options="{ useurlfragment: false }"\n\n::: tab javascript\n\nfunction myfunction(){\n\tvar x="",i=0;\n\tfor (i = 0; i < 10; i++){\n  \t\tif (i == 3){\n    \t\tcontinue;\n    \t}\n\t\tx = x + "该数字为 " + i + "<br>";\n  }\n\tdocument.getelementbyid("demo").innerhtml=x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n:::\n\n::: tab result\n\n该数字为 0\n该数字为 1\n该数字为 2\n该数字为 4\n该数字为 5\n该数字为 6\n该数字为 7\n该数字为 8\n该数字为 9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n:::\n\n::::\n\n🌰 例子：在 while 循环中：\n\nwhile (i < 10){\n  if (i == 3){\n    i++;    //加入i++不会进入死循环\n    continue;\n  }\n  x= x + "该数字为 " + i + "<br>";\n  i++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n * continue 语句（带有或不带标签引用）只能用在循环中。\n\n * break 语句（不带标签引用），只能用在循环或 switch 中。\n\n换句话说，禁止 break/continue 在 ? 三元运算的右边。\n\n\n# break/continue 标签\n\n有时候我们需要一次从多层嵌套的循环中跳出来。在 input 之后的普通 break 只会打破内部循环。标签可以实现这一功能！\n\n标签 是在循环之前带有冒号的标识符：\n\nlabelname: for (...) {\n  ...\n}\n\n\n1\n2\n3\n\n\n例如：\n\nouter: for (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`value at coords (${i},${j})`, \'\');\n\n    // 如果是空字符串或被取消，则中断并跳出这两个循环。\n    if (!input) break outer; // (*)\n\n    // 用得到的值做些事……\n  }\n}\nalert(\'done!\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 上述代码中， break outer 向上寻找名为 outer 的标签并跳出当前循环。\n> \n> 因此，控制权直接从 (*) 转至 alert(\'done!\') 。\n\ncontinue 指令也可以与标签一起使用。在这种情况下，执行跳转到标记循环的下一次迭代。\n\n注意\n\n标签并不允许「跳到」所有位置：标签不允许我们跳到代码的任意位置。\n\n例如： break 指令必须在代码块内。\n\nbreak label;  // 跳转至下面的 label 处（无效）\n\nlabel: for (...)\n\n\n1\n2\n3\n\n\n从技术上讲，任何被标记的代码块都有效，例如：\n\nlabel: {\n  // ...\n  break label; // 有效\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⚙️ JavaScript Function 函数",frontmatter:{title:"⚙️ JavaScript Function 函数",date:"2022-05-04T09:02:30.000Z",permalink:"/pages/944277/",categories:["🚶 前端入门基础","🍪 JavaScript"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/30.%20%F0%9F%8D%AA%20JavaScript/05.%20%E2%9A%99%EF%B8%8F%20JavaScript%20%E5%87%BD%E6%95%B0.html",relativePath:"100. 🚶 前端入门基础/30. 🍪 JavaScript/05. ⚙️ JavaScript 函数.md",key:"v-19c0f996",path:"/pages/944277/",headers:[{level:2,title:"声明函数",slug:"声明函数",normalizedTitle:"声明函数",charIndex:83},{level:2,title:"局部变量与外部（全局）变量",slug:"局部变量与外部-全局-变量",normalizedTitle:"局部变量与外部（全局）变量",charIndex:280},{level:2,title:"函数的参数",slug:"函数的参数",normalizedTitle:"函数的参数",charIndex:561},{level:3,title:"形参",slug:"形参",normalizedTitle:"形参",charIndex:571},{level:3,title:"实参",slug:"实参",normalizedTitle:"实参",charIndex:660},{level:3,title:"返回值",slug:"返回值",normalizedTitle:"返回值",charIndex:1419},{level:2,title:"函数的命名规范",slug:"函数的命名规范",normalizedTitle:"函数的命名规范",charIndex:1785},{level:2,title:"函数是注释般的存在",slug:"函数是注释般的存在",normalizedTitle:"函数是注释般的存在",charIndex:2149},{level:2,title:"函数表达式",slug:"函数表达式",normalizedTitle:"函数表达式",charIndex:2726},{level:2,title:"函数表达式与函数声明比较",slug:"函数表达式与函数声明比较",normalizedTitle:"函数表达式与函数声明比较",charIndex:2975},{level:2,title:"调用函数",slug:"调用函数",normalizedTitle:"调用函数",charIndex:670},{level:3,title:"函数是一个值",slug:"函数是一个值",normalizedTitle:"函数是一个值",charIndex:4523},{level:2,title:"回调函数",slug:"回调函数",normalizedTitle:"回调函数",charIndex:5383},{level:2,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:6098},{level:2,title:"函数的调用多种方法",slug:"函数的调用多种方法",normalizedTitle:"函数的调用多种方法",charIndex:6987},{level:2,title:"函数的关键字",slug:"函数的关键字",normalizedTitle:"函数的关键字",charIndex:7915},{level:3,title:"this",slug:"this",normalizedTitle:"this",charIndex:7131},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:10614}],headersStr:"声明函数 局部变量与外部（全局）变量 函数的参数 形参 实参 返回值 函数的命名规范 函数是注释般的存在 函数表达式 函数表达式与函数声明比较 调用函数 函数是一个值 回调函数 箭头函数 函数的调用多种方法 函数的关键字 this 构造函数",content:'函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数也是一个对象，也具有普通对象 的功能（能有属性）。\n\n函数的作用：提高代码的复用。便于阅读。\n\n\n# 声明函数\n\n使用关键字 function 。\n\nfunction functionName()\n{\n  // 执行代码\n}\n\n// 带有参数的函数：\n// 变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。🚨\nfunction myFunction(var1,var2)\n{\n\t// 代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 局部变量与外部（全局）变量\n\n * 在函数中声明的变量只在该函数内部可见。\n * 函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。\n * 只有在没有局部变量的情况下才会使用外部变量。如果在函数内部声明了同名变量，那么函数会 遮蔽 外部变量。\n\n> 全局变量：任何函数之外声明的变量，都被称为 全局 变量。\n> \n>  * 全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。\n> \n>  * 减少全局变量的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。\n\n\n# 函数的参数\n\n\n# 形参\n\n（形式参数）定义函数时，可以在 () 中定义一个或多个形参，形参之间使用 , 隔开。定义形参就相当于在函数内声明了对应的变量但是并不赋值，形参会在调用时才赋值。\n\n\n# 实参\n\n（实际参数）调用函数时，可以在 () 传递实参，传递的实参会赋值给对应的形参，调用函数时 JavaScript 解析器不会检查实参的类型和个数，可以传递任意数据类型的值。\n\n * 如果实参的数量大于形参，多余实参将不会赋值；\n\n * 如果实参的数量小于形参，则没有对应实参的形参将会赋值 undefined ；\n\n * （JavaScript 新特性）默认参数：可以使用 = 为函数声明中的参数指定所谓的「默认」（如果对应参数的值未被传递则使用）值：\n   \n   function showMessage(from, text = "no text given") {\n     alert( from + ": " + text );\n   }\n   \n   showMessage("Ann"); // Ann: no text given\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 默认值也可以为一个更复杂的表达式，并且只会在缺少参数时才会被计算和分配。\n   > \n   > function showMessage(from, text = anotherFunction()) {\n   >   // anotherFunction() 仅在没有给定 text 时执行\n   >   // 其运行结果将成为 text 的值\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > 默认值也可以放在放在函数执行（相较更后期）而不是函数声明时。通过将参数与 undefined 进行比较，来检查该参数是否在函数执行期间被传递进来。（使用 || 和 ?? 都可以实现。）\n\n\n# 返回值\n\n返回值为函数可以将一个值返回到调用代码中作为结果。\n\n * return 后边的代码都不会执行，一旦执行到 return 语句时，函数将会立刻退出。\n * return 后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。\n * 如果 return 后不跟值，或者是不写 return 则函数默认返回 undefined 。\n\n注意\n\n不要在 return 与返回值之间添加新行。换行后的表达式会被忽略。如果想要将返回的表达式写成跨多行的形式，那么应该在 return 的同一行开始写此表达式。或者至少按照如下的方式放上左括号：\n\nreturn (\n  some + long + expression\n  + or +\n  whatever * f(a) + f(b)\n  )\n\n\n1\n2\n3\n4\n5\n\n\n\n# 函数的命名规范\n\n函数就是行为（action）。所以它们的名字通常是动词。它应该简短且尽可能准确地描述函数的作用。这样读代码的人就能清楚地知道这个函数的功能。\n\n> 常见的函数前缀： 有了前缀，只需瞥一眼函数名，就可以了解它的功能是什么，返回什么样的值。\n> \n>  * "get…" —— 返回一个值，\n>  * "calc…" —— 计算某些内容，\n>  * "create…" —— 创建某些内容，\n>  * "check…" —— 检查某些内容并返回 boolean 值，等。\n\n提示\n\n函数遵循「一个函数一个行为」的原则：一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。\n\n两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。\n\n\n# 函数是注释般的存在\n\n一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！\n\n🌰 例子：\n\nfunction showPrimes(n) {\n  nextPrime: for (let i = 2; i < n; i++) {\n\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // 一个素数\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    if (!isPrime(i)) continue;\n\n    alert(i);  // 一个素数\n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 即使不打算重用，也可以创建函数。函数可以让代码结构更清晰，可读性更强。\n\n\n# 函数表达式\n\nfunction sayHi() {\n  alert( "Hello" );\n}\n\n\n1\n2\n3\n\n\n上所述的仅仅为函数的声明。函数表达式允许我们在任何表达式的中间创建一个新函数。\n\n例如：\n\nlet sayHi = function() {\n  alert( "Hello" );\n};\n\n\n1\n2\n3\n\n>  * function 关键字后面没有函数名。函数表达式允许省略函数名。\n>  * 与原来声明函数的含义相同，都是「创建一个函数并将其放入变量 sayHi 中」。\n\n\n# 函数表达式与函数声明比较\n\n * 语法：\n   \n   * 函数声明：在主代码流中声明为单独的语句的函数。\n     \n     // 函数声明\n     function sum(a, b) {\n       return a + b;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 = 右侧创建的：\n     \n     // 函数表达式\n     let sum = function(a, b) {\n       return a + b;\n     };\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * JavaSript 引擎创建函数的时机：\n   \n   * 函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。 意味着只有赋值了才能使用。\n   \n   * ** 在函数声明被定义之前，它就可以被调用。** 意味着对于整个脚本，无论放在何时何地，都可以被调用。\n   \n   * 这是内部算法的原故。当 JavaScript 准备 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。将其视为「初始化阶段」。\n     \n     在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。\n\n * 函数声明的另一个特殊功能：「块级作用域」。严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。\n   \n   let age = prompt("What is your age?", 18);\n   \n   if (age < 18) {\n     function welcome() {\n       alert("Hello!");\n     }\n   } else {\n     function welcome() {\n       alert("Greetings!");\n     }\n   }\n   \n   welcome(); \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n   \n   * 如果想要在代码块外可见，可以使用函数表达式，先在声明变量，在代码块内声明函数。\n     \n     let age = prompt("What is your age?", 18);\n     let welcome;\n     if (age < 18) {\n       welcome = function() {\n         alert("Hello!");\n       };\n     } else {\n       welcome = function() {\n         alert("Greetings!");\n       };\n     }\n     \n     welcome();\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     \n\n * 如何选择函数声明与函数表达式？ 函数声明其实能为组织代码提供更多的灵活性，并且能在声明函数之前调用，并且对代码的可读性也更好。但是如果由于「块级作用域」的问题，函数表达式会更适合。\n\n\n# 调用函数\n\n\n# 函数是一个值\n\n无论函数是如何创建的，函数都是一个值。\n\n> 没有添加 () 时：在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。例如：最后只会为一个字符串值，即函数的源码。\n> \n> function sayHi() {\n>   alert( "Hello" );\n> }\n> \n> alert( sayHi ); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n * 函数的复制：\n   \n   function sayHi() {   // (1) 创建\n     alert( "Hello" );\n   } // 当 let sayHi = function() { ... } 时也相同\n   \n   let func = sayHi;    // (2) 复制\n   \n   func(); // Hello     // (3) 运行复制的值（正常运行）！\n   sayHi(); // Hello\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   > 注意： sayHi 后面没有括号。如果有括号， func = sayHi() 会把 sayHi() 的调用结果写进 func ，而不是 sayHi 函数 本身。\n\n * 分号的用法：\n   \n   function sayHi() {\n     // ...\n   }\n   \n   let sayHi = function() {\n     // ...\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   这里函数表达式是在赋值语句 let sayHi = ...; 中以 function(…) {…} 的形式创建的。建议在语句末尾加上分号 ; ，它不是函数语法的一部分。\n   \n   分号用于更简单的赋值，例如 let sayHi = 5; ，它也用于函数赋值。\n\n\n# 回调函数\n\n🌰 例子：\n\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nfunction showOk() {\n  alert( "You agreed." );\n}\n\nfunction showCancel() {\n  alert( "You canceled the execution." );\n}\n\nask("Do you agree?", showOk, showCancel);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nask 的两个参数值 showOk 和 showCancel 可以被称为 回调函数 或简称 回调。主要思想是我们传递一个函数，并期望在稍后必要时将其「回调」。\n\n简写为：\n\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nask(\n  "Do you agree?",\n  function() { alert("You agreed."); },\n  function() { alert("You canceled the execution."); }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n没有命名的函数：匿名函数。这样的函数在 ask 外无法访问（因为没有对它们分配变量）。\n\n回调函数正符合 JavaScript 的「一个函数表示一个行为」的原则。我们可以在变量之间传递它们，并在需要时运行。\n\n\n# 箭头函数\n\n箭头函数是一种简单创建函数的语法：\n\nlet func = (arg1, arg2, ..., argN) => expression;\n\n\n1\n\n\n> 创建了一个函数 func ，它接受参数 arg1..argN ，然后使用参数对右侧的 expression 求值并返回其结果。\n> \n> 相当于：\n> \n> let func = function(arg1, arg2, ..., argN) {\n>   return expression;\n> };\n> \n> \n> 1\n> 2\n> 3\n\n🌰 例子：\n\nlet sum = (a, b) => a + b;\n\n\n1\n\n\n * 如果只有一个参数，还可以省略掉 () 。\n   \n   let double = n => n * 2;\n   \n   \n   1\n   \n\n * 如果没有参数，则括号是空的，但是括号必须保留。\n   \n   let sayHi = () => alert("Hello!");\n   \n   sayHi();\n   \n   \n   1\n   2\n   3\n   \n\n * 箭头函数可看作为函数表达式：\n   \n   let age = prompt("What is your age?", 18);\n   \n   let welcome = (age < 18) ?\n     () => alert(\'Hello\'!) :\n     () => alert("Greetings!");\n   \n   welcome();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 多行箭头函数：用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）。\n   \n   let sum = (a, b) => {  /\n     let result = a + b;\n     return result; \n   };\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 函数的调用多种方法\n\n * 直接调用 test() ；\n * 通过对象调用 obj.test ；\n * 通过 new 调用\n * test.call/apply(obj) 让 test 成为 obj 的方法进行调用。\n\nvar obj = {}\nfunction test2 (){\n  this.xxx = \'aaa\'\n}\n// obj.test2()\ntest2.call(obj) // 相当于obj.test2\n// 可以让一个函数称为指定对象的方法进行调用\nconsole.log(obj.xxx) // aaa\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 网页按钮调用函数功能：\n\n<button onclick="myFunction(\'Harry Potter\',\'Wizard\')">点击这里</button>\n\n<script>\nfunction myFunction(name,job){\n    alert("Welcome " + name + ", the " + job);\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 带有返回值的函数：\n\nfunction myFunction(a,b)\n{\n    return a * b;\n}\n \ndocument.getElementById("demo").innerHTML=myFunction(4,3);\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 仅希望退出函数，可以使用 return\n\nfunction myFunction(a,b)\n{\n    if (a>b)\n    {\n        return;\n    }\n    x=a+b\n}\n// 如果 a 大于 b，则上面的代码将退出函数，并不会计算 a 和 b 的总和 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 立即执行函数：函数定义完，立刻被调用，往往只会执行一次：\n\n(function(a,b){  \n    console.log("a = "+a);  \n    console.log("b = "+b);  \n})(123,456); \n\n\n1\n2\n3\n4\n\n\n\n# 函数的关键字\n\nbreak ： 退出循环；\n\ncontinue ：跳过当次循环；\n\nreturn ：退出函数；\n\n\n# this\n\nthis 是函数的上下问对象，根据函数的调用方式不同会指向不同的对象：\n\n * 如果单独使用， this 表示全局对象。\n   \n   在浏览器中，window 就是该全局对象为 [object Window]:\n   \n   严格模式下，如果单独使用， this 也是指向全局 (Global) 对象。\n   \n   var x = this;\n   \n   \n   1\n   \n\n * 在函数中， this 表示全局对象。\n   \n   在浏览器中，window 就是该全局对象为 [object Window]:\n   \n   严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined 。\n   \n   var name = \'simon\';\n   function shows(){\n     console.log(this.name);\n   }\n   \n   shows();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 以方法的形式调用时， this 表示该方法所属的对象：\n   \n   // 创建一个对象\n   var person = {\n     firstName: "John",\n     lastName : "Doe",\n     id     : 5566,\n     fullName : function() {\n       return this.firstName + " " + this.lastName;\n     }\n   };\n   \n   // this 表示 person 对象。\n   // fullName 方法所属的对象就是 person。\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 对象方法中绑定：\n   \n   var person = {\n     firstName  : "John",\n     lastName   : "Doe",\n     id         : 5566,\n     myFunction : function() {\n       return this;\n     }\n   };\n   // this 是 person 对象，person 对象是函数的所有者\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   var person = {\n     firstName: "John",\n     lastName : "Doe",\n     id       : 5566,\n     fullName : function() {\n       return this.firstName + " " + this.lastName;\n     }\n   };\n   \n   // this.firstName 表示 this (person) 对象的 firstName 属性\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * 事件中， this 指向接收事件的 HTML 元素：\n   \n   <button onclick="this.style.display=\'none\'">\n   点我后我就消失了\n   </button>\n   \n   \n   1\n   2\n   3\n   \n\n * 显式函数绑定：在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。\n   \n   var person1 = {\n     fullName: function() {\n       return this.firstName + " " + this.lastName;\n     }\n   }\'\'\n   var person2 = {\n     firstName:"John",\n     lastName: "Doe",\n   }\n   person1.fullName.call(person2);  // 返回 "John Doe"\n   //使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\ncall() ： 直接传递函数的实参；\n\napply() ：通过第一个实参来制定函数中的 this\n\nJavaScript 中 call ()、apply ()、bind () 的用法 | 菜鸟教程 (runoob.com)\n\naruguments 和 this 类似，都是函数中的隐含的参数。是类数组元素，用来封装函数执行过程中的实参。所以即使不定义实参，也可以通过 arguments 来使用实参。arguments 中有一个属性 callee 表示当前执行的函数对象；\n\nx = findMax(1, 123, 500, 115, 44, 88);\n \nfunction findMax() {\n    var i, max = arguments[0];\n    \n    if(arguments.length < 2) return max;\n \n    for (i = 0; i < arguments.length; i++) {\n        if (arguments[i] > max) {\n            max = arguments[i];\n        }\n    }\n    return max;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nJavaScript 函数参数 | 菜鸟教程 (runoob.com)\n\n\n# 构造函数\n\n构造函数是专门用来创建对象的函数，\n\n * 一个构造函数我们也可以称为一个类；\n\n * 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例；\n\n * 通过同一个构造函数创建的对象，我们称为一类对象；\n\n * 构造函数如果直接调用，它就是一个普通函数；如果使用 new 来调用，则它就是一个构造函数；\n\nfunction Person(name , age , gender){  \n    this.name = name;  \n    this.age = age;  \n    this.gender = gender;  \n    this.sayName = function(){  \n        alert(this.name);  \n    };  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n构造函数的执行流程：\n\n * 创建一个新的对象，\n * 将新的对象作为函数的上下文对象 this ，\n * 执行函数中的代码，\n * 将新建的对象返回，',normalizedContent:'函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数也是一个对象，也具有普通对象 的功能（能有属性）。\n\n函数的作用：提高代码的复用。便于阅读。\n\n\n# 声明函数\n\n使用关键字 function 。\n\nfunction functionname()\n{\n  // 执行代码\n}\n\n// 带有参数的函数：\n// 变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。🚨\nfunction myfunction(var1,var2)\n{\n\t// 代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 局部变量与外部（全局）变量\n\n * 在函数中声明的变量只在该函数内部可见。\n * 函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。\n * 只有在没有局部变量的情况下才会使用外部变量。如果在函数内部声明了同名变量，那么函数会 遮蔽 外部变量。\n\n> 全局变量：任何函数之外声明的变量，都被称为 全局 变量。\n> \n>  * 全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。\n> \n>  * 减少全局变量的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。\n\n\n# 函数的参数\n\n\n# 形参\n\n（形式参数）定义函数时，可以在 () 中定义一个或多个形参，形参之间使用 , 隔开。定义形参就相当于在函数内声明了对应的变量但是并不赋值，形参会在调用时才赋值。\n\n\n# 实参\n\n（实际参数）调用函数时，可以在 () 传递实参，传递的实参会赋值给对应的形参，调用函数时 javascript 解析器不会检查实参的类型和个数，可以传递任意数据类型的值。\n\n * 如果实参的数量大于形参，多余实参将不会赋值；\n\n * 如果实参的数量小于形参，则没有对应实参的形参将会赋值 undefined ；\n\n * （javascript 新特性）默认参数：可以使用 = 为函数声明中的参数指定所谓的「默认」（如果对应参数的值未被传递则使用）值：\n   \n   function showmessage(from, text = "no text given") {\n     alert( from + ": " + text );\n   }\n   \n   showmessage("ann"); // ann: no text given\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 默认值也可以为一个更复杂的表达式，并且只会在缺少参数时才会被计算和分配。\n   > \n   > function showmessage(from, text = anotherfunction()) {\n   >   // anotherfunction() 仅在没有给定 text 时执行\n   >   // 其运行结果将成为 text 的值\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > 默认值也可以放在放在函数执行（相较更后期）而不是函数声明时。通过将参数与 undefined 进行比较，来检查该参数是否在函数执行期间被传递进来。（使用 || 和 ?? 都可以实现。）\n\n\n# 返回值\n\n返回值为函数可以将一个值返回到调用代码中作为结果。\n\n * return 后边的代码都不会执行，一旦执行到 return 语句时，函数将会立刻退出。\n * return 后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。\n * 如果 return 后不跟值，或者是不写 return 则函数默认返回 undefined 。\n\n注意\n\n不要在 return 与返回值之间添加新行。换行后的表达式会被忽略。如果想要将返回的表达式写成跨多行的形式，那么应该在 return 的同一行开始写此表达式。或者至少按照如下的方式放上左括号：\n\nreturn (\n  some + long + expression\n  + or +\n  whatever * f(a) + f(b)\n  )\n\n\n1\n2\n3\n4\n5\n\n\n\n# 函数的命名规范\n\n函数就是行为（action）。所以它们的名字通常是动词。它应该简短且尽可能准确地描述函数的作用。这样读代码的人就能清楚地知道这个函数的功能。\n\n> 常见的函数前缀： 有了前缀，只需瞥一眼函数名，就可以了解它的功能是什么，返回什么样的值。\n> \n>  * "get…" —— 返回一个值，\n>  * "calc…" —— 计算某些内容，\n>  * "create…" —— 创建某些内容，\n>  * "check…" —— 检查某些内容并返回 boolean 值，等。\n\n提示\n\n函数遵循「一个函数一个行为」的原则：一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。\n\n两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。\n\n\n# 函数是注释般的存在\n\n一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！\n\n🌰 例子：\n\nfunction showprimes(n) {\n  nextprime: for (let i = 2; i < n; i++) {\n\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextprime;\n    }\n\n    alert( i ); // 一个素数\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nfunction showprimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    if (!isprime(i)) continue;\n\n    alert(i);  // 一个素数\n  }\n}\n\nfunction isprime(n) {\n  for (let i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 即使不打算重用，也可以创建函数。函数可以让代码结构更清晰，可读性更强。\n\n\n# 函数表达式\n\nfunction sayhi() {\n  alert( "hello" );\n}\n\n\n1\n2\n3\n\n\n上所述的仅仅为函数的声明。函数表达式允许我们在任何表达式的中间创建一个新函数。\n\n例如：\n\nlet sayhi = function() {\n  alert( "hello" );\n};\n\n\n1\n2\n3\n\n>  * function 关键字后面没有函数名。函数表达式允许省略函数名。\n>  * 与原来声明函数的含义相同，都是「创建一个函数并将其放入变量 sayhi 中」。\n\n\n# 函数表达式与函数声明比较\n\n * 语法：\n   \n   * 函数声明：在主代码流中声明为单独的语句的函数。\n     \n     // 函数声明\n     function sum(a, b) {\n       return a + b;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 = 右侧创建的：\n     \n     // 函数表达式\n     let sum = function(a, b) {\n       return a + b;\n     };\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * javasript 引擎创建函数的时机：\n   \n   * 函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。 意味着只有赋值了才能使用。\n   \n   * ** 在函数声明被定义之前，它就可以被调用。** 意味着对于整个脚本，无论放在何时何地，都可以被调用。\n   \n   * 这是内部算法的原故。当 javascript 准备 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。将其视为「初始化阶段」。\n     \n     在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。\n\n * 函数声明的另一个特殊功能：「块级作用域」。严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。\n   \n   let age = prompt("what is your age?", 18);\n   \n   if (age < 18) {\n     function welcome() {\n       alert("hello!");\n     }\n   } else {\n     function welcome() {\n       alert("greetings!");\n     }\n   }\n   \n   welcome(); \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n   \n   * 如果想要在代码块外可见，可以使用函数表达式，先在声明变量，在代码块内声明函数。\n     \n     let age = prompt("what is your age?", 18);\n     let welcome;\n     if (age < 18) {\n       welcome = function() {\n         alert("hello!");\n       };\n     } else {\n       welcome = function() {\n         alert("greetings!");\n       };\n     }\n     \n     welcome();\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     \n\n * 如何选择函数声明与函数表达式？ 函数声明其实能为组织代码提供更多的灵活性，并且能在声明函数之前调用，并且对代码的可读性也更好。但是如果由于「块级作用域」的问题，函数表达式会更适合。\n\n\n# 调用函数\n\n\n# 函数是一个值\n\n无论函数是如何创建的，函数都是一个值。\n\n> 没有添加 () 时：在 javascript 中，函数是一个值，所以我们可以把它当成值对待。例如：最后只会为一个字符串值，即函数的源码。\n> \n> function sayhi() {\n>   alert( "hello" );\n> }\n> \n> alert( sayhi ); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n * 函数的复制：\n   \n   function sayhi() {   // (1) 创建\n     alert( "hello" );\n   } // 当 let sayhi = function() { ... } 时也相同\n   \n   let func = sayhi;    // (2) 复制\n   \n   func(); // hello     // (3) 运行复制的值（正常运行）！\n   sayhi(); // hello\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   > 注意： sayhi 后面没有括号。如果有括号， func = sayhi() 会把 sayhi() 的调用结果写进 func ，而不是 sayhi 函数 本身。\n\n * 分号的用法：\n   \n   function sayhi() {\n     // ...\n   }\n   \n   let sayhi = function() {\n     // ...\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   这里函数表达式是在赋值语句 let sayhi = ...; 中以 function(…) {…} 的形式创建的。建议在语句末尾加上分号 ; ，它不是函数语法的一部分。\n   \n   分号用于更简单的赋值，例如 let sayhi = 5; ，它也用于函数赋值。\n\n\n# 回调函数\n\n🌰 例子：\n\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nfunction showok() {\n  alert( "you agreed." );\n}\n\nfunction showcancel() {\n  alert( "you canceled the execution." );\n}\n\nask("do you agree?", showok, showcancel);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nask 的两个参数值 showok 和 showcancel 可以被称为 回调函数 或简称 回调。主要思想是我们传递一个函数，并期望在稍后必要时将其「回调」。\n\n简写为：\n\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nask(\n  "do you agree?",\n  function() { alert("you agreed."); },\n  function() { alert("you canceled the execution."); }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n没有命名的函数：匿名函数。这样的函数在 ask 外无法访问（因为没有对它们分配变量）。\n\n回调函数正符合 javascript 的「一个函数表示一个行为」的原则。我们可以在变量之间传递它们，并在需要时运行。\n\n\n# 箭头函数\n\n箭头函数是一种简单创建函数的语法：\n\nlet func = (arg1, arg2, ..., argn) => expression;\n\n\n1\n\n\n> 创建了一个函数 func ，它接受参数 arg1..argn ，然后使用参数对右侧的 expression 求值并返回其结果。\n> \n> 相当于：\n> \n> let func = function(arg1, arg2, ..., argn) {\n>   return expression;\n> };\n> \n> \n> 1\n> 2\n> 3\n\n🌰 例子：\n\nlet sum = (a, b) => a + b;\n\n\n1\n\n\n * 如果只有一个参数，还可以省略掉 () 。\n   \n   let double = n => n * 2;\n   \n   \n   1\n   \n\n * 如果没有参数，则括号是空的，但是括号必须保留。\n   \n   let sayhi = () => alert("hello!");\n   \n   sayhi();\n   \n   \n   1\n   2\n   3\n   \n\n * 箭头函数可看作为函数表达式：\n   \n   let age = prompt("what is your age?", 18);\n   \n   let welcome = (age < 18) ?\n     () => alert(\'hello\'!) :\n     () => alert("greetings!");\n   \n   welcome();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 多行箭头函数：用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）。\n   \n   let sum = (a, b) => {  /\n     let result = a + b;\n     return result; \n   };\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 函数的调用多种方法\n\n * 直接调用 test() ；\n * 通过对象调用 obj.test ；\n * 通过 new 调用\n * test.call/apply(obj) 让 test 成为 obj 的方法进行调用。\n\nvar obj = {}\nfunction test2 (){\n  this.xxx = \'aaa\'\n}\n// obj.test2()\ntest2.call(obj) // 相当于obj.test2\n// 可以让一个函数称为指定对象的方法进行调用\nconsole.log(obj.xxx) // aaa\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 网页按钮调用函数功能：\n\n<button onclick="myfunction(\'harry potter\',\'wizard\')">点击这里</button>\n\n<script>\nfunction myfunction(name,job){\n    alert("welcome " + name + ", the " + job);\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 带有返回值的函数：\n\nfunction myfunction(a,b)\n{\n    return a * b;\n}\n \ndocument.getelementbyid("demo").innerhtml=myfunction(4,3);\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 仅希望退出函数，可以使用 return\n\nfunction myfunction(a,b)\n{\n    if (a>b)\n    {\n        return;\n    }\n    x=a+b\n}\n// 如果 a 大于 b，则上面的代码将退出函数，并不会计算 a 和 b 的总和 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 立即执行函数：函数定义完，立刻被调用，往往只会执行一次：\n\n(function(a,b){  \n    console.log("a = "+a);  \n    console.log("b = "+b);  \n})(123,456); \n\n\n1\n2\n3\n4\n\n\n\n# 函数的关键字\n\nbreak ： 退出循环；\n\ncontinue ：跳过当次循环；\n\nreturn ：退出函数；\n\n\n# this\n\nthis 是函数的上下问对象，根据函数的调用方式不同会指向不同的对象：\n\n * 如果单独使用， this 表示全局对象。\n   \n   在浏览器中，window 就是该全局对象为 [object window]:\n   \n   严格模式下，如果单独使用， this 也是指向全局 (global) 对象。\n   \n   var x = this;\n   \n   \n   1\n   \n\n * 在函数中， this 表示全局对象。\n   \n   在浏览器中，window 就是该全局对象为 [object window]:\n   \n   严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined 。\n   \n   var name = \'simon\';\n   function shows(){\n     console.log(this.name);\n   }\n   \n   shows();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 以方法的形式调用时， this 表示该方法所属的对象：\n   \n   // 创建一个对象\n   var person = {\n     firstname: "john",\n     lastname : "doe",\n     id     : 5566,\n     fullname : function() {\n       return this.firstname + " " + this.lastname;\n     }\n   };\n   \n   // this 表示 person 对象。\n   // fullname 方法所属的对象就是 person。\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 对象方法中绑定：\n   \n   var person = {\n     firstname  : "john",\n     lastname   : "doe",\n     id         : 5566,\n     myfunction : function() {\n       return this;\n     }\n   };\n   // this 是 person 对象，person 对象是函数的所有者\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   var person = {\n     firstname: "john",\n     lastname : "doe",\n     id       : 5566,\n     fullname : function() {\n       return this.firstname + " " + this.lastname;\n     }\n   };\n   \n   // this.firstname 表示 this (person) 对象的 firstname 属性\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * 事件中， this 指向接收事件的 html 元素：\n   \n   <button onclick="this.style.display=\'none\'">\n   点我后我就消失了\n   </button>\n   \n   \n   1\n   2\n   3\n   \n\n * 显式函数绑定：在 javascript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。\n   \n   var person1 = {\n     fullname: function() {\n       return this.firstname + " " + this.lastname;\n     }\n   }\'\'\n   var person2 = {\n     firstname:"john",\n     lastname: "doe",\n   }\n   person1.fullname.call(person2);  // 返回 "john doe"\n   //使用 person2 作为参数来调用 person1.fullname 方法时, this 将指向 person2, 即便它是 person1 的方法\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\ncall() ： 直接传递函数的实参；\n\napply() ：通过第一个实参来制定函数中的 this\n\njavascript 中 call ()、apply ()、bind () 的用法 | 菜鸟教程 (runoob.com)\n\naruguments 和 this 类似，都是函数中的隐含的参数。是类数组元素，用来封装函数执行过程中的实参。所以即使不定义实参，也可以通过 arguments 来使用实参。arguments 中有一个属性 callee 表示当前执行的函数对象；\n\nx = findmax(1, 123, 500, 115, 44, 88);\n \nfunction findmax() {\n    var i, max = arguments[0];\n    \n    if(arguments.length < 2) return max;\n \n    for (i = 0; i < arguments.length; i++) {\n        if (arguments[i] > max) {\n            max = arguments[i];\n        }\n    }\n    return max;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\njavascript 函数参数 | 菜鸟教程 (runoob.com)\n\n\n# 构造函数\n\n构造函数是专门用来创建对象的函数，\n\n * 一个构造函数我们也可以称为一个类；\n\n * 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例；\n\n * 通过同一个构造函数创建的对象，我们称为一类对象；\n\n * 构造函数如果直接调用，它就是一个普通函数；如果使用 new 来调用，则它就是一个构造函数；\n\nfunction person(name , age , gender){  \n    this.name = name;  \n    this.age = age;  \n    this.gender = gender;  \n    this.sayname = function(){  \n        alert(this.name);  \n    };  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n构造函数的执行流程：\n\n * 创建一个新的对象，\n * 将新的对象作为函数的上下文对象 this ，\n * 执行函数中的代码，\n * 将新建的对象返回，',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📒 JavaScript 基础实例",frontmatter:{title:"📒 JavaScript 基础实例",date:"2021-09-24T16:55:23.000Z",permalink:"/pages/93f713/",categories:["🚶 前端入门基础","🍪 JavaScript"],tags:["JavaScript"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/30.%20%F0%9F%8D%AA%20JavaScript/100.%20%F0%9F%93%92%20JavaScript%20%E5%9F%BA%E7%A1%80%E5%AE%9E%E4%BE%8B.html",relativePath:"100. 🚶 前端入门基础/30. 🍪 JavaScript/100. 📒 JavaScript 基础实例.md",key:"v-5aec749e",path:"/pages/93f713/",headers:[{level:2,title:"1️⃣ 事件 🌰",slug:"事件-🌰",normalizedTitle:"1️⃣ 事件 🌰",charIndex:2},{level:2,title:"2️⃣ JavaScript 定时器 🌰",slug:"javascript-定时器-🌰",normalizedTitle:"2️⃣ javascript 定时器 🌰",charIndex:1478}],headersStr:"1️⃣ 事件 🌰 2️⃣ JavaScript 定时器 🌰",content:'# 1️⃣ 事件 🌰\n\n 1. div 跟随鼠标移动\n    \n    获取鼠标相对于窗口的坐标 clientX 和 clientY ：\n    \n    但是要注意网页高度大于网页窗口的高度时，鼠标相对于窗口的坐标与 div 的偏移量会出现偏差，需要加上滚动条的滚动长度。\n    \n    使用 scrollTop 获取滚动条的滚动长度，需要注意对不同的浏览器的兼容问题：\n    \n    window.onload = function () {\n        // 获取 box1 \n        var box = document.getElementById("box1");\n    \n        // 绑定鼠标移动时加你\n        document.onmousemove = function (event) {\n            event = event || window.event; // 解决兼容问题\n    \n            // 获取鼠标坐标,数值没有单位\n            // 是相对于可见窗口的坐标 \n            // 而 div 的偏移量是相对于整个网页\n            var left = event.clientX;\n            var top = event.clientY;\n    \n            // 获取滚动条top和left\n            // document.body.~ 适用于 Chrome\n            // document.documentElement.~ 适用于火狐和 IE\n            var st = document.body.scrollTop || document.documentElement.scrollTop;\n            var sl = document.body.scrollLeft || document.documentElement.scrollLeft;\n    \n            // 设置 box1 的偏移量\n            box1.style.left = left + sl + \'px\';\n            box1.style.top = top + st + \'px\';\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    直接获取鼠标相对于整个网页的坐标 pageX 和 pageY 即可：\n    \n    var left = event.pageX;\n    var top = event.pageY;\n    \n    // ... \n    \n     box1.style.left = left + \'px\';\n    box1.style.top = top + \'px\';\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n\n# 2️⃣ JavaScript 定时器 🌰\n\n 1. ⏲️ 定时器每秒自动切换\n\n<html>\n  <body>\n    <img src="" alt="" id="img1">\n    <button id="btn01">开始</button>\n    <button id="btn02">停止</button>\n</body>\n</html>\n<script type="text/javascript">\n        window.onload = function () {\n            // 1 获取图片标签元素\n            var img1 = document.getElementById("img1");\n\n            // 获取开始和停止的按钮\n            var btn01 = document.getElementById("btn01");\n            var btn02 = document.getElementById("btn02");\n\n\n            // 2 创建一个数组来保存图片的路径\n            var imgArr = ["https://placekitten.com/80/80", "https://placekitten.com/80/80", "https://placekitten.com/80/80", "https://placekitten.com/80/80"]\n\n            // 定义定时器标识\n            var timer;\n\n            // 3 创建一个变量用来保存当前图片的索引\n            var index = 0;\n\n            // 4 开启一个定时器，实现自动切换图片\n            btn01.onclick = function () {\n                /* 每点击一次就会创建一次定时器\n                 每一个定时器的标识都不同\n                 导致停止按钮只能关闭最后一次开启的定时器  */\n\n                // 每次创建一次定时器把上一次的定时器先关闭了\n                clearInterval(timer);\n\n                timer = setInterval(function () {\n                    // 使索引自增\n                    index++;\n\n                    // 使索引实现循环\n                    // 判断索引是否大于最大索引\n                    /* if (index >= imgArr.length){\n                        index = 0;\n                    } */\n                    // 或者使用取模法\n                    index = index % imgArr.length;\n\n                    // 修改图片元素标签的src属性\n                    img1.src = imgArr[index];\n                }, 1000)\n            }\n\n            btn02.onclick = function () {\n                clearInterval(timer);\n            }\n        }\n    <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n定时器的关闭与停止、定时器的唯一标识；',normalizedContent:'# 1️⃣ 事件 🌰\n\n 1. div 跟随鼠标移动\n    \n    获取鼠标相对于窗口的坐标 clientx 和 clienty ：\n    \n    但是要注意网页高度大于网页窗口的高度时，鼠标相对于窗口的坐标与 div 的偏移量会出现偏差，需要加上滚动条的滚动长度。\n    \n    使用 scrolltop 获取滚动条的滚动长度，需要注意对不同的浏览器的兼容问题：\n    \n    window.onload = function () {\n        // 获取 box1 \n        var box = document.getelementbyid("box1");\n    \n        // 绑定鼠标移动时加你\n        document.onmousemove = function (event) {\n            event = event || window.event; // 解决兼容问题\n    \n            // 获取鼠标坐标,数值没有单位\n            // 是相对于可见窗口的坐标 \n            // 而 div 的偏移量是相对于整个网页\n            var left = event.clientx;\n            var top = event.clienty;\n    \n            // 获取滚动条top和left\n            // document.body.~ 适用于 chrome\n            // document.documentelement.~ 适用于火狐和 ie\n            var st = document.body.scrolltop || document.documentelement.scrolltop;\n            var sl = document.body.scrollleft || document.documentelement.scrollleft;\n    \n            // 设置 box1 的偏移量\n            box1.style.left = left + sl + \'px\';\n            box1.style.top = top + st + \'px\';\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    直接获取鼠标相对于整个网页的坐标 pagex 和 pagey 即可：\n    \n    var left = event.pagex;\n    var top = event.pagey;\n    \n    // ... \n    \n     box1.style.left = left + \'px\';\n    box1.style.top = top + \'px\';\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n\n# 2️⃣ javascript 定时器 🌰\n\n 1. ⏲️ 定时器每秒自动切换\n\n<html>\n  <body>\n    <img src="" alt="" id="img1">\n    <button id="btn01">开始</button>\n    <button id="btn02">停止</button>\n</body>\n</html>\n<script type="text/javascript">\n        window.onload = function () {\n            // 1 获取图片标签元素\n            var img1 = document.getelementbyid("img1");\n\n            // 获取开始和停止的按钮\n            var btn01 = document.getelementbyid("btn01");\n            var btn02 = document.getelementbyid("btn02");\n\n\n            // 2 创建一个数组来保存图片的路径\n            var imgarr = ["https://placekitten.com/80/80", "https://placekitten.com/80/80", "https://placekitten.com/80/80", "https://placekitten.com/80/80"]\n\n            // 定义定时器标识\n            var timer;\n\n            // 3 创建一个变量用来保存当前图片的索引\n            var index = 0;\n\n            // 4 开启一个定时器，实现自动切换图片\n            btn01.onclick = function () {\n                /* 每点击一次就会创建一次定时器\n                 每一个定时器的标识都不同\n                 导致停止按钮只能关闭最后一次开启的定时器  */\n\n                // 每次创建一次定时器把上一次的定时器先关闭了\n                clearinterval(timer);\n\n                timer = setinterval(function () {\n                    // 使索引自增\n                    index++;\n\n                    // 使索引实现循环\n                    // 判断索引是否大于最大索引\n                    /* if (index >= imgarr.length){\n                        index = 0;\n                    } */\n                    // 或者使用取模法\n                    index = index % imgarr.length;\n\n                    // 修改图片元素标签的src属性\n                    img1.src = imgarr[index];\n                }, 1000)\n            }\n\n            btn02.onclick = function () {\n                clearinterval(timer);\n            }\n        }\n    <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n定时器的关闭与停止、定时器的唯一标识；',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔭 JavaScript 作用域",frontmatter:{title:"🔭 JavaScript 作用域",date:"2022-03-10T11:05:39.000Z",permalink:"/pages/f88075/",categories:["🚶 前端入门基础","🍪 JavaScript"],tags:["JavaScript基础"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/100.%20%F0%9F%9A%B6%20%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/30.%20%F0%9F%8D%AA%20JavaScript/50.%20%F0%9F%94%AD%20JavaScript%20%E4%BD%9C%E7%94%A8%E5%9F%9F%20.html",relativePath:"100. 🚶 前端入门基础/30. 🍪 JavaScript/50. 🔭 JavaScript 作用域 .md",key:"v-bdb3a544",path:"/pages/f88075/",headers:[{level:3,title:"局部作用域",slug:"局部作用域",normalizedTitle:"局部作用域",charIndex:30},{level:3,title:"全局作用域",slug:"全局作用域",normalizedTitle:"全局作用域",charIndex:347},{level:3,title:"作用域链",slug:"作用域链",normalizedTitle:"作用域链",charIndex:1007},{level:3,title:"声明提升",slug:"声明提升",normalizedTitle:"声明提升",charIndex:1220}],headersStr:"局部作用域 全局作用域 作用域链 声明提升",content:'作用域表示 JavaScript 变量的作用范围。\n\n\n# 局部作用域\n\n变量在函数内声明，变量为局部作用域。\n\n局部变量：只能在函数内部访问。\n\n// 此处不能调用 carName 变量\nfunction myFunction() {\n    var carName = "Volvo";\n    // 函数内可调用 carName 变量\n}\n\n\n1\n2\n3\n4\n5\n\n * 局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。\n * 因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。\n\n> 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找，一直会；\n\n\n# 全局作用域\n\n变量在函数外定义，即为全局变量。\n\n全局变量有 全局作用域： 网页中所有脚本和函数均可使用。\n\nvar carName = " Volvo";\n \n// 此处可调用 carName 变量\nfunction myFunction() {\n    // 函数内可调用 carName 变量\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n若在函数内没有使用 var 声明，也为全局变量：\n\n// 此处可调用 carName 变量\n \nfunction myFunction() {\n    carName = "Volvo";\n    // 此处可调用 carName 变量\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 直接在 script 标签中编写的代码都运行在全局作用域中；\n * 全局作用域在打开页面时创建，在页面关闭时销毁；\n * 全局作用域中有一个全局对象 window ，window 对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。\n   * 在全局作用域中创建的变量都会作为 window 对象的属性保存\n   * 在全局作用域中创建的函数都会作为 window 对象的方法保存\n   * 在全局作用域中创建的变量和函数可以在页面的任意位置访问。\n * 尽量不要在全局中创建变量；\n\n在 JS 中没有块级作用域；\n\n// example\nif(...){\n\tvar num = 1;\n}\n\nconsole.log(num); // 可以获取num\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 作用域链\n\n根据内部可以访问外部函数变量的机制，用链式查找决定哪些变量能被内部函数访问 —— 作用域链；\n\nvar num = 10;\n\nfunction fn(){\n    var num = 20;\n    function fun(){\n        console.log(num); // 就近原则为：往上一级查找num变量\n    }\n    fun();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 声明提升\n\nJavaScript 中，函数和变量的声明都会被提升到函数的最顶部。所以变量可以在使用后声明，先使用后声明。\n\nx = 5; // 变量 x 设置为 5\n\nelem = document.getElementById("demo"); // 查找元素\nelem.innerHTML = x;                     // 在元素中显示 x\n\nvar x; // 声明 x\n\n\n1\n2\n3\n4\n5\n6\n\n\n只有声明的变量会被提升，初始化的不会！\n\nvar x = 5; // 初始化 x\nvar y = 7; // 初始化 y\n\nelem = document.getElementById("demo"); // 查找元素\nelem.innerHTML = x + " " + y;           // 显示 x 和 y\n\n\n1\n2\n3\n4\n5\n\n\nvar x = 5; // 初始化 x\n\nelem = document.getElementById("demo"); // 查找元素\nelem.innerHTML = x + " " + y;           // 显示 x 和 y\n\nvar y = 7; // 初始化 y\n\n// y 输出了 undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n为了避免出现变量未定义的问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解。\n\nJavaScript 严格模式 (strict mode) 不允许使用未声明的变量。',normalizedContent:'作用域表示 javascript 变量的作用范围。\n\n\n# 局部作用域\n\n变量在函数内声明，变量为局部作用域。\n\n局部变量：只能在函数内部访问。\n\n// 此处不能调用 carname 变量\nfunction myfunction() {\n    var carname = "volvo";\n    // 函数内可调用 carname 变量\n}\n\n\n1\n2\n3\n4\n5\n\n * 局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。\n * 因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。\n\n> 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找，一直会；\n\n\n# 全局作用域\n\n变量在函数外定义，即为全局变量。\n\n全局变量有 全局作用域： 网页中所有脚本和函数均可使用。\n\nvar carname = " volvo";\n \n// 此处可调用 carname 变量\nfunction myfunction() {\n    // 函数内可调用 carname 变量\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n若在函数内没有使用 var 声明，也为全局变量：\n\n// 此处可调用 carname 变量\n \nfunction myfunction() {\n    carname = "volvo";\n    // 此处可调用 carname 变量\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 直接在 script 标签中编写的代码都运行在全局作用域中；\n * 全局作用域在打开页面时创建，在页面关闭时销毁；\n * 全局作用域中有一个全局对象 window ，window 对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。\n   * 在全局作用域中创建的变量都会作为 window 对象的属性保存\n   * 在全局作用域中创建的函数都会作为 window 对象的方法保存\n   * 在全局作用域中创建的变量和函数可以在页面的任意位置访问。\n * 尽量不要在全局中创建变量；\n\n在 js 中没有块级作用域；\n\n// example\nif(...){\n\tvar num = 1;\n}\n\nconsole.log(num); // 可以获取num\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 作用域链\n\n根据内部可以访问外部函数变量的机制，用链式查找决定哪些变量能被内部函数访问 —— 作用域链；\n\nvar num = 10;\n\nfunction fn(){\n    var num = 20;\n    function fun(){\n        console.log(num); // 就近原则为：往上一级查找num变量\n    }\n    fun();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 声明提升\n\njavascript 中，函数和变量的声明都会被提升到函数的最顶部。所以变量可以在使用后声明，先使用后声明。\n\nx = 5; // 变量 x 设置为 5\n\nelem = document.getelementbyid("demo"); // 查找元素\nelem.innerhtml = x;                     // 在元素中显示 x\n\nvar x; // 声明 x\n\n\n1\n2\n3\n4\n5\n6\n\n\n只有声明的变量会被提升，初始化的不会！\n\nvar x = 5; // 初始化 x\nvar y = 7; // 初始化 y\n\nelem = document.getelementbyid("demo"); // 查找元素\nelem.innerhtml = x + " " + y;           // 显示 x 和 y\n\n\n1\n2\n3\n4\n5\n\n\nvar x = 5; // 初始化 x\n\nelem = document.getelementbyid("demo"); // 查找元素\nelem.innerhtml = x + " " + y;           // 显示 x 和 y\n\nvar y = 7; // 初始化 y\n\n// y 输出了 undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n为了避免出现变量未定义的问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 javascript 解析步骤，易于我们理解。\n\njavascript 严格模式 (strict mode) 不允许使用未声明的变量。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥯 ES6 的变量与常量",frontmatter:{title:"🥯 ES6 的变量与常量",date:"2022-06-12T10:37:08.000Z",permalink:"/pages/519b8a/",categories:["🚶🏻 前端巩固基础","🍯 ES6 基本语法"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/01.%20%F0%9F%8D%AF%20ES6%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/10.%20%F0%9F%A5%AF%20ES6%20%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F.html",relativePath:"101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/10. 🥯 ES6 的变量与常量.md",key:"v-44f445c1",path:"/pages/519b8a/",headers:[{level:3,title:"let",slug:"let",normalizedTitle:"let",charIndex:15},{level:3,title:"const",slug:"const",normalizedTitle:"const",charIndex:21}],headersStr:"let const",content:'ES6 新增两个重要的关键字 let 和 const ；\n\n\n# let\n\n区别 let 与 var ：\n\n * let 在代码块内有效， var 在全局范围内有效；\n * let 只能声明一次， var 可以声明多次；\n\n{\n  let a = 0;\n  a\n  var b = 1;\n}\na // error: a is not defined\nb // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nlet a = 1;\nlet a = 1;\na // Identifier \'a\' has already been declared\n\n\n1\n2\n3\n\n\n🧮 在 for 循环计数中：\n\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function(){\n    console.log(i);\n  })\n}\n// 输出十个 10\n\nfor (let j = 0; j < 10; j++) {\n  setTimeout(function(){\n    console.log(j);\n  })\n}\n// 输出 0123456789\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 当使用 var 进行声明时， i 在全局范围有效，所以只有一个变量 i ，循环里的十个 setTimeout 是在循环结束之后才执行，所以 i 都为 10；\n * 当使用 let 进行声明时， j 只在本轮循环中有效，所以每次循环的 j 都是新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量。（JavaScript 引擎内部会记住前一个循环的值）\n\n相比于 var ， let 不存在变量提升：\n\nconsole.log(a);  //ReferenceError: a is not defined\nlet a = "apple";\n \nconsole.log(b);  //undefined\nvar b = "banana";\n\n\n1\n2\n3\n4\n5\n\n\n变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined 。\n\nvar 造成变量穿透：\n\n// let 定义的 i 只在循环内有效\nfor(let i = 0;i < 5;i++){\n  console.log(i);\n};\n\n// var 定义的 i 全区有效：\nfor(var i = 0;i < 5;i++){\n    console.log(i);\n};\nconsole.log("这里就是变量穿透：" + i)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# const\n\n用 const 定义一个只读变量（常量），声明之后不能修改，否则报错。\n\nconst PI = Math.PI;\n\n\n1\n\n\n暂时性死区：\n\nvar PI = "a";\nif(true){\n  console.log(PI);  // ReferenceError: PI is not defined\n  const PI = "3.1415926";\n}\n\n\n1\n2\n3\n4\n5\n\n\nES6 中规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。',normalizedContent:'es6 新增两个重要的关键字 let 和 const ；\n\n\n# let\n\n区别 let 与 var ：\n\n * let 在代码块内有效， var 在全局范围内有效；\n * let 只能声明一次， var 可以声明多次；\n\n{\n  let a = 0;\n  a\n  var b = 1;\n}\na // error: a is not defined\nb // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nlet a = 1;\nlet a = 1;\na // identifier \'a\' has already been declared\n\n\n1\n2\n3\n\n\n🧮 在 for 循环计数中：\n\nfor (var i = 0; i < 10; i++) {\n  settimeout(function(){\n    console.log(i);\n  })\n}\n// 输出十个 10\n\nfor (let j = 0; j < 10; j++) {\n  settimeout(function(){\n    console.log(j);\n  })\n}\n// 输出 0123456789\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 当使用 var 进行声明时， i 在全局范围有效，所以只有一个变量 i ，循环里的十个 settimeout 是在循环结束之后才执行，所以 i 都为 10；\n * 当使用 let 进行声明时， j 只在本轮循环中有效，所以每次循环的 j 都是新的变量，所以 settimeout 定时器里面的 j 其实是不同的变量。（javascript 引擎内部会记住前一个循环的值）\n\n相比于 var ， let 不存在变量提升：\n\nconsole.log(a);  //referenceerror: a is not defined\nlet a = "apple";\n \nconsole.log(b);  //undefined\nvar b = "banana";\n\n\n1\n2\n3\n4\n5\n\n\n变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined 。\n\nvar 造成变量穿透：\n\n// let 定义的 i 只在循环内有效\nfor(let i = 0;i < 5;i++){\n  console.log(i);\n};\n\n// var 定义的 i 全区有效：\nfor(var i = 0;i < 5;i++){\n    console.log(i);\n};\nconsole.log("这里就是变量穿透：" + i)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# const\n\n用 const 定义一个只读变量（常量），声明之后不能修改，否则报错。\n\nconst pi = math.pi;\n\n\n1\n\n\n暂时性死区：\n\nvar pi = "a";\nif(true){\n  console.log(pi);  // referenceerror: pi is not defined\n  const pi = "3.1415926";\n}\n\n\n1\n2\n3\n4\n5\n\n\nes6 中规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 pi 之前使用它会报错。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥖 ES6 的模版字符串",frontmatter:{title:"🥖 ES6 的模版字符串",date:"2022-06-12T10:38:24.000Z",permalink:"/pages/ce93cb/",categories:["🚶🏻 前端巩固基础","🍯 ES6 基本语法"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/01.%20%F0%9F%8D%AF%20ES6%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/20.%20%F0%9F%A5%96%20ES6%20%E7%9A%84%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/20. 🥖 ES6 的模版字符串.md",key:"v-9cb66582",path:"/pages/ce93cb/",headersStr:null,content:"ES6 中可以使用模版字符串，使用反引号 `` ；\n\n当字符串涉及动态更新的部分，可以使用反引号，在字符串中使用 ${} 引入变量。\n\n🌰 例子：\n\n使用单引号（或者双引号）声明字符串：\n\nlet info = {\n  name: 'simon',\n  address: 'anywhere'\n}\nlet info_str1 = string1 = \"Name is \" + info.name + \", address is \" + info.address;\nconsole.log(info_str1);\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用反引号声明字符串：\n\nlet info_str2 = `Name is ${info.name}, address is ${info.address}`;\nconsole.log(string2);\n\n\n1\n2\n",normalizedContent:"es6 中可以使用模版字符串，使用反引号 `` ；\n\n当字符串涉及动态更新的部分，可以使用反引号，在字符串中使用 ${} 引入变量。\n\n🌰 例子：\n\n使用单引号（或者双引号）声明字符串：\n\nlet info = {\n  name: 'simon',\n  address: 'anywhere'\n}\nlet info_str1 = string1 = \"name is \" + info.name + \", address is \" + info.address;\nconsole.log(info_str1);\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用反引号声明字符串：\n\nlet info_str2 = `name is ${info.name}, address is ${info.address}`;\nconsole.log(string2);\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥐 ES6 箭头函数与函数的默认参数",frontmatter:{title:"🥐 ES6 箭头函数与函数的默认参数",date:"2022-06-12T10:41:33.000Z",permalink:"/pages/4f8b56/",categories:["🚶🏻 前端巩固基础","🍯 ES6 基本语法"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/01.%20%F0%9F%8D%AF%20ES6%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/30.%20%F0%9F%A5%90%20ES6%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0.html",relativePath:"101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/30. 🥐 ES6 箭头函数与函数的默认参数.md",key:"v-586b2e40",path:"/pages/4f8b56/",headers:[{level:2,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:2},{level:2,title:"函数的默认参数",slug:"函数的默认参数",normalizedTitle:"函数的默认参数",charIndex:565}],headersStr:"箭头函数 函数的默认参数",content:'# 箭头函数\n\nES5 中的函数定义：\n\nfunction fun1() {\n    console.log("第一种写法");\n};\n\n\n1\n2\n3\n\n\nvar fun2 = function () {\n    console.log("第二种写法");\n};\n\n\n1\n2\n3\n\n\nES6 中的箭头函数：\n\n> 箭头函数最直观的三个特点：\n> \n>  1. 不需要 function 关键字来创建函数\n>  2. 可以省略 return 关键字\n>  3. 继承当前上下文的 this 关键字\n\n// 没有参数时：\nlet fun3 = () => {\n    console.log(\'箭头函数\');\n};\n\n\n1\n2\n3\n4\n\n\n// 有一个参数时，小括号可以省略\nlet fun4 = v => {\n    console.log(v);\n}\n\nfun4("一个参数时")\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 两个或以上的参数时\nlet fun5 = (a, b) => {\n    console.log(a*b);\n}\nfun5(4,5);\n\n\n1\n2\n3\n4\n5\n\n\n// 省略return\nlet fun6 = (a,b) => (a + b)\nlet res = fun6(4,5)\n\n\n1\n2\n3\n\n\n\n# 函数的默认参数\n\n给函数设定默认参数：\n\n// 默认参数 给参数列表设定初始值\nfunction add(a = 100, b = 100) {\n    console.log(a, b);\n}\n// 执行方法，会用默认值填充，打印出来100,200\nadd();\n// 覆盖默认值打印  结果是1，2      \nadd(1, 2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'# 箭头函数\n\nes5 中的函数定义：\n\nfunction fun1() {\n    console.log("第一种写法");\n};\n\n\n1\n2\n3\n\n\nvar fun2 = function () {\n    console.log("第二种写法");\n};\n\n\n1\n2\n3\n\n\nes6 中的箭头函数：\n\n> 箭头函数最直观的三个特点：\n> \n>  1. 不需要 function 关键字来创建函数\n>  2. 可以省略 return 关键字\n>  3. 继承当前上下文的 this 关键字\n\n// 没有参数时：\nlet fun3 = () => {\n    console.log(\'箭头函数\');\n};\n\n\n1\n2\n3\n4\n\n\n// 有一个参数时，小括号可以省略\nlet fun4 = v => {\n    console.log(v);\n}\n\nfun4("一个参数时")\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 两个或以上的参数时\nlet fun5 = (a, b) => {\n    console.log(a*b);\n}\nfun5(4,5);\n\n\n1\n2\n3\n4\n5\n\n\n// 省略return\nlet fun6 = (a,b) => (a + b)\nlet res = fun6(4,5)\n\n\n1\n2\n3\n\n\n\n# 函数的默认参数\n\n给函数设定默认参数：\n\n// 默认参数 给参数列表设定初始值\nfunction add(a = 100, b = 100) {\n    console.log(a, b);\n}\n// 执行方法，会用默认值填充，打印出来100,200\nadd();\n// 覆盖默认值打印  结果是1，2      \nadd(1, 2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥞 ES6 对象",frontmatter:{title:"🥞 ES6 对象",date:"2022-06-12T10:44:18.000Z",permalink:"/pages/876bd2/",categories:["🚶🏻 前端巩固基础","🍯 ES6 基本语法"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/01.%20%F0%9F%8D%AF%20ES6%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/40.%20%F0%9F%A5%9E%20ES6%20%E5%AF%B9%E8%B1%A1.html",relativePath:"101. 🚶🏻 前端巩固基础/01. 🍯 ES6 基本语法/40. 🥞 ES6 对象.md",key:"v-e275eb9c",path:"/pages/876bd2/",headers:[{level:2,title:"对象初始化简写",slug:"对象初始化简写",normalizedTitle:"对象初始化简写",charIndex:2},{level:2,title:"对象的解构",slug:"对象的解构",normalizedTitle:"对象的解构",charIndex:598},{level:2,title:"对象传播符号",slug:"对象传播符号",normalizedTitle:"对象传播符号",charIndex:1179}],headersStr:"对象初始化简写 对象的解构 对象传播符号",content:'# 对象初始化简写\n\n如果一个对象中的 key 和 value 的名字一样的情况下可以定义成一个。\n\n🌰 例子：\n\n> 在 ES5 语法中，对象的定义：\n> \n> let info = {\n>     title: "title",\n>     link: "link",\n>     go: function () {\n>         console.log(" logging ");\n>     }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\nES6 中进行简写：\n\nlet title = "title-text";\nlet link = "link-text";\nlet info2 = {\n    title,\n    link,\n    go() {\n        console.log(" logging ");\n    }\n}\n\nconsole.log(info2);\nconsole.log(info2.title);\nconsole.log(info2.link);\ninfo2.go();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 因为对象 key:value 存在：\n> \n>  1. key 和变量的名字一致时， 可以只指定一次；\n>  2. 函数可以省略 function ；\n\n\n# 对象的解构\n\n以往，对象一般使用 . 或者 [] 获取值或者调用方法。\n\nlet title = "title-text";\nlet link = "link-text";\nlet info2 = {\n    title,\n    link,\n    go() {\n        console.log(" logging ");\n    }\n}\n\n// 第一种方法：.\nconsole.log(info2);\nconsole.log(info2.title);\nconsole.log(info2.link);\ninfo2.go();\n\n// 第二种方法： []\nconsole.log(info2);\nconsole.log(info2["title"]);\nconsole.log(info2["link"]);\ninfo2["go"]();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nES 6 提供一些获取快捷获取对象属性和行为方式；\n\n// ES6 中对象解构：快速获取属性和方法\nconst { title, link, go } = info2;\nconsole.log(title);\nconsole.log(link);\ngo();\n\n\n1\n2\n3\n4\n5\n\n\n\n# 对象传播符号\n\n使用 ... 传播对象中的内容。\n\n🌰 例子：\n\n// 对象传播操作符\nlet person = {\n    name: "name-text",\n    address: "address-text",\n    link: "link-text",\n    phone: 123456,\n    go(){\n        console.log("logging");\n    }\n}\n\n// 传播操作符... 解构，剩下的部分赋予给person2\nlet {name, address, ...person2} = person;\n\nconsole.log(name);\nconsole.log(address);\nconsole.log(person2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'# 对象初始化简写\n\n如果一个对象中的 key 和 value 的名字一样的情况下可以定义成一个。\n\n🌰 例子：\n\n> 在 es5 语法中，对象的定义：\n> \n> let info = {\n>     title: "title",\n>     link: "link",\n>     go: function () {\n>         console.log(" logging ");\n>     }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\nes6 中进行简写：\n\nlet title = "title-text";\nlet link = "link-text";\nlet info2 = {\n    title,\n    link,\n    go() {\n        console.log(" logging ");\n    }\n}\n\nconsole.log(info2);\nconsole.log(info2.title);\nconsole.log(info2.link);\ninfo2.go();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 因为对象 key:value 存在：\n> \n>  1. key 和变量的名字一致时， 可以只指定一次；\n>  2. 函数可以省略 function ；\n\n\n# 对象的解构\n\n以往，对象一般使用 . 或者 [] 获取值或者调用方法。\n\nlet title = "title-text";\nlet link = "link-text";\nlet info2 = {\n    title,\n    link,\n    go() {\n        console.log(" logging ");\n    }\n}\n\n// 第一种方法：.\nconsole.log(info2);\nconsole.log(info2.title);\nconsole.log(info2.link);\ninfo2.go();\n\n// 第二种方法： []\nconsole.log(info2);\nconsole.log(info2["title"]);\nconsole.log(info2["link"]);\ninfo2["go"]();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nes 6 提供一些获取快捷获取对象属性和行为方式；\n\n// es6 中对象解构：快速获取属性和方法\nconst { title, link, go } = info2;\nconsole.log(title);\nconsole.log(link);\ngo();\n\n\n1\n2\n3\n4\n5\n\n\n\n# 对象传播符号\n\n使用 ... 传播对象中的内容。\n\n🌰 例子：\n\n// 对象传播操作符\nlet person = {\n    name: "name-text",\n    address: "address-text",\n    link: "link-text",\n    phone: 123456,\n    go(){\n        console.log("logging");\n    }\n}\n\n// 传播操作符... 解构，剩下的部分赋予给person2\nlet {name, address, ...person2} = person;\n\nconsole.log(name);\nconsole.log(address);\nconsole.log(person2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌱 node.js 基本使用",frontmatter:{title:"🌱 node.js 基本使用",date:"2022-02-11T23:34:25.000Z",permalink:"/pages/4e50dd/",categories:null,tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/10.%20%F0%9F%8C%B1%20NodeJS%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html",relativePath:"101. 🚶🏻 前端巩固基础/10. 🌱 NodeJS 基本使用.md",key:"v-c5c30270",path:"/pages/4e50dd/",headers:[{level:2,title:"Node.js 简介",slug:"node-js-简介",normalizedTitle:"node.js 简介",charIndex:2},{level:2,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:163},{level:2,title:"请求响应",slug:"请求响应",normalizedTitle:"请求响应",charIndex:359},{level:2,title:"NPM 包管理",slug:"npm-包管理",normalizedTitle:"npm 包管理",charIndex:736},{level:3,title:"管理项目",slug:"管理项目",normalizedTitle:"管理项目",charIndex:794},{level:3,title:"安装依赖 install",slug:"安装依赖-install",normalizedTitle:"安装依赖 install",charIndex:917},{level:3,title:"其他命令",slug:"其他命令",normalizedTitle:"其他命令",charIndex:1420},{level:3,title:"package.json",slug:"package-json",normalizedTitle:"package.json",charIndex:1041}],headersStr:"Node.js 简介 基本操作 请求响应 NPM 包管理 管理项目 安装依赖 install 其他命令 package.json",content:"# Node.js 简介\n\n * Node.js 是让 JavaScript 运行在服务端的开发平台。是一个基于 Chrome JavaScript 运行时建立的一个平台。底层架构是 JavaScript，文件后缀名为 .js ；\n * Node.js 是一个事件驱动 I/O 服务端的 JavaScript 环境；\n\n\n# 基本操作\n\n与 Java 程序比较，JavaScript 是解释性语言，不需要进行编译。\n\nNodejs 运行在 V8 (JVM) 引擎中，运行的命令是： node + 文件名.js 。\n\n🌰 例子：\n\n * 创建文件 hello.js\n\nconsole.log(\"Hello, Node.js\");\n\n\n1\n\n * 在终端中运行语句：\n\n$ node hello.js\n\n\n1\n\n\n\n# 请求响应\n\n🌰 创建文件 httpSever.js ：\n\nconst http = require('http'); // 导入 http 模块\n\n// 创建一个httpServer服务：\nhttp.createServer(function(requset, response){\n    response.writeHead(200, {'Content-type':'text/plain'}); // 写入head信息\n    response.end(\"hello Server!\"); // 向浏览器输出内容\n\n}).listen(8080); // 端口为8080\n\nconsole.log(\"server starting at http://localhost:8080\");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# NPM 包管理\n\nNPM 全称 Node Package Manager，是 Node.js 包管理工具。\n\n\n# 管理项目\n\n 1. 创建项目的文件夹📁；\n\n 2. 初始化项目：\n    \n    $ npm init\n    $ npm init -y # 直接生成pakage.json文件\n    \n    \n    1\n    2\n    \n\n\n# 安装依赖 install\n\n 1. 使用 npm install 安装依赖包的最新版，到 项目目录/node_modules 下：\n\n * 安装会自动在项目目录下添加 pakage-lock.json 文件，帮助锁定安装包的版本；\n * 会自动在 package.json 文件中，依赖包会被添加到 dependencies 节点下；\n\n$ npm install jquery\n$ npm install jquery@2.1.x # 安装特定的版本\n\n\n1\n2\n\n 2. devDependencies 节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖，使用 -D 参数将依赖添加到 devDependencies 节点：\n\n$ npm install --save-dev eslint\n$ npm install -D eslint\n\n\n1\n2\n\n 3. 全局安装命令行工具 -g 参数：\n\n$ npm install -g webpack\n\n\n1\n\n 4. 初始化传输或者备份后的项目：\n\n$ npm install # 根据package.json中的配置下载依赖\n\n\n1\n\n\n\n# 其他命令\n\n$ npm update <包名> # 更新包\n$ npm update -g <包名> # 全局更新包\n\n$ npm uninstall <包名> # 卸载包\n$ npm uninstall -g <包名>  # 全局卸载包\n\n\n1\n2\n3\n4\n5\n\n\n\n# package.json\n\n发布或者备份项目时， `node_modules` 文件夹可以不必保留，因为 `package.json` 提供了该项目的包的配置，只要运行命令：\n\n\n$ npm install\n$ npm i\n\n\n1\n2\n\n\n即可重新安装和生成 node_modules 。\n\n因此，在下载 Node.js 项目后，第一个要执行的命令是 npm install 。\n\n🔗 链接：\n\n> Node.js 中文官网：https://nodejs.org/zh-cn/",normalizedContent:"# node.js 简介\n\n * node.js 是让 javascript 运行在服务端的开发平台。是一个基于 chrome javascript 运行时建立的一个平台。底层架构是 javascript，文件后缀名为 .js ；\n * node.js 是一个事件驱动 i/o 服务端的 javascript 环境；\n\n\n# 基本操作\n\n与 java 程序比较，javascript 是解释性语言，不需要进行编译。\n\nnodejs 运行在 v8 (jvm) 引擎中，运行的命令是： node + 文件名.js 。\n\n🌰 例子：\n\n * 创建文件 hello.js\n\nconsole.log(\"hello, node.js\");\n\n\n1\n\n * 在终端中运行语句：\n\n$ node hello.js\n\n\n1\n\n\n\n# 请求响应\n\n🌰 创建文件 httpsever.js ：\n\nconst http = require('http'); // 导入 http 模块\n\n// 创建一个httpserver服务：\nhttp.createserver(function(requset, response){\n    response.writehead(200, {'content-type':'text/plain'}); // 写入head信息\n    response.end(\"hello server!\"); // 向浏览器输出内容\n\n}).listen(8080); // 端口为8080\n\nconsole.log(\"server starting at http://localhost:8080\");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# npm 包管理\n\nnpm 全称 node package manager，是 node.js 包管理工具。\n\n\n# 管理项目\n\n 1. 创建项目的文件夹📁；\n\n 2. 初始化项目：\n    \n    $ npm init\n    $ npm init -y # 直接生成pakage.json文件\n    \n    \n    1\n    2\n    \n\n\n# 安装依赖 install\n\n 1. 使用 npm install 安装依赖包的最新版，到 项目目录/node_modules 下：\n\n * 安装会自动在项目目录下添加 pakage-lock.json 文件，帮助锁定安装包的版本；\n * 会自动在 package.json 文件中，依赖包会被添加到 dependencies 节点下；\n\n$ npm install jquery\n$ npm install jquery@2.1.x # 安装特定的版本\n\n\n1\n2\n\n 2. devdependencies 节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖，使用 -d 参数将依赖添加到 devdependencies 节点：\n\n$ npm install --save-dev eslint\n$ npm install -d eslint\n\n\n1\n2\n\n 3. 全局安装命令行工具 -g 参数：\n\n$ npm install -g webpack\n\n\n1\n\n 4. 初始化传输或者备份后的项目：\n\n$ npm install # 根据package.json中的配置下载依赖\n\n\n1\n\n\n\n# 其他命令\n\n$ npm update <包名> # 更新包\n$ npm update -g <包名> # 全局更新包\n\n$ npm uninstall <包名> # 卸载包\n$ npm uninstall -g <包名>  # 全局卸载包\n\n\n1\n2\n3\n4\n5\n\n\n\n# package.json\n\n发布或者备份项目时， `node_modules` 文件夹可以不必保留，因为 `package.json` 提供了该项目的包的配置，只要运行命令：\n\n\n$ npm install\n$ npm i\n\n\n1\n2\n\n\n即可重新安装和生成 node_modules 。\n\n因此，在下载 node.js 项目后，第一个要执行的命令是 npm install 。\n\n🔗 链接：\n\n> node.js 中文官网：https://nodejs.org/zh-cn/",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔐 JavaScript Object 对象基础知识",frontmatter:{title:"🔐 JavaScript Object 对象基础知识",date:"2022-05-04T23:07:10.000Z",permalink:"/pages/b7cfae/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/10.%20%F0%9F%94%90%20JavaScript%20Object%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/10. 🔐 JavaScript Object 对象基础知识.md",key:"v-3ef35fa2",path:"/pages/b7cfae/",headers:[{level:2,title:"对象基础知识",slug:"对象基础知识",normalizedTitle:"对象基础知识",charIndex:113},{level:3,title:"对象的作用",slug:"对象的作用",normalizedTitle:"对象的作用",charIndex:124},{level:3,title:"对象的组成",slug:"对象的组成",normalizedTitle:"对象的组成",charIndex:147},{level:4,title:"计算属性",slug:"计算属性",normalizedTitle:"计算属性",charIndex:400},{level:4,title:"属性值简写",slug:"属性值简写",normalizedTitle:"属性值简写",charIndex:765},{level:4,title:"属性名命名",slug:"属性名命名",normalizedTitle:"属性名命名",charIndex:864},{level:3,title:"对象的访问",slug:"对象的访问",normalizedTitle:"对象的访问",charIndex:1145},{level:4,title:"属性存在 in 操作符",slug:"属性存在-in-操作符",normalizedTitle:"属性存在 in 操作符",charIndex:2022},{level:4,title:"对象的遍历",slug:"对象的遍历",normalizedTitle:"对象的遍历",charIndex:2579},{level:4,title:"对象特殊的顺序",slug:"对象特殊的顺序",normalizedTitle:"对象特殊的顺序",charIndex:2738},{level:3,title:"对象的分类",slug:"对象的分类",normalizedTitle:"对象的分类",charIndex:3102}],headersStr:"对象基础知识 对象的作用 对象的组成 计算属性 属性值简写 属性名命名 对象的访问 属性存在 in 操作符 对象的遍历 对象特殊的顺序 对象的分类",content:'JavaScript 使用对象用来存储键值对和更复杂的实体。\n\nJavaScript 对象是拥有属性和方法的数据。引用数据类型、复合数据类型，在对象中可以保存多个不同数据类型的属性。一个对象可以代表现实中的一个事物。\n\n\n# 对象基础知识\n\n\n# 对象的作用\n\n可以统一管理多个数据。\n\n\n# 对象的组成\n\n * 属性：属性名（一般为字符串）和属性值（任意）组成。\n * 方法：一种特别的属性，属性值为函数。\n\n对象的创建：使用带有可选 属性列表 的花括号 {…} 来创建对象。一个属性就是一个键值对（ “key: value” ），其中键（ key ）是一个字符串（也叫做属性名），值（ value ）可以是任何值。\n\n> 两种创建空对象的方法：\n> \n>  * 「构造函数」语法： let user = new Object();\n>  * 「字面量」语法： let user = {};\n\n# 计算属性\n\n当创建一个对象时，可以在对象字面量中使用方括号。这叫做 计算属性。例如：\n\nlet fruit = prompt("Which fruit to buy?", "apple");\nlet bag = {};\n\n// 从 fruit 变量中获取值\nbag[fruit] = 5;\n\n\n1\n2\n3\n4\n5\n\n\n使用更复杂的表达式：\n\nlet fruit = \'apple\';\nlet bag = {\n  [fruit + \'Computers\']: 5 // bag.appleComputers = 5\n};\n\n\n1\n2\n3\n4\n\n\n> 方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。\n\n# 属性值简写\n\n当属性名与属性值相同时，可以缩写为只写属性名：\n\nlet user = {\n  name,  // 与 name:name 相同\n  age: 30\n};\n\n\n1\n2\n3\n4\n\n\n# 属性名命名\n\n属性名命名没有限制（对于变量名，不能使用保留字）。可以是任何字符串或者 symbol。其他类型会被自动地转换为字符串。\n\n例如：属性名为数字，会被转化为字符串的数字，但是访问对象时，使用数字或者字符串的属性名皆可访问对象的属性。\n\nlet obj = {\n  0: "test" // 等同于 "0": "test"\n};\n\n// 都会输出相同的属性（数字 0 被转为字符串 "0"）\nalert( obj["0"] ); // test\nalert( obj[0] ); // test (相同的属性)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 对象的访问\n\n * .属性名 （无论是属性还是方法）。有时不能用，如属性名包含特殊字符 - 或者空格；属性名名不确定时。\n\n * [\'属性名\'] 通用。 例如， obj[\'name\'] 、 obj[\'setName\'](\'Simon\')\n\n * 必须使用 [‘属性名’] 访问对象的情况：\n\n// 属性名含有特殊字符时\np[\'content-type\'] = \'text/json\'\n\n// 属性名不确定时\nvar propName = \'myAge\'\nvar value = 18\n// p.proName = value 不能用\np[propName] = value\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 属性名也可以使用多字词语，但是需要加上引号：\n> \n> let user = {\n>   name: "John",\n>   age: 30,\n>   "likes birds": true  // 多词属性名必须加引号\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 此时访问对象同样要使用使用 [‘属性名’] ，或者使用以下方法：\n> \n> let key = "likes birds";\n> \n> // 跟 user["likes birds"] = true; 一样\n> user[key] = true;\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n * 上面提到使用变量访问对象，为代码带来了灵活性：\n\nlet user = {\n  name: "John",\n  age: 30\n};\n\nlet key = prompt("What do you want to know about the user?", "name");\n\n// 访问变量\nalert( user[key] ); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意\n\n通过变量访问对象，不可以使用 . 点符号访问。\n\n * 使用 delete 操作符移除对象属性：\n\ndelete user.age\n\n\n1\n\n\n# 属性存在 in 操作符\n\nJavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！ 读取不存在的属性只会得到 undefined 。\n\n检查属性是否存在，使用操作符 in ：\n\nlet user = { name: "John", age: 30 };\n\nalert( "age" in user ); // true，user.age 存在\nalert( "blabla" in user ); // false，user.blabla 不存在。\n\n\n1\n2\n3\n4\n\n>  * in 的左边必须是 属性名。通常是一个带引号的字符串。\n>  * 如果省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名（字符串变量）。\n\n> 为什么要使用 in 而不仅仅使用与 undefined 比较判断：\n> \n>  * 大部分情况下与 undefined 进行比较的确没有问题。\n>  * 但属性存在，并且存储的值是 undefined 的时候，此时与 undefined 比较就存在问题，只能使用 in 。这种情况很少发生，因为通常情况下不应该给对象赋值 undefined 。通常会用 null 来表示未知的或者空的值。因此， in 运算符是代码中的特殊来宾。\n\n# 对象的遍历\n\n使用 for … in 语句遍历对象：\n\nvar person = {fname:"Bill",lname:"Gates",age:56}; \n \nfor (x in person)  // x 为属性名\n{\n    txt = txt + person[x];\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 对象特殊的顺序\n\n当对象存在整数属性，整数属性会被进行排序，其他属性则按照 创建的顺序 显示。\n\n> ** 整数属性指的是：一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。** 而例如 +4 、 1.2 不是整数属性，不能相互转换。\n\n例如：\n\nlet codes = {\n  "49": "Germany",\n  "41": "Switzerland",\n  "44": "Great Britain",\n  // ..,\n  "1": "USA"\n};\n\nfor(let code in codes) {\n  alert(code); // 1, 41, 44, 49\n}\n// 如果想要按照创建的顺序输出，给每个属性名加一个‘+’号即可。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 对象的分类\n\n 1. 内建对象：由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用，为开发者提供一些常用或最基本的功能 / 属性 / 方法，帮助快速开发。\n    \n    📁 查询参考文档： 使用对象 - JavaScript | MDN (mozilla.org)\n    \n    * Math 对象：Math 对象中具有数学常数和函数的属性与方法；跟数学相关的运算可以使用：\n    \n    * random() 随机对象\n    \n    * 日期对象：与 Math 不一样，Date 对象式构造函数，需要实例化后才能使用；\n    \n    * 数组对象；\n    \n    * 字符串对象；\n\n 2. 宿主对象：由 JavaScript 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象；例如 BOM DOM；\n\n 3. 自定义对象：自己创建的对象：',normalizedContent:'javascript 使用对象用来存储键值对和更复杂的实体。\n\njavascript 对象是拥有属性和方法的数据。引用数据类型、复合数据类型，在对象中可以保存多个不同数据类型的属性。一个对象可以代表现实中的一个事物。\n\n\n# 对象基础知识\n\n\n# 对象的作用\n\n可以统一管理多个数据。\n\n\n# 对象的组成\n\n * 属性：属性名（一般为字符串）和属性值（任意）组成。\n * 方法：一种特别的属性，属性值为函数。\n\n对象的创建：使用带有可选 属性列表 的花括号 {…} 来创建对象。一个属性就是一个键值对（ “key: value” ），其中键（ key ）是一个字符串（也叫做属性名），值（ value ）可以是任何值。\n\n> 两种创建空对象的方法：\n> \n>  * 「构造函数」语法： let user = new object();\n>  * 「字面量」语法： let user = {};\n\n# 计算属性\n\n当创建一个对象时，可以在对象字面量中使用方括号。这叫做 计算属性。例如：\n\nlet fruit = prompt("which fruit to buy?", "apple");\nlet bag = {};\n\n// 从 fruit 变量中获取值\nbag[fruit] = 5;\n\n\n1\n2\n3\n4\n5\n\n\n使用更复杂的表达式：\n\nlet fruit = \'apple\';\nlet bag = {\n  [fruit + \'computers\']: 5 // bag.applecomputers = 5\n};\n\n\n1\n2\n3\n4\n\n\n> 方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。\n\n# 属性值简写\n\n当属性名与属性值相同时，可以缩写为只写属性名：\n\nlet user = {\n  name,  // 与 name:name 相同\n  age: 30\n};\n\n\n1\n2\n3\n4\n\n\n# 属性名命名\n\n属性名命名没有限制（对于变量名，不能使用保留字）。可以是任何字符串或者 symbol。其他类型会被自动地转换为字符串。\n\n例如：属性名为数字，会被转化为字符串的数字，但是访问对象时，使用数字或者字符串的属性名皆可访问对象的属性。\n\nlet obj = {\n  0: "test" // 等同于 "0": "test"\n};\n\n// 都会输出相同的属性（数字 0 被转为字符串 "0"）\nalert( obj["0"] ); // test\nalert( obj[0] ); // test (相同的属性)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 对象的访问\n\n * .属性名 （无论是属性还是方法）。有时不能用，如属性名包含特殊字符 - 或者空格；属性名名不确定时。\n\n * [\'属性名\'] 通用。 例如， obj[\'name\'] 、 obj[\'setname\'](\'simon\')\n\n * 必须使用 [‘属性名’] 访问对象的情况：\n\n// 属性名含有特殊字符时\np[\'content-type\'] = \'text/json\'\n\n// 属性名不确定时\nvar propname = \'myage\'\nvar value = 18\n// p.proname = value 不能用\np[propname] = value\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 属性名也可以使用多字词语，但是需要加上引号：\n> \n> let user = {\n>   name: "john",\n>   age: 30,\n>   "likes birds": true  // 多词属性名必须加引号\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 此时访问对象同样要使用使用 [‘属性名’] ，或者使用以下方法：\n> \n> let key = "likes birds";\n> \n> // 跟 user["likes birds"] = true; 一样\n> user[key] = true;\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n * 上面提到使用变量访问对象，为代码带来了灵活性：\n\nlet user = {\n  name: "john",\n  age: 30\n};\n\nlet key = prompt("what do you want to know about the user?", "name");\n\n// 访问变量\nalert( user[key] ); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意\n\n通过变量访问对象，不可以使用 . 点符号访问。\n\n * 使用 delete 操作符移除对象属性：\n\ndelete user.age\n\n\n1\n\n\n# 属性存在 in 操作符\n\njavascript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！ 读取不存在的属性只会得到 undefined 。\n\n检查属性是否存在，使用操作符 in ：\n\nlet user = { name: "john", age: 30 };\n\nalert( "age" in user ); // true，user.age 存在\nalert( "blabla" in user ); // false，user.blabla 不存在。\n\n\n1\n2\n3\n4\n\n>  * in 的左边必须是 属性名。通常是一个带引号的字符串。\n>  * 如果省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名（字符串变量）。\n\n> 为什么要使用 in 而不仅仅使用与 undefined 比较判断：\n> \n>  * 大部分情况下与 undefined 进行比较的确没有问题。\n>  * 但属性存在，并且存储的值是 undefined 的时候，此时与 undefined 比较就存在问题，只能使用 in 。这种情况很少发生，因为通常情况下不应该给对象赋值 undefined 。通常会用 null 来表示未知的或者空的值。因此， in 运算符是代码中的特殊来宾。\n\n# 对象的遍历\n\n使用 for … in 语句遍历对象：\n\nvar person = {fname:"bill",lname:"gates",age:56}; \n \nfor (x in person)  // x 为属性名\n{\n    txt = txt + person[x];\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 对象特殊的顺序\n\n当对象存在整数属性，整数属性会被进行排序，其他属性则按照 创建的顺序 显示。\n\n> ** 整数属性指的是：一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。** 而例如 +4 、 1.2 不是整数属性，不能相互转换。\n\n例如：\n\nlet codes = {\n  "49": "germany",\n  "41": "switzerland",\n  "44": "great britain",\n  // ..,\n  "1": "usa"\n};\n\nfor(let code in codes) {\n  alert(code); // 1, 41, 44, 49\n}\n// 如果想要按照创建的顺序输出，给每个属性名加一个‘+’号即可。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 对象的分类\n\n 1. 内建对象：由 es 标准中定义的对象，在任何的 es 的实现中都可以使用，为开发者提供一些常用或最基本的功能 / 属性 / 方法，帮助快速开发。\n    \n    📁 查询参考文档： 使用对象 - javascript | mdn (mozilla.org)\n    \n    * math 对象：math 对象中具有数学常数和函数的属性与方法；跟数学相关的运算可以使用：\n    \n    * random() 随机对象\n    \n    * 日期对象：与 math 不一样，date 对象式构造函数，需要实例化后才能使用；\n    \n    * 数组对象；\n    \n    * 字符串对象；\n\n 2. 宿主对象：由 javascript 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象；例如 bom dom；\n\n 3. 自定义对象：自己创建的对象：',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⌛️ JavaScript 对象的复制与引用",frontmatter:{title:"⌛️ JavaScript 对象的复制与引用",date:"2022-05-04T23:47:42.000Z",permalink:"/pages/01d74c/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/11.%20%E2%8C%9B%EF%B8%8F%20JavaScript%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%BC%95%E7%94%A8.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/11. ⌛️ JavaScript 对象的复制与引用.md",key:"v-2ed9553b",path:"/pages/01d74c/",headers:[{level:2,title:"通过引用比较",slug:"通过引用比较",normalizedTitle:"通过引用比较",charIndex:602},{level:2,title:"对象的克隆与合并",slug:"对象的克隆与合并",normalizedTitle:"对象的克隆与合并",charIndex:875},{level:2,title:"对象的深层克隆",slug:"对象的深层克隆",normalizedTitle:"对象的深层克隆",charIndex:2266}],headersStr:"通过引用比较 对象的克隆与合并 对象的深层克隆",content:'与原始类型相比，对象的根本区别之一是对象是「通过引用」被存储和复制的，与原始类型值相反：字符串，数字，布尔值等 —— 始终是以「整体值」的形式被复制的。\n\n🌰 例子：\n\nlet user = {\n  name: \'simon\'\n}\n\n\n1\n2\n3\n\n\n在对象中，赋值了对象的变量存储的不是对象本身，而是该对象「在内存中的地址」 —— 换句话说就是对该对象的「引用」。\n\n上述例子中，对象内容被存储在内存中的某个位置，而变量 user 保存的是对其的「引用」。（可以想象对象变量为一张写有对象的地址的纸） 如果要对对象执行操作，例如获取属性，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。\n\n🌰 例子：\n\nlet admin = user; // 赋值引用\n\n\n1\n\n\n当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。此时两个对象变量，保存的都是对同一个对象的引用。\n\n🌰 例子：\n\nlet user = { name: \'simon\' };\nlet admin = user;\nadmin.name = \'bimon\'; // 通过 "admin" 引用来修改\nalert(user.name);\n\n\n1\n2\n3\n4\n\n\n此时修改对象的内容：可以通过其中任意一个变量访问该对象，并且修改它的内容。（带有两把钥匙的柜子，届可以更改柜子里面的内容）\n\n\n# 通过引用比较\n\n仅当两个对象为同一对象时，两者才相等。\n\n🌰 比较两个引用自同一个对象的对象变量：\n\nlet a = {};\nlet b = a; // 复制引用\n\nalert( a == b ); // true，都引用同一对象\nalert( a === b ); // true\n\n\n1\n2\n3\n4\n5\n\n\n🌰 比较两个看似「相同」的对象变量：\n\nlet a = {};\nlet b = {}; // 两个独立的对象\n\nalert( a == b ); // false\n\n\n1\n2\n3\n4\n\n\n> 实际上，对象的比较很少进行。\n\n\n# 对象的克隆与合并\n\n如果想要复制一个对象，创建一个独立于原来对象的拷贝。通过两种方法：\n\n * 遍历对象复制：\n   \n   let user = {\n     name: "John",\n     age: 30\n   };\n   \n   let clone = {}; // 新的空对象\n   \n   // 将 user 中所有的属性拷贝到其中\n   for (let key in user) {\n     clone[key] = user[key];\n   }\n   \n   // 现在 clone 是带有相同内容的完全独立的对象\n   clone.name = "Pete"; // 改变了其中的数据\n   \n   alert( user.name ); // 原来的对象中的 name 属性依然是 John\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * 使用 Object.assign 方法来达成同样的效果，语法为： Object.assign(dest, [src1, src2, src3...]) ，（ dest 目标对象， src... 源对象）\n   \n   let user = {\n     name: "John",\n     age: 30\n   };\n   \n   let clone = Object.assign({}, user);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   通过 Object.assign 合并对象的例子：\n   \n   let user = { name: "John" };\n   \n   let permissions1 = { canView: true };\n   let permissions2 = { canEdit: true };\n   \n   // 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中\n   Object.assign(user, permissions1, permissions2);\n   \n   // 现在 user = { name: "John", canView: true, canEdit: true }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   如果被拷贝的属性已经存在，则覆盖原来的属性：\n   \n   let user = { name: "John" };\n   Object.assign(user, { name: "Pete" });\n   alert(user.name); // 现在 user = { name: "Pete" }\n   \n   \n   1\n   2\n   3\n   \n\n> JavaScript 进阶用法中，可以直接使用结构对象（？）传递语法， clone = { …user } 完成对象的克隆。Rest 参数与 Spread 语法 (javascript.info)\n\n\n# 对象的深层克隆\n\n前面所述的对象属性，皆为原始类型。但是对象中的属性也可以是对其他对象的引用。上面的简单克隆拷贝是行不通的，因为到了属性为对象时，简单的复制，仍然为对其他对象的引用拷贝。\n\nlet user = {\n  name: "John",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nlet clone = Object.assign({}, user);\n\nalert( user.sizes === clone.sizes ); // true，同一个对象\n\n// user 和 clone 分享同一个 sizes\nuser.sizes.width++;       // 通过其中一个改变属性值\nalert(clone.sizes.width); // 51，能从另外一个看到变更的结果\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n要解决这个问题，应该使用一个拷贝循环来检查 user[key] 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的「深拷贝」。可以使用 递归 实现，在 lodash 库的 _.cloneDeep(obj)。\n\n注意\n\n由于对象的引用存储特性，使用 const 声明的对象是可以被修改的。\n\n🌰 例子：\n\nconst user = {\n  name: "John"\n};\n\nuser.name = "Pete"; // (*)\n\nalert(user.name); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 虽然 user 的值是一个常量。但这里的「常量」指的是始终引用同一个对象。而该对象的值可以被修改。\n> \n> 只有试图对该变量的整体进行赋值时，才会报错。\n> \n> 创建常量的对象属性：属性标志和属性描述符',normalizedContent:'与原始类型相比，对象的根本区别之一是对象是「通过引用」被存储和复制的，与原始类型值相反：字符串，数字，布尔值等 —— 始终是以「整体值」的形式被复制的。\n\n🌰 例子：\n\nlet user = {\n  name: \'simon\'\n}\n\n\n1\n2\n3\n\n\n在对象中，赋值了对象的变量存储的不是对象本身，而是该对象「在内存中的地址」 —— 换句话说就是对该对象的「引用」。\n\n上述例子中，对象内容被存储在内存中的某个位置，而变量 user 保存的是对其的「引用」。（可以想象对象变量为一张写有对象的地址的纸） 如果要对对象执行操作，例如获取属性，javascript 引擎会查看该地址中的内容，并在实际对象上执行操作。\n\n🌰 例子：\n\nlet admin = user; // 赋值引用\n\n\n1\n\n\n当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。此时两个对象变量，保存的都是对同一个对象的引用。\n\n🌰 例子：\n\nlet user = { name: \'simon\' };\nlet admin = user;\nadmin.name = \'bimon\'; // 通过 "admin" 引用来修改\nalert(user.name);\n\n\n1\n2\n3\n4\n\n\n此时修改对象的内容：可以通过其中任意一个变量访问该对象，并且修改它的内容。（带有两把钥匙的柜子，届可以更改柜子里面的内容）\n\n\n# 通过引用比较\n\n仅当两个对象为同一对象时，两者才相等。\n\n🌰 比较两个引用自同一个对象的对象变量：\n\nlet a = {};\nlet b = a; // 复制引用\n\nalert( a == b ); // true，都引用同一对象\nalert( a === b ); // true\n\n\n1\n2\n3\n4\n5\n\n\n🌰 比较两个看似「相同」的对象变量：\n\nlet a = {};\nlet b = {}; // 两个独立的对象\n\nalert( a == b ); // false\n\n\n1\n2\n3\n4\n\n\n> 实际上，对象的比较很少进行。\n\n\n# 对象的克隆与合并\n\n如果想要复制一个对象，创建一个独立于原来对象的拷贝。通过两种方法：\n\n * 遍历对象复制：\n   \n   let user = {\n     name: "john",\n     age: 30\n   };\n   \n   let clone = {}; // 新的空对象\n   \n   // 将 user 中所有的属性拷贝到其中\n   for (let key in user) {\n     clone[key] = user[key];\n   }\n   \n   // 现在 clone 是带有相同内容的完全独立的对象\n   clone.name = "pete"; // 改变了其中的数据\n   \n   alert( user.name ); // 原来的对象中的 name 属性依然是 john\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * 使用 object.assign 方法来达成同样的效果，语法为： object.assign(dest, [src1, src2, src3...]) ，（ dest 目标对象， src... 源对象）\n   \n   let user = {\n     name: "john",\n     age: 30\n   };\n   \n   let clone = object.assign({}, user);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   通过 object.assign 合并对象的例子：\n   \n   let user = { name: "john" };\n   \n   let permissions1 = { canview: true };\n   let permissions2 = { canedit: true };\n   \n   // 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中\n   object.assign(user, permissions1, permissions2);\n   \n   // 现在 user = { name: "john", canview: true, canedit: true }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   如果被拷贝的属性已经存在，则覆盖原来的属性：\n   \n   let user = { name: "john" };\n   object.assign(user, { name: "pete" });\n   alert(user.name); // 现在 user = { name: "pete" }\n   \n   \n   1\n   2\n   3\n   \n\n> javascript 进阶用法中，可以直接使用结构对象（？）传递语法， clone = { …user } 完成对象的克隆。rest 参数与 spread 语法 (javascript.info)\n\n\n# 对象的深层克隆\n\n前面所述的对象属性，皆为原始类型。但是对象中的属性也可以是对其他对象的引用。上面的简单克隆拷贝是行不通的，因为到了属性为对象时，简单的复制，仍然为对其他对象的引用拷贝。\n\nlet user = {\n  name: "john",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nlet clone = object.assign({}, user);\n\nalert( user.sizes === clone.sizes ); // true，同一个对象\n\n// user 和 clone 分享同一个 sizes\nuser.sizes.width++;       // 通过其中一个改变属性值\nalert(clone.sizes.width); // 51，能从另外一个看到变更的结果\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n要解决这个问题，应该使用一个拷贝循环来检查 user[key] 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的「深拷贝」。可以使用 递归 实现，在 lodash 库的 _.clonedeep(obj)。\n\n注意\n\n由于对象的引用存储特性，使用 const 声明的对象是可以被修改的。\n\n🌰 例子：\n\nconst user = {\n  name: "john"\n};\n\nuser.name = "pete"; // (*)\n\nalert(user.name); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 虽然 user 的值是一个常量。但这里的「常量」指的是始终引用同一个对象。而该对象的值可以被修改。\n> \n> 只有试图对该变量的整体进行赋值时，才会报错。\n> \n> 创建常量的对象属性：属性标志和属性描述符',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧭  JavaScript 垃圾回收机制",frontmatter:{title:"🧭  JavaScript 垃圾回收机制",date:"2022-05-04T23:47:42.000Z",permalink:"/pages/d20597/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/12.%20%F0%9F%A7%AD%20%20JavaScript%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/12. 🧭  JavaScript 垃圾回收机制.md",key:"v-2cb1cf16",path:"/pages/d20597/",headers:[{level:2,title:"可达性",slug:"可达性",normalizedTitle:"可达性",charIndex:152},{level:2,title:"结合可达性与垃圾回收",slug:"结合可达性与垃圾回收",normalizedTitle:"结合可达性与垃圾回收",charIndex:492},{level:2,title:"内部算法",slug:"内部算法",normalizedTitle:"内部算法",charIndex:1596}],headersStr:"可达性 结合可达性与垃圾回收 内部算法",content:'> 在 JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数…… 这一切都会占用内存。当不需要某个东西， JavaScript 该如何发现并清理？\n> \n>  * 垃圾：没有任何对象需要（没有任何变量引用它们的对象数据）\n\n了解 JavaScript 的垃圾回收机制之前先来了解可达性：\n\n\n# 可达性\n\nJavaScript 中主要的内存管理概念是 可达性。「可达」意思是以某种方式可访问或可用的值，它们一定是存储在内存中的。\n\n>  * 固有的可达值基本集合（这些值显然不能被释放），这些值被称为根（Root）。：\n>    \n>    * 当前执行的函数，它的局部变量和参数。\n>    \n>    * 当前嵌套调用链上的其他函数、它们的局部变量和参数。\n>    \n>    * 全局变量。\n>    \n>    * （还有一些内部的）\n> \n>  * 还有可以通过引用或引用链从根访问任何其他值，也是可达的。\n\n在 JavaScript 引擎中有一个被称作 垃圾回收器 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。\n\n\n# 结合可达性与垃圾回收\n\n🌰 例子：一个对象的引用\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "John"\n};\n\n\n1\n2\n3\n4\n\n\n全局变量 "user" 引用了对象 {name："John"} 。John 的 "name" 属性存储一个原始值，所以它被写在对象内部。\n\n当 user = null ， user 的值被重写了，这个引用就没了。现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。\n\n🌰 例子： 两个对象的引用：\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "John"\n};\n\nlet admin = user;\n\n\n1\n2\n3\n4\n5\n6\n\n\n再执行 user = null 。此时，对象仍然可以被通过 admin 这个全局变量访问到（ admin 仍然保留对 John 的引用），所以对象还在内存中。如果又重写了 admin （ admin = null ），对象才会被删除。\n\n🌰 例子：相互关联的对象：\n\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nlet family = marry({\n  name: "John"\n}, {\n  name: "Ann"\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nmarry 函数通过让两个对象相互引用使它们 “结婚” 了，并返回了一个包含这两个对象的新对象。如下图，所有对象都是「可达的」。\n\n * 此时移除两个引用：\n   \n   delete family.father\n   delete family.mother.husband\n   \n   \n   1\n   2\n   \n   \n   可以看到「到达 John 的两条途径」显然都被移除了，所以此时 John 是不可达的。这是 John 将被从内存中移除，同时 John 的所有数据都将变得不可达。\n\n * 「无法到达的岛屿」：如果此时重写 family ，即\n   \n   family = null\n   \n   \n   1\n   \n   \n   此时虽然内部几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是「不可达」的，并被从内存中删除。\n\n\n# 内部算法\n\n垃圾回收的基本算法被称为 「mark-and-sweep」。\n\n> 定期执行以下「垃圾回收」步骤：\n> \n>  * 垃圾收集器找到所有的根，并「标记」（记住）它们。\n>  * 然后它遍历并「标记」来自它们的所有引用。\n>  * 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。\n>  * …… 如此操作，直到所有可达的（从根部）引用都被访问到。\n>  * 没有被标记的对象都会被删除。',normalizedContent:'> 在 javascript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数…… 这一切都会占用内存。当不需要某个东西， javascript 该如何发现并清理？\n> \n>  * 垃圾：没有任何对象需要（没有任何变量引用它们的对象数据）\n\n了解 javascript 的垃圾回收机制之前先来了解可达性：\n\n\n# 可达性\n\njavascript 中主要的内存管理概念是 可达性。「可达」意思是以某种方式可访问或可用的值，它们一定是存储在内存中的。\n\n>  * 固有的可达值基本集合（这些值显然不能被释放），这些值被称为根（root）。：\n>    \n>    * 当前执行的函数，它的局部变量和参数。\n>    \n>    * 当前嵌套调用链上的其他函数、它们的局部变量和参数。\n>    \n>    * 全局变量。\n>    \n>    * （还有一些内部的）\n> \n>  * 还有可以通过引用或引用链从根访问任何其他值，也是可达的。\n\n在 javascript 引擎中有一个被称作 垃圾回收器 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。\n\n\n# 结合可达性与垃圾回收\n\n🌰 例子：一个对象的引用\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "john"\n};\n\n\n1\n2\n3\n4\n\n\n全局变量 "user" 引用了对象 {name："john"} 。john 的 "name" 属性存储一个原始值，所以它被写在对象内部。\n\n当 user = null ， user 的值被重写了，这个引用就没了。现在 john 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。\n\n🌰 例子： 两个对象的引用：\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "john"\n};\n\nlet admin = user;\n\n\n1\n2\n3\n4\n5\n6\n\n\n再执行 user = null 。此时，对象仍然可以被通过 admin 这个全局变量访问到（ admin 仍然保留对 john 的引用），所以对象还在内存中。如果又重写了 admin （ admin = null ），对象才会被删除。\n\n🌰 例子：相互关联的对象：\n\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nlet family = marry({\n  name: "john"\n}, {\n  name: "ann"\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nmarry 函数通过让两个对象相互引用使它们 “结婚” 了，并返回了一个包含这两个对象的新对象。如下图，所有对象都是「可达的」。\n\n * 此时移除两个引用：\n   \n   delete family.father\n   delete family.mother.husband\n   \n   \n   1\n   2\n   \n   \n   可以看到「到达 john 的两条途径」显然都被移除了，所以此时 john 是不可达的。这是 john 将被从内存中移除，同时 john 的所有数据都将变得不可达。\n\n * 「无法到达的岛屿」：如果此时重写 family ，即\n   \n   family = null\n   \n   \n   1\n   \n   \n   此时虽然内部几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是「不可达」的，并被从内存中删除。\n\n\n# 内部算法\n\n垃圾回收的基本算法被称为 「mark-and-sweep」。\n\n> 定期执行以下「垃圾回收」步骤：\n> \n>  * 垃圾收集器找到所有的根，并「标记」（记住）它们。\n>  * 然后它遍历并「标记」来自它们的所有引用。\n>  * 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。\n>  * …… 如此操作，直到所有可达的（从根部）引用都被访问到。\n>  * 没有被标记的对象都会被删除。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📡 JavaScript 对象方法",frontmatter:{title:"📡 JavaScript 对象方法",date:"2022-05-04T23:47:42.000Z",permalink:"/pages/a661c0/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/13.%20%F0%9F%93%A1%20JavaScript%20%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/13. 📡 JavaScript 对象方法.md",key:"v-f88617ea",path:"/pages/a661c0/",headers:[{level:2,title:"对象方法概念",slug:"对象方法概念",normalizedTitle:"对象方法概念",charIndex:2},{level:3,title:"对象方法声明简写",slug:"对象方法声明简写",normalizedTitle:"对象方法声明简写",charIndex:319},{level:3,title:"方法的链式调用",slug:"方法的链式调用",normalizedTitle:"方法的链式调用",charIndex:531},{level:2,title:"⭐️ 关于方法中的 this 问题",slug:"关于方法中的-this-问题",normalizedTitle:"⭐️ 关于方法中的 this 问题",charIndex:902},{level:3,title:"this 不受限制",slug:"this-不受限制",normalizedTitle:"this 不受限制",charIndex:1753},{level:3,title:"箭头函数的 this",slug:"箭头函数的-this",normalizedTitle:"箭头函数的 this",charIndex:2692}],headersStr:"对象方法概念 对象方法声明简写 方法的链式调用 ⭐️ 关于方法中的 this 问题 this 不受限制 箭头函数的 this",content:'# 对象方法概念\n\n对象常常可以用来表示真实世界中的实体，在真实世界中对实体的操作，对应 JavaScript 中的 对象方法（Action），由属性中的函数来表示。\n\n🌰 例子：\n\n * 创建对象后，给对象指定函数：\n\nlet user = {\n  name: "John",\n  age: 30\n};\n\nuser.sayHi = function() {\n  alert("Hello!");\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n也可以首先声明函数再添加到对象：\n\nfunction sayHi() {\n  alert("Hello!");\n}\n\nuser.sayHi = sayHi;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 对象方法声明简写\n\nuser = {\n  sayHi: function() {\n    alert("Hello");\n  }\n};\n\n// 简写为：\nlet user = {\n  sayHi() { \n    alert("Hello");\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 但其实两种写法，在对象继承方面有一些细微的差别。在几乎所有的情况下，较短的语法是首选的。\n\n\n# 方法的链式调用\n\n🌰 例子：在对象中的方法，每次都返回对象本身即可实现：\n\nlet ladder = {\n  step: 0,\n  up() {\n    this.step++;\n    return this;\n  },\n  down() {\n    this.step--;\n    return this;\n  },\n  showStep() {\n    alert( this.step );\n    return this;\n  }\n};\n\nladder\n  .up()\n  .up()\n  .down()\n  .showStep()\n  .down()\n  .showStep(); \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ⭐️ 关于方法中的 this 问题\n\n通常对象方法需要访问对象中存储的信息才能完成其工作。为了访问该对象，方法中可以使用 this 关键字。 this 的值就是在点之前的这个对象，即调用该方法的对象。\n\n🌰 例子：\n\nlet user = {\n  name: "John",\n  age: 30,\n\n  sayHi() {\n    // "this" 指的是“当前的对象”\n    alert(this.name);\n  }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> this 只在调用那一刻才重要：\n> \n> 例子：\n> \n> function makeUser() {\n>   return {\n>     name: "John",\n>     ref: this\n>   };\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> \n> \n> 这里 makeUser() 中的 this 的值是 undefined ，因为它是被作为函数调用的，而不是通过点符号被作为方法调用。\n> \n> this 的值是对于整个函数的，代码段和对象字面量对它都没有影响。所以 ref: this 实际上取的是当前函数的 this 。\n> \n> 相当于：\n> \n> function makeUser(){\n>   return this\n> }\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 只有写成才正确：\n> \n> function makeUser() {\n>   return {\n>     name: "John",\n>     ref() {\n>       return this;\n>     }\n>   };\n> }\n> \n> let user = makeUser();\n> alert( user.ref().name ); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n\n# this 不受限制\n\n在 JavaScript 中， this 关键字与其他大多数编程语言中的不同。JavaScript 中的 this 可以用于任何函数，即使它不是对象的方法。\n\n * this 的值是在代码运行时计算出来的，它取决于代码上下文。遵循谁调用谁是 this 的原则，例如：\n   \n   let user = { name: "John" };\n   let admin = { name: "Admin" };\n   \n   function sayHi() {\n     alert( this.name );\n   }\n   \n   // 在两个对象中使用相同的函数\n   user.f = sayHi;\n   admin.f = sayHi;\n   \n   // 这两个调用有不同的 this 值\n   // 函数内部的 "this" 是“点符号前面”的那个对象\n   user.f(); // John（this == user）\n   admin.f(); // Admin（this == admin）\n   admin[\'f\']();  // Admin\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n   \n   > 使用点符号还是方括号访问对象方法，不影响 this 的指向。\n\n * 在没有对象的情况下调用： this == undefined 。例如：\n   \n   function sayHi() {\n     alert(this);\n   }\n   \n   sayHi();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n> 在严格模式下 this 的值为 undefined ，如果尝试访问则会报错。\n> \n> 非严格模式下， this 是 全局对象（浏览器中的 window 对象）（JavaSript 历史行为，）\n\n** 通常如果一个函数内部有 this ，一般它是在对象上下文环境调用的。** 而不应该是 undefiend 。\n\n\n# 箭头函数的 this\n\n箭头函数没有自己的 this 。如果箭头函数中引用 this ， this 值取决于外部「正常的」函数。\n\n🌰 例子：\n\nlet user = {\n  firstName: "Ilya",\n  sayHi() {\n    let arrow = () => alert(this.firstName); // this === user\n    arrow();\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n箭头函数的 this 特性帮助我们在不想要一个独立的 this ，反而要从外部的上下文中获取时很有用。',normalizedContent:'# 对象方法概念\n\n对象常常可以用来表示真实世界中的实体，在真实世界中对实体的操作，对应 javascript 中的 对象方法（action），由属性中的函数来表示。\n\n🌰 例子：\n\n * 创建对象后，给对象指定函数：\n\nlet user = {\n  name: "john",\n  age: 30\n};\n\nuser.sayhi = function() {\n  alert("hello!");\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n也可以首先声明函数再添加到对象：\n\nfunction sayhi() {\n  alert("hello!");\n}\n\nuser.sayhi = sayhi;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 对象方法声明简写\n\nuser = {\n  sayhi: function() {\n    alert("hello");\n  }\n};\n\n// 简写为：\nlet user = {\n  sayhi() { \n    alert("hello");\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 但其实两种写法，在对象继承方面有一些细微的差别。在几乎所有的情况下，较短的语法是首选的。\n\n\n# 方法的链式调用\n\n🌰 例子：在对象中的方法，每次都返回对象本身即可实现：\n\nlet ladder = {\n  step: 0,\n  up() {\n    this.step++;\n    return this;\n  },\n  down() {\n    this.step--;\n    return this;\n  },\n  showstep() {\n    alert( this.step );\n    return this;\n  }\n};\n\nladder\n  .up()\n  .up()\n  .down()\n  .showstep()\n  .down()\n  .showstep(); \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ⭐️ 关于方法中的 this 问题\n\n通常对象方法需要访问对象中存储的信息才能完成其工作。为了访问该对象，方法中可以使用 this 关键字。 this 的值就是在点之前的这个对象，即调用该方法的对象。\n\n🌰 例子：\n\nlet user = {\n  name: "john",\n  age: 30,\n\n  sayhi() {\n    // "this" 指的是“当前的对象”\n    alert(this.name);\n  }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> this 只在调用那一刻才重要：\n> \n> 例子：\n> \n> function makeuser() {\n>   return {\n>     name: "john",\n>     ref: this\n>   };\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> \n> \n> 这里 makeuser() 中的 this 的值是 undefined ，因为它是被作为函数调用的，而不是通过点符号被作为方法调用。\n> \n> this 的值是对于整个函数的，代码段和对象字面量对它都没有影响。所以 ref: this 实际上取的是当前函数的 this 。\n> \n> 相当于：\n> \n> function makeuser(){\n>   return this\n> }\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 只有写成才正确：\n> \n> function makeuser() {\n>   return {\n>     name: "john",\n>     ref() {\n>       return this;\n>     }\n>   };\n> }\n> \n> let user = makeuser();\n> alert( user.ref().name ); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n\n# this 不受限制\n\n在 javascript 中， this 关键字与其他大多数编程语言中的不同。javascript 中的 this 可以用于任何函数，即使它不是对象的方法。\n\n * this 的值是在代码运行时计算出来的，它取决于代码上下文。遵循谁调用谁是 this 的原则，例如：\n   \n   let user = { name: "john" };\n   let admin = { name: "admin" };\n   \n   function sayhi() {\n     alert( this.name );\n   }\n   \n   // 在两个对象中使用相同的函数\n   user.f = sayhi;\n   admin.f = sayhi;\n   \n   // 这两个调用有不同的 this 值\n   // 函数内部的 "this" 是“点符号前面”的那个对象\n   user.f(); // john（this == user）\n   admin.f(); // admin（this == admin）\n   admin[\'f\']();  // admin\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n   \n   > 使用点符号还是方括号访问对象方法，不影响 this 的指向。\n\n * 在没有对象的情况下调用： this == undefined 。例如：\n   \n   function sayhi() {\n     alert(this);\n   }\n   \n   sayhi();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n> 在严格模式下 this 的值为 undefined ，如果尝试访问则会报错。\n> \n> 非严格模式下， this 是 全局对象（浏览器中的 window 对象）（javasript 历史行为，）\n\n** 通常如果一个函数内部有 this ，一般它是在对象上下文环境调用的。** 而不应该是 undefiend 。\n\n\n# 箭头函数的 this\n\n箭头函数没有自己的 this 。如果箭头函数中引用 this ， this 值取决于外部「正常的」函数。\n\n🌰 例子：\n\nlet user = {\n  firstname: "ilya",\n  sayhi() {\n    let arrow = () => alert(this.firstname); // this === user\n    arrow();\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n箭头函数的 this 特性帮助我们在不想要一个独立的 this ，反而要从外部的上下文中获取时很有用。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"💾 JavaScript 对象构造器",frontmatter:{title:"💾 JavaScript 对象构造器",date:"2022-05-05T09:21:47.000Z",permalink:"/pages/42cfe9/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/14.%20%F0%9F%92%BE%20JavaScript%20%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E5%99%A8.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/14. 💾 JavaScript 对象构造器.md",key:"v-7d208927",path:"/pages/42cfe9/",headers:[{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:53},{level:3,title:"构造器的 return",slug:"构造器的-return",normalizedTitle:"构造器的 return",charIndex:928},{level:3,title:"构造器中的方法",slug:"构造器中的方法",normalizedTitle:"构造器中的方法",charIndex:1476},{level:2,title:"构造器总结",slug:"构造器总结",normalizedTitle:"构造器总结",charIndex:1685}],headersStr:"构造函数 构造器的 return 构造器中的方法 构造器总结",content:'常规的 {...} 语法允许创建一个对象。但是在需要创建很多类似的对象，例如多个用户或菜单项等。这可以使用构造函数和 "new" 操作符来实现。\n\n\n# 构造函数\n\n构造函数在技术上是常规函数。不过有两个约定：\n\n 1. 命名以大写字母开头。\n 2. 只能由 new 操作符来执行。\n\n🌰 例子：\n\nfunction User(name) {\n  // this = {} (隐式创建对象) \n  this.name = name;\n  this.isAdmin = false;\n\t\n  // return this (隐式返回对象)\n}\n\nlet user = new User("Jack");\n\nalert(user.name); // Jack\nalert(user.isAdmin); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当一个函数被使用 new 操作符执行时，它按照以下步骤：\n\n 1. 一个新的空对象被创建并分配给 this 。\n 2. 函数体执行。通常它会修改 this ，为其添加新的属性。\n 3. 返回 this 的值。\n\n使用构造器实现可重用的对象创建代码。任何函数（除了箭头函数，它没有自己的 this ）都可以用作构造器。即可以通过 new 来运行，它会执行上面的算法。「首字母大写」是一个共同的约定，以明确表示一个函数将被使用 new 来运行。\n\n> 当无参构造时，括号可以省略，例如： let user = new User 。但是省略括号不是一种好的代码风格，影响代码可读性。\n\n> 关于 new function() ：如果有许多行用于创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中：\n> \n> let user = new function() {\n>   this.name = \'Simon\'\n>   this.isAdmin = false\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。\n\n\n# 构造器的 return\n\n通常，构造器没有 return 语句，它们的任务是将所有必要的东西写入 this ，并自动转换为结果。\n\n但是，如果这有一个 return 语句，那么规则就简单了：\n\n * 如果 return 返回的是一个对象，则返回这个对象，而不是 this （会覆盖掉原来返回的 this ）。🌰 例如：\n   \n   function BigUser() {\n     this.name = "John";\n     return { name: "Godzilla" };  // <-- 返回这个对象\n   }\n   \n   alert( new BigUser().name ); \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 如果 return 返回的是一个原始类型，则忽略。例如：\n   \n   function SmallUser() {\n     this.name = "John";\n     return; // <-- 返回 this\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n提示\n\n通常构造器中不会有 return 语句。 return 返回对象是特殊行为。\n\n\n# 构造器中的方法\n\n🌰 例子：\n\nfunction User(name) {\n  this.name = name;\n\n  this.sayHi = function() {\n    alert( "My name is: " + this.name );\n  };\n}\n\nlet simon = new User(\'Simon\')\nsimon.sayHi()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造器总结\n\n * 构造函数为创建对象带来灵活性。构造函数的参数，定义了如何构造对象以及要在对象放入什么。\n * 构造函数只能使用 new 来调用。这样调用意味着开始创建了空 this ，最后返回了填充了值的 this .\n * JavaScript 还为许多内建对象提供了构造函数，比如 日期 Date 、集合 Set 。',normalizedContent:'常规的 {...} 语法允许创建一个对象。但是在需要创建很多类似的对象，例如多个用户或菜单项等。这可以使用构造函数和 "new" 操作符来实现。\n\n\n# 构造函数\n\n构造函数在技术上是常规函数。不过有两个约定：\n\n 1. 命名以大写字母开头。\n 2. 只能由 new 操作符来执行。\n\n🌰 例子：\n\nfunction user(name) {\n  // this = {} (隐式创建对象) \n  this.name = name;\n  this.isadmin = false;\n\t\n  // return this (隐式返回对象)\n}\n\nlet user = new user("jack");\n\nalert(user.name); // jack\nalert(user.isadmin); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当一个函数被使用 new 操作符执行时，它按照以下步骤：\n\n 1. 一个新的空对象被创建并分配给 this 。\n 2. 函数体执行。通常它会修改 this ，为其添加新的属性。\n 3. 返回 this 的值。\n\n使用构造器实现可重用的对象创建代码。任何函数（除了箭头函数，它没有自己的 this ）都可以用作构造器。即可以通过 new 来运行，它会执行上面的算法。「首字母大写」是一个共同的约定，以明确表示一个函数将被使用 new 来运行。\n\n> 当无参构造时，括号可以省略，例如： let user = new user 。但是省略括号不是一种好的代码风格，影响代码可读性。\n\n> 关于 new function() ：如果有许多行用于创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中：\n> \n> let user = new function() {\n>   this.name = \'simon\'\n>   this.isadmin = false\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。\n\n\n# 构造器的 return\n\n通常，构造器没有 return 语句，它们的任务是将所有必要的东西写入 this ，并自动转换为结果。\n\n但是，如果这有一个 return 语句，那么规则就简单了：\n\n * 如果 return 返回的是一个对象，则返回这个对象，而不是 this （会覆盖掉原来返回的 this ）。🌰 例如：\n   \n   function biguser() {\n     this.name = "john";\n     return { name: "godzilla" };  // <-- 返回这个对象\n   }\n   \n   alert( new biguser().name ); \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 如果 return 返回的是一个原始类型，则忽略。例如：\n   \n   function smalluser() {\n     this.name = "john";\n     return; // <-- 返回 this\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n提示\n\n通常构造器中不会有 return 语句。 return 返回对象是特殊行为。\n\n\n# 构造器中的方法\n\n🌰 例子：\n\nfunction user(name) {\n  this.name = name;\n\n  this.sayhi = function() {\n    alert( "my name is: " + this.name );\n  };\n}\n\nlet simon = new user(\'simon\')\nsimon.sayhi()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造器总结\n\n * 构造函数为创建对象带来灵活性。构造函数的参数，定义了如何构造对象以及要在对象放入什么。\n * 构造函数只能使用 new 来调用。这样调用意味着开始创建了空 this ，最后返回了填充了值的 this .\n * javascript 还为许多内建对象提供了构造函数，比如 日期 date 、集合 set 。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗽 JavaScript symbol 类型",frontmatter:{title:"🗽 JavaScript symbol 类型",date:"2022-05-05T11:05:15.000Z",permalink:"/pages/a17557/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/16.%20%F0%9F%97%BD%20JavaScript%20symbol%20%E7%B1%BB%E5%9E%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/16. 🗽 JavaScript symbol 类型.md",key:"v-5ceaba30",path:"/pages/a17557/",headers:[{level:3,title:"symbol 唯一标识符",slug:"symbol-唯一标识符",normalizedTitle:"symbol 唯一标识符",charIndex:101},{level:3,title:"symbol 隐藏属性",slug:"symbol-隐藏属性",normalizedTitle:"symbol 隐藏属性",charIndex:761},{level:3,title:"在对象字面量中使用 symbol",slug:"在对象字面量中使用-symbol",normalizedTitle:"在对象字面量中使用 symbol",charIndex:1416},{level:3,title:"在遍历循环中的 symbol",slug:"在遍历循环中的-symbol",normalizedTitle:"在遍历循环中的 symbol",charIndex:1633},{level:3,title:"全局 symbol",slug:"全局-symbol",normalizedTitle:"全局 symbol",charIndex:2110},{level:4,title:"Symbol.for(key)",slug:"symbol-for-key",normalizedTitle:"symbol.for(key)",charIndex:2321},{level:4,title:"Symbol.keyFor",slug:"symbol-keyfor",normalizedTitle:"symbol.keyfor",charIndex:2681},{level:3,title:"JavaScript 系统 symbol",slug:"javascript-系统-symbol",normalizedTitle:"javascript 系统 symbol",charIndex:3351},{level:2,title:"symbol 总结",slug:"symbol-总结",normalizedTitle:"symbol 总结",charIndex:3552}],headersStr:"symbol 唯一标识符 symbol 隐藏属性 在对象字面量中使用 symbol 在遍历循环中的 symbol 全局 symbol Symbol.for(key) Symbol.keyFor JavaScript 系统 symbol symbol 总结",content:"在 JavaScript 规范中，只有两种原始类型可以作为对象的属性键（key）。\n\n * 字符串 （使用其他的原始类型，例如数字或者布尔类型，都会自动转化为字符串）\n * symbol 类型\n\n\n# symbol 唯一标识符\n\n语法：可以使用 Symbol() 创建 symbol 类型的值，返回给变量一个唯一的标识符的值。在括号中的参数可以是一个描述（描述可以相同）。\n\n🌰 例子： let id = Symbol() / let id = Symbol(\"id\")\n\nsymbol 保证是唯一的。即使创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。\n\n🌰 例子：\n\nlet id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\nalert(id1 == id2); // false\n\n\n1\n2\n3\n4\n\n\n> symbol 类型不会被自动转换为字符串。JavaScript 中的大多数值都支持字符串的隐式转换。例如，可以 alert 任何值（自动转换为字符串输出），都可以生效。symbol 比较特殊，它不会被自动转换。\n> \n> 🌰 例子：\n> \n> let id = Symbol(\"id\");\n> alert(id); // 类型错误：无法将 symbol 值转换为字符串。\n> \n> \n> 1\n> 2\n> \n> \n> 可以使用强制转换解决：（将 symbol 转换为字符串）\n> \n> alert(id.toString())\n> \n> \n> 1\n> \n> \n> 或者只显示描述：\n> \n> et id = Symbol(\"id\");\n> alert(id.description)\n> \n> \n> 1\n> 2\n\n\n# symbol 隐藏属性\n\nsymbol 允许我们创建对象的「隐藏」属性，代码的任何其他部分都不能意外访问或重写这些属性。\n\n🌰 例子：\n\nlet user {\n  name = 'Simon'\n}\n\nlet id = Sysbol('id')\nuser.[id] = 1 // 添加新的属性\nalert(user[id])\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nuser 对象属于其他的代码，那些代码也会使用这个对象，所以我们不应该在它上面直接添加任何字段，这样很不安全。但是你添加的 symbol 属性不会被意外访问到，第三方代码根本不会看到它，所以使用 symbol 基本上不会有问题。\n\n🌰 例子：假设另一个脚本希望在 user 中有自己的标识符，以实现自己的目的。这可能是另一个 JavaScript 库，因此脚本之间完全不了解彼此。\n\n然后该脚本可以创建自己的 Symbol(\"id\") ，像这样：\n\nlet id = Symbol('id')\nuser[id] = 'their id value'\n\n\n1\n2\n\n\n虽然有相同的名称，但是 symbol 类型保证了唯一性。\n\n> 如果仅仅使用字符串作为属性名：\n> \n> let user = { \n>   // ... \n> }\n> // 一个脚本中\n> user.id = 'id1'\n> // 另一个脚本中也添加id，产生冲突\n> user.id = 'id2'\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n\n# 在对象字面量中使用 symbol\n\n在对象 { … } 字面量中使用 symbol 时，需要使用方括号把它括起来。\n\n🌰 例子：\n\nlet id = Symbol('id')\nlet user = {\n  name: 'Simon',\n  [id]: 123\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 这里需要 symbol 类型的 id 作为对象属性的键， 所以需要使用方括号 [] 区分开字符串 ‘id’ 与 symbol。\n\n\n# 在遍历循环中的 symbol\n\n⭐️ symbol 属性不参与 for..in 循环。（同理还有 Object.keys() ）这是一般「隐藏符号属性」原则的一部分，如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。\n\n🌰 例子：\n\nlet id = Symbol('id')\nlet user = {\n  name: 'Simon',\n  [id]: 123\n}\n\nfor (let key in user) alert(key) // 只有name\n\nalert(user[id]) // 单独可以直接访问\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n但是在 Object.assign() 中，会同时复制字符串和 symbol 属性。\n\n🌰 例子：\n\nlet id = Symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = Object.assign({}, user);\n\nalert( clone[id] ); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 全局 symbol\n\n如前所述，通常所有的 symbol 都是不同的，即使它们有相同的名字。但有时想要名字相同的 symbol 具有相同的实体时，例如，应用程序的不同部分想要访问的 symbol \"id\" 指的是完全相同的属性。\n\n为了实现这一点，可以使用 全局 symbol 注册表。可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。\n\n# Symbol.for(key)\n\n * 从注册表读取（不存在则创建） symbol ，使用 Symbol.for(key)\n   \n   （该调用会检查全局注册表，如果有一个描述为 key 的 symbol，则返回该 symbol，否则将创建一个新 symbol（ Symbol(key) ），并通过给定的 key 将其存储在注册表中。）\n\n * 注册表中的 symbol 被称为 全局 symbol。如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 —— 这就是它们的用途。\n\n🌰 例子：\n\nlet id = Symbol.for('id')\nlet idAgain = Symbol.for('id')\n\nalert(id === idAgain) // true\n\n\n1\n2\n3\n4\n\n\n# Symbol.keyFor\n\n * Symbol.keyFor(symbol) ，它的作用与 Symbol.for(key) 完全反过来：通过全局 symbol 返回一个名字。\n\n * 作用是查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 undefined 。\n\n * 任何 symbol 都具有 description 属性。\n\n🌰 例子：\n\n// 通过 name 获取 symbol\nlet sym = Symbol.for(\"name\");\nlet sym2 = Symbol.for(\"id\");\n\n// 通过 symbol 获取 name\nalert( Symbol.keyFor(sym) ); // name\nalert( Symbol.keyFor(sym2) ); // id\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子：（非全局 symbol）\n\nlet globalSymbol = Symbol.for(\"name\");\nlet localSymbol = Symbol(\"name\");\n\nalert( Symbol.keyFor(globalSymbol) ); // name，全局 symbol\nalert( Symbol.keyFor(localSymbol) ); // undefined，非全局\n\nalert( localSymbol.description ); // name\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# JavaScript 系统 symbol\n\navaScript 内部有很多「系统 symbol」，可以使用它们来微调对象的各个方面。它们都被列在了 众所周知的 symbol 表的规范中：\n\n * Symbol.hasInstance\n * Symbol.isConcatSpreadable\n * Symbol.iterator\n * Symbol.toPrimitive\n * …… 等等。\n\n\n# symbol 总结\n\n * symbol 是 唯一标识符的基本类型，使用带有可选描述（name）的 Symbol() 调用创建的。\n * symbol 总是 不同的值，即使它们有相同的名字。如果希望同名的 symbol 相等，那么应该使用全局注册表： Symbol.for(key) 返回（如果需要的话则创建）一个以 key 作为名字的全局 symbol。使用 Symbol.for 多次调用 key 相同的 symbol 时，返回的就是同一个 symbol。\n * symbol 不是 100% 隐藏的。有一个内建方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 symbol。还有一个名为 Reflect.ownKeys(obj) 的方法可以返回一个对象的 所有 键，包括 symbol。所以它们并不是真正的隐藏。\n\n使用 symbol 的场景：\n\n * 隐藏对象属性。\n * JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。可以使用它们来改变一些内建行为。例如，使用 Symbol.iterator 来进行 迭代 操作，使用 Symbol.toPrimitive 来设置 对象原始值的转换 等等。",normalizedContent:"在 javascript 规范中，只有两种原始类型可以作为对象的属性键（key）。\n\n * 字符串 （使用其他的原始类型，例如数字或者布尔类型，都会自动转化为字符串）\n * symbol 类型\n\n\n# symbol 唯一标识符\n\n语法：可以使用 symbol() 创建 symbol 类型的值，返回给变量一个唯一的标识符的值。在括号中的参数可以是一个描述（描述可以相同）。\n\n🌰 例子： let id = symbol() / let id = symbol(\"id\")\n\nsymbol 保证是唯一的。即使创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。\n\n🌰 例子：\n\nlet id1 = symbol(\"id\");\nlet id2 = symbol(\"id\");\n\nalert(id1 == id2); // false\n\n\n1\n2\n3\n4\n\n\n> symbol 类型不会被自动转换为字符串。javascript 中的大多数值都支持字符串的隐式转换。例如，可以 alert 任何值（自动转换为字符串输出），都可以生效。symbol 比较特殊，它不会被自动转换。\n> \n> 🌰 例子：\n> \n> let id = symbol(\"id\");\n> alert(id); // 类型错误：无法将 symbol 值转换为字符串。\n> \n> \n> 1\n> 2\n> \n> \n> 可以使用强制转换解决：（将 symbol 转换为字符串）\n> \n> alert(id.tostring())\n> \n> \n> 1\n> \n> \n> 或者只显示描述：\n> \n> et id = symbol(\"id\");\n> alert(id.description)\n> \n> \n> 1\n> 2\n\n\n# symbol 隐藏属性\n\nsymbol 允许我们创建对象的「隐藏」属性，代码的任何其他部分都不能意外访问或重写这些属性。\n\n🌰 例子：\n\nlet user {\n  name = 'simon'\n}\n\nlet id = sysbol('id')\nuser.[id] = 1 // 添加新的属性\nalert(user[id])\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nuser 对象属于其他的代码，那些代码也会使用这个对象，所以我们不应该在它上面直接添加任何字段，这样很不安全。但是你添加的 symbol 属性不会被意外访问到，第三方代码根本不会看到它，所以使用 symbol 基本上不会有问题。\n\n🌰 例子：假设另一个脚本希望在 user 中有自己的标识符，以实现自己的目的。这可能是另一个 javascript 库，因此脚本之间完全不了解彼此。\n\n然后该脚本可以创建自己的 symbol(\"id\") ，像这样：\n\nlet id = symbol('id')\nuser[id] = 'their id value'\n\n\n1\n2\n\n\n虽然有相同的名称，但是 symbol 类型保证了唯一性。\n\n> 如果仅仅使用字符串作为属性名：\n> \n> let user = { \n>   // ... \n> }\n> // 一个脚本中\n> user.id = 'id1'\n> // 另一个脚本中也添加id，产生冲突\n> user.id = 'id2'\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n\n# 在对象字面量中使用 symbol\n\n在对象 { … } 字面量中使用 symbol 时，需要使用方括号把它括起来。\n\n🌰 例子：\n\nlet id = symbol('id')\nlet user = {\n  name: 'simon',\n  [id]: 123\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 这里需要 symbol 类型的 id 作为对象属性的键， 所以需要使用方括号 [] 区分开字符串 ‘id’ 与 symbol。\n\n\n# 在遍历循环中的 symbol\n\n⭐️ symbol 属性不参与 for..in 循环。（同理还有 object.keys() ）这是一般「隐藏符号属性」原则的一部分，如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。\n\n🌰 例子：\n\nlet id = symbol('id')\nlet user = {\n  name: 'simon',\n  [id]: 123\n}\n\nfor (let key in user) alert(key) // 只有name\n\nalert(user[id]) // 单独可以直接访问\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n但是在 object.assign() 中，会同时复制字符串和 symbol 属性。\n\n🌰 例子：\n\nlet id = symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = object.assign({}, user);\n\nalert( clone[id] ); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 全局 symbol\n\n如前所述，通常所有的 symbol 都是不同的，即使它们有相同的名字。但有时想要名字相同的 symbol 具有相同的实体时，例如，应用程序的不同部分想要访问的 symbol \"id\" 指的是完全相同的属性。\n\n为了实现这一点，可以使用 全局 symbol 注册表。可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。\n\n# symbol.for(key)\n\n * 从注册表读取（不存在则创建） symbol ，使用 symbol.for(key)\n   \n   （该调用会检查全局注册表，如果有一个描述为 key 的 symbol，则返回该 symbol，否则将创建一个新 symbol（ symbol(key) ），并通过给定的 key 将其存储在注册表中。）\n\n * 注册表中的 symbol 被称为 全局 symbol。如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 —— 这就是它们的用途。\n\n🌰 例子：\n\nlet id = symbol.for('id')\nlet idagain = symbol.for('id')\n\nalert(id === idagain) // true\n\n\n1\n2\n3\n4\n\n\n# symbol.keyfor\n\n * symbol.keyfor(symbol) ，它的作用与 symbol.for(key) 完全反过来：通过全局 symbol 返回一个名字。\n\n * 作用是查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 undefined 。\n\n * 任何 symbol 都具有 description 属性。\n\n🌰 例子：\n\n// 通过 name 获取 symbol\nlet sym = symbol.for(\"name\");\nlet sym2 = symbol.for(\"id\");\n\n// 通过 symbol 获取 name\nalert( symbol.keyfor(sym) ); // name\nalert( symbol.keyfor(sym2) ); // id\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子：（非全局 symbol）\n\nlet globalsymbol = symbol.for(\"name\");\nlet localsymbol = symbol(\"name\");\n\nalert( symbol.keyfor(globalsymbol) ); // name，全局 symbol\nalert( symbol.keyfor(localsymbol) ); // undefined，非全局\n\nalert( localsymbol.description ); // name\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# javascript 系统 symbol\n\navascript 内部有很多「系统 symbol」，可以使用它们来微调对象的各个方面。它们都被列在了 众所周知的 symbol 表的规范中：\n\n * symbol.hasinstance\n * symbol.isconcatspreadable\n * symbol.iterator\n * symbol.toprimitive\n * …… 等等。\n\n\n# symbol 总结\n\n * symbol 是 唯一标识符的基本类型，使用带有可选描述（name）的 symbol() 调用创建的。\n * symbol 总是 不同的值，即使它们有相同的名字。如果希望同名的 symbol 相等，那么应该使用全局注册表： symbol.for(key) 返回（如果需要的话则创建）一个以 key 作为名字的全局 symbol。使用 symbol.for 多次调用 key 相同的 symbol 时，返回的就是同一个 symbol。\n * symbol 不是 100% 隐藏的。有一个内建方法 object.getownpropertysymbols(obj) 允许我们获取所有的 symbol。还有一个名为 reflect.ownkeys(obj) 的方法可以返回一个对象的 所有 键，包括 symbol。所以它们并不是真正的隐藏。\n\n使用 symbol 的场景：\n\n * 隐藏对象属性。\n * javascript 使用了许多系统 symbol，这些 symbol 可以作为 symbol.* 访问。可以使用它们来改变一些内建行为。例如，使用 symbol.iterator 来进行 迭代 操作，使用 symbol.toprimitive 来设置 对象原始值的转换 等等。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⏳ JavaScript 对象与原始值的转换",frontmatter:{title:"⏳ JavaScript 对象与原始值的转换",date:"2022-05-05T16:28:39.000Z",permalink:"/pages/5d0f4e/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/17.%20%E2%8F%B3%20JavaScript%20%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/17. ⏳ JavaScript 对象与原始值的转换.md",key:"v-9d907de4",path:"/pages/5d0f4e/",headers:[{level:2,title:"转换规则",slug:"转换规则",normalizedTitle:"转换规则",charIndex:255},{level:3,title:"hint",slug:"hint",normalizedTitle:"hint",charIndex:431},{level:3,title:"Symbol.toPrimitive",slug:"symbol-toprimitive",normalizedTitle:"symbol.toprimitive",charIndex:1462},{level:3,title:"toString/valueOf",slug:"tostring-valueof",normalizedTitle:"tostring/valueof",charIndex:2416},{level:3,title:"转换可以返回任何原始类型",slug:"转换可以返回任何原始类型",normalizedTitle:"转换可以返回任何原始类型",charIndex:3705},{level:3,title:"进一步的转换",slug:"进一步的转换",normalizedTitle:"进一步的转换",charIndex:4041},{level:2,title:"对象转换总结",slug:"对象转换总结",normalizedTitle:"对象转换总结",charIndex:4472}],headersStr:"转换规则 hint Symbol.toPrimitive toString/valueOf 转换可以返回任何原始类型 进一步的转换 对象转换总结",content:'JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（Ruby，C++）不同，无法实现特殊的对象处理方法来处理加法（或其他运算）。\n\n在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。（⭐️ 重要限制：对象运算的结果不能是另一个对象）\n\n * 例如，无法使用对象来表示向量或矩阵（或成就或其他），把它们相加并期望得到一个 “总和” 向量作为结果。\n * 从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。\n\n\n# 转换规则\n\n * 对于布尔值类型。对象没有转换为布尔值，所有的对象在布尔上下文（context）中均为 true 。\n * 数字转换发生在对象相减或应用数学函数时。例如， Date 对象可以相减， date1 - date2 的结果是两个日期之间的差值。\n * 对于字符串类型。通常为 alert(obj) 这样输出一个对象和类似的上下文中。\n\n\n# hint\n\nJavaScript 对象的类型转换在各种情况下有三种变体（规范 ）：\n\n * "string" ：对象到字符串的转换，当对期望一个字符串的对象执行操作时，例如 alert ：\n   \n   // 输出\n   alert(obj);\n   \n   // 将对象作为属性键\n   anotherObj[obj] = 123;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * "number" ：对象到数字的转换，例如进行数学运算时：\n   \n   // 显式转换\n   let num = Number(obj);\n   \n   // 数学运算（除了二元加法）\n   let n = +obj; // 一元加法\n   let delta = date1 - date2;\n   \n   // 小于/大于的比较\n   let greater = user1 > user2;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * “default” ：在少数情况下发生，当运算符 **「不确定」期望值的类型 ** 时。（有默认 hint）\n   \n   // 二元加法使用默认 hint\n   let total = obj1 + obj2;\n   \n   // obj == number 使用默认 hint\n   if (user == 1) { ... };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   * 二元加法 + 可用于字符串（连接），也可以用于数字（相加）。因此，当二元加法得到对象类型的参数时，它将依据 "default" hint 来对其进行转换。\n   * 如果对象被用于与字符串、数字或 symbol 进行 == 比较，这时到底应该进行哪种转换也不是很明确，因此使用 "default" hint。\n   * 像 < 和 > 这样的小于 / 大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 “number” hint，而不是 “default” 。这是历史原因。\n\n以上的 hint 规则出了一种情况以外，所有内建对象都以和 "number" 相同的方式实现 "default" 转换。\n\n为了进行转换，JavaScript 尝试查找并调用三个对象方法：\n\n 1. 调用 obj[Symbol.toPrimitive](hint) —— 带有 symbol 键 Symbol.toPrimitive （系统 symbol）的方法，如果这个方法存在的话，\n 2. 否则，如果 hint 是 "string" —— 尝试调用 obj.toString() 或 obj.valueOf() ，无论哪个存在。\n 3. 否则，如果 hint 是 "number" 或 "default" —— 尝试调用 obj.valueOf() 或 obj.toString() ，无论哪个存在。\n\n\n# Symbol.toPrimitive\n\n这是一个内建的 symbol，它被用来给转换方法命名：\n\nobj[Symbol.toPrimitive] = function(hint) {\n  // 这里是将此对象转换为原始值的代码\n  // 它必须返回一个原始值\n  // hint = "string"、"number" 或 "default" 中的一个\n}\n\n\n1\n2\n3\n4\n5\n\n\n如果 Symbol.toPrimitive 方法存在，则它会被用于所有 hint，无需更多其他方法。\n\n🌰 user 对象 实现 Symbol.toPrimitive ：\n\nlet user = {\n  name: "John",\n  money: 1000,\n\n  [Symbol.toPrimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == "string" ? `{name: "${this.name}"}` : this.money;\n  }\n};\n\nalert(user); // hint: string -> {name: "John"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从中，根据转换的不同， user 变成一个自描述字符串或者一个金额。 user[Symbol.toPrimitive] 方法处理了所有的转换情况。\n\n\n# toString/valueOf\n\n> 如果没有 Symbol.toPrimitive ，那么 JavaScript 将尝试寻找 toString 和 valueOf 方法：\n> \n>  * 对于 "string" hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString ）。\n>  * 对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。\n> \n> toString 和 valueOf 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是「常规的」字符串命名的方法。它们提供了一种可选的 “老派” 的实现转换的方法。\n> \n> 这些方法必须返回一个原始值。如果 toString 或 valueOf 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。\n\n默认情况下，普通对象具有 toString 和 valueOf 方法：\n\n * toString 方法返回一个字符串 "[object Object]" 。\n * valueOf 方法返回对象自身。（忽略）\n\n🌰 例子：\n\nlet user = {name: \'Simon\'}\n\nalert(user) // [object Oject]\nalert(user.valueOf() === user); // true\n\n\n1\n2\n3\n4\n\n\n实现这些方法自定义转换：\n\n🌰 例子：\n\nlet user = {\n  name: \'Simon\',\n  money: 1000,\n  \n  toString() {\n    return `{name: "${this.name}"`;\n  },\n  valueOf() {\n    return this.money\n  }\n}\n\nalert(user) // {name: "Simon"}\nalert(+user.valueOf()) // 1000\nalert(user + 500) // 1500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 可以看到执行的动作和前面使用 Symbol.toPrimitive 的那个例子相同。\n\n通常希望有一个「全能」的地方来处理所有原始转换。在这种情况下，可以只实现 toString ，例如：\n\nlet user = {\n  name: \'Simon\',\n  toString() {\n    return this.name\n  }\n}\n\nalert(user) // toString -> Simon\nalert(user + 500) // toString -> Simon500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果没有 Symbol.toPrimitive 和 valueOf ， toString 将处理所有原始转换。\n\n\n# 转换可以返回任何原始类型\n\n⭐️ 所有的原始转换方法，不一定会返回 “hint” 的原始值。\n\n * 没有限制 toString() 是否返回字符串，或 Symbol.toPrimitive 方法是否为 "number" hint 返回数字。\n * 唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。\n\n> 由于历史原因，如果 toString 或 valueOf 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 「error」 的概念。\n> \n> 相反， Symbol.toPrimitive 更严格，它 必须 返回一个原始值，否则就会出现 error。\n\n\n# 进一步的转换\n\n许多运算符和函数执行类型转换，例如乘法 * 将操作数转换为数字。\n\n如果将对象作为参数传递，则会出现两个运算阶段：\n\n 1. 对象被转换为原始值（通过前面我们描述的规则）。\n 2. 如果还需要进一步计算，则生成的原始值会被进一步转换。\n\n🌰 例子：\n\nlet obj = {\n  toString() {\n    return \'2\'\n  }\n}\n\nalert(obj * 2) // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n\n>  * 乘法 obj * 2 首先将对象转换为原始值（字符串 “2”）。\n>  * 之后 "2" * 2 变为 2 * 2 （字符串被转换为数字）。\n\n🌰 例子：⚠️ 对于二元加法会将其连接为字符串，因为它更愿意接受字符串。\n\nlet obj = {\n  toString() {\n    return "2";\n  }\n};\n\nalert(obj + 2); // 22\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 对象转换总结\n\n * 对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。\n\n * Symbol.primitive / toString 和 valueOf 是内建的对象方法，可以重新实现。\n\n * 三种 “hint”：\n   \n   * "string" （对于 alert 和其他需要字符串的操作）\n   * "number" （对于数学运算）\n   * "default" （少数运算符，通常对象以和 "number" 相同的方式实现 "default" 转换）\n\n * 转换规则：\n   \n   * 调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在；\n   * 否则，如果 hint 是 "string" ：\n     * 尝试调用 obj.toString() 或 obj.valueOf() ，无论哪个存在。\n   * 否则，如果 hint 是 "number" 或者 "default" ：\n     * 尝试调用 obj.valueOf() 或 obj.toString() ，无论哪个存在。\n   * 所有这些方法都必须返回一个原始值才能工作（如果已定义）。\n\n> 实际使用中，通常只实现 toString() 就足够了。一般返回对象的「可读表示」，用于调试或者日记。\n\n> 🤯 后知后觉，这不就是 Java 的类中，可以重写 toString() 方法一个道理吗。如果不写 toString() 方法打印整个类（的实例对象）就只输出类名和类的地址（？） ，而重写了 toString() 方法就可以指定打印的内容。',normalizedContent:'javascript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（ruby，c++）不同，无法实现特殊的对象处理方法来处理加法（或其他运算）。\n\n在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。（⭐️ 重要限制：对象运算的结果不能是另一个对象）\n\n * 例如，无法使用对象来表示向量或矩阵（或成就或其他），把它们相加并期望得到一个 “总和” 向量作为结果。\n * 从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。\n\n\n# 转换规则\n\n * 对于布尔值类型。对象没有转换为布尔值，所有的对象在布尔上下文（context）中均为 true 。\n * 数字转换发生在对象相减或应用数学函数时。例如， date 对象可以相减， date1 - date2 的结果是两个日期之间的差值。\n * 对于字符串类型。通常为 alert(obj) 这样输出一个对象和类似的上下文中。\n\n\n# hint\n\njavascript 对象的类型转换在各种情况下有三种变体（规范 ）：\n\n * "string" ：对象到字符串的转换，当对期望一个字符串的对象执行操作时，例如 alert ：\n   \n   // 输出\n   alert(obj);\n   \n   // 将对象作为属性键\n   anotherobj[obj] = 123;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * "number" ：对象到数字的转换，例如进行数学运算时：\n   \n   // 显式转换\n   let num = number(obj);\n   \n   // 数学运算（除了二元加法）\n   let n = +obj; // 一元加法\n   let delta = date1 - date2;\n   \n   // 小于/大于的比较\n   let greater = user1 > user2;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * “default” ：在少数情况下发生，当运算符 **「不确定」期望值的类型 ** 时。（有默认 hint）\n   \n   // 二元加法使用默认 hint\n   let total = obj1 + obj2;\n   \n   // obj == number 使用默认 hint\n   if (user == 1) { ... };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   * 二元加法 + 可用于字符串（连接），也可以用于数字（相加）。因此，当二元加法得到对象类型的参数时，它将依据 "default" hint 来对其进行转换。\n   * 如果对象被用于与字符串、数字或 symbol 进行 == 比较，这时到底应该进行哪种转换也不是很明确，因此使用 "default" hint。\n   * 像 < 和 > 这样的小于 / 大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 “number” hint，而不是 “default” 。这是历史原因。\n\n以上的 hint 规则出了一种情况以外，所有内建对象都以和 "number" 相同的方式实现 "default" 转换。\n\n为了进行转换，javascript 尝试查找并调用三个对象方法：\n\n 1. 调用 obj[symbol.toprimitive](hint) —— 带有 symbol 键 symbol.toprimitive （系统 symbol）的方法，如果这个方法存在的话，\n 2. 否则，如果 hint 是 "string" —— 尝试调用 obj.tostring() 或 obj.valueof() ，无论哪个存在。\n 3. 否则，如果 hint 是 "number" 或 "default" —— 尝试调用 obj.valueof() 或 obj.tostring() ，无论哪个存在。\n\n\n# symbol.toprimitive\n\n这是一个内建的 symbol，它被用来给转换方法命名：\n\nobj[symbol.toprimitive] = function(hint) {\n  // 这里是将此对象转换为原始值的代码\n  // 它必须返回一个原始值\n  // hint = "string"、"number" 或 "default" 中的一个\n}\n\n\n1\n2\n3\n4\n5\n\n\n如果 symbol.toprimitive 方法存在，则它会被用于所有 hint，无需更多其他方法。\n\n🌰 user 对象 实现 symbol.toprimitive ：\n\nlet user = {\n  name: "john",\n  money: 1000,\n\n  [symbol.toprimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == "string" ? `{name: "${this.name}"}` : this.money;\n  }\n};\n\nalert(user); // hint: string -> {name: "john"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从中，根据转换的不同， user 变成一个自描述字符串或者一个金额。 user[symbol.toprimitive] 方法处理了所有的转换情况。\n\n\n# tostring/valueof\n\n> 如果没有 symbol.toprimitive ，那么 javascript 将尝试寻找 tostring 和 valueof 方法：\n> \n>  * 对于 "string" hint：调用 tostring 方法，如果它不存在，则调用 valueof 方法（因此，对于字符串转换，优先调用 tostring ）。\n>  * 对于其他 hint：调用 valueof 方法，如果它不存在，则调用 tostring 方法（因此，对于数学运算，优先调用 valueof 方法）。\n> \n> tostring 和 valueof 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是「常规的」字符串命名的方法。它们提供了一种可选的 “老派” 的实现转换的方法。\n> \n> 这些方法必须返回一个原始值。如果 tostring 或 valueof 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。\n\n默认情况下，普通对象具有 tostring 和 valueof 方法：\n\n * tostring 方法返回一个字符串 "[object object]" 。\n * valueof 方法返回对象自身。（忽略）\n\n🌰 例子：\n\nlet user = {name: \'simon\'}\n\nalert(user) // [object oject]\nalert(user.valueof() === user); // true\n\n\n1\n2\n3\n4\n\n\n实现这些方法自定义转换：\n\n🌰 例子：\n\nlet user = {\n  name: \'simon\',\n  money: 1000,\n  \n  tostring() {\n    return `{name: "${this.name}"`;\n  },\n  valueof() {\n    return this.money\n  }\n}\n\nalert(user) // {name: "simon"}\nalert(+user.valueof()) // 1000\nalert(user + 500) // 1500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 可以看到执行的动作和前面使用 symbol.toprimitive 的那个例子相同。\n\n通常希望有一个「全能」的地方来处理所有原始转换。在这种情况下，可以只实现 tostring ，例如：\n\nlet user = {\n  name: \'simon\',\n  tostring() {\n    return this.name\n  }\n}\n\nalert(user) // tostring -> simon\nalert(user + 500) // tostring -> simon500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果没有 symbol.toprimitive 和 valueof ， tostring 将处理所有原始转换。\n\n\n# 转换可以返回任何原始类型\n\n⭐️ 所有的原始转换方法，不一定会返回 “hint” 的原始值。\n\n * 没有限制 tostring() 是否返回字符串，或 symbol.toprimitive 方法是否为 "number" hint 返回数字。\n * 唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。\n\n> 由于历史原因，如果 tostring 或 valueof 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 javascript 语言发展初期，没有很好的 「error」 的概念。\n> \n> 相反， symbol.toprimitive 更严格，它 必须 返回一个原始值，否则就会出现 error。\n\n\n# 进一步的转换\n\n许多运算符和函数执行类型转换，例如乘法 * 将操作数转换为数字。\n\n如果将对象作为参数传递，则会出现两个运算阶段：\n\n 1. 对象被转换为原始值（通过前面我们描述的规则）。\n 2. 如果还需要进一步计算，则生成的原始值会被进一步转换。\n\n🌰 例子：\n\nlet obj = {\n  tostring() {\n    return \'2\'\n  }\n}\n\nalert(obj * 2) // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n\n>  * 乘法 obj * 2 首先将对象转换为原始值（字符串 “2”）。\n>  * 之后 "2" * 2 变为 2 * 2 （字符串被转换为数字）。\n\n🌰 例子：⚠️ 对于二元加法会将其连接为字符串，因为它更愿意接受字符串。\n\nlet obj = {\n  tostring() {\n    return "2";\n  }\n};\n\nalert(obj + 2); // 22\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 对象转换总结\n\n * 对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。\n\n * symbol.primitive / tostring 和 valueof 是内建的对象方法，可以重新实现。\n\n * 三种 “hint”：\n   \n   * "string" （对于 alert 和其他需要字符串的操作）\n   * "number" （对于数学运算）\n   * "default" （少数运算符，通常对象以和 "number" 相同的方式实现 "default" 转换）\n\n * 转换规则：\n   \n   * 调用 obj[symbol.toprimitive](hint) 如果这个方法存在；\n   * 否则，如果 hint 是 "string" ：\n     * 尝试调用 obj.tostring() 或 obj.valueof() ，无论哪个存在。\n   * 否则，如果 hint 是 "number" 或者 "default" ：\n     * 尝试调用 obj.valueof() 或 obj.tostring() ，无论哪个存在。\n   * 所有这些方法都必须返回一个原始值才能工作（如果已定义）。\n\n> 实际使用中，通常只实现 tostring() 就足够了。一般返回对象的「可读表示」，用于调试或者日记。\n\n> 🤯 后知后觉，这不就是 java 的类中，可以重写 tostring() 方法一个道理吗。如果不写 tostring() 方法打印整个类（的实例对象）就只输出类名和类的地址（？） ，而重写了 tostring() 方法就可以指定打印的内容。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔗 JavaScript 对象可选链",frontmatter:{title:"🔗 JavaScript 对象可选链",date:"2022-05-05T11:05:15.000Z",permalink:"/pages/058cb5/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/15.%20%F0%9F%94%97%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%8F%AF%E9%80%89%E9%93%BE.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/15. 🔗 JavaScript 对象可选链.md",key:"v-3b15d3d5",path:"/pages/058cb5/",headers:[{level:3,title:"「不存在的属性」",slug:"「不存在的属性」",normalizedTitle:"「不存在的属性」",charIndex:46},{level:3,title:"可选链",slug:"可选链",normalizedTitle:"可选链",charIndex:0},{level:3,title:"短路效应",slug:"短路效应",normalizedTitle:"短路效应",charIndex:1438},{level:3,title:"可选链的其他变体 ?.(), ?.[]",slug:"可选链的其他变体",normalizedTitle:"可选链的其他变体？.(), ?.[]",charIndex:null},{level:2,title:"可选链总结",slug:"可选链总结",normalizedTitle:"可选链总结",charIndex:2358}],headersStr:"「不存在的属性」 可选链 短路效应 可选链的其他变体 ?.(), ?.[] 可选链总结",content:"可选链 ?. 是一种访问嵌套对象属性的安全方式。即便中间的对象不存在，也不会报错。\n\n\n# 「不存在的属性」\n\n🌰 例子：\n\nlet user = {}\n\n// 尝试读取其可能不存在的属性\nalert(user.address.street) // Error!\n\n\n1\n2\n3\n4\n\n\nJavaScript 的工作原理就是这样的。因为 user.address 为 undefined ，尝试读取 user.address.street 会失败，并收到一个错误。\n\n但是在很多实际场景中，更希望得到的是 undefined （表示没有 street 属性）而不是一个错误。\n\n🌰 例子 2：当获取网页中的元素时，\n\n// 如果 document.querySelector('.elem') 的结果为 null，则这里不存在这个元素\nlet html = document.querySelector('.elem').innerHTML; \n// 如果 document.querySelector('.elem') 的结果为 null，则会出现错误\n\n\n1\n2\n3\n\n\n元素有时候就是获取不到，但是又不想访问时报错。\n\n使用 if 和 ? 三元运算，都给需要编写代码，并且嵌套的代码可读性很差， 不够优雅。可选链 ?. 的出现解决了上面的问题。\n\n\n# 可选链\n\n语法： value?.prop ：解释为\n\n * 如果 value 存在， 则结果与 value.prop 相同。\n * 当 value 为 undefiend / null 时，则返回 undefined 。\n\n🌰 使用例子：安全访问 user.address.street ：\n\nlet user = {}\nalert(user?.address?.street)\n\n\n1\n2\n\n\n同样可以：\n\nlet user = null\nalert(user?.address)\nalert(user?.address.street)\n\n\n1\n2\n3\n\n\n> ?. 可选链使前面的值成为可选值，但不会对后面起作用。\n> \n> 在 user?.address.street.name 中， ?. 允许 user 为 null/undefined （在这种情况下会返回 undefined ）也不会报错，但这仅对于 user 。更深层次的属性是通过常规方式访问的。如果希望它们中的一些属性也是可选的，那么需要使用更多的 ?. 来替换 . 。\n\n🌰 使用例子：获取网页中的元素：\n\nlet html = document.querySelector('.elem')?.innerHTML\n// 如果没有符合的元素则为undefiend\n\n\n1\n2\n\n\n注意\n\n不能过度使用可选链：应该只将 ?. 使用在一些东西可以不存在的地方。\n\n例如，如果根据代码逻辑， user 对象必须存在，但 address 是可选的，那么我们应该这样写 user.address?.street ，而不是这样 user?.address?.street 。\n\n注意\n\n可选链仅适用于已声明的变量。 ?. 前面的变量必须要为已声明。（例如 let/const/var user 或作为一个函数参数）\n\n🌰 例子：当 user 未声明：\n\nuser?.address // user is not defined\n\n\n1\n\n\n\n# 短路效应\n\n只要 ?. 左边的部分不存在，则其后的一系列函数调用或者操作都不会执行。\n\n🌰 例子：\n\nlet user = null\nlet x = 0\n\nuser?.sayHi(x++)\nalert(x)\n\n\n1\n2\n3\n4\n5\n\n\n由于 user 不存在，所以其后的 sayHi 不会执行，所以 x 值不发生变化。\n\n\n# 可选链的其他变体 ?.() , ?.[]\n\n可选链 ?. 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。\n\n🌰 例子： ?.() 用于调用一个可能不存在的函数。\n\nlet userAdmin = {\n  admin() {\n    alert('i am admin') \n  }\n}\n\nlet userGuest = {}\nuserAdmin.admin?.()\nuserGuest.admin?.()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n首先使用点符号（ userAdmin.admin ）来获取 admin 属性，假定对象 userAdmin 存在，因此可以安全地读取它。\n\nadmin 是否存在，存在才调用。如果不存在，则无法调用，并且不报错。\n\n🌰 例子： ?.[] 访问一个可能不存在的属性：\n\nlet key = \"firstName\";\n\nlet user1 = {\n  firstName: \"John\"\n};\n\nlet user2 = null;\n\nalert( user1?.[key] ); // John\nalert( user2?.[key] ); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 配合 delete 一起使用：\n\ndelete user?.name // 当user存在才删除user.name\n\n\n1\n\n\n> 可选链仅仅用做安全读取或者删除，但是不能写入。（不能放在赋值语句的左边 ）\n> \n> 🌰 例子：\n> \n> let user = null\n> user?.name = 'Simon' // 可以看作 undefined = 'Simon'\n> \n> \n> 1\n> 2\n\n\n# 可选链总结\n\n * 可选链有三种形式（分别对应读取属性和读取方法）：\n   * obj?.prop 如果 obj 存在则返回 obj.prop ，否则返回 undefined 。\n   * obj?.[prop] 如果 obj 存在则返回 obj[prop] ，否则返回 undefined 。\n   * obj.method 如果 obj.method 存在则调用 obj.method() ，否则返回 undefined 。",normalizedContent:"可选链 ?. 是一种访问嵌套对象属性的安全方式。即便中间的对象不存在，也不会报错。\n\n\n# 「不存在的属性」\n\n🌰 例子：\n\nlet user = {}\n\n// 尝试读取其可能不存在的属性\nalert(user.address.street) // error!\n\n\n1\n2\n3\n4\n\n\njavascript 的工作原理就是这样的。因为 user.address 为 undefined ，尝试读取 user.address.street 会失败，并收到一个错误。\n\n但是在很多实际场景中，更希望得到的是 undefined （表示没有 street 属性）而不是一个错误。\n\n🌰 例子 2：当获取网页中的元素时，\n\n// 如果 document.queryselector('.elem') 的结果为 null，则这里不存在这个元素\nlet html = document.queryselector('.elem').innerhtml; \n// 如果 document.queryselector('.elem') 的结果为 null，则会出现错误\n\n\n1\n2\n3\n\n\n元素有时候就是获取不到，但是又不想访问时报错。\n\n使用 if 和 ? 三元运算，都给需要编写代码，并且嵌套的代码可读性很差， 不够优雅。可选链 ?. 的出现解决了上面的问题。\n\n\n# 可选链\n\n语法： value?.prop ：解释为\n\n * 如果 value 存在， 则结果与 value.prop 相同。\n * 当 value 为 undefiend / null 时，则返回 undefined 。\n\n🌰 使用例子：安全访问 user.address.street ：\n\nlet user = {}\nalert(user?.address?.street)\n\n\n1\n2\n\n\n同样可以：\n\nlet user = null\nalert(user?.address)\nalert(user?.address.street)\n\n\n1\n2\n3\n\n\n> ?. 可选链使前面的值成为可选值，但不会对后面起作用。\n> \n> 在 user?.address.street.name 中， ?. 允许 user 为 null/undefined （在这种情况下会返回 undefined ）也不会报错，但这仅对于 user 。更深层次的属性是通过常规方式访问的。如果希望它们中的一些属性也是可选的，那么需要使用更多的 ?. 来替换 . 。\n\n🌰 使用例子：获取网页中的元素：\n\nlet html = document.queryselector('.elem')?.innerhtml\n// 如果没有符合的元素则为undefiend\n\n\n1\n2\n\n\n注意\n\n不能过度使用可选链：应该只将 ?. 使用在一些东西可以不存在的地方。\n\n例如，如果根据代码逻辑， user 对象必须存在，但 address 是可选的，那么我们应该这样写 user.address?.street ，而不是这样 user?.address?.street 。\n\n注意\n\n可选链仅适用于已声明的变量。 ?. 前面的变量必须要为已声明。（例如 let/const/var user 或作为一个函数参数）\n\n🌰 例子：当 user 未声明：\n\nuser?.address // user is not defined\n\n\n1\n\n\n\n# 短路效应\n\n只要 ?. 左边的部分不存在，则其后的一系列函数调用或者操作都不会执行。\n\n🌰 例子：\n\nlet user = null\nlet x = 0\n\nuser?.sayhi(x++)\nalert(x)\n\n\n1\n2\n3\n4\n5\n\n\n由于 user 不存在，所以其后的 sayhi 不会执行，所以 x 值不发生变化。\n\n\n# 可选链的其他变体 ?.() , ?.[]\n\n可选链 ?. 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。\n\n🌰 例子： ?.() 用于调用一个可能不存在的函数。\n\nlet useradmin = {\n  admin() {\n    alert('i am admin') \n  }\n}\n\nlet userguest = {}\nuseradmin.admin?.()\nuserguest.admin?.()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n首先使用点符号（ useradmin.admin ）来获取 admin 属性，假定对象 useradmin 存在，因此可以安全地读取它。\n\nadmin 是否存在，存在才调用。如果不存在，则无法调用，并且不报错。\n\n🌰 例子： ?.[] 访问一个可能不存在的属性：\n\nlet key = \"firstname\";\n\nlet user1 = {\n  firstname: \"john\"\n};\n\nlet user2 = null;\n\nalert( user1?.[key] ); // john\nalert( user2?.[key] ); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 配合 delete 一起使用：\n\ndelete user?.name // 当user存在才删除user.name\n\n\n1\n\n\n> 可选链仅仅用做安全读取或者删除，但是不能写入。（不能放在赋值语句的左边 ）\n> \n> 🌰 例子：\n> \n> let user = null\n> user?.name = 'simon' // 可以看作 undefined = 'simon'\n> \n> \n> 1\n> 2\n\n\n# 可选链总结\n\n * 可选链有三种形式（分别对应读取属性和读取方法）：\n   * obj?.prop 如果 obj 存在则返回 obj.prop ，否则返回 undefined 。\n   * obj?.[prop] 如果 obj 存在则返回 obj[prop] ，否则返回 undefined 。\n   * obj.method 如果 obj.method 存在则调用 obj.method() ，否则返回 undefined 。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"💡 JavaScript 对象属性标志和属性描述符",frontmatter:{title:"💡 JavaScript 对象属性标志和属性描述符",date:"2022-05-13T22:17:22.000Z",permalink:"/pages/1f8eeb/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/18.%20%F0%9F%92%A1%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%A0%87%E5%BF%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/18. 💡 JavaScript 对象属性标志和属性描述符.md",key:"v-3e61f4a4",path:"/pages/1f8eeb/",headers:[{level:2,title:"属性标志",slug:"属性标志",normalizedTitle:"属性标志",charIndex:2},{level:3,title:"只读属性",slug:"只读属性",normalizedTitle:"只读属性",charIndex:1670},{level:3,title:"不可枚举属性",slug:"不可枚举属性",normalizedTitle:"不可枚举属性",charIndex:2132},{level:3,title:"不可配置属性",slug:"不可配置属性",normalizedTitle:"不可配置属性",charIndex:2584},{level:3,title:"Object.defineProperties(obj, descriptors)",slug:"object-defineproperties-obj-descriptors",normalizedTitle:"object.defineproperties(obj, descriptors)",charIndex:3643},{level:3,title:"Object.getOwnPropertyDescriptors(obj)",slug:"object-getownpropertydescriptors-obj",normalizedTitle:"object.getownpropertydescriptors(obj)",charIndex:3968}],headersStr:"属性标志 只读属性 不可枚举属性 不可配置属性 Object.defineProperties(obj, descriptors) Object.getOwnPropertyDescriptors(obj)",content:'# 属性标志\n\n对象的属性（properties）除了 value 值以外，还有三个特殊的 特性（attributes），也是 标志 ：\n\n * writable 可写：为 true ，表示该值可以修改。否则为只可读的。\n * enumerable 可迭代：如果为 true ，则会被在循环中列出。否则不会被列出。\n * configurable ：如果为 true ，则此属性可以被删除，这些特性也可以被修改，否则不可以。\n\n在使用 常用的方式 创建一个属性时，这些标志 默认都为 true 。\n\n * 要获取这些标志的信息，可以使用 Object.getOwnPropertyDescriptor 方式查询有关属性的完整信息，语法为：\n   \n   let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName)\n   \n   \n   1\n   \n   >  * obj ：要获取信息的对象。\n   >  * propertyName ：属性名称。\n   > \n   > 该方法的返回值是一个 「属性描述符」 对象， 包含 值 和所有的标志。\n   \n   🌰 例子：\n   \n   let user = {\n     name: "John"\n   };\n   \n   let descriptor = Object.getOwnPropertyDescriptor(user, \'name\');\n   console.log(JSON.stringify(descriptor, null, 2))\n   /*\n   \t"value": "John",\n     "writable": true,\n     "enumerable": true,\n     "configurable": true\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 要 修改 这些标志，可以使用 Object.defineProperty ，语法为：\n   \n   Object.defineProperty(obj, propertyName, descriptor)\n   \n   \n   1\n   \n   >  * obj 、 propertyName ：同上。\n   >  * descriptor ：要应用的 属性描述符对象。\n   > \n   > 如果该属性存在， defineProperty 会更新其标志，否则会使用 特定的值 和标志创建属性，这种情况下没有提供标志则 假定 它为 false 。\n   \n   🌰 例子：\n   \n   let user = {}\n   \n   Object.defineProperty(user, "name", {\n     value: "John"\n   })\n   \n   let descriptor = Object.getOwnPropertyDescriptor(user, name)\n   console.log(JSON.stringify(descriptor, null, 2))\n   /*\n   \tvalue": "John",\n     "writable": false,\n     "enumerable": false,\n     "configurable": false\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n   \n   > 这种创建属性的方式与上面常用的普通创建属性的方法进行比较，现在所有的 标志 都被假定为 false ，可以在创建属性时通过 descriptor 中设置为 true 。\n\n\n# 只读属性\n\n可以通过将 标志 writable 设置为 false ，使对象中的属性为只读（即不能重新赋值）。\n\n🌰 例子：\n\nlet user = {\n  name: \'John\'\n}\n\nObject.defineProperty(user, \'name\', {\n  writable: false\n})\n\nuser.name = \'Pete\' // Error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子：\n\nlet user = { };\n\nObject.defineProperty(user, "name", {\n  value: "John",\n\t// 对于新创建的属性需要列出要为 true 的标志，否则为 false\n  enumerable: true,\n  configurable: true\n});\n\nconsole.log(user.name); // John\nuser.name = "Pete"; // Error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 不可枚举属性\n\n🌰 例子：一般属性自带的 toString() 方法默认是不可枚举的，即在 for ... in 中不会出现。但是如果自定义重写的 toString() 时，它会出现在 for ... in 中。\n\nlet user = {\n  name: \'Simon\',\n  toString() {\n    return this.name\n  }\n}\n\nfor(let key in user) console.log(key) // name, toString\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将 toString 设置为不可枚举：\n\nObject.defineProperty(user, "toString", {\n  enumerable: false\n})\n\nfor(let key in user) console.log(key) // name\n\nconsole.log(Object.keys(user)) // name\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 不可配置属性\n\n不可配置的属性不能被删除，它的 特性（attribute） 不能被修改。\n\n🌰 例子 / Math.PI 是可读的、不可枚举、不可配置的：\n\nlet descriptor = Object.getOwnPropertyDescriptor(Math, \'PI\');\nconsole.log(JSON.stringify(descriptor, null, 2 ))\n/*\n{\n  "value": 3.141592653589793,\n  "writable": false,\n  "enumerable": false,\n  "configurable": false\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 所以，并不能修改 Math.PI 的值，或者覆盖它。也无法修改它的特性， writable 或者 enumerable 。\n\n注意\n\n可以从例子中看出，只要将 configurable 设置为 false ，之后再也无法通过 defineProperty 更改回来。\n\n注意： configurable: false 防止更改和删除属性标志，但是允许更改对象的值。\n\n🌰 例子：\n\nlet user = {\n  name: "John"\n};\n\nObject.defineProperty(user, "name", {\n  configurable: false\n});\n\nuser.name = "Pete" // 正常工作\ndelete user.name // 出错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n将 name 属性同时设置为 writable: false ，此时该属性就会像内建的 Math.PI 一样，永不可改：\n\nObject.defineProperty(user, "name", {\n  writable: false,\n  configurable: false\n});\n\nuser.name = "Pete" // 出错\ndelete user.name // 出错\nObject.defineProperty(user, "name", { value: "Pete" }); // 出错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n唯一可以修改的特性（ writable ）：对于不可配置的属性，可以将 writbale 设置为 false ，以防止其值被修改（以添加另一层保护）。但无法反向行之。\n\n\n# Object.defineProperties(obj, descriptors)\n\n该方法允许一次定义多个属性，语法为：\n\nObject.defineProperties(obj, {\n  prop1: descriptor1,\n  prop2: descriptor2\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子：\n\nObject.defineProperties(user, {\n  name: { value: "John", writable: false },\n  surname: { value: "Smith", writable: false },\n  // ...\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# Object.getOwnPropertyDescriptors(obj)\n\n该方法可以一次获取 所有属性描述符。\n\n通常在克隆一个对象时，使用 for key in obj 遍历赋值的方式进行克隆，但是不能复制 包括 symbol 类型的和不可枚举属性在内的所有 属性描述符。\n\n深层完全克隆方式：可以与 Object.defineProperties 一起用作 克隆对象 的 「标志感知」 方式：\n\nlet clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n\n\n1\n\n\n> 因为 Object.getOwnPropertyDescriptors(obj) 可以返回包含 symbol 类型的和不可枚举的属性在内的 所有属性描述符。',normalizedContent:'# 属性标志\n\n对象的属性（properties）除了 value 值以外，还有三个特殊的 特性（attributes），也是 标志 ：\n\n * writable 可写：为 true ，表示该值可以修改。否则为只可读的。\n * enumerable 可迭代：如果为 true ，则会被在循环中列出。否则不会被列出。\n * configurable ：如果为 true ，则此属性可以被删除，这些特性也可以被修改，否则不可以。\n\n在使用 常用的方式 创建一个属性时，这些标志 默认都为 true 。\n\n * 要获取这些标志的信息，可以使用 object.getownpropertydescriptor 方式查询有关属性的完整信息，语法为：\n   \n   let descriptor = object.getownpropertydescriptor(obj, propertyname)\n   \n   \n   1\n   \n   >  * obj ：要获取信息的对象。\n   >  * propertyname ：属性名称。\n   > \n   > 该方法的返回值是一个 「属性描述符」 对象， 包含 值 和所有的标志。\n   \n   🌰 例子：\n   \n   let user = {\n     name: "john"\n   };\n   \n   let descriptor = object.getownpropertydescriptor(user, \'name\');\n   console.log(json.stringify(descriptor, null, 2))\n   /*\n   \t"value": "john",\n     "writable": true,\n     "enumerable": true,\n     "configurable": true\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 要 修改 这些标志，可以使用 object.defineproperty ，语法为：\n   \n   object.defineproperty(obj, propertyname, descriptor)\n   \n   \n   1\n   \n   >  * obj 、 propertyname ：同上。\n   >  * descriptor ：要应用的 属性描述符对象。\n   > \n   > 如果该属性存在， defineproperty 会更新其标志，否则会使用 特定的值 和标志创建属性，这种情况下没有提供标志则 假定 它为 false 。\n   \n   🌰 例子：\n   \n   let user = {}\n   \n   object.defineproperty(user, "name", {\n     value: "john"\n   })\n   \n   let descriptor = object.getownpropertydescriptor(user, name)\n   console.log(json.stringify(descriptor, null, 2))\n   /*\n   \tvalue": "john",\n     "writable": false,\n     "enumerable": false,\n     "configurable": false\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n   \n   > 这种创建属性的方式与上面常用的普通创建属性的方法进行比较，现在所有的 标志 都被假定为 false ，可以在创建属性时通过 descriptor 中设置为 true 。\n\n\n# 只读属性\n\n可以通过将 标志 writable 设置为 false ，使对象中的属性为只读（即不能重新赋值）。\n\n🌰 例子：\n\nlet user = {\n  name: \'john\'\n}\n\nobject.defineproperty(user, \'name\', {\n  writable: false\n})\n\nuser.name = \'pete\' // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子：\n\nlet user = { };\n\nobject.defineproperty(user, "name", {\n  value: "john",\n\t// 对于新创建的属性需要列出要为 true 的标志，否则为 false\n  enumerable: true,\n  configurable: true\n});\n\nconsole.log(user.name); // john\nuser.name = "pete"; // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 不可枚举属性\n\n🌰 例子：一般属性自带的 tostring() 方法默认是不可枚举的，即在 for ... in 中不会出现。但是如果自定义重写的 tostring() 时，它会出现在 for ... in 中。\n\nlet user = {\n  name: \'simon\',\n  tostring() {\n    return this.name\n  }\n}\n\nfor(let key in user) console.log(key) // name, tostring\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将 tostring 设置为不可枚举：\n\nobject.defineproperty(user, "tostring", {\n  enumerable: false\n})\n\nfor(let key in user) console.log(key) // name\n\nconsole.log(object.keys(user)) // name\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 不可配置属性\n\n不可配置的属性不能被删除，它的 特性（attribute） 不能被修改。\n\n🌰 例子 / math.pi 是可读的、不可枚举、不可配置的：\n\nlet descriptor = object.getownpropertydescriptor(math, \'pi\');\nconsole.log(json.stringify(descriptor, null, 2 ))\n/*\n{\n  "value": 3.141592653589793,\n  "writable": false,\n  "enumerable": false,\n  "configurable": false\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 所以，并不能修改 math.pi 的值，或者覆盖它。也无法修改它的特性， writable 或者 enumerable 。\n\n注意\n\n可以从例子中看出，只要将 configurable 设置为 false ，之后再也无法通过 defineproperty 更改回来。\n\n注意： configurable: false 防止更改和删除属性标志，但是允许更改对象的值。\n\n🌰 例子：\n\nlet user = {\n  name: "john"\n};\n\nobject.defineproperty(user, "name", {\n  configurable: false\n});\n\nuser.name = "pete" // 正常工作\ndelete user.name // 出错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n将 name 属性同时设置为 writable: false ，此时该属性就会像内建的 math.pi 一样，永不可改：\n\nobject.defineproperty(user, "name", {\n  writable: false,\n  configurable: false\n});\n\nuser.name = "pete" // 出错\ndelete user.name // 出错\nobject.defineproperty(user, "name", { value: "pete" }); // 出错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n唯一可以修改的特性（ writable ）：对于不可配置的属性，可以将 writbale 设置为 false ，以防止其值被修改（以添加另一层保护）。但无法反向行之。\n\n\n# object.defineproperties(obj, descriptors)\n\n该方法允许一次定义多个属性，语法为：\n\nobject.defineproperties(obj, {\n  prop1: descriptor1,\n  prop2: descriptor2\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子：\n\nobject.defineproperties(user, {\n  name: { value: "john", writable: false },\n  surname: { value: "smith", writable: false },\n  // ...\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# object.getownpropertydescriptors(obj)\n\n该方法可以一次获取 所有属性描述符。\n\n通常在克隆一个对象时，使用 for key in obj 遍历赋值的方式进行克隆，但是不能复制 包括 symbol 类型的和不可枚举属性在内的所有 属性描述符。\n\n深层完全克隆方式：可以与 object.defineproperties 一起用作 克隆对象 的 「标志感知」 方式：\n\nlet clone = object.defineproperties({}, object.getownpropertydescriptors(obj));\n\n\n1\n\n\n> 因为 object.getownpropertydescriptors(obj) 可以返回包含 symbol 类型的和不可枚举的属性在内的 所有属性描述符。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔦 JavaScript 对象的访问器属性和描述符",frontmatter:{title:"🔦 JavaScript 对象的访问器属性和描述符",date:"2022-05-13T22:55:10.000Z",permalink:"/pages/6ea59d/",categories:["🚶🏻 前端巩固基础","📒 JavaScript 深入对象"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/31.%20%F0%9F%93%92%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/19.%20%F0%9F%94%A6%20JavaScript%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6.html",relativePath:"101. 🚶🏻 前端巩固基础/31. 📒 JavaScript 深入对象/19. 🔦 JavaScript 对象的访问器属性和描述符.md",key:"v-1be9ae19",path:"/pages/6ea59d/",headers:[{level:2,title:"getter / setter",slug:"getter-setter",normalizedTitle:"getter / setter",charIndex:98},{level:2,title:"访问器描述符",slug:"访问器描述符",normalizedTitle:"访问器描述符",charIndex:1038},{level:2,title:"访问器的兼容性",slug:"访问器的兼容性",normalizedTitle:"访问器的兼容性",charIndex:2239}],headersStr:"getter / setter 访问器描述符 访问器的兼容性",content:'对象有两种 对象属性：\n\n * 数据属性。常用存储于对象的数据的属性。\n * 访问器属性（accessor property）。本质上是用作 获取和设置值的函数，但是从外部看像常规属性。\n\n\n# getter / setter\n\n在 对象字面量 中，使用 get 和 set 表示：\n\nlet obj = {\n  get propName() {\n    // ... 当读取 obj.propName 时起作用\n  },\n  set propName() {\n    // ... 设置 obj.propName 的值时起作用\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子：\n\nlet user = {\n  name: "John",\n  surname: "Smith",\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nconsole.log(user.fullName) // John Smith \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从外部看访问属性就像一个普通的属性，这就是 访问属性的设计思想。不应该使用 函数形式 访问。只要正常读取 访问属性，而 getter 在幕后运行。\n\n在上面的例子中，如果不设置 setter ，此时对 fullName 设值（赋值），就会出错。所以就要给 fullName 添加一个 setter :\n\nlet user = {\n  name: "John",\n  surname: "Smith",\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set fullName(value) {\n    [this.name, this.surname] = value.split(" ");\n  }\n};\n\n// 此时赋值\nuser.fullName = "Alice Cooper" \nconsole.log(user.name)    // Alice\nconsole.log(user.surname) // Cooper\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n至此， fullName 访问属性可以看作是一个 「虚拟属性」，可读且可写。\n\n\n# 访问器描述符\n\n访问器属性的描述符与数据属性的不同。对于访问器属性，没有 value 和 writable ，但是有 get 和 set 函数。\n\n访问器描述符有：\n\n * get ：一个 没有参数 的 函数，在读取属性时工作。\n * set ：带有 一个参数 的 函数，当属性被设置时调用。\n * enumerable ：与数据属性的相同。\n * configurable ：与数据属性的相同。\n\n🌰 例子 / 使用 defineProperty 创建一个 fullName 的访问器。可以使用 get 和 set 传递描述符。\n\nlet user = {\n  name: "John",\n  surname: "Smith"\n};\n\nObject.defineProperty(user, \'fullName\', {\n  get() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set(value) {\n    [this.name, this.surname] = value.split(" ");\n  }\n});\n\nconsole.log(user.fullName) // John Smith\nfor(let key in user) alert(key); // name, surname\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意\n\n一个属性要么是访问器（具有 get/set 方法），要么是数据属性（具有 value ），但不能两者都是。如果试图在同一个描述符中同时提供 get 和 value ，就会报错。\n\ngetter 和 setter 可以用于包装 真实 属性值（包装器），可以对它们实现更多的控制。\n\n🌰 例子：\n\nlet user = {\n  get name() {\n    return this._name\n  }\n  \n  set name(value) {\n    if(value.length < 4) {\n      console.log("")\n    }\n    this._name = value\n  }\n}\n\nuser.name = "Pete"\nconsole.log(user.name)\n\nuser.name = "A" // 太短\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> name 被存储在 _name 属性中，并通过 getter 和 setter 进行访问。\n> \n> 从技术上讲，外部代码可以使用 user._name 直接访问 name。但是，这儿有一个众所周知的约定，即以下划线 "_" 开头的属性是内部属性，不应该从对象外部进行访问。\n\n\n# 访问器的兼容性\n\n访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换「正常的」数据属性，来控制和调整这些属性的行为。\n\n🌰 例子：\n\nfunction User(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet john = new User("John", 25);\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，之后可能会选择 存储 birthday 而不是 age ，选择日期类型的 birthday 可以更加精准，但是 age 又想要保留：\n\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\n  // 年龄是根据当前日期和生日计算得出的\n  Object.defineProperty(this, "age", {\n    get() {\n      let todayYear = new Date().getFullYear();\n      return todayYear - this.birthday.getFullYear();\n    }\n  });\n}\n\nlet john = new User("John", new Date(1992, 6, 1));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',normalizedContent:'对象有两种 对象属性：\n\n * 数据属性。常用存储于对象的数据的属性。\n * 访问器属性（accessor property）。本质上是用作 获取和设置值的函数，但是从外部看像常规属性。\n\n\n# getter / setter\n\n在 对象字面量 中，使用 get 和 set 表示：\n\nlet obj = {\n  get propname() {\n    // ... 当读取 obj.propname 时起作用\n  },\n  set propname() {\n    // ... 设置 obj.propname 的值时起作用\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子：\n\nlet user = {\n  name: "john",\n  surname: "smith",\n\n  get fullname() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nconsole.log(user.fullname) // john smith \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从外部看访问属性就像一个普通的属性，这就是 访问属性的设计思想。不应该使用 函数形式 访问。只要正常读取 访问属性，而 getter 在幕后运行。\n\n在上面的例子中，如果不设置 setter ，此时对 fullname 设值（赋值），就会出错。所以就要给 fullname 添加一个 setter :\n\nlet user = {\n  name: "john",\n  surname: "smith",\n\n  get fullname() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set fullname(value) {\n    [this.name, this.surname] = value.split(" ");\n  }\n};\n\n// 此时赋值\nuser.fullname = "alice cooper" \nconsole.log(user.name)    // alice\nconsole.log(user.surname) // cooper\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n至此， fullname 访问属性可以看作是一个 「虚拟属性」，可读且可写。\n\n\n# 访问器描述符\n\n访问器属性的描述符与数据属性的不同。对于访问器属性，没有 value 和 writable ，但是有 get 和 set 函数。\n\n访问器描述符有：\n\n * get ：一个 没有参数 的 函数，在读取属性时工作。\n * set ：带有 一个参数 的 函数，当属性被设置时调用。\n * enumerable ：与数据属性的相同。\n * configurable ：与数据属性的相同。\n\n🌰 例子 / 使用 defineproperty 创建一个 fullname 的访问器。可以使用 get 和 set 传递描述符。\n\nlet user = {\n  name: "john",\n  surname: "smith"\n};\n\nobject.defineproperty(user, \'fullname\', {\n  get() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set(value) {\n    [this.name, this.surname] = value.split(" ");\n  }\n});\n\nconsole.log(user.fullname) // john smith\nfor(let key in user) alert(key); // name, surname\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意\n\n一个属性要么是访问器（具有 get/set 方法），要么是数据属性（具有 value ），但不能两者都是。如果试图在同一个描述符中同时提供 get 和 value ，就会报错。\n\ngetter 和 setter 可以用于包装 真实 属性值（包装器），可以对它们实现更多的控制。\n\n🌰 例子：\n\nlet user = {\n  get name() {\n    return this._name\n  }\n  \n  set name(value) {\n    if(value.length < 4) {\n      console.log("")\n    }\n    this._name = value\n  }\n}\n\nuser.name = "pete"\nconsole.log(user.name)\n\nuser.name = "a" // 太短\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> name 被存储在 _name 属性中，并通过 getter 和 setter 进行访问。\n> \n> 从技术上讲，外部代码可以使用 user._name 直接访问 name。但是，这儿有一个众所周知的约定，即以下划线 "_" 开头的属性是内部属性，不应该从对象外部进行访问。\n\n\n# 访问器的兼容性\n\n访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换「正常的」数据属性，来控制和调整这些属性的行为。\n\n🌰 例子：\n\nfunction user(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet john = new user("john", 25);\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，之后可能会选择 存储 birthday 而不是 age ，选择日期类型的 birthday 可以更加精准，但是 age 又想要保留：\n\nfunction user(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\n  // 年龄是根据当前日期和生日计算得出的\n  object.defineproperty(this, "age", {\n    get() {\n      let todayyear = new date().getfullyear();\n      return todayyear - this.birthday.getfullyear();\n    }\n  });\n}\n\nlet john = new user("john", new date(1992, 6, 1));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⏺ JavaScript 原始类型的方法",frontmatter:{title:"⏺ JavaScript 原始类型的方法",date:"2022-05-05T17:40:46.000Z",permalink:"/pages/75d69a/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/20.%20%E2%8F%BA%20JavaScript%20%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/20. ⏺ JavaScript 原始类型的方法.md",key:"v-1cd573e8",path:"/pages/75d69a/",headers:[{level:2,title:"原始类型与对象之间的区别",slug:"原始类型与对象之间的区别",normalizedTitle:"原始类型与对象之间的区别",charIndex:64},{level:2,title:"为原始类型提供「对象包装器」",slug:"为原始类型提供「对象包装器」",normalizedTitle:"为原始类型提供「对象包装器」",charIndex:421},{level:2,title:"原始类型总结",slug:"原始类型总结",normalizedTitle:"原始类型总结",charIndex:1822}],headersStr:"原始类型与对象之间的区别 为原始类型提供「对象包装器」 原始类型总结",content:'JavaScript 允许像使用对象一样使用原始类型（字符串，数字等），并且提供调用方法。⚠️ 但原始类型并不是对象！\n\n\n# 原始类型与对象之间的区别\n\n * 原始值：\n   * 是原始类型中的一种值。\n   * 在 JavaScript 中有 7 种原始类型： string ， number ， bigint ， boolean ， symbol ， null 和 undefined 。（相对于 ES6 以后的 JavaScript）\n * 对象：\n   * 能够存储多个值作为属性。\n   * 可以使用大括号 {} 创建对象，例如： {name: "John", age: 30} 。JavaScript 中还有其他种类的对象，例如函数就是对象。\n   * JavaScript 还有内建对象，处理日期、错误、HTML 元素等的内建对象。它们具有不同的属性和方法。\n * 对象比原始类型更加「厚重」，需要额外资源支持运作。\n\n\n# 为原始类型提供「对象包装器」\n\n为了保持原始数据类型简单轻量，又想完成对字符串或者数字等原始类型执行操作。\n\n * 原始类型仍然是原始的，提供单个值。\n\n * JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。\n\n * JavaScript 创建了提供额外功能的特殊「对象包装器」，使用后即被销毁。\n\n「对象包装器」对于每种原始类型都是不同的，分别被称为 String 、 Number 、 Boolean 、 Symbol 和 BigInt 。因此，它们提供了不同的方法。\n\n🌰 例子 / 字符串方法 str.toUpperCase() 字母大写化处理：\n\nlet str = "Hello";\nconsole.log( str.toUpperCase() );\n\n\n1\n2\n\n\n> 在 str.toUpperCase() 实际发生的事情：\n> \n>  * 访问字符串 str 时会创建一个包含字符串字面值的「特殊对象」，并且具有有用的方法，例如 toUpperCase() 。\n>  * 该方法运行并返回一个新的字符串。\n>  * 「特殊对象」被销毁。\n\n🌰 例子 / 数字方法 toFixed 将数字舍入到给定的精度：\n\nlet n = 1.23456;\nconsole.log( n.toFixed(2) ); // 1.23\n\n\n1\n2\n\n\n所以原始类型可以提供方法，但它们依然是轻量级的。\n\n> JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。\n\n注意\n\n构造器 String/Number/Boolean 仅供内部使用。（在 Java 中也许可以 new Number(1) 或 new Boolean(false) ，但是 JavaScript 极不推荐这样使用）\n\n * new …() JavaScript 的使用会引起问题：\n   \n   console.log( typeof 0 ); // "number"\n   console.log( typeof new Number(0) ); // "object"!\n   \n   \n   1\n   2\n   \n   \n   let zero = new Number(0);\n   if (zero) { // zero 为 true，因为它是一个对象\n     console.log( "zero is truthy?!?" );\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > ? 返回的对象始终为 true 。\n\n另一方面，JavaScript 可以调用不带 new （关键字）的 String/Number/Boolean 函数（类型转换），将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。\n\n🌰 例子：\n\nlet num = Number("123"); // 将字符串转成数字\n\n\n1\n\n\n提示\n\n对于 null/undefined 类型，没有任何数据类型的方法：它们没有对应的「对象包装器」，也没有提供任何方法，它们是「最原始的」数据类型。\n\n尝试访问这种值的属性会导致错误：\n\nalert(null.test)\n\n\n1\n\n\n\n# 原始类型总结\n\n * JavaScript 中基本类型不是对象，基本类型不能存储数据；所有的属性 / 方法操作都是在临时对象的帮助下执行的。\n * JavaScript 为原始类型提供了许多有用的方法（* 除了 null/undefined ）',normalizedContent:'javascript 允许像使用对象一样使用原始类型（字符串，数字等），并且提供调用方法。⚠️ 但原始类型并不是对象！\n\n\n# 原始类型与对象之间的区别\n\n * 原始值：\n   * 是原始类型中的一种值。\n   * 在 javascript 中有 7 种原始类型： string ， number ， bigint ， boolean ， symbol ， null 和 undefined 。（相对于 es6 以后的 javascript）\n * 对象：\n   * 能够存储多个值作为属性。\n   * 可以使用大括号 {} 创建对象，例如： {name: "john", age: 30} 。javascript 中还有其他种类的对象，例如函数就是对象。\n   * javascript 还有内建对象，处理日期、错误、html 元素等的内建对象。它们具有不同的属性和方法。\n * 对象比原始类型更加「厚重」，需要额外资源支持运作。\n\n\n# 为原始类型提供「对象包装器」\n\n为了保持原始数据类型简单轻量，又想完成对字符串或者数字等原始类型执行操作。\n\n * 原始类型仍然是原始的，提供单个值。\n\n * javascript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。\n\n * javascript 创建了提供额外功能的特殊「对象包装器」，使用后即被销毁。\n\n「对象包装器」对于每种原始类型都是不同的，分别被称为 string 、 number 、 boolean 、 symbol 和 bigint 。因此，它们提供了不同的方法。\n\n🌰 例子 / 字符串方法 str.touppercase() 字母大写化处理：\n\nlet str = "hello";\nconsole.log( str.touppercase() );\n\n\n1\n2\n\n\n> 在 str.touppercase() 实际发生的事情：\n> \n>  * 访问字符串 str 时会创建一个包含字符串字面值的「特殊对象」，并且具有有用的方法，例如 touppercase() 。\n>  * 该方法运行并返回一个新的字符串。\n>  * 「特殊对象」被销毁。\n\n🌰 例子 / 数字方法 tofixed 将数字舍入到给定的精度：\n\nlet n = 1.23456;\nconsole.log( n.tofixed(2) ); // 1.23\n\n\n1\n2\n\n\n所以原始类型可以提供方法，但它们依然是轻量级的。\n\n> javascript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。\n\n注意\n\n构造器 string/number/boolean 仅供内部使用。（在 java 中也许可以 new number(1) 或 new boolean(false) ，但是 javascript 极不推荐这样使用）\n\n * new …() javascript 的使用会引起问题：\n   \n   console.log( typeof 0 ); // "number"\n   console.log( typeof new number(0) ); // "object"!\n   \n   \n   1\n   2\n   \n   \n   let zero = new number(0);\n   if (zero) { // zero 为 true，因为它是一个对象\n     console.log( "zero is truthy?!?" );\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > ? 返回的对象始终为 true 。\n\n另一方面，javascript 可以调用不带 new （关键字）的 string/number/boolean 函数（类型转换），将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。\n\n🌰 例子：\n\nlet num = number("123"); // 将字符串转成数字\n\n\n1\n\n\n提示\n\n对于 null/undefined 类型，没有任何数据类型的方法：它们没有对应的「对象包装器」，也没有提供任何方法，它们是「最原始的」数据类型。\n\n尝试访问这种值的属性会导致错误：\n\nalert(null.test)\n\n\n1\n\n\n\n# 原始类型总结\n\n * javascript 中基本类型不是对象，基本类型不能存储数据；所有的属性 / 方法操作都是在临时对象的帮助下执行的。\n * javascript 为原始类型提供了许多有用的方法（* 除了 null/undefined ）',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔢 JavaScript 数字类型",frontmatter:{title:"🔢 JavaScript 数字类型",date:"2022-05-05T17:40:01.000Z",permalink:"/pages/f89962/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/21.%20%F0%9F%94%A2%20JavaScript%20%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/21. 🔢 JavaScript 数字类型.md",key:"v-04bd74da",path:"/pages/f89962/",headers:[{level:2,title:"数字的表示方法",slug:"数字的表示方法",normalizedTitle:"数字的表示方法",charIndex:153},{level:3,title:"_ 的使用",slug:"的使用",normalizedTitle:"_ 的使用",charIndex:165},{level:3,title:"科学计数法",slug:"科学计数法",normalizedTitle:"科学计数法",charIndex:336},{level:3,title:"二进制、八进制、十六进制",slug:"二进制、八进制、十六进制",normalizedTitle:"二进制、八进制、十六进制",charIndex:480},{level:2,title:"与数字类型有关的方法",slug:"与数字类型有关的方法",normalizedTitle:"与数字类型有关的方法",charIndex:753},{level:3,title:"toString(base)",slug:"tostring-base",normalizedTitle:"tostring(base)",charIndex:768},{level:3,title:"数字的舍入",slug:"数字的舍入",normalizedTitle:"数字的舍入",charIndex:1452},{level:3,title:"JavaScript 小数数字精度",slug:"javascript-小数数字精度",normalizedTitle:"javascript 小数数字精度",charIndex:2272},{level:3,title:"isFinite 和 isNaN",slug:"isfinite-和-isnan",normalizedTitle:"isfinite 和 isnan",charIndex:3430},{level:3,title:"parseInt 和 parseFloat",slug:"parseint-和-parsefloat",normalizedTitle:"parseint 和 parsefloat",charIndex:4971},{level:3,title:"其他数学函数",slug:"其他数学函数",normalizedTitle:"其他数学函数",charIndex:5836},{level:2,title:"数字类型总结",slug:"数字类型总结",normalizedTitle:"数字类型总结",charIndex:7729}],headersStr:"数字的表示方法 _ 的使用 科学计数法 二进制、八进制、十六进制 与数字类型有关的方法 toString(base) 数字的舍入 JavaScript 小数数字精度 isFinite 和 isNaN parseInt 和 parseFloat 其他数学函数 数字类型总结",content:"在 JavaScript 中，数字类型中两种：\n\n * 常规数字以 64 位的格式 IEEE-754 存储，也被称为「双精度浮点数」，安全范围在：-253 ~ 253 。常用的数字以这种为主。\n * BigInt 数字，用于表示任意长度的整数。仅在少数特殊领域才会用到 BigInt 类型的数字。\n\n\n# 数字的表示方法\n\n\n# _ 的使用\n\n下划线可用作分隔符（是语法糖的角色），使得数字具有更强的可读性。JavaScript 引擎会直接忽略数字之间的 _ 。\n\n🌰 例子 / 下划线分割数字：\n\nlet billion = 1000000000; // before\nlet billion = 1_000_000_000; // after\n\n\n1\n2\n\n\n\n# 科学计数法\n\n> 在 JavaScript （许多编程语言中），使用 e 表示为 10 的几次方，由 e 后面跟着的定量数字决定，可以是正数也可以是负数。\n\n🌰 例子：\n\nlet billion = 1e9;  // 10 亿，字面意思：数字 1 后面跟 9 个 0\n\n\n1\n\n\n\n# 二进制、八进制、十六进制\n\n二进制和八进制数字系统很少使用，但也支持使用 0b 和 0o 前缀：\n\nlet a = 0b11111111; // 二进制形式的 255\nlet b = 0o377; // 八进制形式的 255\n\nalert( a == b );\n\n\n1\n2\n3\n4\n\n\n十六进制数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。 0x ，然后是数字。\n\nalert( 0xff ); // 255\nalert( 0xFF );\n\n\n1\n2\n\n\n对于其他进制，应该使用函数 parseInt 。\n\n\n# 与数字类型有关的方法\n\n\n# toString(base)\n\n使用此方法 num.toString(base) 返回在给定 base 进制数字系统中 num 的字符串表示形式（将二进制数字转换为相应的 base 进制，对应反过来的方法是 parseInt(str, radix) 。）。\n\nbase 的范围可以从 2 到 36 。默认情况下是 10 。\n\n>  * base=16 用于十六进制颜色，字符编码等，数字可以是 0..9 或 A..F 。\n>  * base=2 主要用于调试按位操作，数字可以是 0 或 1 。\n>  * base=36 是最大进制，数字可以是 0..9 或 A..Z 。所有拉丁字母都被用于了表示数字。\n\n🌰 例子 ：\n\nlet num = 255\n\nconsole.log(num.toString(16)) // 转为十六进制\nconsole.log(num.toString(2)) // 转为二进制\n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 将较长的数字使用 36 数字系统表示：\n\nconsole.log(12345678..toString(36)) // 7clzi\n\n\n1\n\n\n> .. 两个点调用方法：想直接在一个数字上调用一个方法，比如上面例子中的 toString ，那么需要在它后面放置两个点 .. 。这是因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。\n> \n> 也可以使用括号分隔 (123456).toString(36)\n\n\n# 数字的舍入\n\n关于数字进行舍入的内建函数：\n\n * Math.floor 向下舍入。例如， 3.1 变成 3 ， -1.1 变成 -2 。\n * Math.ceil 向上舍入。例如， 3.1 变成 4 ， -1.1 变成 -1 。\n * Math.round 向最近的整数舍入， 3.1 变成 3 ， 3.6 变成 4 ，中间值 3.5 变成 4 。\n * Math.trunc 移除小数点的所有内容（没有舍入）。例如， 3.1 变成 3 ， -1.1 变成 -1 。\n\n常用的处理数字小数部分（移除）就是上述这些方法。\n\n如果想要保留数字的小数部分（舍入到后 n 位），有两种方法：\n\n * toFixed(n) ：将数字舍入到小数点后 n 位（规则四舍五入，向上或向下舍入到最接近的值），例如：\n   \n   let num = 12.34;\n   num.toFixed(1); // 12.3\n   \n   \n   1\n   2\n   \n   \n   let num = 12.36;\n   num.toFixed(1); // 12.4\n   \n   \n   1\n   2\n   \n   \n   toFixed 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零（补上不足的小数位）：\n   \n   let num = 12.34;\n   alert( num.toFixed(5) ); // \"12.34000\"\n   \n   \n   1\n   2\n   \n\n * 乘除法：例如，要将数字舍入到小数点后两位，我们可以将数字乘以 100 ，调用舍入函数，然后再将其除回。例如：\n   \n   let num = 1.23456;\n   Math.round(num * 100) / 100 // 1.23456 -> 123.456 -> 123 -> 1.23\n   \n   \n   1\n   2\n   \n\n\n# JavaScript 小数数字精度\n\nJavaScript 中数字精度问题：\n\n点击查看\n\n在内部，数字是以 64 位格式 IEEE-754 表示的，所以有 64 位可以存储一个数字：其中 52 位存储这些数字，11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。\n\n如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 Infinity ：\n\nconsole.log(1e500) // Infinity\n\n\n1\n\n\n🌰 例子 / 一个常见的小数加法运算，并不是预期的结果：\n\nalert( 0.1 + 0.2 ); // 0.30000000000000004\n\n\n1\n\n\n在 JavaScript 中，一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1 ， 0.2 这样的小数，实际上在二进制形式中是无限循环小数。\n\nIEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许看到「极小的精度损失」，但是它确实存在。\n\nalert( 0.1.toFixed(20) ); // 0.10000000000000000555\n\n\n1\n\n\n所以当对两个数字进行求和时，它们的「精度损失」会叠加起来。这就是为什么 0.1 + 0.2 不等于 0.3 。\n\n解决方法：\n\n * 使用 toFixed(n) 对结果舍入。\n\n🌰 例子：\n\nlet sum = 0.1 + 0.2;\nalert( sum.toFixed(2) ); // toFixed 总是返回一个字符串\nalert( +sum.toFixed(2) ); // 使用一元加号将其强制转换为一个数字\n\n\n1\n2\n3\n\n * 将小数临时乘以小数位数的 10 的倍数，先将其转换为整数，进行数学运算，然后再除回相应的 10 的倍数。但是这种方法只可以减少误差，但不能完全消除误差。\n\n🌰 例子：\n\nalert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3\nalert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001\n\n\n1\n2\n\n\n> 小数的运算处理是不可能完全避免的。就算所有的价格数据都是整数，也避免不了打折计算结果的情况。所以最好的方法就是在得到计算小数的结果进行「剪掉尾巴」的处理，\n\n提示\n\nJavaScript 数字内部存在两个零， -0 和 0 ，这是因为在存储时，使用一位来存储符号，因此对于包括零在内的任何数字，可以设置这一位或者不设置。在大多数情况下，这种区别并不明显，运算符将它们视为相同的值。\n\n\n# isFinite 和 isNaN\n\n对于两个特殊的数值： Infinity （ -Infinity ）（比任何数值都大的特殊数值）和 NaN （计算出错的结果），它们属于 number 类型，但不是「普通」的数字，因此，这里有用于检查它们的特殊函数：\n\n * isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN ：\n   \n   console.log( isNaN(NaN) ); // true\n   console.log( isNaN(\"str\") ); // true\n   \n   \n   1\n   2\n   \n   \n   > 注意：不能使用与 NaN 全等比较， NaN 独一无二的，它不等于任何东西，包括它自身。\n   > \n   > console.log(NaN === NaN)\n   > \n   > \n   > 1\n\n * ⭐️ isFinite(value) 将其参数转换为数字，如果是常规数字，则返回 true ，而不是 NaN/Infinity/-Infinity ，（可以理解为检验一个数字是否为有限值（不是 NaN 或者 Infinity ））：\n   \n   console.log(isFinite(\"15\")) // true\n   console.log(isFinite(\"str\")) // true\n   console.log(isFinite(Infinity)) // false \n   \n   \n   1\n   2\n   3\n   \n   \n   还被用于验证字符串值是否为常规数字：\n   \n   let num = +prompt(\"Enter a number\", '');\n   console.log(isFinite(num));// 结果会是 true，除非你输入的是 Infinity、-Infinity 或不是数字\n   \n   \n   1\n   2\n   \n\n注意\n\n在所有的数字方法函数中，包括 isInfinity ，空字符串或者仅有空格的字符串均被视为 0 。\n\n提示\n\n** 更可靠的比较方法 Object.is **：这是一个特殊的 JavaScript 内建方法，它类似于 === 一样对值进行比较，但它对于两种边缘情况更可靠：\n\n * NaN ： Object.is(NaN，NaN) === true 。\n * 值 0 和 -0 是不同的： Object.is(0，-0) === false 。（从技术上看，数字的字符位可能会不同，这就导致数字并不相同，即使其他所有位都为零）\n\n其他情况， Object.is(a，b) 完成的比较结果与 a === b 结果相同。\n\n这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 Object.is （内部称为 SameValue）。\n\n提示\n\nJavaScript 中检验用户的输入问题：现有一函数需要将用户输入的数值相加，返回相加后的结果。所以要判断用户的输入（完整考虑，不能仅仅只将用户的输入转换为数字）：\n\nfunction add(){\n  let a = +prompt('first num', 0)\n  if(!isFinite(a)) return alert('error')\n  \n  \n  let b = +prompt('second num', 0)\n  if(!isFinite(b)) return alert('error')\n  \n  return alert(a + b)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# parseInt 和 parseFloat\n\n前面所述，当我们需要将计算结果或者某一个值转换为数字类型，可以选择使用 + 或者 Number() 转换。使用这两种方法对于如果一个值不完全是数字（带有单位），就会失败：\n\nconsole.log(+\"100px\") // NaN\n\n\n1\n\n\n但是对于字符串中存在空格（无论开头结尾），都会被忽略成功转换。所以这两种方法存在局限。\n\n对于带有单位（ '100px' 、 ‘12pt’ 、 “19€” ）的数字字符串，要提取其中的数值，JavaScript 提供了 parseInt 和 parseFloat ，可以从字符串中读取出数字，直到无法读取:\n\n * parseInt 返回一个整数；\n * parseFloat 返回一个浮点数；\n\n🌰 例子：\n\nconsole.log(parseInt('100px')) // 100\nconsole.log(parseFloat('12.5em')) // 12.5\n\nconsole.log(parseInt('12.5')) // 12 提取整数\nconsole.log(parseFloat(3.14.159)) // 3.14 停止在第二个小数点\n\nconsole.log(parseInt('a123')) // NaN 第一个符号即非数值，则停止读取，对于parseFloat也同理\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\nparseInt(str, radix) 的第二个参数： radix 指定了数字系统的基数，因此 parseInt 还可以解析十六进制数字、二进制数字等的字符串（转换为十进制整数）：\n\nconsole.log(parseInt('0xff', 16)) // 转换16进制的数为十进制\nconsole.log(parseInt('ff', 16)) // 不带0x仍然有效\n\nconsole.log(parseInt('2n9c', 36)) // 123456\n\n\n1\n2\n3\n4\n\n\n\n# 其他数学函数\n\n * Math.random() ：返回一个从 0 到 1 的随机数（不包括 1。）：\n   \n   console.log(Math.random()) // 0.5181640579695068\n   \n   \n   1\n   \n   \n   > 与舍入的方法配合使用：\n   > \n   > Math.floor(Math.random()*10) // 0～10之间的随机整数\n   > Math.ceil(Math.random()*10) // 0～10之间的随机整数\n   > Math.round(Math.random()*10) // *均衡获取0～10之间的随机整数\n   > \n   > \n   > 1\n   > 2\n   > 3\n\n更详细的生成随机数的方案：\n\n点击查看\n\n * 生成从 min 到 max 的随机整数：\n   \n   错误方案 / 边缘值的概率会比其他值少 ：\n   \n   function randomInteger(min, max) {\n     let rand = min + Math.random() * (max - min);\n     return Math.round(rand);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   正确方案 / 调整取值范围的边界：\n   \n   function randomInteger(min, max) {\n     // 现在范围是从  (min-0.5) 到 (max+0.5)\n     let rand = min - 0.5 + Math.random() * (max - min + 1);\n     return Math.round(rand);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   正确方案 / 取范围从 min 到 max+1 的随机数 ：\n   \n   function randomInteger(min, max) {\n     let rand = min + Math.random() * (max + 1 - min);\n   \treturn Math.round(rand);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 生成从 min 到 max 的随机数：\n   \n   function random(min, max) {\n     return min + Math.random() * (max - min)\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * Math.max(a, b, c) / Math.min(a, b, c) ：Math.max() - JavaScript | MDN (mozilla.org) 获取一组参数中（参数可以是一组数字，可以是数组）的最大值或者最小值：\n   \n   console.log(Math.max(1, 3, 2));\n   // expected output: 3\n   \n   console.log(Math.max(-1, -3, -2));\n   // expected output: -1\n   \n   const array1 = [1, 3, 2];\n   console.log(Math.max(...array1));\n   // expected output: 3\n   \n   // 对于 Math.min() 使用方法同理。\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   如果有任一参数不能转换为数值，则返回值为 NaN 。如果没有参数，结果为 Infinity （ -Infinity ）。\n\n提示\n\n使用 Math.max() 或者 Math.min() 裁剪值：使某个方法的返回值始终小于或者大于某个值。\n\n🌰 例子：\n\nvar x = f(foo);\nif (x > boundary) {\n    x = boundary;\n}\n\n\n1\n2\n3\n4\n\n\nCopy to Clipboard\n\n可以写成：\n\nvar x = Math.min(f(foo), boundary); // 只要返回值大于边界值就只返回边界值\n\n\n1\n\n\n\n# 数字类型总结\n\n * 对于很多零（或者有很多小数位）的数字可以使用科学计数法 e 简化表示数值。\n * 对于不同的数字系统（不同进制的数字），在前添加相关的前缀，十六进制（ 0x ），八进制（ 0o ）和二进制（ 0b ），即可以在系统中写入数字。\n   * parseInt(str，base) ：指定的 base 数字系统 （ 2 ≤ base ≤ 36 ） 转换为十进制整数。\n   * num.toString(base) ：将数字转换为在给定的 base 数字系统中的字符串（二进制转换为其他进制）。\n * 提取出带有单位的数字字符串：使用 parseInt/parseFloat 进行转换，在特殊字符之前停止读取转换。\n * 小数的舍入：使用 Math.floor ， Math.ceil ， Math.trunc ， Math.round 或 num.toFixed(precision) 进行舍入。\n * 使用小数会有损失数字精度的问题。\n * 更多的数值类型的数学函数来自 Math 对象。",normalizedContent:"在 javascript 中，数字类型中两种：\n\n * 常规数字以 64 位的格式 ieee-754 存储，也被称为「双精度浮点数」，安全范围在：-253 ~ 253 。常用的数字以这种为主。\n * bigint 数字，用于表示任意长度的整数。仅在少数特殊领域才会用到 bigint 类型的数字。\n\n\n# 数字的表示方法\n\n\n# _ 的使用\n\n下划线可用作分隔符（是语法糖的角色），使得数字具有更强的可读性。javascript 引擎会直接忽略数字之间的 _ 。\n\n🌰 例子 / 下划线分割数字：\n\nlet billion = 1000000000; // before\nlet billion = 1_000_000_000; // after\n\n\n1\n2\n\n\n\n# 科学计数法\n\n> 在 javascript （许多编程语言中），使用 e 表示为 10 的几次方，由 e 后面跟着的定量数字决定，可以是正数也可以是负数。\n\n🌰 例子：\n\nlet billion = 1e9;  // 10 亿，字面意思：数字 1 后面跟 9 个 0\n\n\n1\n\n\n\n# 二进制、八进制、十六进制\n\n二进制和八进制数字系统很少使用，但也支持使用 0b 和 0o 前缀：\n\nlet a = 0b11111111; // 二进制形式的 255\nlet b = 0o377; // 八进制形式的 255\n\nalert( a == b );\n\n\n1\n2\n3\n4\n\n\n十六进制数字在 javascript 中被广泛用于表示颜色，编码字符以及其他许多东西。 0x ，然后是数字。\n\nalert( 0xff ); // 255\nalert( 0xff );\n\n\n1\n2\n\n\n对于其他进制，应该使用函数 parseint 。\n\n\n# 与数字类型有关的方法\n\n\n# tostring(base)\n\n使用此方法 num.tostring(base) 返回在给定 base 进制数字系统中 num 的字符串表示形式（将二进制数字转换为相应的 base 进制，对应反过来的方法是 parseint(str, radix) 。）。\n\nbase 的范围可以从 2 到 36 。默认情况下是 10 。\n\n>  * base=16 用于十六进制颜色，字符编码等，数字可以是 0..9 或 a..f 。\n>  * base=2 主要用于调试按位操作，数字可以是 0 或 1 。\n>  * base=36 是最大进制，数字可以是 0..9 或 a..z 。所有拉丁字母都被用于了表示数字。\n\n🌰 例子 ：\n\nlet num = 255\n\nconsole.log(num.tostring(16)) // 转为十六进制\nconsole.log(num.tostring(2)) // 转为二进制\n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 将较长的数字使用 36 数字系统表示：\n\nconsole.log(12345678..tostring(36)) // 7clzi\n\n\n1\n\n\n> .. 两个点调用方法：想直接在一个数字上调用一个方法，比如上面例子中的 tostring ，那么需要在它后面放置两个点 .. 。这是因为 javascript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 javascript 就知道小数部分为空，现在使用该方法。\n> \n> 也可以使用括号分隔 (123456).tostring(36)\n\n\n# 数字的舍入\n\n关于数字进行舍入的内建函数：\n\n * math.floor 向下舍入。例如， 3.1 变成 3 ， -1.1 变成 -2 。\n * math.ceil 向上舍入。例如， 3.1 变成 4 ， -1.1 变成 -1 。\n * math.round 向最近的整数舍入， 3.1 变成 3 ， 3.6 变成 4 ，中间值 3.5 变成 4 。\n * math.trunc 移除小数点的所有内容（没有舍入）。例如， 3.1 变成 3 ， -1.1 变成 -1 。\n\n常用的处理数字小数部分（移除）就是上述这些方法。\n\n如果想要保留数字的小数部分（舍入到后 n 位），有两种方法：\n\n * tofixed(n) ：将数字舍入到小数点后 n 位（规则四舍五入，向上或向下舍入到最接近的值），例如：\n   \n   let num = 12.34;\n   num.tofixed(1); // 12.3\n   \n   \n   1\n   2\n   \n   \n   let num = 12.36;\n   num.tofixed(1); // 12.4\n   \n   \n   1\n   2\n   \n   \n   tofixed 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零（补上不足的小数位）：\n   \n   let num = 12.34;\n   alert( num.tofixed(5) ); // \"12.34000\"\n   \n   \n   1\n   2\n   \n\n * 乘除法：例如，要将数字舍入到小数点后两位，我们可以将数字乘以 100 ，调用舍入函数，然后再将其除回。例如：\n   \n   let num = 1.23456;\n   math.round(num * 100) / 100 // 1.23456 -> 123.456 -> 123 -> 1.23\n   \n   \n   1\n   2\n   \n\n\n# javascript 小数数字精度\n\njavascript 中数字精度问题：\n\n点击查看\n\n在内部，数字是以 64 位格式 ieee-754 表示的，所以有 64 位可以存储一个数字：其中 52 位存储这些数字，11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。\n\n如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 infinity ：\n\nconsole.log(1e500) // infinity\n\n\n1\n\n\n🌰 例子 / 一个常见的小数加法运算，并不是预期的结果：\n\nalert( 0.1 + 0.2 ); // 0.30000000000000004\n\n\n1\n\n\n在 javascript 中，一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1 ， 0.2 这样的小数，实际上在二进制形式中是无限循环小数。\n\nieee-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许看到「极小的精度损失」，但是它确实存在。\n\nalert( 0.1.tofixed(20) ); // 0.10000000000000000555\n\n\n1\n\n\n所以当对两个数字进行求和时，它们的「精度损失」会叠加起来。这就是为什么 0.1 + 0.2 不等于 0.3 。\n\n解决方法：\n\n * 使用 tofixed(n) 对结果舍入。\n\n🌰 例子：\n\nlet sum = 0.1 + 0.2;\nalert( sum.tofixed(2) ); // tofixed 总是返回一个字符串\nalert( +sum.tofixed(2) ); // 使用一元加号将其强制转换为一个数字\n\n\n1\n2\n3\n\n * 将小数临时乘以小数位数的 10 的倍数，先将其转换为整数，进行数学运算，然后再除回相应的 10 的倍数。但是这种方法只可以减少误差，但不能完全消除误差。\n\n🌰 例子：\n\nalert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3\nalert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001\n\n\n1\n2\n\n\n> 小数的运算处理是不可能完全避免的。就算所有的价格数据都是整数，也避免不了打折计算结果的情况。所以最好的方法就是在得到计算小数的结果进行「剪掉尾巴」的处理，\n\n提示\n\njavascript 数字内部存在两个零， -0 和 0 ，这是因为在存储时，使用一位来存储符号，因此对于包括零在内的任何数字，可以设置这一位或者不设置。在大多数情况下，这种区别并不明显，运算符将它们视为相同的值。\n\n\n# isfinite 和 isnan\n\n对于两个特殊的数值： infinity （ -infinity ）（比任何数值都大的特殊数值）和 nan （计算出错的结果），它们属于 number 类型，但不是「普通」的数字，因此，这里有用于检查它们的特殊函数：\n\n * isnan(value) 将其参数转换为数字，然后测试它是否为 nan ：\n   \n   console.log( isnan(nan) ); // true\n   console.log( isnan(\"str\") ); // true\n   \n   \n   1\n   2\n   \n   \n   > 注意：不能使用与 nan 全等比较， nan 独一无二的，它不等于任何东西，包括它自身。\n   > \n   > console.log(nan === nan)\n   > \n   > \n   > 1\n\n * ⭐️ isfinite(value) 将其参数转换为数字，如果是常规数字，则返回 true ，而不是 nan/infinity/-infinity ，（可以理解为检验一个数字是否为有限值（不是 nan 或者 infinity ））：\n   \n   console.log(isfinite(\"15\")) // true\n   console.log(isfinite(\"str\")) // true\n   console.log(isfinite(infinity)) // false \n   \n   \n   1\n   2\n   3\n   \n   \n   还被用于验证字符串值是否为常规数字：\n   \n   let num = +prompt(\"enter a number\", '');\n   console.log(isfinite(num));// 结果会是 true，除非你输入的是 infinity、-infinity 或不是数字\n   \n   \n   1\n   2\n   \n\n注意\n\n在所有的数字方法函数中，包括 isinfinity ，空字符串或者仅有空格的字符串均被视为 0 。\n\n提示\n\n** 更可靠的比较方法 object.is **：这是一个特殊的 javascript 内建方法，它类似于 === 一样对值进行比较，但它对于两种边缘情况更可靠：\n\n * nan ： object.is(nan，nan) === true 。\n * 值 0 和 -0 是不同的： object.is(0，-0) === false 。（从技术上看，数字的字符位可能会不同，这就导致数字并不相同，即使其他所有位都为零）\n\n其他情况， object.is(a，b) 完成的比较结果与 a === b 结果相同。\n\n这种比较方式经常被用在 javascript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 object.is （内部称为 samevalue）。\n\n提示\n\njavascript 中检验用户的输入问题：现有一函数需要将用户输入的数值相加，返回相加后的结果。所以要判断用户的输入（完整考虑，不能仅仅只将用户的输入转换为数字）：\n\nfunction add(){\n  let a = +prompt('first num', 0)\n  if(!isfinite(a)) return alert('error')\n  \n  \n  let b = +prompt('second num', 0)\n  if(!isfinite(b)) return alert('error')\n  \n  return alert(a + b)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# parseint 和 parsefloat\n\n前面所述，当我们需要将计算结果或者某一个值转换为数字类型，可以选择使用 + 或者 number() 转换。使用这两种方法对于如果一个值不完全是数字（带有单位），就会失败：\n\nconsole.log(+\"100px\") // nan\n\n\n1\n\n\n但是对于字符串中存在空格（无论开头结尾），都会被忽略成功转换。所以这两种方法存在局限。\n\n对于带有单位（ '100px' 、 ‘12pt’ 、 “19€” ）的数字字符串，要提取其中的数值，javascript 提供了 parseint 和 parsefloat ，可以从字符串中读取出数字，直到无法读取:\n\n * parseint 返回一个整数；\n * parsefloat 返回一个浮点数；\n\n🌰 例子：\n\nconsole.log(parseint('100px')) // 100\nconsole.log(parsefloat('12.5em')) // 12.5\n\nconsole.log(parseint('12.5')) // 12 提取整数\nconsole.log(parsefloat(3.14.159)) // 3.14 停止在第二个小数点\n\nconsole.log(parseint('a123')) // nan 第一个符号即非数值，则停止读取，对于parsefloat也同理\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\nparseint(str, radix) 的第二个参数： radix 指定了数字系统的基数，因此 parseint 还可以解析十六进制数字、二进制数字等的字符串（转换为十进制整数）：\n\nconsole.log(parseint('0xff', 16)) // 转换16进制的数为十进制\nconsole.log(parseint('ff', 16)) // 不带0x仍然有效\n\nconsole.log(parseint('2n9c', 36)) // 123456\n\n\n1\n2\n3\n4\n\n\n\n# 其他数学函数\n\n * math.random() ：返回一个从 0 到 1 的随机数（不包括 1。）：\n   \n   console.log(math.random()) // 0.5181640579695068\n   \n   \n   1\n   \n   \n   > 与舍入的方法配合使用：\n   > \n   > math.floor(math.random()*10) // 0～10之间的随机整数\n   > math.ceil(math.random()*10) // 0～10之间的随机整数\n   > math.round(math.random()*10) // *均衡获取0～10之间的随机整数\n   > \n   > \n   > 1\n   > 2\n   > 3\n\n更详细的生成随机数的方案：\n\n点击查看\n\n * 生成从 min 到 max 的随机整数：\n   \n   错误方案 / 边缘值的概率会比其他值少 ：\n   \n   function randominteger(min, max) {\n     let rand = min + math.random() * (max - min);\n     return math.round(rand);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   正确方案 / 调整取值范围的边界：\n   \n   function randominteger(min, max) {\n     // 现在范围是从  (min-0.5) 到 (max+0.5)\n     let rand = min - 0.5 + math.random() * (max - min + 1);\n     return math.round(rand);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   正确方案 / 取范围从 min 到 max+1 的随机数 ：\n   \n   function randominteger(min, max) {\n     let rand = min + math.random() * (max + 1 - min);\n   \treturn math.round(rand);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 生成从 min 到 max 的随机数：\n   \n   function random(min, max) {\n     return min + math.random() * (max - min)\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * math.max(a, b, c) / math.min(a, b, c) ：math.max() - javascript | mdn (mozilla.org) 获取一组参数中（参数可以是一组数字，可以是数组）的最大值或者最小值：\n   \n   console.log(math.max(1, 3, 2));\n   // expected output: 3\n   \n   console.log(math.max(-1, -3, -2));\n   // expected output: -1\n   \n   const array1 = [1, 3, 2];\n   console.log(math.max(...array1));\n   // expected output: 3\n   \n   // 对于 math.min() 使用方法同理。\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   如果有任一参数不能转换为数值，则返回值为 nan 。如果没有参数，结果为 infinity （ -infinity ）。\n\n提示\n\n使用 math.max() 或者 math.min() 裁剪值：使某个方法的返回值始终小于或者大于某个值。\n\n🌰 例子：\n\nvar x = f(foo);\nif (x > boundary) {\n    x = boundary;\n}\n\n\n1\n2\n3\n4\n\n\ncopy to clipboard\n\n可以写成：\n\nvar x = math.min(f(foo), boundary); // 只要返回值大于边界值就只返回边界值\n\n\n1\n\n\n\n# 数字类型总结\n\n * 对于很多零（或者有很多小数位）的数字可以使用科学计数法 e 简化表示数值。\n * 对于不同的数字系统（不同进制的数字），在前添加相关的前缀，十六进制（ 0x ），八进制（ 0o ）和二进制（ 0b ），即可以在系统中写入数字。\n   * parseint(str，base) ：指定的 base 数字系统 （ 2 ≤ base ≤ 36 ） 转换为十进制整数。\n   * num.tostring(base) ：将数字转换为在给定的 base 数字系统中的字符串（二进制转换为其他进制）。\n * 提取出带有单位的数字字符串：使用 parseint/parsefloat 进行转换，在特殊字符之前停止读取转换。\n * 小数的舍入：使用 math.floor ， math.ceil ， math.trunc ， math.round 或 num.tofixed(precision) 进行舍入。\n * 使用小数会有损失数字精度的问题。\n * 更多的数值类型的数学函数来自 math 对象。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"♒️ JavaScript 字符串",frontmatter:{title:"♒️ JavaScript 字符串",date:"2022-05-05T18:39:13.000Z",permalink:"/pages/33f8b7/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/22.%20%E2%99%92%EF%B8%8F%20JavaScript%20%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/22. ♒️ JavaScript 字符串.md",key:"v-57dee333",path:"/pages/33f8b7/",headers:[{level:2,title:"声明字符串",slug:"声明字符串",normalizedTitle:"声明字符串",charIndex:75},{level:2,title:"特殊字符",slug:"特殊字符",normalizedTitle:"特殊字符",charIndex:554},{level:2,title:"访问字符串",slug:"访问字符串",normalizedTitle:"访问字符串",charIndex:1217},{level:3,title:"获取字符串的长度",slug:"获取字符串的长度",normalizedTitle:"获取字符串的长度",charIndex:1227},{level:2,title:"更多关于字符串的方法",slug:"更多关于字符串的方法",normalizedTitle:"更多关于字符串的方法",charIndex:2123},{level:4,title:"更改字符串的大小写（整个字符串）",slug:"更改字符串的大小写-整个字符串",normalizedTitle:"更改字符串的大小写（整个字符串）",charIndex:2137},{level:4,title:"查找子字符串的方法",slug:"查找子字符串的方法",normalizedTitle:"查找子字符串的方法",charIndex:2430},{level:4,title:"获取子字符串",slug:"获取子字符串",normalizedTitle:"获取子字符串",charIndex:4318},{level:3,title:"字符串的比较",slug:"字符串的比较",normalizedTitle:"字符串的比较",charIndex:5709},{level:2,title:"字符串总结",slug:"字符串总结",normalizedTitle:"字符串总结",charIndex:6837}],headersStr:"声明字符串 特殊字符 访问字符串 获取字符串的长度 更多关于字符串的方法 更改字符串的大小写（整个字符串） 查找子字符串的方法 获取子字符串 字符串的比较 字符串总结",content:"在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。字符串的内部格式始终是 UTF-16，它不依赖于页面编码。\n\n\n# 声明字符串\n\n字符串可以被包含在单引号 ‘’ 、 “” 、 `` 反引号。\n\n * 反引号的特殊使用，可以通过 ${…} 将任何表达式嵌入到字符串中：\n   \n   function sum(a, b) {\n     return a + b;\n   }\n   \n   console.log(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   并且反引号允许字符串跨行：\n   \n   let guestList = `Guests:\n    * John\n    * Pete\n    * Mary\n   `;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   ⚠️ 单引号或者双引号不能跨行，只能添加换行的转义符 \\n\n\n * 较少的用法，在反引号之前指定一个「模版函数」，函数 func 被自动调用，接收字符串和嵌入式表达式，并处理它们。此功能可以将字符串包装到自定义模版或其他函数中。\n\n\n# 特殊字符\n\n在字符串中允许使用一些特殊的字符使用于不同的场景：\n\n字符                             描述\n\\n                             换行\n\\' , \\\"                        在字符串中添加引号\n\\\\                             在字符串中添加反斜线\n\\t                             制表符\n\\b , \\f , \\v                   退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。\n\\xXX                           具有给定十六进制 Unicode XX 的 Unicode 字符，例如： '\\x7A' 和 'z' 相同。\n\\uXXXX                         以 UTF-16 编码的十六进制代码 XXXX 的 Unicode 字符，例如 \\u00A9 是版权符号 © 的\n                               Unicode。它必须正好是 4 个十六进制数字。（字符串使用 emoji 的用法）\n\\u{X…XXXXXX} （1 到 6 个十六进制字符）   具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4\n                               个字节。通过它插入长代码。\n\n\n# 访问字符串\n\n\n# 获取字符串的长度\n\n字符串有属性 length 表示字符串长度：\n\nconsole.log('abc'.length) // 3\n\ncosole.log('abc//'.length) // 4，要算上特殊字符\n\n\n1\n2\n3\n\n\n注意\n\nlength 是属性不是函数，读取不需要加括号。\n\n读取 pos 位置的一个字符，有两种方法：\n\n * 直接使用 [pos] 方括号读取；\n * 使用 str.charAt[pos] 。\n\n🌰 例子：\n\nlet str = `Hello`;\n\n// 第一个字符\nalert( str[0] ); // H\nalert( str.charAt(0) ); // H\n\n// 最后一个字符\nalert( str[str.length - 1] ); // o\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 方括号是获取字符的一种现代化方法，而 charAt 是历史原因才存在的。它们之间的唯一区别是，如果没有找到字符， [] 返回 undefined ，而 charAt 返回一个空字符串：\n> \n> let str = `Hello`;\n> \n> alert( str[1000] ); // undefined\n> alert( str.charAt(1000) ); // ''（空字符串)\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n使用 for ... of 遍历字符串：\n\nfor (let char of \"Hello\") {\n  alert(char); \n}\n\n\n\n1\n2\n3\n4\n\n\n注意\n\nJavaScript 中的字符串不能更改其中的一个字符：\n\nlet str = 'Hi';\n\nstr[0] = 'h'; // error\nconsole.log( str[0] ); // 无法运行\n\n\n1\n2\n3\n4\n\n\n只能重新创建一个字符串（修改的部分加上不修改的部分），分配给以前的字符串：\n\nlet str = 'Hi';\nstr = 'h' + str[1];\nconsole.log( str );\n\n\n1\n2\n3\n\n\n\n# 更多关于字符串的方法\n\n# 更改字符串的大小写（整个字符串）\n\ntoLowerCase() 和 toUpperCase()\n\nconsole.log('Interface'.toUpperCase()) // INTERFACE\nconsole.log('Interface'.toUpperCase()) // interface\n\n\n1\n2\n\n\n只修改其中一个字符：\n\nconsole.log('Interface'[0].toUpperCase()) // Interface\nconsole.log('Interface'[0].toLowerCase()) // interface\n\n\n1\n2\n\n\n# 查找子字符串的方法\n\n * str.indexOf(substr, pos) ：从给定的位置 pos 开始，在 str 中查找 substr ，如果没有找到，则返回 -1 ，否则返回匹配成功的位置。\n   \n   let str = 'Widget with id';\n   \n   console.log(str.indexOf('Widget')); // 0 一开始就找到\n   console.log(str.indexOf('widget')); // -1，没有找到，检索是大小写敏感的\n   \n   console.log(str.indexOf(\"id\")); // 1，\"id\" 在位置 1 处（……idget 和 id） 不完全匹配所以可以指定检索位置\n   console.log(str.indexOf('id', 2)) // 12 跳过第一个\"id\"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   可以循环遍历查找，保存所有找到的位置：\n   \n   let str = 'As sly as a fox, as strong as an ox';\n   \n   let target = 'as';\n   let pos = 0;\n   let res = []\n   while (true) {\n     let foundPos = str.indexOf(target, pos);\n     if (foundPos == -1) break;\n   \n     console.log( `Found at ${foundPos}` );\n     res.push(foundPos)\n     pos = foundPos + 1; // 继续从下一个位置查找\n   }\n   \n   console.log(res) // [7, 17, 27]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > ⚠️ 位置包括空格字符。\n   \n   简写方法：\n   \n   while((pos = str.indexOf(target, pos + 1)) != -1){\n     res.push(pos)\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   > 对于 str.lastIndexOf(substr, pos) 方法，查找结果是相反的（从字符串的结尾开始查找）。\n   \n   > 不要使用查找结果为 if 的判断条件，因为有可能第一个字符就是结果，而 0 在 if 中判断为 false 。应该检查是否等于 -1 ：\n   > \n   > let str = \"Widget with id\";\n   > \n   > if (str.indexOf(\"Widget\") != -1) {\n   >     alert(\"We found it\");\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n\n * ⭐️ 现代方法 str.includes(substr, pos) ：\n   \n   只需要检验是否匹配，可以不带位置 pos\n   \n   console.log(\"Widget with id\".includes(\"Widget\")) // true\n   \n   \n   1\n   \n   \n   可选参数 pos 是开始搜索的位置：\n   \n   console.log(\"Midget\".includes(\"id\")); // true\n   console.log(\"Midget\".includes(\"id\", 3)); // false\n   \n   \n   1\n   2\n   \n   \n   str.startsWith(str) / str.endsWith(str) 分别是从字符串的开头或者结尾开始搜索：\n   \n   console.log( \"Widget\".startsWith(\"Wid\") ); // true \n   console.log( \"Widget\".endsWith(\"get\") ); // false\n   \n   \n   1\n   2\n   \n\n# 获取子字符串\n\nJavaScript 中有三种获取字符串的方法： substring 、 substr 和 slice 。\n\n * str.slice(start [, end]) （ end 是可选参数）：返回字符串从 start 到 end 的位置： 【注意不包括 end 处的字符】\n   \n   let str = \"stringify\";\n   console.log(str.slice(0, 5)) // 'strin'\n   console.log(str.slice(0, 1)) // 's'\n   \n   \n   1\n   2\n   3\n   \n   \n   如果没有 end 参数，则一直从 start 位置运行到字符串末尾：\n   \n   let str = \"stringify\";\n   console.log(str.slice(2)); // 'ringify'\n   \n   \n   1\n   2\n   \n   \n   start / end 可以为负数，从字符串结尾计算：\n   \n   let str = \"stringify\";\n   console.log(str.slice(-4, -1)) // 'gif'\n   \n   \n   1\n   2\n   \n\n * str.substring() 允许 start 大于 end （但是不支持负数的参数），其他几乎与 slice 相同：\n   \n   let str = \"stringify\";\n   console.log( str.substring(2, 6) ); // \"ring\"\n   console.log( str.substring(6, 2) ); // \"ring\"\n   \n   \n   1\n   2\n   3\n   \n\n * str.substr(start [, length]) 从 start 开始取 length 长度的字符串：\n   \n   let str = \"stringify\";\n   console.log( str.substr(2, 4) );\n   \n   \n   1\n   2\n   \n   \n   start 可以为负值， 从字符串结尾计算：\n   \n   let str = \"stringify\";\n   console.log( str.substr(-4, 2) ); // 'gi'\n   \n   \n   1\n   2\n   \n\n> 总结：\n> \n> 方法                      选择方式……                                负值参数\n> slice(start, end)       从 start 到 end （不含 end ）               允许\n> substring(start, end)   start 与 end 之间（包括 start ，但不包括 end ）   不允许负值\n> substr(start, length)   从 start 开始获取长为 length 的字符串            允许 start 为负数\n\n提示\n\n相较于其他两个变体， slice 稍微灵活一些，它允许以负值作为参数并且写法更简短。\n\n\n# 字符串的比较\n\nJavaScript 中，字符串按字母顺序逐字比较。比较顺序按照个字符都有对应的数字代码（ UTF-16 编码）。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。\n\n * str.codePointAt(pos) ：返回 pos 位置的字符代码：\n   \n   console.log(\"z\".codePointAt(0)) // 122\n   console.log(\"Z\".codePointAt(0)) // 90\n   \n   \n   1\n   2\n   \n\n * String.fromCodePoint(code) ：通过字符代码创建字符：\n   \n   console.log(String.fromCodePoint(90)) // 'Z'、\n   \n   \n   1\n   \n\n * 使用十六进制代码（二进制的字符代码转换为十六进制），添加 Unicode 字符串：\n   \n   console.log('\\u005a') // 'Z' (90 -> 5a)\n   \n   \n   1\n   \n\n> 遍历输出代码为 65..220 的字符：\n> \n> let str = '';\n> \n> for (let i = 65; i <= 220; i++) {\n>   str += String.fromCodePoint(i);\n> }\n> console.log( str );\n> // ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n> // ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 大写字母一般顺序在小写字母之后。\n\n通过字符代码比较字符串的顺序，越大的代码意味着字符越大。\n\n * 所有小写字母追随在大写字母之后，因为它们的代码更大。\n * 一些像 Ö 的字母与主要字母表不同。这里，它的代码比任何从 a 到 z 的代码都要大。\n\n利用 str.localeCompare(str2) 完成「符合语言正确」的字符串比较。会根据语言规则返回一个整数，这个整数能指示字符串 str 在排序顺序中排在字符串 str2 前面、后面、还是相同：\n\n * 如果 str 排在 str2 前面，则返回负数。\n * 如果 str 排在 str2 后面，则返回正数。\n * 如果它们在相同位置，则返回 0 。\n\n> 根据不同的语言的字母都不相同。\n\n\n# 字符串总结\n\n * 定义字符串有三种方式。\n   \n   * 使用反引号允许跨越多行，并且可以插入表达式。\n\n * JavaScript 中的字符串使用的是 UTF-16 编码。\n\n * 介绍了许多处理字符串的方法：\n   \n   * 获取字符时，使用 [] 。\n   * 获取字符串的长度，使用 str.length\n   * 获取子字符串，使用 slice() 。\n   * 字符串的大 / 小写转换，使用： toLowerCase() / toUpperCase() 。\n   * 查找子字符串时，使用 indexOf 或 includes/startsWith/endsWith 进行简单检查。\n   * 比较字符串一般按照字符代码比较。\n\n更多的字符串方法：手册",normalizedContent:"在 javascript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。字符串的内部格式始终是 utf-16，它不依赖于页面编码。\n\n\n# 声明字符串\n\n字符串可以被包含在单引号 ‘’ 、 “” 、 `` 反引号。\n\n * 反引号的特殊使用，可以通过 ${…} 将任何表达式嵌入到字符串中：\n   \n   function sum(a, b) {\n     return a + b;\n   }\n   \n   console.log(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   并且反引号允许字符串跨行：\n   \n   let guestlist = `guests:\n    * john\n    * pete\n    * mary\n   `;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   ⚠️ 单引号或者双引号不能跨行，只能添加换行的转义符 \\n\n\n * 较少的用法，在反引号之前指定一个「模版函数」，函数 func 被自动调用，接收字符串和嵌入式表达式，并处理它们。此功能可以将字符串包装到自定义模版或其他函数中。\n\n\n# 特殊字符\n\n在字符串中允许使用一些特殊的字符使用于不同的场景：\n\n字符                             描述\n\\n                             换行\n\\' , \\\"                        在字符串中添加引号\n\\\\                             在字符串中添加反斜线\n\\t                             制表符\n\\b , \\f , \\v                   退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。\n\\xxx                           具有给定十六进制 unicode xx 的 unicode 字符，例如： '\\x7a' 和 'z' 相同。\n\\uxxxx                         以 utf-16 编码的十六进制代码 xxxx 的 unicode 字符，例如 \\u00a9 是版权符号 © 的\n                               unicode。它必须正好是 4 个十六进制数字。（字符串使用 emoji 的用法）\n\\u{x…xxxxxx} （1 到 6 个十六进制字符）   具有给定 utf-32 编码的 unicode 符号。一些罕见的字符用两个 unicode 符号编码，占用 4\n                               个字节。通过它插入长代码。\n\n\n# 访问字符串\n\n\n# 获取字符串的长度\n\n字符串有属性 length 表示字符串长度：\n\nconsole.log('abc'.length) // 3\n\ncosole.log('abc//'.length) // 4，要算上特殊字符\n\n\n1\n2\n3\n\n\n注意\n\nlength 是属性不是函数，读取不需要加括号。\n\n读取 pos 位置的一个字符，有两种方法：\n\n * 直接使用 [pos] 方括号读取；\n * 使用 str.charat[pos] 。\n\n🌰 例子：\n\nlet str = `hello`;\n\n// 第一个字符\nalert( str[0] ); // h\nalert( str.charat(0) ); // h\n\n// 最后一个字符\nalert( str[str.length - 1] ); // o\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 方括号是获取字符的一种现代化方法，而 charat 是历史原因才存在的。它们之间的唯一区别是，如果没有找到字符， [] 返回 undefined ，而 charat 返回一个空字符串：\n> \n> let str = `hello`;\n> \n> alert( str[1000] ); // undefined\n> alert( str.charat(1000) ); // ''（空字符串)\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n使用 for ... of 遍历字符串：\n\nfor (let char of \"hello\") {\n  alert(char); \n}\n\n\n\n1\n2\n3\n4\n\n\n注意\n\njavascript 中的字符串不能更改其中的一个字符：\n\nlet str = 'hi';\n\nstr[0] = 'h'; // error\nconsole.log( str[0] ); // 无法运行\n\n\n1\n2\n3\n4\n\n\n只能重新创建一个字符串（修改的部分加上不修改的部分），分配给以前的字符串：\n\nlet str = 'hi';\nstr = 'h' + str[1];\nconsole.log( str );\n\n\n1\n2\n3\n\n\n\n# 更多关于字符串的方法\n\n# 更改字符串的大小写（整个字符串）\n\ntolowercase() 和 touppercase()\n\nconsole.log('interface'.touppercase()) // interface\nconsole.log('interface'.touppercase()) // interface\n\n\n1\n2\n\n\n只修改其中一个字符：\n\nconsole.log('interface'[0].touppercase()) // interface\nconsole.log('interface'[0].tolowercase()) // interface\n\n\n1\n2\n\n\n# 查找子字符串的方法\n\n * str.indexof(substr, pos) ：从给定的位置 pos 开始，在 str 中查找 substr ，如果没有找到，则返回 -1 ，否则返回匹配成功的位置。\n   \n   let str = 'widget with id';\n   \n   console.log(str.indexof('widget')); // 0 一开始就找到\n   console.log(str.indexof('widget')); // -1，没有找到，检索是大小写敏感的\n   \n   console.log(str.indexof(\"id\")); // 1，\"id\" 在位置 1 处（……idget 和 id） 不完全匹配所以可以指定检索位置\n   console.log(str.indexof('id', 2)) // 12 跳过第一个\"id\"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   可以循环遍历查找，保存所有找到的位置：\n   \n   let str = 'as sly as a fox, as strong as an ox';\n   \n   let target = 'as';\n   let pos = 0;\n   let res = []\n   while (true) {\n     let foundpos = str.indexof(target, pos);\n     if (foundpos == -1) break;\n   \n     console.log( `found at ${foundpos}` );\n     res.push(foundpos)\n     pos = foundpos + 1; // 继续从下一个位置查找\n   }\n   \n   console.log(res) // [7, 17, 27]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > ⚠️ 位置包括空格字符。\n   \n   简写方法：\n   \n   while((pos = str.indexof(target, pos + 1)) != -1){\n     res.push(pos)\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   > 对于 str.lastindexof(substr, pos) 方法，查找结果是相反的（从字符串的结尾开始查找）。\n   \n   > 不要使用查找结果为 if 的判断条件，因为有可能第一个字符就是结果，而 0 在 if 中判断为 false 。应该检查是否等于 -1 ：\n   > \n   > let str = \"widget with id\";\n   > \n   > if (str.indexof(\"widget\") != -1) {\n   >     alert(\"we found it\");\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n\n * ⭐️ 现代方法 str.includes(substr, pos) ：\n   \n   只需要检验是否匹配，可以不带位置 pos\n   \n   console.log(\"widget with id\".includes(\"widget\")) // true\n   \n   \n   1\n   \n   \n   可选参数 pos 是开始搜索的位置：\n   \n   console.log(\"midget\".includes(\"id\")); // true\n   console.log(\"midget\".includes(\"id\", 3)); // false\n   \n   \n   1\n   2\n   \n   \n   str.startswith(str) / str.endswith(str) 分别是从字符串的开头或者结尾开始搜索：\n   \n   console.log( \"widget\".startswith(\"wid\") ); // true \n   console.log( \"widget\".endswith(\"get\") ); // false\n   \n   \n   1\n   2\n   \n\n# 获取子字符串\n\njavascript 中有三种获取字符串的方法： substring 、 substr 和 slice 。\n\n * str.slice(start [, end]) （ end 是可选参数）：返回字符串从 start 到 end 的位置： 【注意不包括 end 处的字符】\n   \n   let str = \"stringify\";\n   console.log(str.slice(0, 5)) // 'strin'\n   console.log(str.slice(0, 1)) // 's'\n   \n   \n   1\n   2\n   3\n   \n   \n   如果没有 end 参数，则一直从 start 位置运行到字符串末尾：\n   \n   let str = \"stringify\";\n   console.log(str.slice(2)); // 'ringify'\n   \n   \n   1\n   2\n   \n   \n   start / end 可以为负数，从字符串结尾计算：\n   \n   let str = \"stringify\";\n   console.log(str.slice(-4, -1)) // 'gif'\n   \n   \n   1\n   2\n   \n\n * str.substring() 允许 start 大于 end （但是不支持负数的参数），其他几乎与 slice 相同：\n   \n   let str = \"stringify\";\n   console.log( str.substring(2, 6) ); // \"ring\"\n   console.log( str.substring(6, 2) ); // \"ring\"\n   \n   \n   1\n   2\n   3\n   \n\n * str.substr(start [, length]) 从 start 开始取 length 长度的字符串：\n   \n   let str = \"stringify\";\n   console.log( str.substr(2, 4) );\n   \n   \n   1\n   2\n   \n   \n   start 可以为负值， 从字符串结尾计算：\n   \n   let str = \"stringify\";\n   console.log( str.substr(-4, 2) ); // 'gi'\n   \n   \n   1\n   2\n   \n\n> 总结：\n> \n> 方法                      选择方式……                                负值参数\n> slice(start, end)       从 start 到 end （不含 end ）               允许\n> substring(start, end)   start 与 end 之间（包括 start ，但不包括 end ）   不允许负值\n> substr(start, length)   从 start 开始获取长为 length 的字符串            允许 start 为负数\n\n提示\n\n相较于其他两个变体， slice 稍微灵活一些，它允许以负值作为参数并且写法更简短。\n\n\n# 字符串的比较\n\njavascript 中，字符串按字母顺序逐字比较。比较顺序按照个字符都有对应的数字代码（ utf-16 编码）。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。\n\n * str.codepointat(pos) ：返回 pos 位置的字符代码：\n   \n   console.log(\"z\".codepointat(0)) // 122\n   console.log(\"z\".codepointat(0)) // 90\n   \n   \n   1\n   2\n   \n\n * string.fromcodepoint(code) ：通过字符代码创建字符：\n   \n   console.log(string.fromcodepoint(90)) // 'z'、\n   \n   \n   1\n   \n\n * 使用十六进制代码（二进制的字符代码转换为十六进制），添加 unicode 字符串：\n   \n   console.log('\\u005a') // 'z' (90 -> 5a)\n   \n   \n   1\n   \n\n> 遍历输出代码为 65..220 的字符：\n> \n> let str = '';\n> \n> for (let i = 65; i <= 220; i++) {\n>   str += string.fromcodepoint(i);\n> }\n> console.log( str );\n> // abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n> // ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿aaaaaaæceeeeiiiiðnooooo×øuuuu\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 大写字母一般顺序在小写字母之后。\n\n通过字符代码比较字符串的顺序，越大的代码意味着字符越大。\n\n * 所有小写字母追随在大写字母之后，因为它们的代码更大。\n * 一些像 o 的字母与主要字母表不同。这里，它的代码比任何从 a 到 z 的代码都要大。\n\n利用 str.localecompare(str2) 完成「符合语言正确」的字符串比较。会根据语言规则返回一个整数，这个整数能指示字符串 str 在排序顺序中排在字符串 str2 前面、后面、还是相同：\n\n * 如果 str 排在 str2 前面，则返回负数。\n * 如果 str 排在 str2 后面，则返回正数。\n * 如果它们在相同位置，则返回 0 。\n\n> 根据不同的语言的字母都不相同。\n\n\n# 字符串总结\n\n * 定义字符串有三种方式。\n   \n   * 使用反引号允许跨越多行，并且可以插入表达式。\n\n * javascript 中的字符串使用的是 utf-16 编码。\n\n * 介绍了许多处理字符串的方法：\n   \n   * 获取字符时，使用 [] 。\n   * 获取字符串的长度，使用 str.length\n   * 获取子字符串，使用 slice() 。\n   * 字符串的大 / 小写转换，使用： tolowercase() / touppercase() 。\n   * 查找子字符串时，使用 indexof 或 includes/startswith/endswith 进行简单检查。\n   * 比较字符串一般按照字符代码比较。\n\n更多的字符串方法：手册",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔃 JavaScript 数组",frontmatter:{title:"🔃 JavaScript 数组",date:"2022-05-05T17:40:32.000Z",permalink:"/pages/e6c21b/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/24.%20%F0%9F%94%83%20JavaScript%20%E6%95%B0%E7%BB%84.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/24. 🔃 JavaScript 数组.md",key:"v-1c37d794",path:"/pages/e6c21b/",headers:[{level:2,title:"数组的声明 / 访问",slug:"数组的声明-访问",normalizedTitle:"数组的声明 / 访问",charIndex:46},{level:3,title:"数组的基本操作",slug:"数组的基本操作",normalizedTitle:"数组的基本操作",charIndex:1157},{level:4,title:"作用于 数组末端 的方法",slug:"作用于-数组末端-的方法",normalizedTitle:"作用于 数组末端 的方法",charIndex:1713},{level:4,title:"作用于 数组首端 的方法",slug:"作用于-数组首端-的方法",normalizedTitle:"作用于 数组首端 的方法",charIndex:1837},{level:3,title:"理解数组的内部",slug:"理解数组的内部",normalizedTitle:"理解数组的内部",charIndex:2502},{level:4,title:"数组的复制",slug:"数组的复制",normalizedTitle:"数组的复制",charIndex:2704},{level:2,title:"数组的性能",slug:"数组的性能",normalizedTitle:"数组的性能",charIndex:3262},{level:2,title:"数组的循环",slug:"数组的循环",normalizedTitle:"数组的循环",charIndex:3474},{level:2,title:"数组的长度 length",slug:"数组的长度-length",normalizedTitle:"数组的长度 length",charIndex:4158},{level:2,title:"多维数组",slug:"多维数组",normalizedTitle:"多维数组",charIndex:4645},{level:2,title:"数组的 toString()",slug:"数组的-tostring",normalizedTitle:"数组的 tostring ()",charIndex:null},{level:2,title:"数组的比较",slug:"数组的比较",normalizedTitle:"数组的比较",charIndex:5214},{level:2,title:"数组的更多方法",slug:"数组的更多方法",normalizedTitle:"数组的更多方法",charIndex:5622},{level:3,title:"添加 / 移除数组元素",slug:"添加-移除数组元素",normalizedTitle:"添加 / 移除数组元素",charIndex:5634},{level:4,title:"🍎 splice",slug:"splice",normalizedTitle:"🍎 splice",charIndex:5649},{level:4,title:"slice",slug:"slice",normalizedTitle:"slice",charIndex:6741},{level:4,title:"concat",slug:"concat",normalizedTitle:"concat",charIndex:7136},{level:4,title:"forEach 遍历",slug:"foreach-遍历",normalizedTitle:"foreach 遍历",charIndex:8135},{level:3,title:"搜索数组",slug:"搜索数组",normalizedTitle:"搜索数组",charIndex:8516},{level:4,title:"indexOf / lastIndexOf 和 includes",slug:"indexof-lastindexof-和-includes",normalizedTitle:"indexof /lastindexof 和 includes",charIndex:null},{level:4,title:"find / findIndex",slug:"find-findindex",normalizedTitle:"find / findindex",charIndex:9174},{level:4,title:"🍎 filter",slug:"filter",normalizedTitle:"🍎 filter",charIndex:9685},{level:3,title:"转换数组",slug:"转换数组",normalizedTitle:"转换数组",charIndex:10176},{level:4,title:"🍎 map",slug:"map",normalizedTitle:"🍎 map",charIndex:10184},{level:3,title:"数组排序",slug:"数组排序",normalizedTitle:"数组排序",charIndex:10451},{level:4,title:"🍎 sort(fn)",slug:"sort-fn",normalizedTitle:"🍎 sort(fn)",charIndex:10459},{level:4,title:"reverse()",slug:"reverse",normalizedTitle:"reverse()",charIndex:11168},{level:3,title:"🍎 数组拆分/组合 split / join",slug:"数组拆分-组合-split-join",normalizedTitle:"🍎 数组拆分 / 组合 split /join",charIndex:null},{level:3,title:"🍎 reduce / reduceRight",slug:"reduce-reduceright",normalizedTitle:"🍎 reduce / reduceright",charIndex:12077},{level:3,title:"Array.isArray()",slug:"array-isarray",normalizedTitle:"array.isarray()",charIndex:12776},{level:3,title:"thisArg 参数",slug:"thisarg-参数",normalizedTitle:"thisarg 参数",charIndex:13014},{level:2,title:"数组总结",slug:"数组总结",normalizedTitle:"数组总结",charIndex:13817}],headersStr:"数组的声明 / 访问 数组的基本操作 作用于 数组末端 的方法 作用于 数组首端 的方法 理解数组的内部 数组的复制 数组的性能 数组的循环 数组的长度 length 多维数组 数组的 toString() 数组的比较 数组的更多方法 添加 / 移除数组元素 🍎 splice slice concat forEach 遍历 搜索数组 indexOf / lastIndexOf 和 includes find / findIndex 🍎 filter 转换数组 🍎 map 数组排序 🍎 sort(fn) reverse() 🍎 数组拆分/组合 split / join 🍎 reduce / reduceRight Array.isArray() thisArg 参数 数组总结",content:'JavaScript 的数组元素都是按顺序排列，对比 对象 ，数组是 有序集合 。\n\n\n# 数组的声明 / 访问\n\n * 创建空数组的两种方法：\n   \n   let arr = new Array();\n   let arr = [];\n   \n   \n   1\n   2\n   \n\n🌰 例子 / 一般常用第二种语法声明数组：\n\nlet fruits = ["Apple", "Orange", "Plum"];\n\n\n1\n\n\n🌰 例子 / 使用 new 方法创建数组可能存在问题：\n\n点击查看\n\n对于普通的字符串创建数组，可以直接作为 new Array() 的参数：\n\nlet arr = new Array("Apple", "Pear", "etc");\n\n\n1\n\n\n但是当参数为数字时，此时数字意味着指定数组的长度，创建空数组，而不是创建带有该参数的数组。注意区分！\n\nlet arr = new Array(2);\nconsole.log(arr.length) // 2\n\n\n1\n2\n\n\n * 获取数组中的元素：使用方括号加索引值 [] （数组元素从 0 索引）\n   \n   console.log(fruits[0]) // \'Apple\'\n   \n   \n   1\n   \n\n * 替换数组中的元素：直接访问数组元素，赋上新的值（区别于字符串，字符串不能这样操作）\n   \n   fruits[2] = \'Pear\'; // after: fruits = ["Apple", "Pear", "Plum"];\n   \n   \n   1\n   \n\n * 获取数组的长度：（与字符串相同，自带属性 length ）：\n   \n   console.log(fruits.length) // 3\n   \n   \n   1\n   \n\n * 直接打印数组的内容：（与对象区分，对象需要重写 toString 方法才能打印内容，下文有关于数组的 toString 方法详细介绍）\n   \n   console.log(fruits) // Apple,Orange,Plum\n   \n   \n   1\n   \n\n * 数组可以存储任何类型的元素：（单一类型或者混合类型都可以，甚至是对象、函数类型）\n   \n   let arr = [ \'Apple\', { name: \'John\' }, true, function() { alert(\'hello\'); } ];\n   \n   console.log((arr[1].name)) // 获取数组中对象的属性的值\n   arr[3](); // 执行数组中元素的函数\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# 数组的基本操作\n\n> 如果想要获取数组的 最后一个元素 。不可以 fruits[-1] ，因为在 JavaScript 中方括号的索引是按照其字面意思处理的，结果为 undefined ，只可以 fruits[fruits.length - 1] 通过获取数组长度显示计算索引。\n\n * ⭐️ 使用 at() 获取数组元素（最近版本更新） 可以直接使用 -1 ：\n   \n   console.log(fruits.at(-1)) // \'Plum\'\n   \n   \n   1\n   \n   \n   > 对于 at() ：\n   > \n   >  * i >= 0 ，则与 arr[i] 完全相同。\n   >  * i 为负数的情况，它则从数组的尾部向前数。\n\n> JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端 / 末端来添加 / 删除元素。（可以看作数组为双向队列）\n\n队列使用数组的两个方法：\n\n * shift() 在数组首端取出一个元素（出队）。\n * push() 在数组首端添加一个元素（入队）。\n\n栈使用数组的两个方法：\n\n * push() 在数组末端添加一个元素（进栈）。\n * pop() 在数组末端移除一个元素（推栈）。\n\n进一步深入了解数组的方法：\n\n# 作用于 数组末端 的方法\n\n * pop() ：取出并返回数组的最后一个元素。（影响原数组）\n * push(...) ：在数组末端添加元素。（无返回值，参数为要添加的元素）（相当于 arr[arr.length + 1 ] = ... ）\n\n# 作用于 数组首端 的方法\n\n * shift() ：取出并返回数组的第一个元素。\n * unshift() ：在数组首端添加元素。\n\n🌰 例子 / 使用 push() / unshift() 一次添加多个元素：\n\nlet fruits = ["Apple"];\n\nfruits.push("Orange", "Peach");\nfruits.unshift("Pineapple", "Lemon");\n\nconsole.log(fruits) // ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 接收用户输入的数（判断）求和：\n\n点击查看\n\nfunction sum() {\n  let sum = 0;\n  let arr = [];\n  \n  while(true) {\n    let value = prompt(\'input number\', 0)\n    if(value === \'\' || value === null || isFinite(value)) break;\n\t\tvalue = +value // 处理为数字类型\n    arr.push(value)\n  }\n  \n  for(value of arr) {\n    sum += value\n  }\n  \n  return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 理解数组的内部\n\n数组是一种特殊的对象。使用方括号来访问属性 arr[0] 实际上是来自于对象的语法。它其实与 obj[key] 相同，其中 arr 是对象，而数字用作键（key）。\n\n数组扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象。\n\n> JavaScript 只有 8 种基本的数据类型。其中数组仍属于对象类型。行为也与对象相似。\n\n# 数组的复制\n\n与对象的引用复制相同原理。\n\n🌰 例子：\n\nlet fruits = ["Banana"]\nlet arr = fruits; // 实际上，两个数组引用同一个数组\nconsole.log(arr === fruits) // true\n\narr.push("Pear");\nconsole.log(fruits) // Banana, Pear \n\n\n1\n2\n3\n4\n5\n6\n\n\n数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在 连续的内存区域，还有一些其它的优化，以使数组运行得非常快。\n\n但如果破坏数组的连续性去使用数组，例如直接访问远超出初始索引的值，或者给数组对象添加属性，针对数组的优化就不再适用了，然后对应的优化就会被关闭，数组不将存在优势。\n\n>  * 添加一个非数字的属性，比如 arr.test = 5 。\n>  * 制造空洞，比如：添加 arr[0] ，然后添加 arr[1000] (它们中间什么都没有)。\n>  * 以倒序填充数组，比如 arr[1000] ， arr[999] 等等。\n\n注意\n\n所以数组最好作用于 有序数据 的特殊结构，以正确的方式使用数组，才能发挥数组最大的优势。如果需要任意键值，那使用常规的对象。\n\n\n# 数组的性能\n\n可以从数据结构的「时间复杂度」思考：（ push/pop 方法运行的比较快，而 shift/unshift 比较慢）\n\n * 从首端操作，要从首端开始向后（或从后端向前端）推移元素， 数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作 。\n * 而从数组的末端操作，意味着 不需要移动任何元素 。 因为其它元素都保留了各自的索引。这就是为什么 pop / push 的操作会特别快。\n\n\n# 数组的循环\n\n * 经典方式 / 使用 for 的 完整形式 循环：\n   \n   let arr = ["Apple", "Orange", "Pear"];\n   \n   for (let i = 0; i < arr.length; i++) {\n     console.log(arr[i]);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 使用 for…of 循环：\n   \n   for (let fruit of fruits) {\n     console.log( fruit );\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   > 注意： for..of 不能获取当前元素的索引，只是获取元素值。\n\n * 根据对象特性使用 for…in ：\n   \n   for (let key in arr) {\n     alert( arr[key] ); // Apple, Orange, Pear\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   > 使用 for…in 会带来潜在的问题：\n   > \n   >  * for..in 循环会遍历 所有属性，不仅仅是这些数字属性。对于浏览器和其它环境中的「类数组」对象，会有其它的非数字的属性和方法。这些额外的循环是不必要的。\n   >  * for..in 循环适用于普通对象，并且做了对应的优化，但是不适用于数组。\n   > \n   > 所以不应该使用 for…in 处理数组。\n\n\n# 数组的长度 length\n\n当修改数组的时候， length 属性会自动更新。实际上 length 不是数组里元素的个数，而是最大的数字索引值加一。\n\n🌰 例子 / 一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 length 也会很大：\n\nlet fruits = [];\nfruits[123] = "Apple";\n\nconsole.log( fruits.length ); \n\n\n1\n2\n3\n4\n\n\n> 但是通常都不会这样使用数组。\n\n🌰 例子 / 手动修改 length ：\n\nlet arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // 截断到只剩 2 个元素\nalert( arr ); // [1, 2]\n\narr.length = 5; // 又把 length 加回来\nalert( arr[3] ); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 可以看到，这个修改的过程是不可逆的。\n\n利用 length ，清空数组的最简单的方法是 arr.length = 0 。\n\n\n# 多维数组\n\n数组里的项也可以是数组。可以用来创建 矩阵：\n\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nconsole.log( matrix[1][1] ); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数组的 toString()\n\n数组自己的 toString 方法的实现，会返回 以逗号隔开的元素列表字符串。\n\n🌰 例子 / 打印数组：\n\nlet arr = [1, 2, 3];\n\nconsole.log( arr ); // 1,2,3\nconsole.log( String(arr) === \'1,2,3\' ); \n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 数组的打印结果拼接字符串：\n\nconsole.log( [] + 1 ); // "1"\nconsole.log( [1] + 1 ); // "11"\nconsole.log( [1,2] + 1 ); // "1,21"\n\n\n1\n2\n3\n\n\n> 对于数组，没有 Symbol.toPrimitive ，也没有 valueOf ，它们只能执行 toString 进行转换，所以这里 [] 就变成了一个空字符串， [1] 变成了 "1" ， [1,2] 变成了 "1,2" 。\n\n\n# 数组的比较\n\nJavaScript 中的数组 不能使用 == 运算符比较，该运算符不会对数组进行特殊处理，它会像 处理任意对象 那样处理数组。\n\n> 在对象中：\n> \n>  * 仅当两个对象引用的是同一个对象时，它们才相等 == 。\n>  * 如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型。\n>  * 严格比较 === 更简单，不会进行类型转换。\n\n使用 == 比较数组，除非引用的是同一个数组对象，否则尽管数组的内容相同（实质上仍然不是同一个对象），比较结果永远都不会相等。\n\n> console.log([] == [])\n> \n> // 与原始对象比较\n> alert( 0 == [] ); // true []被转换为空字符串\'\'\n> alert(\'0\' == [] ); // false\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 数组的更多方法\n\n\n# 添加 / 移除数组元素\n\n# 🍎 splice\n\narr.splice 方法可以说是处理数组的瑞士军刀，它可以做所有事情：添加，删除和插入元素。语法如下：\n\narr.splice(start[, deleteCount, elem1, ..., elemN])\n\n\n1\n\n\n它从索引 start 开始修改 arr ：删除 deleteCount 个元素并在当前位置插入 elem1, ..., elemN 。最后 返回已被删除元素的数组。\n\n🌰 例子 / 删除数组元素：\n\nlet arr = ["I", "study", "JavaScript"];\narr.splice(1, 1); // 从索引 1 开始删除 1 个元素\nconsole.log(arr) // ["I", "JavaScript"]\n\n\n1\n2\n3\n\n\n> 当参数只有 start ，从 start 索引开始删除所有的数组元素。\n\n🌰 例子 / 删除数组元素并替换：\n\nlet arr = ["I", "study", "JavaScript", "right", "now"];\n// 删除数组的前三项，并使用其他内容代替它们\nlet removed = arr.splice(0, 3, "Let\'s", "dance");\nconsole.log(arr) // ["Let\'s", "dance", "right", "now"]\nconsole.log(removed) // ["I", "study"] \n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 在指定位置新增元素：\n\nlet arr = ["I", "study", "JavaScript"];\n\n// 从索引 2 开始\n// 删除 0 个元素\n// 然后插入 "complex" 和 "language"\narr.splice(2, 0, "complex", "language"); \nconsole.log(arr) // ["I", "study", "complex", "language", "JavaScript"]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n区别于方括号访问，数组的方法中可以使用「负向索引」，即索引值可以为负数，从数组末尾计算位置。\n\nlet arr = [1, 2, 5];\n\n// 从索引 -1（尾端前一位）\n// 删除 0 个元素，\n// 然后插入 3 和 4\narr.splice(-1, 0, 3, 4);\nconsole.log(arr); // 1,2,3,4,5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# slice\n\n用于切割数组，将所有从索引 start 到 end （ ⚠️ 不包括 end ）的数组项复制到一个新的数组，返回这个新的数组。\n\narr.slice([start], [end])\n\n\n1\n\n\n> 与字符串的 str.slice 相似。\n\n🌰 例子：\n\nlet arr = ["t", "e", "s", "t"];\nconsole.log(arr.slice(1, 3)) // \'e\' \'s\'\n\n\n1\n2\n\n\n🌰 例子 / 不含参数的 slice() 获取原数组的副本，在此副本进行的操作不会影响原来的数组：\n\nconsole.log(arr.slice) // [\'t\', \'e\', \'s\', \'t\']\n\n\n1\n\n\n🌰 例子 / 从末尾开始索引（即使是末尾索引但不代表反过来切割）：\n\nconsole.log(arr.slice(-2)) s,t\n\n\n1\n\n\n# concat\n\n拼接数组，用于创建一个新的数组，包含来自其他数组和其他项的值。可以接受 任意参数 （数组或者值）。结果是包含来自于 arr 、 arg1 、 arg2 等元素的新数组。如果参数 argN 是一个数组，那么其中的 所有元素 都会被复制。如果不是数组，将复制 参数本身（例如对象，即便其中有类似数组的结构，仍然会作为一个整体添加）。\n\narr.concat(arg1, arg2...)\n\n\n1\n\n\n🌰 例子 ：\n\nlet arr = [1, 2];\n\n// create an array from: arr and [3,4]\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n\n// create an array from: arr and [3,4] and [5,6]\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n\n// create an array from: arr and [3,4], then add values 5 and 6\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子：复制其他对象：\n\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: "something",\n  length: 1\n};\n\nconsole.log(arr.concat(arrayLike)) // 1,2,[object Object]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子：如果类似数组的对象具有 Symbol.isConcatSpreadable 的属性，则可以被 concat 当作一个数组处理：\n\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: "something",\n  1: "else",\n  [Symbol.isConcatSpreadable]: true,\n  length: 2\n};\n\nconsole.log(arr.concat(arrayLike)); // 1,2,something,else \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# forEach 遍历\n\n使用 arr.forEach() 允许为数组的 每一个元素 都运行一个函数：\n\narr.forEach(function(item, index, array) {\n  // ... do something with item\n});\n\n\n1\n2\n3\n\n\n🌰 例子 / 对每一个元素都运行 alert() ：\n\n["Bilbo", "Gandalf", "Nazgul"].forEach(alert);\n\n\n1\n\n\n🌰 例子 / 打印详细信息：\n\n["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {\n  console.log(`${item} is at index ${index} in ${array}`);\n});\n\n\n1\n2\n3\n\n\n\n# 搜索数组\n\n# indexOf / lastIndexOf 和 includes\n\n与字符串的用法基本相同：\n\n * arr.indexOf(item, from) ： 从索引 from 开始搜索 item ，如果找到则 返回索引 ，否则返回 -1 。\n * arr.lastIndexOf(item, from) ：逆序搜索。找到 返回索引，否则返回 -1 。\n * arr.includes(item, from) ：从索引 from 开始搜索 item ，如果找到则返回 true ，否则返回 false 。\n\n🌰 例子 ：\n\nlet arr = [1, 0, false];\nconsole.log(arr.indexOf(0)) // 1\nconsole.log(arr.lsatIndexOf(false)) // 0 \nconsole.log(arr.includes(0)) // true\n\n\n1\n2\n3\n4\n\n\n⚠️ 注意：这些方法使用的是 严格相等 === 比较。所以如果搜索 false ，会精确到的确是 false 而不是数字 0 。\n\n🌰 例子： includes 它能正确处理 NaN ，不像 indexOf/lastIndexOf ：\n\nconst arr = [NaN];\nalert( arr.indexOf(NaN) ); // -1（应该为 0，但是严格相等对 NaN 无效）\nalert( arr.includes(NaN) );// true\n\n\n1\n2\n3\n\n\n# find / findIndex\n\n在对象数组中要找到特定的对象使用 find ，依次对数组中的 每个元素 调用该函数：\n\nlet result = arr.find(function(item, index, array) {\n  // item 元素，index 索引, array 数组本身\n  // 如果返回 true，则返回 item 并停止迭代\n  // 没有搜索到，则返回 undefined\n});\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 ：\n\nlet users = [\n  {id: 1, name: "John"},\n  {id: 2, name: "Pete"},\n  {id: 3, name: "Mary"}\n];\n\nlet result = users.find(item => item.id == 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 最常用的用法就是使用 item 去筛选条件，返回筛选后的结果（ index 和 array 不常用）。\n\nfindIndex 与 find 方法基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1 。\n\n# 🍎 filter\n\nfind 方法只会找到使函数返回 true 的 第一个（单个）元素。如果需要匹配的元素有很多，可以使用 filter 方法，语法与 find 方法大致相同， filter 返回的是 所有匹配元素组成的数组 。\n\nlet results = arr.filter(function(item, index, array) {\n  // 如果为 true , item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n\n\n1\n2\n3\n4\n\n\n🌰 例子 ：\n\nlet users = [\n  {id: 1, name: "John"},\n  {id: 2, name: "Pete"},\n  {id: 3, name: "Mary"}\n];\n\nlet res = users.filter((item) => item.id < 2)\nconsole.log(res) // [{id: 1, name: "John"}, {id: 2, name: "Pete"},]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 转换数组\n\n# 🍎 map\n\n是最常使用、最有用的数组方法。对数组的每个元素都调用函数，并返回结果数组。\n\nlet result = arr.map(function(item, index, array) {\n  // 返回新值而不是当前元素\n})\n\n\n1\n2\n3\n\n\n🌰 例子 / 将每个元素转换为它的字符串长度：\n\nlet lengths = ["Bilbo", "Gandalf", "Nazgul"].map((item)=> item.length)\nconsole.log(lengths) // 5,7,6\n\n\n1\n2\n\n\n\n# 数组排序\n\n# 🍎 sort(fn)\n\n该方法对数组进行 原位（in-place） 排序，更改元素的顺序。\n\n> 原位：在此数组排序，并非生成新的数组。\n\n🌰 例子：\n\nlet arr = [15, 1, 2]\narr.sort() \nconsole.log(arr) // 1, 15, 2\n\n\n1\n2\n3\n\n\n> 注意：以上排序结果并非按照数字大小顺序排序，这些元素默认情况下被按字符串进行排序。 所有元素都被转换为字符串，然后进行比较。\n\n如果要想要按照定义的排序顺序，需要提供一个函数作为 arr.sort() 的参数。该函数应该比较两个任意值并返回：\n\nfunction compare(a, b){\n  if(a > b) return 1;\n  if(a == b) return 0;\n  if(a < b) return -1;\n}\n\nlet arr = [1, 2, 15]\narr.sort(compare)\nconsole.log(arr) // 1, 2, 15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 由于数组可以由任何内容组成的数组，可能包含数字、字符串、对象或其他任何内容。要对这些不同类型的元素排序，需要一个 排序函数 来确认如何比较这些元素。数组默认是按字符串进行排序的。\n> \n> arr.sort(fn) 遍历数组，使用提供的函数比较其元素并对其重新排序。比较函数只需要返回一个正数表示「大于」，一个负数表示「小于」。\n\n🌰 例子 / 常用比较大小函数（从小到大）（简化为 箭头函数 版本）：\n\n[5,4,3,2,1].sort((a, b) => a - b)\n\n\n1\n\n\n# reverse()\n\n用于 颠倒 数组中的顺序（原位修改）。\n\n🌰 例子 ：\n\nlet arr = [1, 2, 3, 4, 5]\narr.reverse();\nconsole.log(arr) // 5,4,3,2,1\n\n// let res = arr.reverse()\n// console.log(res) // 返回值也可以接收结果\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 🍎 数组拆分 / 组合 split / join\n\nstr.split(delim) 方法用于 字符串 上，通过给定的分隔符 delim 将字符串分割成一个数组。（字符串分割为数组）\n\n🌰 例子 ：\n\nlet names = \'Bilbo, Gandalf, Nazgul\';\nlet arr = names.split(\', \');\nfor (let name of arr) {\n  console.log(name)\n}\n\n\n1\n2\n3\n4\n5\n\n\nsplit() 的第二个可以选择的参数，是对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用。\n\n🌰 例子：\n\nlet arr = \'Bilbo, Gandalf, Nazgul, Saruman\'.split(\', \', 2);\nconsole.log(arr); // Bilbo, Gandalf\n\n\n1\n2\n\n\n🌰 例子 / 第一个参数为空字符串，将字符串拆分为字母数组：\n\nlet str = "test";\nconsole.log(str.split(\'\')); // t,e,s,t\n\n\n1\n2\n\n\narr.join(glue) 与 split 相反，它会在它们之间创建一串由 glue 粘合的 arr 项。（数组粘合为字符串）\n\n🌰 例子：\n\nlet arr = [\'Bilbo\', \'Gandalf\', \'Nazgul\'];\nlet str = arr.join(\';\'); // 使用分号 ; 将数组粘合成字符串\nconsole.log(str); // Bilbo;Gandalf;Nazgul\n\n\n1\n2\n3\n\n\n\n# 🍎 reduce / reduceRight\n\n这个函数一个接一个地应用于所有数组元素，并将其结果「搬运」到下一个调用。语法如下：\n\nlet value = arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);\n\n\n1\n2\n3\n\n\n> 参数：\n> \n>  * accumulator ：（累加器）是上一个函数调用的结果，第一次等于 initial （如果提供了 initial 的话）。\n>  * item ：当前的数组元素。\n>  * index ：当前索引。\n>  * arr ：数组本身。\n\n🌰 例子 / 通过 reduce 计算数组元素总和：\n\nlet arr = [1, 2, 3, 4, 5]\nlet res = arr.reduce((sum, cur) => sum + cur, 0)\nconsole.log(res) // 15\n\n\n1\n2\n3\n\n\n> sum 是累加器， cur 是当前的元素， 0 是累加器的初始值。通常只需要这两个参数即可。\n\n也可以省略初始值，数组的第一个元素作为初始值，第二个元素开始迭代，得出的结果相同：\n\nlet res = arr.reduce((sum, cur) => sum + cur)\n\n\n1\n\n\n> 注意省略初始值使用的情况不能为数组为空时，当数组为空时，第一个累加器返回的就是空值导致出错。所以始终建议指定初始值。\n\narr.reduceRight 和 arr.reduce 方法的功能一样，只是遍历为 从右到左。\n\n\n# Array.isArray()\n\n由于数组是基于对象的，不构成单独的语言类型，所以 typeof 不能帮助 从数组中区分出普通对象。Array.isArray(value) 用于检验一个对象是否为数组，如果 value 是一个数组，则返回 true ；否则返回 false 。\n\n🌰 例子：\n\nconsole.log(Array.isArray({})) // false\nconsole.log(Array.isArray([])) // true\n\n\n1\n2\n\n\n\n# thisArg 参数\n\n几乎所有 调用函数的数组方法 ， 比如 find ， filter ， map ，除了 sort 是一个 特例，都接受一个 可选的附加参数 thisArg 。由于较少使用所以涉及以上数组方法并没有介绍。\n\n完整的用法：\n\narr.find(func, thisArg);\narr.filter(func, thisArg);\narr.map(func, thisArg);\n// ... \n\n\n1\n2\n3\n4\n\n\nthisArg 最后可选参数的值在 func 中变为 this 。\n\n🌰 例子 / 使用 army 对象方法作为 过滤器， thisArg 用于传递上下文：\n\nlet army = {\n  minAge: 18,\n  maxAge: 27,\n  canJoin(user) {\n    return user.age >= this.minAge && user.age < this.maxAge;\n  }\n};\n\nlet users = [\n  {age: 16},\n  {age: 20},\n  {age: 23},\n  {age: 30}\n];\n\n// *找到 army.canJoin 返回 true 的 user\nlet soldiers = users.filter(army.canJoin, army)\nalert(soldiers.length); // 2\nalert(soldiers[0].age); // 20\nalert(soldiers[1].age); // 23\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 实际中，为了可读性，可以写成：\n> \n> users.filter(user => army.canJoin(user))\n> \n> \n> 1\n\n\n# 数组总结\n\n关于数组的方法备忘录：\n\n * 添加 / 移除元素相关：\n   \n   * 🍎 push(...items) ：向 尾端 添加元素。\n   \n   * 🍎 pop() ：从 尾端 提取一个元素。\n   \n   * 🍎 shift() ：从 首端 提取一个元素。\n   \n   * 🍎 unshift(...items) ：向 首端 添加元素。\n   \n   * 🍎 splice(pos, deleteCount, ...items) ： 从 pos 开始删除 deleteCount 个元素，并插入 items 。\n   \n   * 🍎 slice(start, end) ：创建一个新数组，将从索引 start 到索引 end （但不包括 end ）的元素 复制 进去。\n   \n   * concat(...items) ：返回一个新数组：复制 当前数组的所有元素，并向其中添加 items 。如果 items 中的任意一项是一个数组，那么就取其元素。（其他对象则为对象本身）\n\n * 查找元素相关：\n   \n   * indexOf / lastIndexOf(item, pos) ：从索引 pos 开始搜索 item ，搜索到则返回该项的 索引值，否则返回 -1 。\n   * includes(value) ：如果数组有 value ，则返回 true ，否则返回 false 。\n   * 🍎 find(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 第一个值。\n   * 🍎 filter(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 所有值。\n   * findIndex 和 find 类似，但返回 索引 而不是值。\n\n * 遍历元素相关：\n   \n   * 🍎 forEach(func) —— 对每个元素都调用 func ，不返回任何内容\n\n * 转换数组相关：\n   \n   * 🍎 map(func) ： 根据对每个元素调用 func 的结果创建一个新数组。\n   * 🍎 sort(func) ： 对数组进行 原位排序，然后返回排序后的数组。\n   * reverse() ： 原位反转 数组，然后返回反转后的数组。\n   * 🍎 split/join ：将字符串 转换为数组 并返回。\n   * 🍎 reduce / reduceRight(func, initial) ：通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。（常见用法累加）\n\n * 其他：\n   \n   * Array.isArray(arr) ：检查 arr 是否是一个数组。\n\n补充数组方法：\n\n * 🍎 arr.some(fn) / arr.every(fn) 检查数组。对数组的每个元素调用函数 fn ：\n   * 有一 true 所有就返回 true ：如果 fn 返回一个真值， arr.some() 立即返回 true 并停止迭代其余数组项；\n   * 所有 true 才返回 true ：如果 fn 返回一个假值， arr.every() 立即返回 false 并停止对其余数组项的迭代。\n\n🌰 例子 / 使用 every() 检验数组是否全等：\n\nfunction compareArray(arr1, arr2){\n  return arr1.length && arr2.length && arr1.every((value, index) => value === arr2[index])\n}\n\ncompareArray([1,2], [1,2]) // true\n\n\n1\n2\n3\n4\n5\n\n * arr.fill(value, start, end) ：从索引 start 到 end ，用重复的 value 填充数组。\n * arr.copyWithin(target, start, end) ：将从位置 start 到 end 的所有元素复制到 自身 的 target 位置（覆盖现有元素）。\n * arr.flat(depth) / arr.flatMap(fn) ： 从多维数组创建一个新的扁平数组。\n * Array.of(element0[, element1[, …[, elementN]]]) ： 基于 可变数量的参数 创建一个新的 Array 实例，而不需要考虑参数的数量或类型。',normalizedContent:'javascript 的数组元素都是按顺序排列，对比 对象 ，数组是 有序集合 。\n\n\n# 数组的声明 / 访问\n\n * 创建空数组的两种方法：\n   \n   let arr = new array();\n   let arr = [];\n   \n   \n   1\n   2\n   \n\n🌰 例子 / 一般常用第二种语法声明数组：\n\nlet fruits = ["apple", "orange", "plum"];\n\n\n1\n\n\n🌰 例子 / 使用 new 方法创建数组可能存在问题：\n\n点击查看\n\n对于普通的字符串创建数组，可以直接作为 new array() 的参数：\n\nlet arr = new array("apple", "pear", "etc");\n\n\n1\n\n\n但是当参数为数字时，此时数字意味着指定数组的长度，创建空数组，而不是创建带有该参数的数组。注意区分！\n\nlet arr = new array(2);\nconsole.log(arr.length) // 2\n\n\n1\n2\n\n\n * 获取数组中的元素：使用方括号加索引值 [] （数组元素从 0 索引）\n   \n   console.log(fruits[0]) // \'apple\'\n   \n   \n   1\n   \n\n * 替换数组中的元素：直接访问数组元素，赋上新的值（区别于字符串，字符串不能这样操作）\n   \n   fruits[2] = \'pear\'; // after: fruits = ["apple", "pear", "plum"];\n   \n   \n   1\n   \n\n * 获取数组的长度：（与字符串相同，自带属性 length ）：\n   \n   console.log(fruits.length) // 3\n   \n   \n   1\n   \n\n * 直接打印数组的内容：（与对象区分，对象需要重写 tostring 方法才能打印内容，下文有关于数组的 tostring 方法详细介绍）\n   \n   console.log(fruits) // apple,orange,plum\n   \n   \n   1\n   \n\n * 数组可以存储任何类型的元素：（单一类型或者混合类型都可以，甚至是对象、函数类型）\n   \n   let arr = [ \'apple\', { name: \'john\' }, true, function() { alert(\'hello\'); } ];\n   \n   console.log((arr[1].name)) // 获取数组中对象的属性的值\n   arr[3](); // 执行数组中元素的函数\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# 数组的基本操作\n\n> 如果想要获取数组的 最后一个元素 。不可以 fruits[-1] ，因为在 javascript 中方括号的索引是按照其字面意思处理的，结果为 undefined ，只可以 fruits[fruits.length - 1] 通过获取数组长度显示计算索引。\n\n * ⭐️ 使用 at() 获取数组元素（最近版本更新） 可以直接使用 -1 ：\n   \n   console.log(fruits.at(-1)) // \'plum\'\n   \n   \n   1\n   \n   \n   > 对于 at() ：\n   > \n   >  * i >= 0 ，则与 arr[i] 完全相同。\n   >  * i 为负数的情况，它则从数组的尾部向前数。\n\n> javascript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端 / 末端来添加 / 删除元素。（可以看作数组为双向队列）\n\n队列使用数组的两个方法：\n\n * shift() 在数组首端取出一个元素（出队）。\n * push() 在数组首端添加一个元素（入队）。\n\n栈使用数组的两个方法：\n\n * push() 在数组末端添加一个元素（进栈）。\n * pop() 在数组末端移除一个元素（推栈）。\n\n进一步深入了解数组的方法：\n\n# 作用于 数组末端 的方法\n\n * pop() ：取出并返回数组的最后一个元素。（影响原数组）\n * push(...) ：在数组末端添加元素。（无返回值，参数为要添加的元素）（相当于 arr[arr.length + 1 ] = ... ）\n\n# 作用于 数组首端 的方法\n\n * shift() ：取出并返回数组的第一个元素。\n * unshift() ：在数组首端添加元素。\n\n🌰 例子 / 使用 push() / unshift() 一次添加多个元素：\n\nlet fruits = ["apple"];\n\nfruits.push("orange", "peach");\nfruits.unshift("pineapple", "lemon");\n\nconsole.log(fruits) // ["pineapple", "lemon", "apple", "orange", "peach"]\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 接收用户输入的数（判断）求和：\n\n点击查看\n\nfunction sum() {\n  let sum = 0;\n  let arr = [];\n  \n  while(true) {\n    let value = prompt(\'input number\', 0)\n    if(value === \'\' || value === null || isfinite(value)) break;\n\t\tvalue = +value // 处理为数字类型\n    arr.push(value)\n  }\n  \n  for(value of arr) {\n    sum += value\n  }\n  \n  return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 理解数组的内部\n\n数组是一种特殊的对象。使用方括号来访问属性 arr[0] 实际上是来自于对象的语法。它其实与 obj[key] 相同，其中 arr 是对象，而数字用作键（key）。\n\n数组扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象。\n\n> javascript 只有 8 种基本的数据类型。其中数组仍属于对象类型。行为也与对象相似。\n\n# 数组的复制\n\n与对象的引用复制相同原理。\n\n🌰 例子：\n\nlet fruits = ["banana"]\nlet arr = fruits; // 实际上，两个数组引用同一个数组\nconsole.log(arr === fruits) // true\n\narr.push("pear");\nconsole.log(fruits) // banana, pear \n\n\n1\n2\n3\n4\n5\n6\n\n\n数组真正特殊的是它们的内部实现。javascript 引擎尝试把这些元素一个接一个地存储在 连续的内存区域，还有一些其它的优化，以使数组运行得非常快。\n\n但如果破坏数组的连续性去使用数组，例如直接访问远超出初始索引的值，或者给数组对象添加属性，针对数组的优化就不再适用了，然后对应的优化就会被关闭，数组不将存在优势。\n\n>  * 添加一个非数字的属性，比如 arr.test = 5 。\n>  * 制造空洞，比如：添加 arr[0] ，然后添加 arr[1000] (它们中间什么都没有)。\n>  * 以倒序填充数组，比如 arr[1000] ， arr[999] 等等。\n\n注意\n\n所以数组最好作用于 有序数据 的特殊结构，以正确的方式使用数组，才能发挥数组最大的优势。如果需要任意键值，那使用常规的对象。\n\n\n# 数组的性能\n\n可以从数据结构的「时间复杂度」思考：（ push/pop 方法运行的比较快，而 shift/unshift 比较慢）\n\n * 从首端操作，要从首端开始向后（或从后端向前端）推移元素， 数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作 。\n * 而从数组的末端操作，意味着 不需要移动任何元素 。 因为其它元素都保留了各自的索引。这就是为什么 pop / push 的操作会特别快。\n\n\n# 数组的循环\n\n * 经典方式 / 使用 for 的 完整形式 循环：\n   \n   let arr = ["apple", "orange", "pear"];\n   \n   for (let i = 0; i < arr.length; i++) {\n     console.log(arr[i]);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 使用 for…of 循环：\n   \n   for (let fruit of fruits) {\n     console.log( fruit );\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   > 注意： for..of 不能获取当前元素的索引，只是获取元素值。\n\n * 根据对象特性使用 for…in ：\n   \n   for (let key in arr) {\n     alert( arr[key] ); // apple, orange, pear\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   > 使用 for…in 会带来潜在的问题：\n   > \n   >  * for..in 循环会遍历 所有属性，不仅仅是这些数字属性。对于浏览器和其它环境中的「类数组」对象，会有其它的非数字的属性和方法。这些额外的循环是不必要的。\n   >  * for..in 循环适用于普通对象，并且做了对应的优化，但是不适用于数组。\n   > \n   > 所以不应该使用 for…in 处理数组。\n\n\n# 数组的长度 length\n\n当修改数组的时候， length 属性会自动更新。实际上 length 不是数组里元素的个数，而是最大的数字索引值加一。\n\n🌰 例子 / 一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 length 也会很大：\n\nlet fruits = [];\nfruits[123] = "apple";\n\nconsole.log( fruits.length ); \n\n\n1\n2\n3\n4\n\n\n> 但是通常都不会这样使用数组。\n\n🌰 例子 / 手动修改 length ：\n\nlet arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // 截断到只剩 2 个元素\nalert( arr ); // [1, 2]\n\narr.length = 5; // 又把 length 加回来\nalert( arr[3] ); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 可以看到，这个修改的过程是不可逆的。\n\n利用 length ，清空数组的最简单的方法是 arr.length = 0 。\n\n\n# 多维数组\n\n数组里的项也可以是数组。可以用来创建 矩阵：\n\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nconsole.log( matrix[1][1] ); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数组的 tostring()\n\n数组自己的 tostring 方法的实现，会返回 以逗号隔开的元素列表字符串。\n\n🌰 例子 / 打印数组：\n\nlet arr = [1, 2, 3];\n\nconsole.log( arr ); // 1,2,3\nconsole.log( string(arr) === \'1,2,3\' ); \n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 数组的打印结果拼接字符串：\n\nconsole.log( [] + 1 ); // "1"\nconsole.log( [1] + 1 ); // "11"\nconsole.log( [1,2] + 1 ); // "1,21"\n\n\n1\n2\n3\n\n\n> 对于数组，没有 symbol.toprimitive ，也没有 valueof ，它们只能执行 tostring 进行转换，所以这里 [] 就变成了一个空字符串， [1] 变成了 "1" ， [1,2] 变成了 "1,2" 。\n\n\n# 数组的比较\n\njavascript 中的数组 不能使用 == 运算符比较，该运算符不会对数组进行特殊处理，它会像 处理任意对象 那样处理数组。\n\n> 在对象中：\n> \n>  * 仅当两个对象引用的是同一个对象时，它们才相等 == 。\n>  * 如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型。\n>  * 严格比较 === 更简单，不会进行类型转换。\n\n使用 == 比较数组，除非引用的是同一个数组对象，否则尽管数组的内容相同（实质上仍然不是同一个对象），比较结果永远都不会相等。\n\n> console.log([] == [])\n> \n> // 与原始对象比较\n> alert( 0 == [] ); // true []被转换为空字符串\'\'\n> alert(\'0\' == [] ); // false\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 数组的更多方法\n\n\n# 添加 / 移除数组元素\n\n# 🍎 splice\n\narr.splice 方法可以说是处理数组的瑞士军刀，它可以做所有事情：添加，删除和插入元素。语法如下：\n\narr.splice(start[, deletecount, elem1, ..., elemn])\n\n\n1\n\n\n它从索引 start 开始修改 arr ：删除 deletecount 个元素并在当前位置插入 elem1, ..., elemn 。最后 返回已被删除元素的数组。\n\n🌰 例子 / 删除数组元素：\n\nlet arr = ["i", "study", "javascript"];\narr.splice(1, 1); // 从索引 1 开始删除 1 个元素\nconsole.log(arr) // ["i", "javascript"]\n\n\n1\n2\n3\n\n\n> 当参数只有 start ，从 start 索引开始删除所有的数组元素。\n\n🌰 例子 / 删除数组元素并替换：\n\nlet arr = ["i", "study", "javascript", "right", "now"];\n// 删除数组的前三项，并使用其他内容代替它们\nlet removed = arr.splice(0, 3, "let\'s", "dance");\nconsole.log(arr) // ["let\'s", "dance", "right", "now"]\nconsole.log(removed) // ["i", "study"] \n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 在指定位置新增元素：\n\nlet arr = ["i", "study", "javascript"];\n\n// 从索引 2 开始\n// 删除 0 个元素\n// 然后插入 "complex" 和 "language"\narr.splice(2, 0, "complex", "language"); \nconsole.log(arr) // ["i", "study", "complex", "language", "javascript"]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n区别于方括号访问，数组的方法中可以使用「负向索引」，即索引值可以为负数，从数组末尾计算位置。\n\nlet arr = [1, 2, 5];\n\n// 从索引 -1（尾端前一位）\n// 删除 0 个元素，\n// 然后插入 3 和 4\narr.splice(-1, 0, 3, 4);\nconsole.log(arr); // 1,2,3,4,5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# slice\n\n用于切割数组，将所有从索引 start 到 end （ ⚠️ 不包括 end ）的数组项复制到一个新的数组，返回这个新的数组。\n\narr.slice([start], [end])\n\n\n1\n\n\n> 与字符串的 str.slice 相似。\n\n🌰 例子：\n\nlet arr = ["t", "e", "s", "t"];\nconsole.log(arr.slice(1, 3)) // \'e\' \'s\'\n\n\n1\n2\n\n\n🌰 例子 / 不含参数的 slice() 获取原数组的副本，在此副本进行的操作不会影响原来的数组：\n\nconsole.log(arr.slice) // [\'t\', \'e\', \'s\', \'t\']\n\n\n1\n\n\n🌰 例子 / 从末尾开始索引（即使是末尾索引但不代表反过来切割）：\n\nconsole.log(arr.slice(-2)) s,t\n\n\n1\n\n\n# concat\n\n拼接数组，用于创建一个新的数组，包含来自其他数组和其他项的值。可以接受 任意参数 （数组或者值）。结果是包含来自于 arr 、 arg1 、 arg2 等元素的新数组。如果参数 argn 是一个数组，那么其中的 所有元素 都会被复制。如果不是数组，将复制 参数本身（例如对象，即便其中有类似数组的结构，仍然会作为一个整体添加）。\n\narr.concat(arg1, arg2...)\n\n\n1\n\n\n🌰 例子 ：\n\nlet arr = [1, 2];\n\n// create an array from: arr and [3,4]\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n\n// create an array from: arr and [3,4] and [5,6]\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n\n// create an array from: arr and [3,4], then add values 5 and 6\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子：复制其他对象：\n\nlet arr = [1, 2];\n\nlet arraylike = {\n  0: "something",\n  length: 1\n};\n\nconsole.log(arr.concat(arraylike)) // 1,2,[object object]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子：如果类似数组的对象具有 symbol.isconcatspreadable 的属性，则可以被 concat 当作一个数组处理：\n\nlet arr = [1, 2];\n\nlet arraylike = {\n  0: "something",\n  1: "else",\n  [symbol.isconcatspreadable]: true,\n  length: 2\n};\n\nconsole.log(arr.concat(arraylike)); // 1,2,something,else \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# foreach 遍历\n\n使用 arr.foreach() 允许为数组的 每一个元素 都运行一个函数：\n\narr.foreach(function(item, index, array) {\n  // ... do something with item\n});\n\n\n1\n2\n3\n\n\n🌰 例子 / 对每一个元素都运行 alert() ：\n\n["bilbo", "gandalf", "nazgul"].foreach(alert);\n\n\n1\n\n\n🌰 例子 / 打印详细信息：\n\n["bilbo", "gandalf", "nazgul"].foreach((item, index, array) => {\n  console.log(`${item} is at index ${index} in ${array}`);\n});\n\n\n1\n2\n3\n\n\n\n# 搜索数组\n\n# indexof / lastindexof 和 includes\n\n与字符串的用法基本相同：\n\n * arr.indexof(item, from) ： 从索引 from 开始搜索 item ，如果找到则 返回索引 ，否则返回 -1 。\n * arr.lastindexof(item, from) ：逆序搜索。找到 返回索引，否则返回 -1 。\n * arr.includes(item, from) ：从索引 from 开始搜索 item ，如果找到则返回 true ，否则返回 false 。\n\n🌰 例子 ：\n\nlet arr = [1, 0, false];\nconsole.log(arr.indexof(0)) // 1\nconsole.log(arr.lsatindexof(false)) // 0 \nconsole.log(arr.includes(0)) // true\n\n\n1\n2\n3\n4\n\n\n⚠️ 注意：这些方法使用的是 严格相等 === 比较。所以如果搜索 false ，会精确到的确是 false 而不是数字 0 。\n\n🌰 例子： includes 它能正确处理 nan ，不像 indexof/lastindexof ：\n\nconst arr = [nan];\nalert( arr.indexof(nan) ); // -1（应该为 0，但是严格相等对 nan 无效）\nalert( arr.includes(nan) );// true\n\n\n1\n2\n3\n\n\n# find / findindex\n\n在对象数组中要找到特定的对象使用 find ，依次对数组中的 每个元素 调用该函数：\n\nlet result = arr.find(function(item, index, array) {\n  // item 元素，index 索引, array 数组本身\n  // 如果返回 true，则返回 item 并停止迭代\n  // 没有搜索到，则返回 undefined\n});\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 ：\n\nlet users = [\n  {id: 1, name: "john"},\n  {id: 2, name: "pete"},\n  {id: 3, name: "mary"}\n];\n\nlet result = users.find(item => item.id == 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 最常用的用法就是使用 item 去筛选条件，返回筛选后的结果（ index 和 array 不常用）。\n\nfindindex 与 find 方法基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1 。\n\n# 🍎 filter\n\nfind 方法只会找到使函数返回 true 的 第一个（单个）元素。如果需要匹配的元素有很多，可以使用 filter 方法，语法与 find 方法大致相同， filter 返回的是 所有匹配元素组成的数组 。\n\nlet results = arr.filter(function(item, index, array) {\n  // 如果为 true , item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n\n\n1\n2\n3\n4\n\n\n🌰 例子 ：\n\nlet users = [\n  {id: 1, name: "john"},\n  {id: 2, name: "pete"},\n  {id: 3, name: "mary"}\n];\n\nlet res = users.filter((item) => item.id < 2)\nconsole.log(res) // [{id: 1, name: "john"}, {id: 2, name: "pete"},]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 转换数组\n\n# 🍎 map\n\n是最常使用、最有用的数组方法。对数组的每个元素都调用函数，并返回结果数组。\n\nlet result = arr.map(function(item, index, array) {\n  // 返回新值而不是当前元素\n})\n\n\n1\n2\n3\n\n\n🌰 例子 / 将每个元素转换为它的字符串长度：\n\nlet lengths = ["bilbo", "gandalf", "nazgul"].map((item)=> item.length)\nconsole.log(lengths) // 5,7,6\n\n\n1\n2\n\n\n\n# 数组排序\n\n# 🍎 sort(fn)\n\n该方法对数组进行 原位（in-place） 排序，更改元素的顺序。\n\n> 原位：在此数组排序，并非生成新的数组。\n\n🌰 例子：\n\nlet arr = [15, 1, 2]\narr.sort() \nconsole.log(arr) // 1, 15, 2\n\n\n1\n2\n3\n\n\n> 注意：以上排序结果并非按照数字大小顺序排序，这些元素默认情况下被按字符串进行排序。 所有元素都被转换为字符串，然后进行比较。\n\n如果要想要按照定义的排序顺序，需要提供一个函数作为 arr.sort() 的参数。该函数应该比较两个任意值并返回：\n\nfunction compare(a, b){\n  if(a > b) return 1;\n  if(a == b) return 0;\n  if(a < b) return -1;\n}\n\nlet arr = [1, 2, 15]\narr.sort(compare)\nconsole.log(arr) // 1, 2, 15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 由于数组可以由任何内容组成的数组，可能包含数字、字符串、对象或其他任何内容。要对这些不同类型的元素排序，需要一个 排序函数 来确认如何比较这些元素。数组默认是按字符串进行排序的。\n> \n> arr.sort(fn) 遍历数组，使用提供的函数比较其元素并对其重新排序。比较函数只需要返回一个正数表示「大于」，一个负数表示「小于」。\n\n🌰 例子 / 常用比较大小函数（从小到大）（简化为 箭头函数 版本）：\n\n[5,4,3,2,1].sort((a, b) => a - b)\n\n\n1\n\n\n# reverse()\n\n用于 颠倒 数组中的顺序（原位修改）。\n\n🌰 例子 ：\n\nlet arr = [1, 2, 3, 4, 5]\narr.reverse();\nconsole.log(arr) // 5,4,3,2,1\n\n// let res = arr.reverse()\n// console.log(res) // 返回值也可以接收结果\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 🍎 数组拆分 / 组合 split / join\n\nstr.split(delim) 方法用于 字符串 上，通过给定的分隔符 delim 将字符串分割成一个数组。（字符串分割为数组）\n\n🌰 例子 ：\n\nlet names = \'bilbo, gandalf, nazgul\';\nlet arr = names.split(\', \');\nfor (let name of arr) {\n  console.log(name)\n}\n\n\n1\n2\n3\n4\n5\n\n\nsplit() 的第二个可以选择的参数，是对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用。\n\n🌰 例子：\n\nlet arr = \'bilbo, gandalf, nazgul, saruman\'.split(\', \', 2);\nconsole.log(arr); // bilbo, gandalf\n\n\n1\n2\n\n\n🌰 例子 / 第一个参数为空字符串，将字符串拆分为字母数组：\n\nlet str = "test";\nconsole.log(str.split(\'\')); // t,e,s,t\n\n\n1\n2\n\n\narr.join(glue) 与 split 相反，它会在它们之间创建一串由 glue 粘合的 arr 项。（数组粘合为字符串）\n\n🌰 例子：\n\nlet arr = [\'bilbo\', \'gandalf\', \'nazgul\'];\nlet str = arr.join(\';\'); // 使用分号 ; 将数组粘合成字符串\nconsole.log(str); // bilbo;gandalf;nazgul\n\n\n1\n2\n3\n\n\n\n# 🍎 reduce / reduceright\n\n这个函数一个接一个地应用于所有数组元素，并将其结果「搬运」到下一个调用。语法如下：\n\nlet value = arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);\n\n\n1\n2\n3\n\n\n> 参数：\n> \n>  * accumulator ：（累加器）是上一个函数调用的结果，第一次等于 initial （如果提供了 initial 的话）。\n>  * item ：当前的数组元素。\n>  * index ：当前索引。\n>  * arr ：数组本身。\n\n🌰 例子 / 通过 reduce 计算数组元素总和：\n\nlet arr = [1, 2, 3, 4, 5]\nlet res = arr.reduce((sum, cur) => sum + cur, 0)\nconsole.log(res) // 15\n\n\n1\n2\n3\n\n\n> sum 是累加器， cur 是当前的元素， 0 是累加器的初始值。通常只需要这两个参数即可。\n\n也可以省略初始值，数组的第一个元素作为初始值，第二个元素开始迭代，得出的结果相同：\n\nlet res = arr.reduce((sum, cur) => sum + cur)\n\n\n1\n\n\n> 注意省略初始值使用的情况不能为数组为空时，当数组为空时，第一个累加器返回的就是空值导致出错。所以始终建议指定初始值。\n\narr.reduceright 和 arr.reduce 方法的功能一样，只是遍历为 从右到左。\n\n\n# array.isarray()\n\n由于数组是基于对象的，不构成单独的语言类型，所以 typeof 不能帮助 从数组中区分出普通对象。array.isarray(value) 用于检验一个对象是否为数组，如果 value 是一个数组，则返回 true ；否则返回 false 。\n\n🌰 例子：\n\nconsole.log(array.isarray({})) // false\nconsole.log(array.isarray([])) // true\n\n\n1\n2\n\n\n\n# thisarg 参数\n\n几乎所有 调用函数的数组方法 ， 比如 find ， filter ， map ，除了 sort 是一个 特例，都接受一个 可选的附加参数 thisarg 。由于较少使用所以涉及以上数组方法并没有介绍。\n\n完整的用法：\n\narr.find(func, thisarg);\narr.filter(func, thisarg);\narr.map(func, thisarg);\n// ... \n\n\n1\n2\n3\n4\n\n\nthisarg 最后可选参数的值在 func 中变为 this 。\n\n🌰 例子 / 使用 army 对象方法作为 过滤器， thisarg 用于传递上下文：\n\nlet army = {\n  minage: 18,\n  maxage: 27,\n  canjoin(user) {\n    return user.age >= this.minage && user.age < this.maxage;\n  }\n};\n\nlet users = [\n  {age: 16},\n  {age: 20},\n  {age: 23},\n  {age: 30}\n];\n\n// *找到 army.canjoin 返回 true 的 user\nlet soldiers = users.filter(army.canjoin, army)\nalert(soldiers.length); // 2\nalert(soldiers[0].age); // 20\nalert(soldiers[1].age); // 23\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 实际中，为了可读性，可以写成：\n> \n> users.filter(user => army.canjoin(user))\n> \n> \n> 1\n\n\n# 数组总结\n\n关于数组的方法备忘录：\n\n * 添加 / 移除元素相关：\n   \n   * 🍎 push(...items) ：向 尾端 添加元素。\n   \n   * 🍎 pop() ：从 尾端 提取一个元素。\n   \n   * 🍎 shift() ：从 首端 提取一个元素。\n   \n   * 🍎 unshift(...items) ：向 首端 添加元素。\n   \n   * 🍎 splice(pos, deletecount, ...items) ： 从 pos 开始删除 deletecount 个元素，并插入 items 。\n   \n   * 🍎 slice(start, end) ：创建一个新数组，将从索引 start 到索引 end （但不包括 end ）的元素 复制 进去。\n   \n   * concat(...items) ：返回一个新数组：复制 当前数组的所有元素，并向其中添加 items 。如果 items 中的任意一项是一个数组，那么就取其元素。（其他对象则为对象本身）\n\n * 查找元素相关：\n   \n   * indexof / lastindexof(item, pos) ：从索引 pos 开始搜索 item ，搜索到则返回该项的 索引值，否则返回 -1 。\n   * includes(value) ：如果数组有 value ，则返回 true ，否则返回 false 。\n   * 🍎 find(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 第一个值。\n   * 🍎 filter(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 所有值。\n   * findindex 和 find 类似，但返回 索引 而不是值。\n\n * 遍历元素相关：\n   \n   * 🍎 foreach(func) —— 对每个元素都调用 func ，不返回任何内容\n\n * 转换数组相关：\n   \n   * 🍎 map(func) ： 根据对每个元素调用 func 的结果创建一个新数组。\n   * 🍎 sort(func) ： 对数组进行 原位排序，然后返回排序后的数组。\n   * reverse() ： 原位反转 数组，然后返回反转后的数组。\n   * 🍎 split/join ：将字符串 转换为数组 并返回。\n   * 🍎 reduce / reduceright(func, initial) ：通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。（常见用法累加）\n\n * 其他：\n   \n   * array.isarray(arr) ：检查 arr 是否是一个数组。\n\n补充数组方法：\n\n * 🍎 arr.some(fn) / arr.every(fn) 检查数组。对数组的每个元素调用函数 fn ：\n   * 有一 true 所有就返回 true ：如果 fn 返回一个真值， arr.some() 立即返回 true 并停止迭代其余数组项；\n   * 所有 true 才返回 true ：如果 fn 返回一个假值， arr.every() 立即返回 false 并停止对其余数组项的迭代。\n\n🌰 例子 / 使用 every() 检验数组是否全等：\n\nfunction comparearray(arr1, arr2){\n  return arr1.length && arr2.length && arr1.every((value, index) => value === arr2[index])\n}\n\ncomparearray([1,2], [1,2]) // true\n\n\n1\n2\n3\n4\n5\n\n * arr.fill(value, start, end) ：从索引 start 到 end ，用重复的 value 填充数组。\n * arr.copywithin(target, start, end) ：将从位置 start 到 end 的所有元素复制到 自身 的 target 位置（覆盖现有元素）。\n * arr.flat(depth) / arr.flatmap(fn) ： 从多维数组创建一个新的扁平数组。\n * array.of(element0[, element1[, …[, elementn]]]) ： 基于 可变数量的参数 创建一个新的 array 实例，而不需要考虑参数的数量或类型。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔀 JavaScript 可迭代对象",frontmatter:{title:"🔀 JavaScript 可迭代对象",date:"2022-05-05T17:41:30.000Z",permalink:"/pages/2c7626/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/25.%20%F0%9F%94%80%20JavaScript%20%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/25. 🔀 JavaScript 可迭代对象.md",key:"v-11fc5ceb",path:"/pages/2c7626/",headers:[{level:3,title:"Symbol.iterator",slug:"symbol-iterator",normalizedTitle:"symbol.iterator",charIndex:71},{level:3,title:"可迭代字符串",slug:"可迭代字符串",normalizedTitle:"可迭代字符串",charIndex:1982},{level:3,title:"显式调用迭代器",slug:"显式调用迭代器",normalizedTitle:"显式调用迭代器",charIndex:2227},{level:2,title:"可迭代与类数组",slug:"可迭代与类数组",normalizedTitle:"可迭代与类数组",charIndex:2550},{level:3,title:"Array.from",slug:"array-from",normalizedTitle:"array.from",charIndex:2978},{level:2,title:"可迭代对象总结",slug:"可迭代对象总结",normalizedTitle:"可迭代对象总结",charIndex:4295}],headersStr:"Symbol.iterator 可迭代字符串 显式调用迭代器 可迭代与类数组 Array.from 可迭代对象总结",content:'可迭代对象 是数组的泛化，任何对象都可以被定制为可在 for..of 循环中使用的对象。许多内建对象都可迭代，除了数组，还有字符串。\n\n\n# Symbol.iterator\n\n🌰 例子：使自定义的对象可迭代：\n\nlet range = {\n  from: 1,\n  to: 5\n}\n// 希望得到 for(let num of range) ... num=1,2,3,4,5\n\n\n1\n2\n3\n4\n5\n\n\n> 为了让 range 可迭代， 需要为对象添加 Symbol.iterator （使对象可迭代的 内建 symbol）\n> \n>  * 当 for..of 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 迭代器（iterator） （ 一个有 next 方法的对象）。\n>  * 从此开始， for..of 仅适用于这个被返回的对象。\n>  * 当 for..of 循环希望取得下一个数值，它就调用这个对象的 next() 方法。\n>  * next() 方法返回的结果的格式必须是 {done: Boolean, value: any} ，当 done=true 时，表示循环结束，否则 value 是下一个值。\n\n// 1.为 range 添加 Symbol.iterator\nrange[Symbol.iterator] = function() {\n  // 返回一个迭代器对象\n  // 2. for...of 仅与希望的迭代器对象工作，要求它提供一个值\n  return {\n    current: this.from,\n    last: this.to,\n    \n    // 3. next() 在 for...of 每一轮循环迭代中被调用\n    next() {\n      // 4. 返回 {done: ..., value: ...} 格式的对象\n      if(this.current <= this.last) {\n        return {\n          done: false,\n          value: this.current++\n        } \n      } else {\n        return {done: true}\n      }\n    }\n  }\n}\n\n// for...of循环\nfor(let num of range) {\n  console.log(num)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n迭代器的核心功能：关注点分离：\n\n * range 自身没有 next() 方法。\n * 相反，是通过调用 range[Symbol.iterator]() 创建了另一个对象，即所谓的「迭代器」对象，并且它的 next 会为迭代生成值。\n\n进一步简化，将 Symbol.iterator 合并进对象，使用 range 自身作为迭代器。\n\nlet range = {\n  from: 1,\n  to: 5,\n  \n  [System.iterator]() {\n    this.current = this.from,\n    return this\n  },\n  \n  next() {\n    if(this.current <= this.to) {\n      return {done: false, value: this.current++}\n    } else {\n      return {done: true}\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 现在 range[Symbol.iterator]() 返回的是 range 对象自身：它包括了必需的 next() 方法，并通过 this.current 记忆了当前的迭代进程。\n> \n> 但是存在缺点：现在不可能 同时在对象上运行两个 for..of 循环 了：它们将 共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 for..of 是很 罕见 的，即使在异步情况下。\n\n> 无穷的迭代器：将 range 设置为 range.to = Infinity ，这时 range 则成为了无穷迭代器。或者可以创建一个可迭代对象，它生成一个无穷伪随机数序列。\n> \n> next 没有什么限制，它可以返回越来越多的值，这是正常的。\n> \n> 迭代这种对象的 for..of 循环将不会停止。但是可以通过使用 break 来停止它。\n\n\n# 可迭代字符串\n\n数组和字符串 是使用最广泛的 内建可迭代对象。\n\n🌰 例子：\n\nfor (let char of "test") {\n  console.log( char );\n}\n\n\n1\n2\n3\n\n\n🌰 例子 / for…of 可处理代理对：\n\nlet smileString = \'😀😃😄\'\n\nfor (let smile of smileString) {\n\tconsole.log(smile) // "😀" "😃" "😄"\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 显式调用迭代器\n\n使用 与 for..of 完全相同 的方式遍历字符串，但是使用的是 直接调用。这段代码创建了一个字符串迭代器，并「手动」从中获取值。\n\nlet str = \'Hello\'\n\nlet iterator = str[Symbol.iterator]\n\nwhile(true) {\n  let result = iterator.next()\n  if (result.done) break;\n  console.log(result,value)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n此过程，比 for..of 给了更多的控制权。例如，可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。\n\n\n# 可迭代与类数组\n\n * 可迭代 Interable： 是实现了 Symbol.iterator 方法的对象。\n * 类数组 Array-like：是有索引和 length 属性的对象，所以它们看起来很像数组。\n\n当将 JavaScript 用于编写 在浏览器或任何其他环境中 的实际任务时，可能会遇到 可迭代对象或类数组对象，或两者兼有。例如， 字符串 既是可迭代的，又是类数组的。\n\n** 但是，一个可迭代对象也许不是类数组对象。反之亦然，类数组对象可能不可迭代。** 例如，第一个例子 range 对象，迭代的，但并非类数组对象，因为它没有索引属性，也没有 length 属性。\n\n🌰 例子 / 类数组但不可迭代：\n\nlet arrayLike = {\n  0: \'hello\',\n  1: \'world\',\n  length: 2\n}\n\n// for (let item of arraylike) {}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Array.from\n\n对于可迭代对象和类数组对象通常都 不是数组，它们没有 push 和 pop 等方法。如果想引入数组的方法操作 range 对象：\n\n全局方法 Array.from 可以 接受一个可迭代或类数组的值，并从中获取一个「真正的」数组，然后就可以对其调用数组方法了。\n\n🌰 例子：\n\nlet arrayLike = {\n  0: \'hello\',\n  1: \'world\',\n  length: 2\n}\n\nlet arr = Array.from(arrayLike) \nconsole.log(arr.pop()) // world 数组方法有效\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> Array.from 方法接受对象，检查它是一个可迭代对象或类数组对象，然后创建一个新数组，并将该对象的所有元素 复制 到这个新数组。\n\n🌰 例子 / 处理一个数组转换为单个字符的数组：\n\nlet smileString = \'😀😃😄\'\nlet arraySmile = Array.from(smileString)\nconsole.log(arrayString) // ["😀", "😃", "😄"]\n\n\n1\n2\n3\n\n\n> 与 str.split() 方法不同，它依赖于字符串的可迭代特性，因此，就像 for..of 一样，可以正确地处理代理对（surrogate pair）。\n> \n> let splitSmile = smile.split(\'\')\n> console.log(splitSmile) // ["�", "�", "�", "�", "�", "�"]\n> \n> \n> 1\n> 2\n> \n> \n> split 无法处理代理对（surrogate pair）。\n> \n> 实际上，可以看作 for…of 的工作：\n> \n> let arraySmile = []\n> let (smile of smileString) {\n>   arraySmile.push(smile)\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n🌰 例子 / 基于 Array.from 创建代理感知（surrogate-aware）的 slice 方法，解决原生 slice 不支持识别代理对：\n\nfunction slice(str, start, end) {\n    return Array.from(str).slice(start, end).join(\'\');\n}\n\nlet str = \'𝒳😂𩷶\'\nconsole.log(slice(str, 1, 3)) // "😂𩷶"\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 使用展开运算符也可转换为真正的数组：\n\nlet str = "𝒳😂";\nlet chars = [...str];\n\nconsole.log(chars[0]); // 𝒳\nconsole.log(chars[1]); // 😂\nconsole.log(chars.length); // 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 可迭代对象总结\n\n * 🍎 可以应用 for..of 的对象被称为 可迭代的。\n   \n   * 可迭代对象必须实现 Symbol.iterator 方法。\n   * obj[Symbol.iterator]() 的结果被称为 迭代器（iterator）。由它处理进一步的迭代过程。\n   * 一个迭代器必须有 next() 方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。\n\n * Symbol.iterator 方法会被 for..of 自动调用或者可以直接调用。\n\n * 内建的可迭代对象例如字符串和数组，都实现了 Symbol.iterator 。\n\n * 字符串迭代器能够 识别代理对（surrogate pair）。\n\n * 类数组对象：有索引属性和 length 属性的对象，但是 没有数组的内建方法。\n   \n   大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是「真正的」数组，因为这样 抽象度更高。\n\n * 🍎 Array.from(obj[, mapFn, thisArg]) 将可迭代对象或类数组对象 obj 转化 为真正的数组 Array ，然后就可以对它 应用数组的方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。',normalizedContent:'可迭代对象 是数组的泛化，任何对象都可以被定制为可在 for..of 循环中使用的对象。许多内建对象都可迭代，除了数组，还有字符串。\n\n\n# symbol.iterator\n\n🌰 例子：使自定义的对象可迭代：\n\nlet range = {\n  from: 1,\n  to: 5\n}\n// 希望得到 for(let num of range) ... num=1,2,3,4,5\n\n\n1\n2\n3\n4\n5\n\n\n> 为了让 range 可迭代， 需要为对象添加 symbol.iterator （使对象可迭代的 内建 symbol）\n> \n>  * 当 for..of 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 迭代器（iterator） （ 一个有 next 方法的对象）。\n>  * 从此开始， for..of 仅适用于这个被返回的对象。\n>  * 当 for..of 循环希望取得下一个数值，它就调用这个对象的 next() 方法。\n>  * next() 方法返回的结果的格式必须是 {done: boolean, value: any} ，当 done=true 时，表示循环结束，否则 value 是下一个值。\n\n// 1.为 range 添加 symbol.iterator\nrange[symbol.iterator] = function() {\n  // 返回一个迭代器对象\n  // 2. for...of 仅与希望的迭代器对象工作，要求它提供一个值\n  return {\n    current: this.from,\n    last: this.to,\n    \n    // 3. next() 在 for...of 每一轮循环迭代中被调用\n    next() {\n      // 4. 返回 {done: ..., value: ...} 格式的对象\n      if(this.current <= this.last) {\n        return {\n          done: false,\n          value: this.current++\n        } \n      } else {\n        return {done: true}\n      }\n    }\n  }\n}\n\n// for...of循环\nfor(let num of range) {\n  console.log(num)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n迭代器的核心功能：关注点分离：\n\n * range 自身没有 next() 方法。\n * 相反，是通过调用 range[symbol.iterator]() 创建了另一个对象，即所谓的「迭代器」对象，并且它的 next 会为迭代生成值。\n\n进一步简化，将 symbol.iterator 合并进对象，使用 range 自身作为迭代器。\n\nlet range = {\n  from: 1,\n  to: 5,\n  \n  [system.iterator]() {\n    this.current = this.from,\n    return this\n  },\n  \n  next() {\n    if(this.current <= this.to) {\n      return {done: false, value: this.current++}\n    } else {\n      return {done: true}\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 现在 range[symbol.iterator]() 返回的是 range 对象自身：它包括了必需的 next() 方法，并通过 this.current 记忆了当前的迭代进程。\n> \n> 但是存在缺点：现在不可能 同时在对象上运行两个 for..of 循环 了：它们将 共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 for..of 是很 罕见 的，即使在异步情况下。\n\n> 无穷的迭代器：将 range 设置为 range.to = infinity ，这时 range 则成为了无穷迭代器。或者可以创建一个可迭代对象，它生成一个无穷伪随机数序列。\n> \n> next 没有什么限制，它可以返回越来越多的值，这是正常的。\n> \n> 迭代这种对象的 for..of 循环将不会停止。但是可以通过使用 break 来停止它。\n\n\n# 可迭代字符串\n\n数组和字符串 是使用最广泛的 内建可迭代对象。\n\n🌰 例子：\n\nfor (let char of "test") {\n  console.log( char );\n}\n\n\n1\n2\n3\n\n\n🌰 例子 / for…of 可处理代理对：\n\nlet smilestring = \'😀😃😄\'\n\nfor (let smile of smilestring) {\n\tconsole.log(smile) // "😀" "😃" "😄"\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 显式调用迭代器\n\n使用 与 for..of 完全相同 的方式遍历字符串，但是使用的是 直接调用。这段代码创建了一个字符串迭代器，并「手动」从中获取值。\n\nlet str = \'hello\'\n\nlet iterator = str[symbol.iterator]\n\nwhile(true) {\n  let result = iterator.next()\n  if (result.done) break;\n  console.log(result,value)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n此过程，比 for..of 给了更多的控制权。例如，可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。\n\n\n# 可迭代与类数组\n\n * 可迭代 interable： 是实现了 symbol.iterator 方法的对象。\n * 类数组 array-like：是有索引和 length 属性的对象，所以它们看起来很像数组。\n\n当将 javascript 用于编写 在浏览器或任何其他环境中 的实际任务时，可能会遇到 可迭代对象或类数组对象，或两者兼有。例如， 字符串 既是可迭代的，又是类数组的。\n\n** 但是，一个可迭代对象也许不是类数组对象。反之亦然，类数组对象可能不可迭代。** 例如，第一个例子 range 对象，迭代的，但并非类数组对象，因为它没有索引属性，也没有 length 属性。\n\n🌰 例子 / 类数组但不可迭代：\n\nlet arraylike = {\n  0: \'hello\',\n  1: \'world\',\n  length: 2\n}\n\n// for (let item of arraylike) {}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# array.from\n\n对于可迭代对象和类数组对象通常都 不是数组，它们没有 push 和 pop 等方法。如果想引入数组的方法操作 range 对象：\n\n全局方法 array.from 可以 接受一个可迭代或类数组的值，并从中获取一个「真正的」数组，然后就可以对其调用数组方法了。\n\n🌰 例子：\n\nlet arraylike = {\n  0: \'hello\',\n  1: \'world\',\n  length: 2\n}\n\nlet arr = array.from(arraylike) \nconsole.log(arr.pop()) // world 数组方法有效\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> array.from 方法接受对象，检查它是一个可迭代对象或类数组对象，然后创建一个新数组，并将该对象的所有元素 复制 到这个新数组。\n\n🌰 例子 / 处理一个数组转换为单个字符的数组：\n\nlet smilestring = \'😀😃😄\'\nlet arraysmile = array.from(smilestring)\nconsole.log(arraystring) // ["😀", "😃", "😄"]\n\n\n1\n2\n3\n\n\n> 与 str.split() 方法不同，它依赖于字符串的可迭代特性，因此，就像 for..of 一样，可以正确地处理代理对（surrogate pair）。\n> \n> let splitsmile = smile.split(\'\')\n> console.log(splitsmile) // ["�", "�", "�", "�", "�", "�"]\n> \n> \n> 1\n> 2\n> \n> \n> split 无法处理代理对（surrogate pair）。\n> \n> 实际上，可以看作 for…of 的工作：\n> \n> let arraysmile = []\n> let (smile of smilestring) {\n>   arraysmile.push(smile)\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n🌰 例子 / 基于 array.from 创建代理感知（surrogate-aware）的 slice 方法，解决原生 slice 不支持识别代理对：\n\nfunction slice(str, start, end) {\n    return array.from(str).slice(start, end).join(\'\');\n}\n\nlet str = \'𝒳😂𩷶\'\nconsole.log(slice(str, 1, 3)) // "😂𩷶"\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 使用展开运算符也可转换为真正的数组：\n\nlet str = "𝒳😂";\nlet chars = [...str];\n\nconsole.log(chars[0]); // 𝒳\nconsole.log(chars[1]); // 😂\nconsole.log(chars.length); // 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 可迭代对象总结\n\n * 🍎 可以应用 for..of 的对象被称为 可迭代的。\n   \n   * 可迭代对象必须实现 symbol.iterator 方法。\n   * obj[symbol.iterator]() 的结果被称为 迭代器（iterator）。由它处理进一步的迭代过程。\n   * 一个迭代器必须有 next() 方法，它返回一个 {done: boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。\n\n * symbol.iterator 方法会被 for..of 自动调用或者可以直接调用。\n\n * 内建的可迭代对象例如字符串和数组，都实现了 symbol.iterator 。\n\n * 字符串迭代器能够 识别代理对（surrogate pair）。\n\n * 类数组对象：有索引属性和 length 属性的对象，但是 没有数组的内建方法。\n   \n   大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是「真正的」数组，因为这样 抽象度更高。\n\n * 🍎 array.from(obj[, mapfn, thisarg]) 将可迭代对象或类数组对象 obj 转化 为真正的数组 array ，然后就可以对它 应用数组的方法。可选参数 mapfn 和 thisarg 允许我们将函数应用到每个元素。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔂 JavaScript 映射与集合",frontmatter:{title:"🔂 JavaScript 映射与集合",date:"2022-05-07T13:23:58.000Z",permalink:"/pages/ca2625/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/26.%20%F0%9F%94%82%20JavaScript%20%E6%98%A0%E5%B0%84%E4%B8%8E%E9%9B%86%E5%90%88.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/26. 🔂 JavaScript 映射与集合.md",key:"v-0a26fed9",path:"/pages/ca2625/",headers:[{level:2,title:"映射 Map",slug:"映射-map",normalizedTitle:"映射 map",charIndex:2},{level:3,title:"Map 迭代",slug:"map-迭代",normalizedTitle:"map 迭代",charIndex:973},{level:3,title:"从对象中创建 Map Object.entries",slug:"从对象中创建-map-object-entries",normalizedTitle:"从对象中创建 map object.entries",charIndex:1700},{level:2,title:"集合 set",slug:"集合-set",normalizedTitle:"集合 set",charIndex:2721},{level:3,title:"Set 迭代",slug:"set-迭代",normalizedTitle:"set 迭代",charIndex:3545},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4069}],headersStr:"映射 Map Map 迭代 从对象中创建 Map Object.entries 集合 set Set 迭代 总结",content:"# 映射 Map\n\nMap 是一个 带键的数据项 的集合，就像一个 对象 Object 一样。 但是它们 最大的差别 是 Map 允许任何类型的键（key）。\n\n🍎 包含以下方法和属性：\n\n * new Map() ：创建 一个 map 。\n * map.set(key, value) ：根据 键值 存储值。\n * map.get(key) ：根据键 返回 值。如果 map 不存在对应的 key ，则返回 undefined 。\n * map.has(key) ：根据键 查找 值。如果 key 存在则返回 true ，否则返回 false 。\n * map.delete(key) ：根据键 删除 值。\n * map.clear() ：清空 集合。\n * map.size ：返回当前元素个数。\n\nkey 与对象不同，不会被转换成字符串，键可以是 任何类型。\n\n> 注意在集合不建议使用方括号取值，这样会将 map 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（仅支持 string/symbol 键等）。\n\n🌰 例子 / Map 可以使用 对象 作为键：\n\nlet john = {name: 'John'}\nlet visitsCountMap = new Map()\nvisitsCountMap.set(john, 'johnValue')\nconsole.log(visitsCountMap.get(john)) // 'johnValue'\n\n\n1\n2\n3\n4\n\n\n> 在对象中不能使用 对象 作为键。因为对象会先讲键转换为字符串，转换为字符串后，内容为 [object Object]\n\n提示\n\n在 Map 中 比较键： Map 使用 SameValueZero 算法比较键值是否相等。它和严格等于 === 差不多，但区别是 NaN 被看成是等于 NaN 。所以 NaN 也可以被 用作键。这个算法不能被改变或者自定义。\n\n提示\n\nMap 的链式调用：每一次 map.set 调用都会返回 map 本身，所以可以进行链式调用：\n\nmap.set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');\n\n\n1\n2\n3\n\n\n\n# Map 迭代\n\n在 map 里使用 循环，可以使用以下三个方法：\n\n * map.keys() ：遍历并返回所有的 键。\n * map.values() ：遍历并返回所有的 值。\n * 🍎 map.entries() ：遍历并返回 所有的实体 [key, value] ， for..of 在默认情况下使用的就是这个。。\n\n除此之外， Map 有内建的 forEach 方法，与 Array 类似。\n\n🌰 例子 / Map 的三个遍历方法：\n\nlet recipeMap = new Map([\n  ['cucumber', 500],\n  ['tomatoes', 350],\n  ['onion',    50]\n])\n\nfor (let vegetable of recipeMap.keys()) {\n  console.log(vegetable)\n}\n\nfor (let price of recipeMap.values()) {\n  console.log(price)\n}\n\nfor (let entry of recipeMap.entries()) {\n  console.log(entry)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n:::\n\n迭代的顺序与插入值的顺序相同。与普通的对象不同， Map 会保留插入值的顺序。\n\n:::\n\n🌰 例子 / 集合中的 forEach 方法：\n\nrecipeMap.forEach((value, key, map) => {\n  console.log(`${key}: ${value}`)\n})\n\n\n1\n2\n3\n\n\n\n# 从对象中创建 Map Object.entries\n\n当创建一个 Map 后，可以传入一个 带有键值对的数组（或 其它可迭代对象）来进行 初始化。\n\n🌰 例子：\n\n// 带有键值对 [key, value] 的数组\nlet map = new Map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果想从一个已有的普通对象来创建一个 Map ，那么可以使用内建方法 Object.entries(obj)，该方法返回 对象的键 / 值对数组，该数组格式完全按照 Map 所需的格式。\n\n🌰 例子：\n\nlet obj = {\n  name: 'Simon',\n  age: 3\n}\n\nlet map = new Map(Object.entries(obj))\nfor(let item of map.entries()){\n\tconsole.log(item)\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> Object.entries 返回键 / 值对数组： [ [\"name\",\"John\"], [\"age\", 30] ] 。\n\n🌰 例子 / 从 Map 中转换值为对象\n\nlet map = new Map();\nmap.set('banana', 1);\nmap.set('orange', 2);\nmap.set('meat', 4);\n\nlet obj = Object.fromEntries(map.entries())\nconsole.log(obj)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> Object.fromEntries 创建一个普通对象。调用 map.entries() 将返回一个可迭代的键 / 值对，这刚好是 Object.fromEntries 所需要的格式。\n> \n> 可以简化为：\n> \n> let obj = Object.fromEntries(map)\n> \n> \n> 1\n> \n> \n> 因为 Object.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组。并且 map 的标准迭代会返回跟 map.entries() 一样的键 / 值对。\n> \n> 因此，可以获得一个普通对象（plain object），其键 / 值对与 map 相同。\n\n\n# 集合 set\n\nSet 是一个特殊的类型集合「值的集合」（没有键），它的每一个值只能出现一次。\n\n🍎 包含以下的方法：\n\n * new Set(iterable) ： 创建一个 set ，如果提供了一个可迭代对象（通常是数组），将会从该对象里面 复制 值到 set 中。\n * set.add(value) ：添加 value 到集合，返回集合本身。\n * set.delete(value) ：删除 value 。如果 value 在这个方法调用的时候 存在则返回 true ，否则返回 false 。\n * set.has(value) ：查找 value 。存在返回 true ，否则返回 false 。\n * set.clear() ：清空 set 。\n * set.size ：返回元素个数。\n\nSet 的主要特点：重复使用同一个值调用 set.add(value) 并不会发生什么改变。这就是 Set 里面的 每一个值只出现一次 的原因。\n\n🌰 例子 / 记录到访的客人，不重复记录已经来访的客人：\n\nlet set = new Set()\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\nconsole.log(set.size) // 3\nfor(let user of set){\n  console.log(user.name) // 3个\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 仅用数组实现在插入元素时查重时会带来遍历的时间开销。 Set 内部对唯一性检查进行了更好的优化。\n\n\n# Set 迭代\n\n可以使用 for..of 或 forEach 来遍历 Set：\n\n🌰 例子 ：\n\nlet set = new Set([\"oranges\", \"apples\", \"bananas\"]);\n\nfor (let item of set) {\n  console.log(item)\n}\n\nset.forEach((value, valueAgain, set)=>{\n  console.log(value)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> forEach 的回调函数有三个参数：一个 value ，然后是 同一个值 valueAgain ，最后是目标对象。\n> \n> 这三个参数是为了与 Map 兼容。对在特定情况下轻松地用 Set 代替 Map 很有帮助，反之亦然。\n\nMap 中用于迭代的方法在 Set 中也同样支持：\n\n * set.keys() ：遍历并返回所有的值，\n * set.values() ： 与 set.keys() 作用相同，这是为了兼容 Map 。\n * set.entries() ：遍历并返回所有的实体， [value, value] ，它的存在也是为了兼容 Map 。\n\n\n# 总结\n\n * Map 是一个带键的数据项的集合。\n   * 与普通对象 Object 的不同点：\n     * 任何键、对象都可以作为键。\n     * 有其他的便捷方法，如 size 属性。\n * Set 是一组唯一值的集合。\n * 在 Map 和 Set 中迭代总是按照值 插入的顺序 进行的，所以我们说这些集合是无序的，但是不能对元素进行重新排序，也不能直接按其编号来获取元素。",normalizedContent:"# 映射 map\n\nmap 是一个 带键的数据项 的集合，就像一个 对象 object 一样。 但是它们 最大的差别 是 map 允许任何类型的键（key）。\n\n🍎 包含以下方法和属性：\n\n * new map() ：创建 一个 map 。\n * map.set(key, value) ：根据 键值 存储值。\n * map.get(key) ：根据键 返回 值。如果 map 不存在对应的 key ，则返回 undefined 。\n * map.has(key) ：根据键 查找 值。如果 key 存在则返回 true ，否则返回 false 。\n * map.delete(key) ：根据键 删除 值。\n * map.clear() ：清空 集合。\n * map.size ：返回当前元素个数。\n\nkey 与对象不同，不会被转换成字符串，键可以是 任何类型。\n\n> 注意在集合不建议使用方括号取值，这样会将 map 视为 javascript 的 plain object，因此它暗含了所有相应的限制（仅支持 string/symbol 键等）。\n\n🌰 例子 / map 可以使用 对象 作为键：\n\nlet john = {name: 'john'}\nlet visitscountmap = new map()\nvisitscountmap.set(john, 'johnvalue')\nconsole.log(visitscountmap.get(john)) // 'johnvalue'\n\n\n1\n2\n3\n4\n\n\n> 在对象中不能使用 对象 作为键。因为对象会先讲键转换为字符串，转换为字符串后，内容为 [object object]\n\n提示\n\n在 map 中 比较键： map 使用 samevaluezero 算法比较键值是否相等。它和严格等于 === 差不多，但区别是 nan 被看成是等于 nan 。所以 nan 也可以被 用作键。这个算法不能被改变或者自定义。\n\n提示\n\nmap 的链式调用：每一次 map.set 调用都会返回 map 本身，所以可以进行链式调用：\n\nmap.set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');\n\n\n1\n2\n3\n\n\n\n# map 迭代\n\n在 map 里使用 循环，可以使用以下三个方法：\n\n * map.keys() ：遍历并返回所有的 键。\n * map.values() ：遍历并返回所有的 值。\n * 🍎 map.entries() ：遍历并返回 所有的实体 [key, value] ， for..of 在默认情况下使用的就是这个。。\n\n除此之外， map 有内建的 foreach 方法，与 array 类似。\n\n🌰 例子 / map 的三个遍历方法：\n\nlet recipemap = new map([\n  ['cucumber', 500],\n  ['tomatoes', 350],\n  ['onion',    50]\n])\n\nfor (let vegetable of recipemap.keys()) {\n  console.log(vegetable)\n}\n\nfor (let price of recipemap.values()) {\n  console.log(price)\n}\n\nfor (let entry of recipemap.entries()) {\n  console.log(entry)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n:::\n\n迭代的顺序与插入值的顺序相同。与普通的对象不同， map 会保留插入值的顺序。\n\n:::\n\n🌰 例子 / 集合中的 foreach 方法：\n\nrecipemap.foreach((value, key, map) => {\n  console.log(`${key}: ${value}`)\n})\n\n\n1\n2\n3\n\n\n\n# 从对象中创建 map object.entries\n\n当创建一个 map 后，可以传入一个 带有键值对的数组（或 其它可迭代对象）来进行 初始化。\n\n🌰 例子：\n\n// 带有键值对 [key, value] 的数组\nlet map = new map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果想从一个已有的普通对象来创建一个 map ，那么可以使用内建方法 object.entries(obj)，该方法返回 对象的键 / 值对数组，该数组格式完全按照 map 所需的格式。\n\n🌰 例子：\n\nlet obj = {\n  name: 'simon',\n  age: 3\n}\n\nlet map = new map(object.entries(obj))\nfor(let item of map.entries()){\n\tconsole.log(item)\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> object.entries 返回键 / 值对数组： [ [\"name\",\"john\"], [\"age\", 30] ] 。\n\n🌰 例子 / 从 map 中转换值为对象\n\nlet map = new map();\nmap.set('banana', 1);\nmap.set('orange', 2);\nmap.set('meat', 4);\n\nlet obj = object.fromentries(map.entries())\nconsole.log(obj)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> object.fromentries 创建一个普通对象。调用 map.entries() 将返回一个可迭代的键 / 值对，这刚好是 object.fromentries 所需要的格式。\n> \n> 可以简化为：\n> \n> let obj = object.fromentries(map)\n> \n> \n> 1\n> \n> \n> 因为 object.fromentries 期望得到一个可迭代对象作为参数，而不一定是数组。并且 map 的标准迭代会返回跟 map.entries() 一样的键 / 值对。\n> \n> 因此，可以获得一个普通对象（plain object），其键 / 值对与 map 相同。\n\n\n# 集合 set\n\nset 是一个特殊的类型集合「值的集合」（没有键），它的每一个值只能出现一次。\n\n🍎 包含以下的方法：\n\n * new set(iterable) ： 创建一个 set ，如果提供了一个可迭代对象（通常是数组），将会从该对象里面 复制 值到 set 中。\n * set.add(value) ：添加 value 到集合，返回集合本身。\n * set.delete(value) ：删除 value 。如果 value 在这个方法调用的时候 存在则返回 true ，否则返回 false 。\n * set.has(value) ：查找 value 。存在返回 true ，否则返回 false 。\n * set.clear() ：清空 set 。\n * set.size ：返回元素个数。\n\nset 的主要特点：重复使用同一个值调用 set.add(value) 并不会发生什么改变。这就是 set 里面的 每一个值只出现一次 的原因。\n\n🌰 例子 / 记录到访的客人，不重复记录已经来访的客人：\n\nlet set = new set()\n\nlet john = { name: \"john\" };\nlet pete = { name: \"pete\" };\nlet mary = { name: \"mary\" };\n\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\nconsole.log(set.size) // 3\nfor(let user of set){\n  console.log(user.name) // 3个\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 仅用数组实现在插入元素时查重时会带来遍历的时间开销。 set 内部对唯一性检查进行了更好的优化。\n\n\n# set 迭代\n\n可以使用 for..of 或 foreach 来遍历 set：\n\n🌰 例子 ：\n\nlet set = new set([\"oranges\", \"apples\", \"bananas\"]);\n\nfor (let item of set) {\n  console.log(item)\n}\n\nset.foreach((value, valueagain, set)=>{\n  console.log(value)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> foreach 的回调函数有三个参数：一个 value ，然后是 同一个值 valueagain ，最后是目标对象。\n> \n> 这三个参数是为了与 map 兼容。对在特定情况下轻松地用 set 代替 map 很有帮助，反之亦然。\n\nmap 中用于迭代的方法在 set 中也同样支持：\n\n * set.keys() ：遍历并返回所有的值，\n * set.values() ： 与 set.keys() 作用相同，这是为了兼容 map 。\n * set.entries() ：遍历并返回所有的实体， [value, value] ，它的存在也是为了兼容 map 。\n\n\n# 总结\n\n * map 是一个带键的数据项的集合。\n   * 与普通对象 object 的不同点：\n     * 任何键、对象都可以作为键。\n     * 有其他的便捷方法，如 size 属性。\n * set 是一组唯一值的集合。\n * 在 map 和 set 中迭代总是按照值 插入的顺序 进行的，所以我们说这些集合是无序的，但是不能对元素进行重新排序，也不能直接按其编号来获取元素。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔄 JavaScript 弱映射与弱集合",frontmatter:{title:"🔄 JavaScript 弱映射与弱集合",date:"2022-05-07T14:48:03.000Z",permalink:"/pages/5de515/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/27.%20%F0%9F%94%84%20JavaScript%20%E5%BC%B1%E6%98%A0%E5%B0%84%E4%B8%8E%E5%BC%B1%E9%9B%86%E5%90%88.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/27. 🔄 JavaScript 弱映射与弱集合.md",key:"v-4768b646",path:"/pages/5de515/",headers:[{level:2,title:"弱映射 WeakMap",slug:"弱映射-weakmap",normalizedTitle:"弱映射 weakmap",charIndex:543},{level:3,title:"弱映射的应用实例",slug:"弱映射的应用实例",normalizedTitle:"弱映射的应用实例",charIndex:1576},{level:4,title:"用户访问计数",slug:"用户访问计数",normalizedTitle:"用户访问计数",charIndex:1840},{level:4,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:2422},{level:2,title:"弱集合 WeakSet",slug:"弱集合-weakset",normalizedTitle:"弱集合 weakset",charIndex:3077},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3802}],headersStr:"弱映射 WeakMap 弱映射的应用实例 用户访问计数 缓存 弱集合 WeakSet 总结",content:'> 前述 垃圾回收 中，JavaScript 引擎在值「可达」和可能被使用时会将其保持在内存中。通常，当对象、数组之类的数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都被认为是可达的。\n\n🌰 例子 / 如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。\n\nlet john = { name: "John" };\n\nlet array = [ john ];\n\njohn = null\n\n\n1\n2\n3\n4\n5\n\n\n> 前面由 john 所引用的那个对象被存储在了 array 中，所以它不会被垃圾回收机制回收，可以通过 array[0] 获取到它。\n\n🌰 例子 / 类似上例子，如果使用对象作为常规 Map 的键，那么当 Map 存在时，该对象也将存在。它会占用内存，并且应该不会被（垃圾回收机制）回收。\n\nlet john = { name: "John" };\n\nlet map = new Map();\nmap.set(john, "...");\n\njohn = null; // 覆盖引用\n\n\n1\n2\n3\n4\n5\n6\n\n\n> john 被存储在了 map 中，可以使用 map.keys() 来获取它。\n\n\n# 弱映射 WeakMap\n\n前面介绍垃圾回收的机制，就是说明 Map 可以保留对象作为键不被垃圾回收。 WeakMap 在这方面有着 根本上 的不同，它 不会阻止垃圾回收机制对作为键的对象（key object）的回收。\n\n第一个不同点： WeakMap 的键 必须是对象，不能是原始值：\n\n🌰 例子：\n\nlet weakMap = new WeakMap();\n\nlet obj = {};\n\nweakMap.set(obj, "ok"); \n\n// 不能使用字符串作为键\nweakMap.set("test", "Whoops"); // Error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在，如果 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用，该对象将会被从内存（和 map）中自动清除。\n\nlet john = { name: "John" };\n\nlet weakMap = new WeakMap();\nweakMap.set(john, "...");\n\njohn = null;\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 与上面常规的 Map 的例子相比，现在如果 john 仅仅是作为 WeakMap 的键而存在，它将会被从 map（和内存）中自动删除。\n\nWeakMap 不支持迭代以及 keys() ， values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。\n\n🍎 WeakMap 只有以下的方法：\n\n * weakMap.get(key)\n * weakMap.set(key, value)\n * weakMap.delete(key)\n * weakMap.has(key)\n\nWeakMap 存在的意义：如果一个对象丢失了其它所有引用（就像上面例子中的 john ），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 何时会被回收。\n\n> 这些都是由 JavaScript 引擎决定的。JavaScript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 JavaScript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲， WeakMap 的当前元素的数量是未知的。JavaScript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 WeakMap 的所有键 / 值的方法。\n\n\n# 弱映射的应用实例\n\n主要应用场景：额外数据的存储。\n\n> 如果正在处理一个「属于」另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡， WeakMap 就可以派上用场。\n\n将这项数据放进 WeakMap 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。\n\nweakMap.set(john, "secret documents");\n// 如果 john 消失，secret documents 将会被自动清除\n\n\n1\n2\n\n\n# 用户访问计数\n\n🌰 例子 / 如果有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时这些数据不再需要。\n\n📃 在处理用户计数 visitCount.js 中：\n\nlet visitsCountMap = new WeakMap(); // weakmap: user => visits count\n\n// 递增用户来访次数\nfunction countUser(user) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n📃 在调用 countUser 的文件中：\n\nlet john = { name: "John" };\ncountUser(john); // count his visits\n\n// 不久之后，john 离开了\njohn = null;\n\n\n1\n2\n3\n4\n5\n\n\n> 现在， john 这个对象应该被垃圾回收。当 john 对象变成不可达时，即便它是 WeakMap 里的一个键，它也会连同它作为 WeakMap 里的键所对应的信息一同被从内存中删除。\n\n# 缓存\n\n存储（“缓存”）函数的结果，以便将来对同一个对象的调用可以重用这个结果。对于多次调用同一个对象，它只需在第一次调用时计算出结果，之后的调用可以直接从 cache 中获取。这样做的缺点是，当我们不再需要这个对象的时候需要清理 cache 。\n\n如果我们用 WeakMap 替代 Map ，便不会存在这个问题。当对象被垃圾回收时，对应缓存的结果也会被自动从内存中清除。\n\n📁 在 cache.js 中：\n\nlet cache = new WeakMap();\n\n// 计算并记结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculate the result for */ obj;\n\n    cache.set(obj, result);\n  }\n\n  return cache.get(obj);\n}\n\n// 📁 main.js\nlet obj = {/* some object */};\n\nlet result1 = process(obj);\nlet result2 = process(obj);\n\n// 不再需要这个对象时：\nobj = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> 注意使用 WeakMap 后无法获取 cache.size 。当 obj 被垃圾回收，缓存的数据也会被清除\n\n\n# 弱集合 WeakSet\n\nWeakSet 的表现类似：\n\n * 与 Set 类似，但是只能向 WeakSet 添加对象（而且不能是原始值）。\n * 对象只有在其它某个（些）地方能被访问的时候，才能留在 set 中。\n * 跟 Set 一样， WeakSet 支持 add ， has 和 delete 方法，但不支持 size 和 keys() ，并且不可迭代。\n\nSet 变为弱集合 WeakSet 的同时，可以作为额外的存储空间。但并非针对任意数据，而是针对「是 / 否『的事实。 WeakSet 的元素可能代表着有关该对象的某些信息。\n\n🌰 例子 / 可以将用户添加到 WeakSet 中，以追踪访问过我们网站的用户：\n\nlet visitedSet = new WeakSet();\n\nlet john = { name: "John" };\nlet pete = { name: "Pete" };\nlet mary = { name: "Mary" };\n\nvisitedSet.add(john); // John 访问了我们\nvisitedSet.add(pete); // 然后是 Pete\nvisitedSet.add(john); // John 再次访问\n\nconsole.log(visitedSet.has(john)) // true\nconsole.log(visitedSet(mary)) // false\n\njohn = null // 离开\n// visitedSet 将被自动清理(即自动清除其中已失效的值 john)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 总结\n\n * WeakMap 和 WeakSet 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 WeakMap / WeakSet 完成其主要工作，成为在其它地方管理 / 存储「额外」的对象数据。\n   * 主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。\n * WeakMap 是类似于 Map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问它们，便会将它们与其关联值一同删除。\n * WeakSet 是类似于 Set 的集合，它仅存储对象，并且一旦通过其他方式无法访问它们，便会将其删除。\n * WeakMap 和 WeakSet 被用作「主要」对象存储之外的「辅助」数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 WeakMap 或 WeakSet 的键，那么它将被自动清除。',normalizedContent:'> 前述 垃圾回收 中，javascript 引擎在值「可达」和可能被使用时会将其保持在内存中。通常，当对象、数组之类的数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都被认为是可达的。\n\n🌰 例子 / 如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。\n\nlet john = { name: "john" };\n\nlet array = [ john ];\n\njohn = null\n\n\n1\n2\n3\n4\n5\n\n\n> 前面由 john 所引用的那个对象被存储在了 array 中，所以它不会被垃圾回收机制回收，可以通过 array[0] 获取到它。\n\n🌰 例子 / 类似上例子，如果使用对象作为常规 map 的键，那么当 map 存在时，该对象也将存在。它会占用内存，并且应该不会被（垃圾回收机制）回收。\n\nlet john = { name: "john" };\n\nlet map = new map();\nmap.set(john, "...");\n\njohn = null; // 覆盖引用\n\n\n1\n2\n3\n4\n5\n6\n\n\n> john 被存储在了 map 中，可以使用 map.keys() 来获取它。\n\n\n# 弱映射 weakmap\n\n前面介绍垃圾回收的机制，就是说明 map 可以保留对象作为键不被垃圾回收。 weakmap 在这方面有着 根本上 的不同，它 不会阻止垃圾回收机制对作为键的对象（key object）的回收。\n\n第一个不同点： weakmap 的键 必须是对象，不能是原始值：\n\n🌰 例子：\n\nlet weakmap = new weakmap();\n\nlet obj = {};\n\nweakmap.set(obj, "ok"); \n\n// 不能使用字符串作为键\nweakmap.set("test", "whoops"); // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在，如果 weakmap 中使用一个对象作为键，并且没有其他对这个对象的引用，该对象将会被从内存（和 map）中自动清除。\n\nlet john = { name: "john" };\n\nlet weakmap = new weakmap();\nweakmap.set(john, "...");\n\njohn = null;\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 与上面常规的 map 的例子相比，现在如果 john 仅仅是作为 weakmap 的键而存在，它将会被从 map（和内存）中自动删除。\n\nweakmap 不支持迭代以及 keys() ， values() 和 entries() 方法。所以没有办法获取 weakmap 的所有键或值。\n\n🍎 weakmap 只有以下的方法：\n\n * weakmap.get(key)\n * weakmap.set(key, value)\n * weakmap.delete(key)\n * weakmap.has(key)\n\nweakmap 存在的意义：如果一个对象丢失了其它所有引用（就像上面例子中的 john ），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 何时会被回收。\n\n> 这些都是由 javascript 引擎决定的。javascript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 javascript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲， weakmap 的当前元素的数量是未知的。javascript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 weakmap 的所有键 / 值的方法。\n\n\n# 弱映射的应用实例\n\n主要应用场景：额外数据的存储。\n\n> 如果正在处理一个「属于」另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡， weakmap 就可以派上用场。\n\n将这项数据放进 weakmap 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。\n\nweakmap.set(john, "secret documents");\n// 如果 john 消失，secret documents 将会被自动清除\n\n\n1\n2\n\n\n# 用户访问计数\n\n🌰 例子 / 如果有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时这些数据不再需要。\n\n📃 在处理用户计数 visitcount.js 中：\n\nlet visitscountmap = new weakmap(); // weakmap: user => visits count\n\n// 递增用户来访次数\nfunction countuser(user) {\n  let count = visitscountmap.get(user) || 0;\n  visitscountmap.set(user, count + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n📃 在调用 countuser 的文件中：\n\nlet john = { name: "john" };\ncountuser(john); // count his visits\n\n// 不久之后，john 离开了\njohn = null;\n\n\n1\n2\n3\n4\n5\n\n\n> 现在， john 这个对象应该被垃圾回收。当 john 对象变成不可达时，即便它是 weakmap 里的一个键，它也会连同它作为 weakmap 里的键所对应的信息一同被从内存中删除。\n\n# 缓存\n\n存储（“缓存”）函数的结果，以便将来对同一个对象的调用可以重用这个结果。对于多次调用同一个对象，它只需在第一次调用时计算出结果，之后的调用可以直接从 cache 中获取。这样做的缺点是，当我们不再需要这个对象的时候需要清理 cache 。\n\n如果我们用 weakmap 替代 map ，便不会存在这个问题。当对象被垃圾回收时，对应缓存的结果也会被自动从内存中清除。\n\n📁 在 cache.js 中：\n\nlet cache = new weakmap();\n\n// 计算并记结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculate the result for */ obj;\n\n    cache.set(obj, result);\n  }\n\n  return cache.get(obj);\n}\n\n// 📁 main.js\nlet obj = {/* some object */};\n\nlet result1 = process(obj);\nlet result2 = process(obj);\n\n// 不再需要这个对象时：\nobj = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> 注意使用 weakmap 后无法获取 cache.size 。当 obj 被垃圾回收，缓存的数据也会被清除\n\n\n# 弱集合 weakset\n\nweakset 的表现类似：\n\n * 与 set 类似，但是只能向 weakset 添加对象（而且不能是原始值）。\n * 对象只有在其它某个（些）地方能被访问的时候，才能留在 set 中。\n * 跟 set 一样， weakset 支持 add ， has 和 delete 方法，但不支持 size 和 keys() ，并且不可迭代。\n\nset 变为弱集合 weakset 的同时，可以作为额外的存储空间。但并非针对任意数据，而是针对「是 / 否『的事实。 weakset 的元素可能代表着有关该对象的某些信息。\n\n🌰 例子 / 可以将用户添加到 weakset 中，以追踪访问过我们网站的用户：\n\nlet visitedset = new weakset();\n\nlet john = { name: "john" };\nlet pete = { name: "pete" };\nlet mary = { name: "mary" };\n\nvisitedset.add(john); // john 访问了我们\nvisitedset.add(pete); // 然后是 pete\nvisitedset.add(john); // john 再次访问\n\nconsole.log(visitedset.has(john)) // true\nconsole.log(visitedset(mary)) // false\n\njohn = null // 离开\n// visitedset 将被自动清理(即自动清除其中已失效的值 john)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 总结\n\n * weakmap 和 weakset 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 weakmap / weakset 完成其主要工作，成为在其它地方管理 / 存储「额外」的对象数据。\n   * 主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。\n * weakmap 是类似于 map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问它们，便会将它们与其关联值一同删除。\n * weakset 是类似于 set 的集合，它仅存储对象，并且一旦通过其他方式无法访问它们，便会将其删除。\n * weakmap 和 weakset 被用作「主要」对象存储之外的「辅助」数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 weakmap 或 weakset 的键，那么它将被自动清除。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔀 JavaScript 更多迭代方法",frontmatter:{title:"🔀 JavaScript 更多迭代方法",date:"2022-05-07T15:55:05.000Z",permalink:"/pages/aa670e/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/28.%20%F0%9F%94%80%20JavaScript%20%E6%9B%B4%E5%A4%9A%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/28. 🔀 JavaScript 更多迭代方法.md",key:"v-cc0ff3e4",path:"/pages/aa670e/",headers:[{level:2,title:"Object.keys / values / entries",slug:"object-keys-values-entries",normalizedTitle:"object.keys / values / entries",charIndex:133},{level:2,title:"转换对象",slug:"转换对象",normalizedTitle:"转换对象",charIndex:944}],headersStr:"Object.keys / values / entries 转换对象",content:'在 Map 中，可以使用 map.keys() ， map.values() 和 map.entries() 方法，遍历 Map 中的键值。\n\n这些方法是通用的，有一个共同的约定来将它们 用于各种数据结构。如果创建一个自定义的数据结构，也应该实现这些方法。\n\n\n# Object.keys / values / entries\n\n对于普通对象，下列这些方法是可用的：\n\n * Object.keys(obj) ：返回一个包含 该对象所有的键 的 数组。\n * Object.values(obj) ：返回一个包含 该对象所有的值 的 数组。\n * Object.entries(obj) ：返回一个包含该对象所有 [key, value] 键值对的 数组。\n\n注意两个区别：\n\n * 与 Map 的遍历方法要区别，对于对象我们使用的调用语法是 Object.keys(obj) ，而不是 obj.keys() 。\n\n> 保证对象的灵活性：在 JavaScript 中，对象是所有复杂结构的基础。因此，要创建一个对象，比如 data ，并实现了它自己的 data.values() 方法。同时，依然可以对它调用 Object.values(data) 方法。\n\n * Object.* 方法返回的是「真正的」数组对象，而不只是一个可迭代项。这主要是历史原因。\n\n🌰 例子：\n\nlet user = {\n  name: "John",\n  age: 30\n};\n\nfor(let value of Object.keys(user)){\n  console.log(value)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\nObject.keys/values/entries 会忽略 symbol 属性。就像 for..in 循环一样，这些方法会忽略使用 Symbol(...) 作为键的属性。\n\n因为 symbol 通常需要隐藏。如果想要 Symbol 类型的键，那么可以使用 Object.getOwnPropertySymbols，它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 Reflect.ownKeys(obj)，它会返回 所有 键。\n\n\n# 转换对象\n\n对象缺少数组存在的许多方法，例如 map 和 filter 等。\n\n如果在对象中应用它们，那么可以使用 Object.entries ，然后使用 Object.fromEntries ：\n\n 1. 使用 Object.entries(obj) 从 obj 获取由键 / 值对组成的数组。\n 2. 对该数组使用数组方法，例如 map ，对这些键 / 值对进行转换。\n 3. 对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。\n\n> 先转换为数组，然后使用数组的方法处理，处理后的数组转换为对象。\n\n🌰 例子 / 将带有价格的对象，将价格属性值加倍：\n\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n}\n\nlet doublePriceArr = Object.entries(prices).map((entry) => [entry[0], entry[1] * 2])\nconsole.log(doublePriceArr)\n\nlet doublePrices = Object.fromEntries(doublePriceArr)\nconsole.log(doublePrices)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 初始对象转换为数组的结果： [["banana", 1], ["orange", 2], ["meat", 4]] 。所以要处理输出应该返回一个数组包含水果名和双倍水果价钱。\n\n简化为：\n\nlet doublePrices = Object.fromEntries(Object.entries(prices).map((entry) => [entry[0], entry[1] * 2]))\nconsole.log(doublePrices)\n\n\n1\n2\n\n\n🌰 例子 / 将带有薪水信息的对象计算总和\n\n> 编写函数 sumSalaries(salaries) ，该函数使用 Object.values 和 for..of 循环返回所有薪水的总和。\n> \n> 如果 salaries 是空对象，那么结果必须是 0 。\n> \n> let salaries = {\n>   "John": 100,\n>   "Pete": 300,\n>   "Mary": 250\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction sumSalaries(salaries) {\n  let sum = 0\n  for (let salary of Object.values(salaries)) {\n    sum += salary\n  }\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n也可以通过 reduce 方法实现：\n\nfunction sumSalaries(salaries) {\n  return Object.values(salaries).reduce((sum, salary) => (sum + salary), 0)\n}\n\n\n1\n2\n3\n\n\n🌰 例子 / 返回对象中属性的数量：\n\n> 写一个函数 count(obj) ，该函数返回对象中的属性的数量：\n> \n> let user = {\n>   name: \'John\',\n>   age: 30\n> };\n> \n> alert( count(user) );\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n点击查看\n\nfunction count(obj) {\n\treturn Object.keys(obj).length\n}\n\n\n1\n2\n3\n',normalizedContent:'在 map 中，可以使用 map.keys() ， map.values() 和 map.entries() 方法，遍历 map 中的键值。\n\n这些方法是通用的，有一个共同的约定来将它们 用于各种数据结构。如果创建一个自定义的数据结构，也应该实现这些方法。\n\n\n# object.keys / values / entries\n\n对于普通对象，下列这些方法是可用的：\n\n * object.keys(obj) ：返回一个包含 该对象所有的键 的 数组。\n * object.values(obj) ：返回一个包含 该对象所有的值 的 数组。\n * object.entries(obj) ：返回一个包含该对象所有 [key, value] 键值对的 数组。\n\n注意两个区别：\n\n * 与 map 的遍历方法要区别，对于对象我们使用的调用语法是 object.keys(obj) ，而不是 obj.keys() 。\n\n> 保证对象的灵活性：在 javascript 中，对象是所有复杂结构的基础。因此，要创建一个对象，比如 data ，并实现了它自己的 data.values() 方法。同时，依然可以对它调用 object.values(data) 方法。\n\n * object.* 方法返回的是「真正的」数组对象，而不只是一个可迭代项。这主要是历史原因。\n\n🌰 例子：\n\nlet user = {\n  name: "john",\n  age: 30\n};\n\nfor(let value of object.keys(user)){\n  console.log(value)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\nobject.keys/values/entries 会忽略 symbol 属性。就像 for..in 循环一样，这些方法会忽略使用 symbol(...) 作为键的属性。\n\n因为 symbol 通常需要隐藏。如果想要 symbol 类型的键，那么可以使用 object.getownpropertysymbols，它会返回一个只包含 symbol 类型的键的数组。另外，还有一种方法 reflect.ownkeys(obj)，它会返回 所有 键。\n\n\n# 转换对象\n\n对象缺少数组存在的许多方法，例如 map 和 filter 等。\n\n如果在对象中应用它们，那么可以使用 object.entries ，然后使用 object.fromentries ：\n\n 1. 使用 object.entries(obj) 从 obj 获取由键 / 值对组成的数组。\n 2. 对该数组使用数组方法，例如 map ，对这些键 / 值对进行转换。\n 3. 对结果数组使用 object.fromentries(array) 方法，将结果转回成对象。\n\n> 先转换为数组，然后使用数组的方法处理，处理后的数组转换为对象。\n\n🌰 例子 / 将带有价格的对象，将价格属性值加倍：\n\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n}\n\nlet doublepricearr = object.entries(prices).map((entry) => [entry[0], entry[1] * 2])\nconsole.log(doublepricearr)\n\nlet doubleprices = object.fromentries(doublepricearr)\nconsole.log(doubleprices)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 初始对象转换为数组的结果： [["banana", 1], ["orange", 2], ["meat", 4]] 。所以要处理输出应该返回一个数组包含水果名和双倍水果价钱。\n\n简化为：\n\nlet doubleprices = object.fromentries(object.entries(prices).map((entry) => [entry[0], entry[1] * 2]))\nconsole.log(doubleprices)\n\n\n1\n2\n\n\n🌰 例子 / 将带有薪水信息的对象计算总和\n\n> 编写函数 sumsalaries(salaries) ，该函数使用 object.values 和 for..of 循环返回所有薪水的总和。\n> \n> 如果 salaries 是空对象，那么结果必须是 0 。\n> \n> let salaries = {\n>   "john": 100,\n>   "pete": 300,\n>   "mary": 250\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction sumsalaries(salaries) {\n  let sum = 0\n  for (let salary of object.values(salaries)) {\n    sum += salary\n  }\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n也可以通过 reduce 方法实现：\n\nfunction sumsalaries(salaries) {\n  return object.values(salaries).reduce((sum, salary) => (sum + salary), 0)\n}\n\n\n1\n2\n3\n\n\n🌰 例子 / 返回对象中属性的数量：\n\n> 写一个函数 count(obj) ，该函数返回对象中的属性的数量：\n> \n> let user = {\n>   name: \'john\',\n>   age: 30\n> };\n> \n> alert( count(user) );\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n点击查看\n\nfunction count(obj) {\n\treturn object.keys(obj).length\n}\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📶 JavaScript 解构赋值",frontmatter:{title:"📶 JavaScript 解构赋值",date:"2022-05-07T17:30:21.000Z",permalink:"/pages/62fb3f/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/29.%20%F0%9F%93%B6%20JavaScript%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/29. 📶 JavaScript 解构赋值.md",key:"v-5fdcd749",path:"/pages/62fb3f/",headers:[{level:2,title:"数组解构",slug:"数组解构",normalizedTitle:"数组解构",charIndex:129},{level:3,title:"… 剩余项",slug:"剩余项",normalizedTitle:"… 剩余项",charIndex:1403},{level:3,title:"默认值",slug:"默认值",normalizedTitle:"默认值",charIndex:1648},{level:2,title:"对象解构",slug:"对象解构",normalizedTitle:"对象解构",charIndex:2213},{level:3,title:"剩余模式",slug:"剩余模式",normalizedTitle:"剩余模式",charIndex:3808},{level:2,title:"嵌套解构",slug:"嵌套解构",normalizedTitle:"嵌套解构",charIndex:4331},{level:2,title:"智能函数参数",slug:"智能函数参数",normalizedTitle:"智能函数参数",charIndex:4848},{level:2,title:"解构总结",slug:"解构总结",normalizedTitle:"解构总结",charIndex:5920},{level:3,title:"解构实例",slug:"解构实例",normalizedTitle:"解构实例",charIndex:6245},{level:4,title:"获取最大值的对象属性",slug:"获取最大值的对象属性",normalizedTitle:"获取最大值的对象属性",charIndex:6253}],headersStr:"数组解构 … 剩余项 默认值 对象解构 剩余模式 嵌套解构 智能函数参数 解构总结 解构实例 获取最大值的对象属性",content:'在 JavaScript 中最常用的两种数据结构是 对象 Object 和 数组 Array。要将它们传递给函数，函数可能不需要 整个对象或者数组。\n\n解构赋值 是一种特殊的语法，它使我们可以将数组或对象「拆包」至一系列变量中，因为有时这样更方便。\n\n\n# 数组解构\n\n🌰 例子 / 将数组结构到变量：\n\nlet arr = ["John", "Smith"]\n\nlet [firstName, surname] = arr\n// 相当于 firstName = arr[0], surname = arr[1]\n\n\n1\n2\n3\n4\n\n\n> 在新的变量上进行的操作不会影响到原来的数组元素。\n\n🌰 例子 / 对字符串使用解构：\n\nlet [firstName, surname] = \'John Smith\'.split(\' \')\n\n\n1\n\n\n注意\n\n「解构」不意味着「破坏」：解构通过将结构中的各元素 复制 到变量中来达到「解构」的目的。但数组本身是没有被修改的。\n\n🌰 例子 / 使用「 , 」 逗号选择性赋值：：\n\nlet [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];\n// 第二个元素不需要，使用逗号跳过，并且剩下的元素没有对应变量也会被忽略\n\n\n1\n2\n\n\n🌰 例子 / 等号的右侧可以是 任何可迭代对象：\n\nlet [a, b, c] = "abc"; // ["a", "b", "c"]\nlet [one, two, three] = new Set([1, 2, 3]);\n\n\n1\n2\n\n\n🌰 例子 / 等号的左侧可以是任何「可以被赋值的」：\n\nlet user = {}\n[user.firstName, user.surname] = \'John Smith\'.split(\' \') \n\n\n1\n2\n\n\n🌰 例子 / 配合 .entries 循环（只循环其中特定的值）：\n\nlet user = {\n  name: \'Simon\'.\n  age: 30,\n  gender: \'male\'\n}\n\nfor(let [key, value] of Object.entries(user)) {\n  console.log(`${key}: ${name}`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于 Map 可迭代的对象更简单：\n\nlet user = new Map()\nuser.set(\'name\', \'Simon\')\nuser.set(\'age\', 30)\nuser.set(\'gender\', \'male\')\n\nfor(let [key, value] of user) {\n  console.log(`${key}: ${value}`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🍎 🌰 例子 / 使用解构赋值交换变量：\n\nlet guest = "Jane";\nlet admin = "Pete";\n\n[guest, admin] = [admin, guest]\n\n\n1\n2\n3\n4\n\n\n> 创建了一个由两个变量组成的临时数组，并且立即以交换了的顺序对其进行了解构。这样解决两个及以上的变量的交换一下就简单了。\n\n\n# … 剩余项\n\n当不设置相应的变量接收对应的数组项，这里剩余的数组项可以使用 … 加一个参数来接收。\n\n🌰 例子：\n\nlet [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];\n\nconsole.log(rest) // ["Consul", "of the Roman Republic"]\n\n\n1\n2\n3\n\n\n> rest 的值就是数组中剩下的元素组成的 数组。\n\n\n# 默认值\n\n如果数组比等号左边的变量列表短，这里也不会出现报错。缺少的值被认为是 undefined ：\n\n🌰 例子：\n\nlet [firstName, surname] = [];\n\nconsole.log(firstName); // undefined\nconsole.log(surname); // undefined\n\n\n1\n2\n3\n4\n\n\n对于可能没有的值，可以设置一个默认值，避免出现 undefined 。\n\n🌰 例子：\n\nlet [name = "Guest", surname = "Anonymous"] = ["Julius"];\nconsole.log(name, surname) // "Julius", "Anonymous"\n\n\n1\n2\n\n\n> 默认值可以是 更加复杂的表达式 甚至可以是 函数调用，这些表达式或函数只会在这个变量 未被赋值的时候 才会被计算。\n\n🌰 例子 / 使用函数作为默认值：\n\nlet [name = prompt(\'name?\'), surname = prompt(\'surname?\')] = ["Julius"];\n\nconsole.log(name, surname)\n\n\n1\n2\n3\n\n\n> 这样当 surname 没有提供值时，会发起输入框。\n\n\n# 对象解构\n\n基本语法：\n\nlet {var1, var2} = {var1: ..., var2: ...}\n\n\n1\n\n\n在等号右侧应该有 一个已经存在的对象，等号左侧包含了对象 相应属性的一个类对象「模式（pattern）」。在最简单的情况下，等号左侧的就是 {...} 中的变量名列表。\n\n🌰 例子：\n\nlet options = {\n  title: "Menu",\n  width: 100,\n  height: 200\n};\n\nlet {title, width, height} = options;\nconsole.log(title);  // Menu\nconsole.log(width);  // 100\nconsole.log(height); // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子 / 等号左边的模式不需要按照对象中的顺序也可以，会自动对应上。\n\nlet {height, width, title} = { title: "Menu", height: 200, width: 100 }\n\n\n1\n\n\n🌰 例子 / 等号左侧的模式可以更加复杂，并且指定了属性和变量之间的映射关系。\n\n要把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么可以使用冒号来设置变量名称：\n\nlet options = {\n  title: "Menu",\n  width: 100,\n  height: 200\n};\n\n// { sourceProperty: targetVariable }\nlet {width: w, height: h, title} = options;\n\n// width -> w\n// height -> h\n// title -> title\n\nconsole.log(w)\nconsole.log(h)\nconsole.log(title)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 冒号表示 什么值：赋值给谁 。上面的例子中，属性 width 被赋值给了 w ，属性 height 被赋值给了 h ，属性 title 被赋值给了同名变量。\n\n🌰 例子 / 对可能缺失的属性设置默认值：\n\nlet options = {\n  title: "Menu"\n};\n\nlet {width = 100, height = 200, title} = options;\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 默认值可以为任意表达式或函数调用，会在未提供对应的值时才会被计算 / 调用。\n\nlet options = {\n  title: "Menu"\n};\n\nlet {width = prompt("width?"), title = prompt("title?")} = options;\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 将 : 的使用与等号 = 结合：\n\nlet options = {\n  title: "Menu"\n};\n\nlet {width: w = 100, height: h = 200, title} = options;\n\nconsole.log(w)\nconsole.log(h)\nconsole.log(title)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子 / 只提取所需的内容：\n\nlet options = {\n  title: "Menu",\n  width: 100,\n  height: 200\n};\n\n// 仅提取 title 作为变量\nlet { title } = options;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 剩余模式\n\n使用方式与数组解构中的 ... 中类似，在对象中的 剩余模式 ，把没有提取的对象属性保存到一个对象中。\n\n🌰 例子 ：\n\nlet options = {\n  title: "Menu",\n  height: 200,\n  width: 100\n};\n\nlet {title, ...rest} = options;\nconsole.log(rest) // { height: 200, width: 100 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n() 的使用：并且要注意在 JavaScript 中 { ... } 中当做一个 代码块。这样的代码块可以用于对语句分组，就是说 { ... } 中也可以 let 声明变量并且使用。为了在对象解构时，需要 JavaScript 认为 这不是 { } 代码块而是对象 ，所以要用 ( ... ) 括号包起来（在箭头函数中返回对象时同样有用到这个原理）\n\nlet title, width, height;\n\n({title, width, height} = {title: "Menu", width: 200, height: 100});\n\n\n1\n2\n3\n\n\n\n# 嵌套解构\n\n如果一个对象或数组嵌套了其他的对象和数组，可以在等号左侧使用 更复杂的模式（pattern） 来 提取更深层的数据。\n\n🌰 例子 / 赋值语句中等号左侧的模式（pattern）具有相同的结构以从中提取值：\n\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: ["Cake", "Donut"],\n  extra: true\n};\n\nlet {\n  size: { // 把 size 赋值到这里\n    width,\n    height\n  },\n  items: [item1, item2], // 把 items 赋值到这里\n  title = "Menu" // 在对象中不存在（使用默认值）\n} = options;\n\nconsole.log(title, width, height, item1. item2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> options 的属性 size 是另一个对象，属性 items 是另一个数组。\n\n\n# 智能函数参数\n\n有时，一个函数有很多参数，其中大部分的参数都是可选的。对可能不需要提供的参数设置默认值。\n\n> 一般不可能写成：\n> \n> function showMenu(title = "Untitled", width = 200, height = 100, items = []) {\n>   // ...\n> }\n> \n> showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n🌰 例子 / 使用解构赋值，将函数参数写成对象，传入的参数也是一个对象：\n\nlet options = {\n  title: "My menu",\n  items: ["Item1", "Item2"]\n};\n\nfunction showMenu({title = "Untitled", width = 200, height = 100, items = []}) {\n  // title, items – 提取于 options，\n  // width, height – 使用默认值\n  console.log( `${title} ${width} ${height}` ); // My Menu 200 100\n  console.log(items); // Item1, Item2\n}\n\nshowMenu(options) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 更详细的语法与结构相同：\n> \n> function({\n>   incomingProperty: varName = defaultValue\n>   ...\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 对于参数中的对象，属性 incomingProperty 对应的变量是 varName ，默认值是 defaultValue 。\n\n如果想要所有参数对象属性都使用默认值，要传入一个空的对象：\n\nshowMenu({})\n\n\n1\n\n\n要什么都不传，可以为该 参数对象设一个默认值：\n\nfunction showMenu({ title = "Menu", width = 100, height = 200 } = {}) {\n  alert( `${title} ${width} ${height}` );\n}\n\nshowMenu()\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解构总结\n\n * 解构赋值可以立即将一个对象或数组映射到多个变量上。\n\n * 解构数组： let [item1 = default, item2, ...rest] = array 。数组的第一个元素被赋值给 item1 ，第二个元素被赋值给 item2 ，剩下的所有元素被复制到另一个数组 rest 。`\n\n * 解构对象： let {prop : varName = default, ...rest} = object 。属性 prop 会被赋值给变量 varName ，如果没有这个属性的话，就会使用默认值 default 。没有对应映射的对象属性会被复制到 rest 对象。\n\n * 嵌套解构：等号左侧必须和等号右侧有相同的结构。\n\n\n# 解构实例\n\n# 获取最大值的对象属性\n\n> 新建一个函数 topSalary(salaries) ，返回收入最高的人的姓名。\n> \n>  * 如果 salaries 是空的，函数应该返回 null 。\n>  * 如果有多个收入最高的人，返回其中任意一个即可。\n> \n> let salaries = {\n>   "John": 100,\n>   "Pete": 300,\n>   "Mary": 250\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction topSalary(salaries) {\n\tlet maxSalary = 0\n  let maxName = null\n  \n  for (let [name, salary] of Object.entries(salaries)){\n  \tif(maxSalary < salary){ \n    \tmaxSalary = salary\n      maxName = name}\n  }\n  return maxName\n}\n\nconsole.log(topSalary(salaries))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'在 javascript 中最常用的两种数据结构是 对象 object 和 数组 array。要将它们传递给函数，函数可能不需要 整个对象或者数组。\n\n解构赋值 是一种特殊的语法，它使我们可以将数组或对象「拆包」至一系列变量中，因为有时这样更方便。\n\n\n# 数组解构\n\n🌰 例子 / 将数组结构到变量：\n\nlet arr = ["john", "smith"]\n\nlet [firstname, surname] = arr\n// 相当于 firstname = arr[0], surname = arr[1]\n\n\n1\n2\n3\n4\n\n\n> 在新的变量上进行的操作不会影响到原来的数组元素。\n\n🌰 例子 / 对字符串使用解构：\n\nlet [firstname, surname] = \'john smith\'.split(\' \')\n\n\n1\n\n\n注意\n\n「解构」不意味着「破坏」：解构通过将结构中的各元素 复制 到变量中来达到「解构」的目的。但数组本身是没有被修改的。\n\n🌰 例子 / 使用「 , 」 逗号选择性赋值：：\n\nlet [firstname, , title] = ["julius", "caesar", "consul", "of the roman republic"];\n// 第二个元素不需要，使用逗号跳过，并且剩下的元素没有对应变量也会被忽略\n\n\n1\n2\n\n\n🌰 例子 / 等号的右侧可以是 任何可迭代对象：\n\nlet [a, b, c] = "abc"; // ["a", "b", "c"]\nlet [one, two, three] = new set([1, 2, 3]);\n\n\n1\n2\n\n\n🌰 例子 / 等号的左侧可以是任何「可以被赋值的」：\n\nlet user = {}\n[user.firstname, user.surname] = \'john smith\'.split(\' \') \n\n\n1\n2\n\n\n🌰 例子 / 配合 .entries 循环（只循环其中特定的值）：\n\nlet user = {\n  name: \'simon\'.\n  age: 30,\n  gender: \'male\'\n}\n\nfor(let [key, value] of object.entries(user)) {\n  console.log(`${key}: ${name}`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于 map 可迭代的对象更简单：\n\nlet user = new map()\nuser.set(\'name\', \'simon\')\nuser.set(\'age\', 30)\nuser.set(\'gender\', \'male\')\n\nfor(let [key, value] of user) {\n  console.log(`${key}: ${value}`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🍎 🌰 例子 / 使用解构赋值交换变量：\n\nlet guest = "jane";\nlet admin = "pete";\n\n[guest, admin] = [admin, guest]\n\n\n1\n2\n3\n4\n\n\n> 创建了一个由两个变量组成的临时数组，并且立即以交换了的顺序对其进行了解构。这样解决两个及以上的变量的交换一下就简单了。\n\n\n# … 剩余项\n\n当不设置相应的变量接收对应的数组项，这里剩余的数组项可以使用 … 加一个参数来接收。\n\n🌰 例子：\n\nlet [name1, name2, ...rest] = ["julius", "caesar", "consul", "of the roman republic"];\n\nconsole.log(rest) // ["consul", "of the roman republic"]\n\n\n1\n2\n3\n\n\n> rest 的值就是数组中剩下的元素组成的 数组。\n\n\n# 默认值\n\n如果数组比等号左边的变量列表短，这里也不会出现报错。缺少的值被认为是 undefined ：\n\n🌰 例子：\n\nlet [firstname, surname] = [];\n\nconsole.log(firstname); // undefined\nconsole.log(surname); // undefined\n\n\n1\n2\n3\n4\n\n\n对于可能没有的值，可以设置一个默认值，避免出现 undefined 。\n\n🌰 例子：\n\nlet [name = "guest", surname = "anonymous"] = ["julius"];\nconsole.log(name, surname) // "julius", "anonymous"\n\n\n1\n2\n\n\n> 默认值可以是 更加复杂的表达式 甚至可以是 函数调用，这些表达式或函数只会在这个变量 未被赋值的时候 才会被计算。\n\n🌰 例子 / 使用函数作为默认值：\n\nlet [name = prompt(\'name?\'), surname = prompt(\'surname?\')] = ["julius"];\n\nconsole.log(name, surname)\n\n\n1\n2\n3\n\n\n> 这样当 surname 没有提供值时，会发起输入框。\n\n\n# 对象解构\n\n基本语法：\n\nlet {var1, var2} = {var1: ..., var2: ...}\n\n\n1\n\n\n在等号右侧应该有 一个已经存在的对象，等号左侧包含了对象 相应属性的一个类对象「模式（pattern）」。在最简单的情况下，等号左侧的就是 {...} 中的变量名列表。\n\n🌰 例子：\n\nlet options = {\n  title: "menu",\n  width: 100,\n  height: 200\n};\n\nlet {title, width, height} = options;\nconsole.log(title);  // menu\nconsole.log(width);  // 100\nconsole.log(height); // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子 / 等号左边的模式不需要按照对象中的顺序也可以，会自动对应上。\n\nlet {height, width, title} = { title: "menu", height: 200, width: 100 }\n\n\n1\n\n\n🌰 例子 / 等号左侧的模式可以更加复杂，并且指定了属性和变量之间的映射关系。\n\n要把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么可以使用冒号来设置变量名称：\n\nlet options = {\n  title: "menu",\n  width: 100,\n  height: 200\n};\n\n// { sourceproperty: targetvariable }\nlet {width: w, height: h, title} = options;\n\n// width -> w\n// height -> h\n// title -> title\n\nconsole.log(w)\nconsole.log(h)\nconsole.log(title)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 冒号表示 什么值：赋值给谁 。上面的例子中，属性 width 被赋值给了 w ，属性 height 被赋值给了 h ，属性 title 被赋值给了同名变量。\n\n🌰 例子 / 对可能缺失的属性设置默认值：\n\nlet options = {\n  title: "menu"\n};\n\nlet {width = 100, height = 200, title} = options;\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 默认值可以为任意表达式或函数调用，会在未提供对应的值时才会被计算 / 调用。\n\nlet options = {\n  title: "menu"\n};\n\nlet {width = prompt("width?"), title = prompt("title?")} = options;\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 将 : 的使用与等号 = 结合：\n\nlet options = {\n  title: "menu"\n};\n\nlet {width: w = 100, height: h = 200, title} = options;\n\nconsole.log(w)\nconsole.log(h)\nconsole.log(title)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子 / 只提取所需的内容：\n\nlet options = {\n  title: "menu",\n  width: 100,\n  height: 200\n};\n\n// 仅提取 title 作为变量\nlet { title } = options;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 剩余模式\n\n使用方式与数组解构中的 ... 中类似，在对象中的 剩余模式 ，把没有提取的对象属性保存到一个对象中。\n\n🌰 例子 ：\n\nlet options = {\n  title: "menu",\n  height: 200,\n  width: 100\n};\n\nlet {title, ...rest} = options;\nconsole.log(rest) // { height: 200, width: 100 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n() 的使用：并且要注意在 javascript 中 { ... } 中当做一个 代码块。这样的代码块可以用于对语句分组，就是说 { ... } 中也可以 let 声明变量并且使用。为了在对象解构时，需要 javascript 认为 这不是 { } 代码块而是对象 ，所以要用 ( ... ) 括号包起来（在箭头函数中返回对象时同样有用到这个原理）\n\nlet title, width, height;\n\n({title, width, height} = {title: "menu", width: 200, height: 100});\n\n\n1\n2\n3\n\n\n\n# 嵌套解构\n\n如果一个对象或数组嵌套了其他的对象和数组，可以在等号左侧使用 更复杂的模式（pattern） 来 提取更深层的数据。\n\n🌰 例子 / 赋值语句中等号左侧的模式（pattern）具有相同的结构以从中提取值：\n\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: ["cake", "donut"],\n  extra: true\n};\n\nlet {\n  size: { // 把 size 赋值到这里\n    width,\n    height\n  },\n  items: [item1, item2], // 把 items 赋值到这里\n  title = "menu" // 在对象中不存在（使用默认值）\n} = options;\n\nconsole.log(title, width, height, item1. item2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> options 的属性 size 是另一个对象，属性 items 是另一个数组。\n\n\n# 智能函数参数\n\n有时，一个函数有很多参数，其中大部分的参数都是可选的。对可能不需要提供的参数设置默认值。\n\n> 一般不可能写成：\n> \n> function showmenu(title = "untitled", width = 200, height = 100, items = []) {\n>   // ...\n> }\n> \n> showmenu("my menu", undefined, undefined, ["item1", "item2"])\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n🌰 例子 / 使用解构赋值，将函数参数写成对象，传入的参数也是一个对象：\n\nlet options = {\n  title: "my menu",\n  items: ["item1", "item2"]\n};\n\nfunction showmenu({title = "untitled", width = 200, height = 100, items = []}) {\n  // title, items – 提取于 options，\n  // width, height – 使用默认值\n  console.log( `${title} ${width} ${height}` ); // my menu 200 100\n  console.log(items); // item1, item2\n}\n\nshowmenu(options) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 更详细的语法与结构相同：\n> \n> function({\n>   incomingproperty: varname = defaultvalue\n>   ...\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 对于参数中的对象，属性 incomingproperty 对应的变量是 varname ，默认值是 defaultvalue 。\n\n如果想要所有参数对象属性都使用默认值，要传入一个空的对象：\n\nshowmenu({})\n\n\n1\n\n\n要什么都不传，可以为该 参数对象设一个默认值：\n\nfunction showmenu({ title = "menu", width = 100, height = 200 } = {}) {\n  alert( `${title} ${width} ${height}` );\n}\n\nshowmenu()\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解构总结\n\n * 解构赋值可以立即将一个对象或数组映射到多个变量上。\n\n * 解构数组： let [item1 = default, item2, ...rest] = array 。数组的第一个元素被赋值给 item1 ，第二个元素被赋值给 item2 ，剩下的所有元素被复制到另一个数组 rest 。`\n\n * 解构对象： let {prop : varname = default, ...rest} = object 。属性 prop 会被赋值给变量 varname ，如果没有这个属性的话，就会使用默认值 default 。没有对应映射的对象属性会被复制到 rest 对象。\n\n * 嵌套解构：等号左侧必须和等号右侧有相同的结构。\n\n\n# 解构实例\n\n# 获取最大值的对象属性\n\n> 新建一个函数 topsalary(salaries) ，返回收入最高的人的姓名。\n> \n>  * 如果 salaries 是空的，函数应该返回 null 。\n>  * 如果有多个收入最高的人，返回其中任意一个即可。\n> \n> let salaries = {\n>   "john": 100,\n>   "pete": 300,\n>   "mary": 250\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction topsalary(salaries) {\n\tlet maxsalary = 0\n  let maxname = null\n  \n  for (let [name, salary] of object.entries(salaries)){\n  \tif(maxsalary < salary){ \n    \tmaxsalary = salary\n      maxname = name}\n  }\n  return maxname\n}\n\nconsole.log(topsalary(salaries))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🆕 JavaScript 日期和时间",frontmatter:{title:"🆕 JavaScript 日期和时间",date:"2022-05-05T17:42:01.000Z",permalink:"/pages/3f5e62/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/30.%20%F0%9F%86%95%20JavaScript%20%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/30. 🆕 JavaScript 日期和时间.md",key:"v-358d30aa",path:"/pages/3f5e62/",headers:[{level:2,title:"创建 Date 对象",slug:"创建-date-对象",normalizedTitle:"创建 date 对象",charIndex:86},{level:2,title:"访问日期 / 时间组件（方法）",slug:"访问日期-时间组件-方法",normalizedTitle:"访问日期 / 时间组件（方法）",charIndex:1166},{level:2,title:"设置时间组件",slug:"设置时间组件",normalizedTitle:"设置时间组件",charIndex:1851},{level:2,title:"日期的自动校准特性",slug:"日期的自动校准特性",normalizedTitle:"日期的自动校准特性",charIndex:2329},{level:3,title:"计算差值",slug:"计算差值",normalizedTitle:"计算差值",charIndex:2718},{level:2,title:"Date.now()",slug:"date-now",normalizedTitle:"date.now()",charIndex:3089},{level:2,title:"度量",slug:"度量",normalizedTitle:"度量",charIndex:3291},{level:2,title:"Date.parse",slug:"date-parse",normalizedTitle:"date.parse",charIndex:583},{level:2,title:"日期和时间总结",slug:"日期和时间总结",normalizedTitle:"日期和时间总结",charIndex:5353},{level:3,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:5441},{level:4,title:"转换为星期",slug:"转换为星期",normalizedTitle:"转换为星期",charIndex:5447},{level:4,title:"计算 X 天之前的日期",slug:"计算-x-天之前的日期",normalizedTitle:"计算 x 天之前的日期",charIndex:5681},{level:4,title:"今年过去了多久（进度）",slug:"今年过去了多久-进度",normalizedTitle:"今年过去了多久（进度）",charIndex:6090}],headersStr:"创建 Date 对象 访问日期 / 时间组件（方法） 设置时间组件 日期的自动校准特性 计算差值 Date.now() 度量 Date.parse 日期和时间总结 实例 转换为星期 计算 X 天之前的日期 今年过去了多久（进度）",content:"JavaScript 中内置对象中 ，提供了存储日期时间、管理日期时间的对象 Date ，可以存储创建 / 修改时间，或者用来测量时间，再或者仅用来打印当前时间。\n\n\n# 创建 Date 对象\n\n * 不带参数创建，创建一个表示 当前日期和时间 的 Date 对象：\n   \n   let now = new Date();\n   \n   \n   1\n   \n\n * new Date(milliseconds) ：传入的 整数参数 （时间戳）为基于 1970 年 1 月 1 日 UTC+0 之后经过的 毫秒数：\n   \n   let Jan01_1970 = new Date(0);\n   \n   \n   1\n   \n   \n   > 时间戳：是一种日期的轻量级数字表示形式。通常使用 new Date(timestamp) 通过时间戳来创建日期，并可以使用 date.getTime() 将现有的 Date 对象转化为时间戳。\n   \n   时间戳可以为负数，同样基于 1970 年 1 月 1 日 UTC+0，向后推的时间：\n   \n   let Dec31_1969 = new Date(-24 * 3600 * 1000); \n   \n   \n   1\n   \n\n * new Date(datestring) ：传入字符串，会被自动解析。该算法与 Date.parse 所使用的算法相同。\n   \n   let date = new Date(\"2022-01-01\");\n   console.log(date)\n   \n   \n   1\n   2\n   \n\n * new Date(year, month, date, hours, minutes, seconds, ms) ：使用当前时区中的给定组件创建日期。只有 前两个参数是必须的。\n   \n   * year 必须是四位数。\n   * month 范围是 0 （一月）～ 11 （十二月 ）。\n   * date 是当月的具体某一天，如果缺失，则为默认值 1 。\n   * 如果 hours / minutes / seconds / ms 缺失，则均为默认值 0 。\n   \n   new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00\n   new Date(2011, 0, 1); // 同样，时分秒等均为默认值 0\n   \n   \n   1\n   2\n   \n   \n   时分秒的精度最大精确到 毫秒（1 / 1000 秒）：\n   \n   let date = new Date(2011, 0, 1, 2, 3, 4, 567);\n   \n   \n   1\n   \n\n\n# 访问日期 / 时间组件（方法）\n\nDate() 对象中提供获取日期的多种方法：\n\n * getFullYear() ：获取 4 位数的年份。\n * getMonth ：获取月份（同样范围为 0 ～ 11 。\n * getDate() ：获取当月的具体日期。（范围为 1 ～ 31 ）。🍎 不要与 Date 对象混淆。\n * getDay() ：获取一周中的第几天（范围为 0 （星期日）～ 6 （星期六） 比月份好理解）\n * getHours() / getMinutes() / getSeconds() / getMilliseconds() ：获取时间的组件。\n\n注意\n\n要获取年份就使用 getFullYear() 。不要使用不规范的 getYear() 。\n\n提示\n\n以上的所有方法返回的组件都是基于当地时区的。\n\n基于 UTC+0 时区的日、月、年等：getUTCFullYear()，getUTCMonth()，getUTCDay()。只需要在 \"get\" 之后插入 \"UTC\" 即可。\n\n但是 getTime() 、 getTimezoneOffset 没有 UTC 变体。\n\n * getTime() ：返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。\n\n * getTimezoneOffset() ：返回 UTC 与本地时区之间的时差，以分钟为单位： new Date().getTimezoneOffset() 。\n   \n   北京时间 （UTC + 8） 返回 -480 。\n\n\n# 设置时间组件\n\n设置日期 / 时间组件：\n\n * setFullYear(year, [month], [date])\n * setMonth(month, [date])\n * setDate(date)\n * setHours(hour, [min], [sec], [ms])\n * setMinutes(min, [sec], [ms])\n * setSeconds(sec, [ms])\n * setMilliseconds(ms)\n * setTime(milliseconds) ：基于 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期。\n\n以上方法除了 setTime() 都有 UTC 变体，例如： setUTCHours() 。\n\n🌰 例子 / 一次性设置多个组件：\n\nlet today = new Date();\n\ntoday.setHours(0); // 小时数为 0\ntoday.setHours(0, 0, 0, 0); // 同时设置时分秒 00:00:00\n\n\n1\n2\n3\n4\n\n\n\n# 日期的自动校准特性\n\n设置了超出常理的日期范围， Date 对象会自动校准，超出范围的日期组件将会被自动分配响应的日期。\n\n🌰 例子：\n\nlet date = new Date(2013, 0, 32); // 2013-01-32? 2013-2-1\nconsole.log(date) // 矫正为 1st Feb 2013\n\n\n1\n2\n\n\n🌰 例子 / Date 对象处理闰年：\n\nlet date = new Date(2016, 1, 28); // 2月28日\ndate.setDate(date.getDate() + 2); \n\n\n1\n2\n\n\n🌰 例子 / 常用与计算 … 之后 / 之前的日期：\n\nlet date = new Date();\ndate.setYear(date.getFullYear() + 700); // \n\n\n1\n2\n\n\n\n# 计算差值\n\n当 Date 对象被转化为数字时，得到的是对应的 时间戳，与使用 date.getTime() 的结果相同：\n\nlet date = new Date();\nalert(+date);\n\n\n1\n2\n\n\n得到的时间戳可以用来计算日期的差值，以毫秒为单位时间差：\n\n🌰 例子 / 测量算法用时 ：\n\nlet start = new Date(); \n\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\nlet end = new Date(); \n\nconsole.log(`The loop took ${end - start} ms`)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 使用 new Date() 测量并不精准。\n\n\n# Date.now()\n\n如果仅仅想要测量时间间隔，不需要 Date 对象。特殊的方法 Date.now() ，它会 返回当前的时间戳。相当于 new Date().getTime() ，但它 不会创建中间的 Date 对象。因此它更快，而且不会对垃圾处理造成额外的压力。\n\n这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 JavaScript 编写游戏或其他的特殊应用场景。\n\n\n# 度量\n\n🌰 例子 / 判断两个计算日期差值的函数：\n\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 两种方法的结果一样，做的事情完全相同。但是其中一个函数使用显性的 date.getTime() 来获取 毫秒形式 的日期，另一个则依赖于「日期 — 数字」的转换。\n\n测试后发现， getTime() 会比 需要日期转换的方法快，因为类型转换带来了时间开销。\n\n🌰 例子 / 使用多进程测试度量：为了得到更加可靠的度量，整个度量测试包应该重新运行多次。\n\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nlet time1 = 0;\nlet time2 = 0;\n\n// 交替运行 bench(diffSubtract) 和 bench(diffGetTime) 各 10 次\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n\nconsole.log( 'Total time for diffSubtract: ' + time1 );\nconsole.log( 'Total time for diffGetTime: ' + time2 );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n> 当运行 bench(diffSubtract) 的同时，CPU 还在并行处理其他事务，并且这也会占用资源。然而，运行 bench(diffGetTime) 的时候，并行处理的事务完成了。\n\n现代的 JavaScript 引擎的先进优化策略只对执行很多次的 「hot code」 有效（对于执行很少次数的代码没有必要优化）。因此在上面的例子中，第一次执行的优化程度不高。可能需要增加一个升温步骤：\n\n// 在主循环中增加“升温”环节\nbench(diffSubtract);\nbench(diffGetTime);\n\n// 开始度量\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n提示\n\n进行微度量测试时要小心：现代的 JavaScript 引擎执行了很多优化。与「正常使用」相比，它们可能会改变「人为测试」的结果，特别是在对很细微的东西进行度量测试时，例如 operator 的工作方式或内建函数。\n\n\n# Date.parse\n\n转换字符串为 Date 对象可以使用该方法。字符串的格式应该为： YYYY-MM-DDTHH:mm:ss.sssZ ，其中：\n\n * YYYY-MM-DD —— 日期： 年-月-日 。\n * 字符 \"T\" 是一个分隔符。\n * HH:mm:ss.sss —— 时间：小时，分钟，秒，毫秒。\n * 可选字符 'Z' 为 +-hh:mm 格式的时区。单个字符 Z 代表 UTC+0 时区。\n\n一般可以直接使用简短形式： YYYY-MM-DD 或 YYYY-MM 、 YYYY 。\n\nDate.parse(str) 调用会解析给定格式的字符串，并返回 时间戳。如果给定字符串的 格式不正确，则返回 NaN 。\n\n🌰 例子：\n\nlet ms = Date.parse('2022-01-01');\nconsole.log(ms) // 1640995200000\n\n\n1\n2\n\n\n🌰 例子 / 通过时间戳创建 Date 对象：\n\nlet date = new Date(Date.parse('2022-01-01'))\n\n\n1\n\n\n\n# 日期和时间总结\n\n * JavaScript 中使用 Date 对象表示日期和时间，包括两者信息。\n * 使用 Date.now() 可以更快地获取当前时间的时间戳。\n\n\n# 实例\n\n# 转换为星期\n\n> 编写一个函数将日期转换为 「星期 X 」类型的日期类型。\n\n点击查看\n\nfunction getWeekdays(date) {\n  let weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六', ]\n  return weekdays[date.getDay()]\n}\n\nconsole.log(getWeekdays(new Date()))\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 计算 X 天之前的日期\n\n> 写一个函数 getDateAgo(date, days) ，返回特定日期 date 往前 days 天是哪个月的哪一天。\n> \n> 假设今天是 20 号，那么 getDateAgo(new Date(), 1) 的结果应该是 19 号， getDateAgo(new Date(), 2) 的结果应该是 18 号。能实现跨月、跨年。\n\n点击查看\n\nfunction getDateAgo(date, days) {\n\tlet dateCopy = new Date(date)\n  \n  dateCopy.setDate(date.getDate() - days)\n  return dateCopy.getDate()\n}\n\nlet date = new Date()\nconsole.log(getDateAgo(date, 2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 今年过去了多久（进度）\n\n点击查看\n\nfunction getYearProgress() {\n\tlet now = new Date()\n  let yearFirstDay = new Date(now.getFullYear().toString())\n  let progress = (((now - yearFirstDay) / (1000 * 60 * 60 * 24 * 365)) * 100).toFixed(2) + '% / 100%'\n  return progress\n}\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"javascript 中内置对象中 ，提供了存储日期时间、管理日期时间的对象 date ，可以存储创建 / 修改时间，或者用来测量时间，再或者仅用来打印当前时间。\n\n\n# 创建 date 对象\n\n * 不带参数创建，创建一个表示 当前日期和时间 的 date 对象：\n   \n   let now = new date();\n   \n   \n   1\n   \n\n * new date(milliseconds) ：传入的 整数参数 （时间戳）为基于 1970 年 1 月 1 日 utc+0 之后经过的 毫秒数：\n   \n   let jan01_1970 = new date(0);\n   \n   \n   1\n   \n   \n   > 时间戳：是一种日期的轻量级数字表示形式。通常使用 new date(timestamp) 通过时间戳来创建日期，并可以使用 date.gettime() 将现有的 date 对象转化为时间戳。\n   \n   时间戳可以为负数，同样基于 1970 年 1 月 1 日 utc+0，向后推的时间：\n   \n   let dec31_1969 = new date(-24 * 3600 * 1000); \n   \n   \n   1\n   \n\n * new date(datestring) ：传入字符串，会被自动解析。该算法与 date.parse 所使用的算法相同。\n   \n   let date = new date(\"2022-01-01\");\n   console.log(date)\n   \n   \n   1\n   2\n   \n\n * new date(year, month, date, hours, minutes, seconds, ms) ：使用当前时区中的给定组件创建日期。只有 前两个参数是必须的。\n   \n   * year 必须是四位数。\n   * month 范围是 0 （一月）～ 11 （十二月 ）。\n   * date 是当月的具体某一天，如果缺失，则为默认值 1 。\n   * 如果 hours / minutes / seconds / ms 缺失，则均为默认值 0 。\n   \n   new date(2011, 0, 1, 0, 0, 0, 0); // 1 jan 2011, 00:00:00\n   new date(2011, 0, 1); // 同样，时分秒等均为默认值 0\n   \n   \n   1\n   2\n   \n   \n   时分秒的精度最大精确到 毫秒（1 / 1000 秒）：\n   \n   let date = new date(2011, 0, 1, 2, 3, 4, 567);\n   \n   \n   1\n   \n\n\n# 访问日期 / 时间组件（方法）\n\ndate() 对象中提供获取日期的多种方法：\n\n * getfullyear() ：获取 4 位数的年份。\n * getmonth ：获取月份（同样范围为 0 ～ 11 。\n * getdate() ：获取当月的具体日期。（范围为 1 ～ 31 ）。🍎 不要与 date 对象混淆。\n * getday() ：获取一周中的第几天（范围为 0 （星期日）～ 6 （星期六） 比月份好理解）\n * gethours() / getminutes() / getseconds() / getmilliseconds() ：获取时间的组件。\n\n注意\n\n要获取年份就使用 getfullyear() 。不要使用不规范的 getyear() 。\n\n提示\n\n以上的所有方法返回的组件都是基于当地时区的。\n\n基于 utc+0 时区的日、月、年等：getutcfullyear()，getutcmonth()，getutcday()。只需要在 \"get\" 之后插入 \"utc\" 即可。\n\n但是 gettime() 、 gettimezoneoffset 没有 utc 变体。\n\n * gettime() ：返回日期的时间戳 —— 从 1970-1-1 00:00:00 utc+0 开始到现在所经过的毫秒数。\n\n * gettimezoneoffset() ：返回 utc 与本地时区之间的时差，以分钟为单位： new date().gettimezoneoffset() 。\n   \n   北京时间 （utc + 8） 返回 -480 。\n\n\n# 设置时间组件\n\n设置日期 / 时间组件：\n\n * setfullyear(year, [month], [date])\n * setmonth(month, [date])\n * setdate(date)\n * sethours(hour, [min], [sec], [ms])\n * setminutes(min, [sec], [ms])\n * setseconds(sec, [ms])\n * setmilliseconds(ms)\n * settime(milliseconds) ：基于 1970-01-01 00:00:00 utc+0 以来的毫秒数来设置整个日期。\n\n以上方法除了 settime() 都有 utc 变体，例如： setutchours() 。\n\n🌰 例子 / 一次性设置多个组件：\n\nlet today = new date();\n\ntoday.sethours(0); // 小时数为 0\ntoday.sethours(0, 0, 0, 0); // 同时设置时分秒 00:00:00\n\n\n1\n2\n3\n4\n\n\n\n# 日期的自动校准特性\n\n设置了超出常理的日期范围， date 对象会自动校准，超出范围的日期组件将会被自动分配响应的日期。\n\n🌰 例子：\n\nlet date = new date(2013, 0, 32); // 2013-01-32? 2013-2-1\nconsole.log(date) // 矫正为 1st feb 2013\n\n\n1\n2\n\n\n🌰 例子 / date 对象处理闰年：\n\nlet date = new date(2016, 1, 28); // 2月28日\ndate.setdate(date.getdate() + 2); \n\n\n1\n2\n\n\n🌰 例子 / 常用与计算 … 之后 / 之前的日期：\n\nlet date = new date();\ndate.setyear(date.getfullyear() + 700); // \n\n\n1\n2\n\n\n\n# 计算差值\n\n当 date 对象被转化为数字时，得到的是对应的 时间戳，与使用 date.gettime() 的结果相同：\n\nlet date = new date();\nalert(+date);\n\n\n1\n2\n\n\n得到的时间戳可以用来计算日期的差值，以毫秒为单位时间差：\n\n🌰 例子 / 测量算法用时 ：\n\nlet start = new date(); \n\nfor (let i = 0; i < 100000; i++) {\n  let dosomething = i * i * i;\n}\n\nlet end = new date(); \n\nconsole.log(`the loop took ${end - start} ms`)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 使用 new date() 测量并不精准。\n\n\n# date.now()\n\n如果仅仅想要测量时间间隔，不需要 date 对象。特殊的方法 date.now() ，它会 返回当前的时间戳。相当于 new date().gettime() ，但它 不会创建中间的 date 对象。因此它更快，而且不会对垃圾处理造成额外的压力。\n\n这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 javascript 编写游戏或其他的特殊应用场景。\n\n\n# 度量\n\n🌰 例子 / 判断两个计算日期差值的函数：\n\nfunction diffsubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffgettime(date1, date2) {\n  return date2.gettime() - date1.gettime();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 两种方法的结果一样，做的事情完全相同。但是其中一个函数使用显性的 date.gettime() 来获取 毫秒形式 的日期，另一个则依赖于「日期 — 数字」的转换。\n\n测试后发现， gettime() 会比 需要日期转换的方法快，因为类型转换带来了时间开销。\n\n🌰 例子 / 使用多进程测试度量：为了得到更加可靠的度量，整个度量测试包应该重新运行多次。\n\nfunction diffsubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffgettime(date1, date2) {\n  return date2.gettime() - date1.gettime();\n}\n\nfunction bench(f) {\n  let date1 = new date(0);\n  let date2 = new date();\n\n  let start = date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return date.now() - start;\n}\n\nlet time1 = 0;\nlet time2 = 0;\n\n// 交替运行 bench(diffsubtract) 和 bench(diffgettime) 各 10 次\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffsubtract);\n  time2 += bench(diffgettime);\n}\n\nconsole.log( 'total time for diffsubtract: ' + time1 );\nconsole.log( 'total time for diffgettime: ' + time2 );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n> 当运行 bench(diffsubtract) 的同时，cpu 还在并行处理其他事务，并且这也会占用资源。然而，运行 bench(diffgettime) 的时候，并行处理的事务完成了。\n\n现代的 javascript 引擎的先进优化策略只对执行很多次的 「hot code」 有效（对于执行很少次数的代码没有必要优化）。因此在上面的例子中，第一次执行的优化程度不高。可能需要增加一个升温步骤：\n\n// 在主循环中增加“升温”环节\nbench(diffsubtract);\nbench(diffgettime);\n\n// 开始度量\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffsubtract);\n  time2 += bench(diffgettime);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n提示\n\n进行微度量测试时要小心：现代的 javascript 引擎执行了很多优化。与「正常使用」相比，它们可能会改变「人为测试」的结果，特别是在对很细微的东西进行度量测试时，例如 operator 的工作方式或内建函数。\n\n\n# date.parse\n\n转换字符串为 date 对象可以使用该方法。字符串的格式应该为： yyyy-mm-ddthh:mm:ss.sssz ，其中：\n\n * yyyy-mm-dd —— 日期： 年-月-日 。\n * 字符 \"t\" 是一个分隔符。\n * hh:mm:ss.sss —— 时间：小时，分钟，秒，毫秒。\n * 可选字符 'z' 为 +-hh:mm 格式的时区。单个字符 z 代表 utc+0 时区。\n\n一般可以直接使用简短形式： yyyy-mm-dd 或 yyyy-mm 、 yyyy 。\n\ndate.parse(str) 调用会解析给定格式的字符串，并返回 时间戳。如果给定字符串的 格式不正确，则返回 nan 。\n\n🌰 例子：\n\nlet ms = date.parse('2022-01-01');\nconsole.log(ms) // 1640995200000\n\n\n1\n2\n\n\n🌰 例子 / 通过时间戳创建 date 对象：\n\nlet date = new date(date.parse('2022-01-01'))\n\n\n1\n\n\n\n# 日期和时间总结\n\n * javascript 中使用 date 对象表示日期和时间，包括两者信息。\n * 使用 date.now() 可以更快地获取当前时间的时间戳。\n\n\n# 实例\n\n# 转换为星期\n\n> 编写一个函数将日期转换为 「星期 x 」类型的日期类型。\n\n点击查看\n\nfunction getweekdays(date) {\n  let weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六', ]\n  return weekdays[date.getday()]\n}\n\nconsole.log(getweekdays(new date()))\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 计算 x 天之前的日期\n\n> 写一个函数 getdateago(date, days) ，返回特定日期 date 往前 days 天是哪个月的哪一天。\n> \n> 假设今天是 20 号，那么 getdateago(new date(), 1) 的结果应该是 19 号， getdateago(new date(), 2) 的结果应该是 18 号。能实现跨月、跨年。\n\n点击查看\n\nfunction getdateago(date, days) {\n\tlet datecopy = new date(date)\n  \n  datecopy.setdate(date.getdate() - days)\n  return datecopy.getdate()\n}\n\nlet date = new date()\nconsole.log(getdateago(date, 2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 今年过去了多久（进度）\n\n点击查看\n\nfunction getyearprogress() {\n\tlet now = new date()\n  let yearfirstday = new date(now.getfullyear().tostring())\n  let progress = (((now - yearfirstday) / (1000 * 60 * 60 * 24 * 365)) * 100).tofixed(2) + '% / 100%'\n  return progress\n}\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🈁 JavaScript 与 JSON",frontmatter:{title:"🈁 JavaScript 与 JSON",date:"2022-05-05T17:42:19.000Z",permalink:"/pages/cf5da1/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/31.%20%F0%9F%88%81%20JavaScript%20%E4%B8%8E%20JSON.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/31. 🈁 JavaScript 与 JSON.md",key:"v-af0f602e",path:"/pages/cf5da1/",headers:[{level:2,title:"JSON.stringfy",slug:"json-stringfy",normalizedTitle:"json.stringfy",charIndex:84},{level:3,title:"replacer",slug:"replacer",normalizedTitle:"replacer",charIndex:1598},{level:2,title:"space 格式化",slug:"space-格式化",normalizedTitle:"space 格式化",charIndex:3183},{level:2,title:"toJSON",slug:"tojson",normalizedTitle:"tojson",charIndex:3262},{level:2,title:"JSON.parse",slug:"json-parse",normalizedTitle:"json.parse",charIndex:55},{level:3,title:"receiver",slug:"receiver",normalizedTitle:"receiver",charIndex:4165},{level:2,title:"JSON 总结",slug:"json-总结",normalizedTitle:"json 总结",charIndex:4845}],headersStr:"JSON.stringfy replacer space 格式化 toJSON JSON.parse receiver JSON 总结",content:'JavaScript 提供了如下方法：\n\n * JSON.stringify 将对象转换为 JSON。\n * JSON.parse 将 JSON 转换回对象。\n\n\n# JSON.stringfy\n\n🌰 例子 / 将对象转换为 JSON 字符串：\n\nlet student = {\n  name: \'John\',\n  age: 30,\n  isAdmin: false,\n  courses: [\'html\', \'css\', \'js\'],\n  wife: null\n};\n\nlet json = JSON.stringify(student);\nconsole.log(typeof json) // string\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意\n\n注意：JSON 编码的对象与对象字面量有几个重要的区别：\n\n * 字符串使用双引号。JSON 中没有单引号或反引号。\n * 对象属性名称也是双引号的。这是强制性的。\n\nJSON.stringify 也可以应用于原数据类型。JSON 支持以下数据类型：\n\n * Objects { ... }\n * Arrays [ ... ]\n * 原始数据类型：\n   * 字符串\n   * 数值\n   * 布尔\n   * null\n\n🌰 例子 / JSON.stringify 转换原始数据类型：\n\nalert( JSON.stringify(1) ) // 1\nalert( JSON.stringify(\'test\') ) // "test"\nalert( JSON.stringify(true) ); // true\nalert( JSON.stringify([1, 2, 3]) ); // [1,2,3]\n\n\n1\n2\n3\n4\n\n\nJSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。\n\n * 函数属性 （方法）。\n * Symbol 类型的键和值。\n * 存储 undefined 的属性。\n\n🌰 例子：\n\nlet user = {\n  sayHi() { // 被忽略\n    alert("Hello");\n  },\n  [Symbol("id")]: 123, // 被忽略\n  something: undefined // 被忽略\n};\n\nconsole.log(JSON.stringfy(user)) // {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nJSON.stringify 支持嵌套对象转换，并且可以自动对其进行转换。\n\n🌰 例子：\n\nlet meetup = {\n  title: "Conference",\n  room: {\n    number: 23,\n    participants: ["john", "ann"]\n  }\n};\n\nconsole.log(JSON.stringify(meetup))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意\n\n不允许 循环引用的对象：\n\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: "Conference",\n  participants: ["john", "ann"]\n};\n\nmeetup.place = room;       // meetup 引用了 room\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nJSON.stringify(meetup);  //  Error: Converting circular structure to JSON\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# replacer\n\nJSON.stringify 的完整语法是：\n\nJSON.stringify(value[, replacer, space])\n\n\n1\n\n * value ：要编码的值。\n * replacer ：要编码的属性数组或映射函数 function(key, value) 。\n * space ：用于格式化的空格数量。\n\n大部分情况， JSON.stringify 仅 value 参数使用。但是，如果需要微调替换过程，比如 过滤掉循环引用，可以使用 JSON.stringify 的 replacer ，如果传递一个属性数组给它，那么只有这些属性会被编码。\n\n🌰 例子 ：\n\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: "Conference",\n  participants: [{name: "John"}, {name: "Alice"}],\n  place: room // meetup 引用了 room\n};\n\nroom.occupiedBy = meetup; \nconsole.log(JSON.stringify(meetup, [\'title\', \'participants\'])) // {"title":"Conference","participants":[{},{}]}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 属性列表应用于整个对象解构。 name 不在列表中，所以 participants 为空。即便这里存在循环引用，也不会报错。\n\n🌰 例子 / 排除掉循环引用的属性：\n\n可以使用一个函数代替数组作为 replacer ，该函数会为每个 (key,value) 对调用并返回「已替换」的值，该值将替换原有的值。如果值被跳过了，则为 undefined 。\n\nconsole.log(SON.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`);\n  return (key == \'occupiedBy\') ? undefined : value;\n})))\n\n/* key:value pairs that come to replacer:\n:             [object Object]\ntitle:        Conference\nparticipants: [object Object],[object Object]\n0:            [object Object]\nname:         John\n1:            [object Object]\nname:         Alice\nplace:        [object Object]\nnumber:       23\noccupiedBy: [object Object]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 注意 replacer 函数会获取每个键 / 值对，包括嵌套对象和数组项。它被递归地应用。 replacer 中的 this 的值是包含当前属性的对象。\n> \n> 第一个调用很特别。它是使用特殊的「包装对象」制作的： {"": meetup} 。即第一个 (key, value) 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 ":[object Object]" 的原因。\n> \n> 函数是为了给 replacer 提供尽可能多的功能：如果有必要，它有机会分析并替换 / 跳过整个对象。\n\n\n# space 格式化\n\nJSON.stringify(value, replacer, spaces) 的第三个参数是用于优化格式的空格数量（缩进）。\n\n\n# toJSON\n\n像 toString 进行字符串转换，对象也可以提供 toJSON 方法来进行 JSON 转换。如果可用， JSON.stringify 会自动调用它。\n\n🌰 例子：\n\nlet room = {\n  number: 23,\n  toJSON() {\n    return this.number;\n  }\n};\n\nlet meetup = {\n  title: "Conference",\n  room\n};\n\nalert( JSON.stringify(room) ); // 23\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    "title":"Conference",\n    "room": 23\n  }\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> toJSON 既可以用于直接调用 JSON.stringify(room) 也可以用于当 room 嵌套在另一个编码对象中时。\n\n\n# JSON.parse\n\n语法： JSON.parse(str, [reviver])\n\n * str ：要解析的字符串。\n * reviver ：可选参数，该函数将为每个 (key, value) 对调用，并可以对值进行转换。\n\n🌰 例子 / 字符串化数组：\n\nlet numbers = "[0, 1, 2, 3]";\nnumbers = JSON.parse(numbers);\n\n\n1\n2\n\n\n🌰 例子 / 嵌套对象的字符串：\n\nlet userData = \'{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }\';\nlet user = JSON.parse(userData);\n\n\n1\n2\n\n\nJSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。\n\n⚠️ JSON 不支持注释。向 JSON 添加注释无效。\n\n\n# receiver\n\n🌰 例子 / 处理 JSON 字符串中的特定属性类型 Date ：\n\nlet str = \'{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}\';\n\nlet meetup = JSON.parse(str, function(key, value) {\n  if (key == \'date\') return new Date(value);\n  return value;\n});\nconsole.log(meetup.date.getDate())\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子 / 同样适用于嵌套的对象：\n\nlet schedule = `{\n  "meetups": [\n    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},\n    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}\n  ]\n}`;\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == \'date\') return new Date(value);\n  return value;\n});\n\nconsole.log( schedule.meetups[1].date.getDate() );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# JSON 总结\n\n * JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。\n * JSON 支持对象、数组和原始数据类型。\n * JavaScript 提供序列化成 JSON 的方法 JSON.stringify 和解析 JSON 的方法 JSON.parse。\n   * 支持 replacer / receiver 调用智能 读 / 写 转换函数',normalizedContent:'javascript 提供了如下方法：\n\n * json.stringify 将对象转换为 json。\n * json.parse 将 json 转换回对象。\n\n\n# json.stringfy\n\n🌰 例子 / 将对象转换为 json 字符串：\n\nlet student = {\n  name: \'john\',\n  age: 30,\n  isadmin: false,\n  courses: [\'html\', \'css\', \'js\'],\n  wife: null\n};\n\nlet json = json.stringify(student);\nconsole.log(typeof json) // string\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意\n\n注意：json 编码的对象与对象字面量有几个重要的区别：\n\n * 字符串使用双引号。json 中没有单引号或反引号。\n * 对象属性名称也是双引号的。这是强制性的。\n\njson.stringify 也可以应用于原数据类型。json 支持以下数据类型：\n\n * objects { ... }\n * arrays [ ... ]\n * 原始数据类型：\n   * 字符串\n   * 数值\n   * 布尔\n   * null\n\n🌰 例子 / json.stringify 转换原始数据类型：\n\nalert( json.stringify(1) ) // 1\nalert( json.stringify(\'test\') ) // "test"\nalert( json.stringify(true) ); // true\nalert( json.stringify([1, 2, 3]) ); // [1,2,3]\n\n\n1\n2\n3\n4\n\n\njson 是语言无关的纯数据规范，因此一些特定于 javascript 的对象属性会被 json.stringify 跳过。\n\n * 函数属性 （方法）。\n * symbol 类型的键和值。\n * 存储 undefined 的属性。\n\n🌰 例子：\n\nlet user = {\n  sayhi() { // 被忽略\n    alert("hello");\n  },\n  [symbol("id")]: 123, // 被忽略\n  something: undefined // 被忽略\n};\n\nconsole.log(json.stringfy(user)) // {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\njson.stringify 支持嵌套对象转换，并且可以自动对其进行转换。\n\n🌰 例子：\n\nlet meetup = {\n  title: "conference",\n  room: {\n    number: 23,\n    participants: ["john", "ann"]\n  }\n};\n\nconsole.log(json.stringify(meetup))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意\n\n不允许 循环引用的对象：\n\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: "conference",\n  participants: ["john", "ann"]\n};\n\nmeetup.place = room;       // meetup 引用了 room\nroom.occupiedby = meetup; // room 引用了 meetup\n\njson.stringify(meetup);  //  error: converting circular structure to json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# replacer\n\njson.stringify 的完整语法是：\n\njson.stringify(value[, replacer, space])\n\n\n1\n\n * value ：要编码的值。\n * replacer ：要编码的属性数组或映射函数 function(key, value) 。\n * space ：用于格式化的空格数量。\n\n大部分情况， json.stringify 仅 value 参数使用。但是，如果需要微调替换过程，比如 过滤掉循环引用，可以使用 json.stringify 的 replacer ，如果传递一个属性数组给它，那么只有这些属性会被编码。\n\n🌰 例子 ：\n\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: "conference",\n  participants: [{name: "john"}, {name: "alice"}],\n  place: room // meetup 引用了 room\n};\n\nroom.occupiedby = meetup; \nconsole.log(json.stringify(meetup, [\'title\', \'participants\'])) // {"title":"conference","participants":[{},{}]}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 属性列表应用于整个对象解构。 name 不在列表中，所以 participants 为空。即便这里存在循环引用，也不会报错。\n\n🌰 例子 / 排除掉循环引用的属性：\n\n可以使用一个函数代替数组作为 replacer ，该函数会为每个 (key,value) 对调用并返回「已替换」的值，该值将替换原有的值。如果值被跳过了，则为 undefined 。\n\nconsole.log(son.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`);\n  return (key == \'occupiedby\') ? undefined : value;\n})))\n\n/* key:value pairs that come to replacer:\n:             [object object]\ntitle:        conference\nparticipants: [object object],[object object]\n0:            [object object]\nname:         john\n1:            [object object]\nname:         alice\nplace:        [object object]\nnumber:       23\noccupiedby: [object object]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 注意 replacer 函数会获取每个键 / 值对，包括嵌套对象和数组项。它被递归地应用。 replacer 中的 this 的值是包含当前属性的对象。\n> \n> 第一个调用很特别。它是使用特殊的「包装对象」制作的： {"": meetup} 。即第一个 (key, value) 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 ":[object object]" 的原因。\n> \n> 函数是为了给 replacer 提供尽可能多的功能：如果有必要，它有机会分析并替换 / 跳过整个对象。\n\n\n# space 格式化\n\njson.stringify(value, replacer, spaces) 的第三个参数是用于优化格式的空格数量（缩进）。\n\n\n# tojson\n\n像 tostring 进行字符串转换，对象也可以提供 tojson 方法来进行 json 转换。如果可用， json.stringify 会自动调用它。\n\n🌰 例子：\n\nlet room = {\n  number: 23,\n  tojson() {\n    return this.number;\n  }\n};\n\nlet meetup = {\n  title: "conference",\n  room\n};\n\nalert( json.stringify(room) ); // 23\n\nalert( json.stringify(meetup) );\n/*\n  {\n    "title":"conference",\n    "room": 23\n  }\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> tojson 既可以用于直接调用 json.stringify(room) 也可以用于当 room 嵌套在另一个编码对象中时。\n\n\n# json.parse\n\n语法： json.parse(str, [reviver])\n\n * str ：要解析的字符串。\n * reviver ：可选参数，该函数将为每个 (key, value) 对调用，并可以对值进行转换。\n\n🌰 例子 / 字符串化数组：\n\nlet numbers = "[0, 1, 2, 3]";\nnumbers = json.parse(numbers);\n\n\n1\n2\n\n\n🌰 例子 / 嵌套对象的字符串：\n\nlet userdata = \'{ "name": "john", "age": 35, "isadmin": false, "friends": [0,1,2,3] }\';\nlet user = json.parse(userdata);\n\n\n1\n2\n\n\njson 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 json 格式。\n\n⚠️ json 不支持注释。向 json 添加注释无效。\n\n\n# receiver\n\n🌰 例子 / 处理 json 字符串中的特定属性类型 date ：\n\nlet str = \'{"title":"conference","date":"2017-11-30t12:00:00.000z"}\';\n\nlet meetup = json.parse(str, function(key, value) {\n  if (key == \'date\') return new date(value);\n  return value;\n});\nconsole.log(meetup.date.getdate())\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子 / 同样适用于嵌套的对象：\n\nlet schedule = `{\n  "meetups": [\n    {"title":"conference","date":"2017-11-30t12:00:00.000z"},\n    {"title":"birthday","date":"2017-04-18t12:00:00.000z"}\n  ]\n}`;\n\nschedule = json.parse(schedule, function(key, value) {\n  if (key == \'date\') return new date(value);\n  return value;\n});\n\nconsole.log( schedule.meetups[1].date.getdate() );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# json 总结\n\n * json 是一种数据格式，具有自己的独立标准和大多数编程语言的库。\n * json 支持对象、数组和原始数据类型。\n * javascript 提供序列化成 json 的方法 json.stringify 和解析 json 的方法 json.parse。\n   * 支持 replacer / receiver 调用智能 读 / 写 转换函数',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧭 JavaScript 数组方法应用实例",frontmatter:{title:"🧭 JavaScript 数组方法应用实例",date:"2022-05-06T22:47:57.000Z",permalink:"/pages/cb7d78/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/40.%20%F0%9F%A7%AD%20JavaScript%20%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/40. 🧭 JavaScript 数组方法应用实例.md",key:"v-5f9ee188",path:"/pages/cb7d78/",headers:[{level:2,title:"split() / join()",slug:"split-join",normalizedTitle:"split() / join()",charIndex:2},{level:3,title:"转换短划线命名为驼峰命名",slug:"转换短划线命名为驼峰命名",normalizedTitle:"转换短划线命名为驼峰命名",charIndex:23},{level:3,title:"拓展的 Calculator",slug:"拓展的-calculator",normalizedTitle:"拓展的 calculator",charIndex:502},{level:2,title:"filter()",slug:"filter",normalizedTitle:"filter()",charIndex:1751},{level:3,title:"过滤范围",slug:"过滤范围",normalizedTitle:"过滤范围",charIndex:1764},{level:3,title:"原位过滤范围",slug:"原位过滤范围",normalizedTitle:"原位过滤范围",charIndex:2138},{level:2,title:"map() 映射",slug:"map-映射",normalizedTitle:"map () 映射",charIndex:null},{level:3,title:"映射到 names",slug:"映射到-names",normalizedTitle:"映射到 names",charIndex:2582},{level:3,title:"映射到对象",slug:"映射到对象",normalizedTitle:"映射到对象",charIndex:2942},{level:2,title:"sort() 数组排序",slug:"sort-数组排序",normalizedTitle:"sort () 数组排序",charIndex:null},{level:3,title:"根据对象中的数据排序",slug:"根据对象中的数据排序",normalizedTitle:"根据对象中的数据排序",charIndex:3676},{level:3,title:"随机排序",slug:"随机排序",normalizedTitle:"随机排序",charIndex:4013},{level:2,title:"reduce()",slug:"reduce",normalizedTitle:"reduce()",charIndex:4793},{level:3,title:"计算平均值",slug:"计算平均值",normalizedTitle:"计算平均值",charIndex:4806},{level:3,title:"从数组创建对象",slug:"从数组创建对象",normalizedTitle:"从数组创建对象",charIndex:5186},{level:2,title:"includes()",slug:"includes",normalizedTitle:"includes()",charIndex:5890},{level:3,title:"数组去重",slug:"数组去重",normalizedTitle:"数组去重",charIndex:5905}],headersStr:"split() / join() 转换短划线命名为驼峰命名 拓展的 Calculator filter() 过滤范围 原位过滤范围 map() 映射 映射到 names 映射到对象 sort() 数组排序 根据对象中的数据排序 随机排序 reduce() 计算平均值 从数组创建对象 includes() 数组去重",content:'# split() / join()\n\n\n# 转换短划线命名为驼峰命名\n\n> 编写函数 camelize(str) 。即：删除所有短横线，并将短横线后的每一个单词的首字母变为大写。例如 my-short-string 转换为 myShortString 。\n\n相关用例：\n\ncamelize("background-color") == \'backgroundColor\';\ncamelize("list-style-image") == \'listStyleImage\';\ncamelize("-webkit-transition") == \'WebkitTransition\';\n\n\n1\n2\n3\n\n点击查看\n\nfunction camelize(str) {\n    return str.split(\'-\').map((item, index)=> index === 0 ? item : item[0].toUpperCase() + item.slice(1)).join(\'\')\n}\n\n\n1\n2\n3\n\n\n涉及关键字 split / map / toUpperCase / join\n\n\n# 拓展的 Calculator\n\n> 实现两部分功能：\n> \n>  * 现 calculate(str) 方法，该方法接受像 "1 + 2" 这样格式为 “数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 + 和减号 - 。\n>    \n>    let calc = new Calculator;\n>    console.log( calc.calculate("3 + 7") ); \n>    \n>    \n>    1\n>    2\n>    \n> \n>  * 添加方法 addMethod(name, func) ，该方法教 calculator 进行新操作。它需要运算符 name 和实现它的双参数函数 func(a,b) 。\n>    \n>    let powerCalc = new Calculator;\n>    powerCalc.addMethod("*", (a, b) => a * b);\n>    powerCalc.addMethod("/", (a, b) => a / b);\n>    powerCalc.addMethod("**", (a, b) => a ** b);\n>          \n>    let result = powerCalc.calculate("2 ** 3");\n>    console.log(result); // 8\n>    \n>    \n>    1\n>    2\n>    3\n>    4\n>    5\n>    6\n>    7\n>    \n\n点击查看\n\n  function Calculator() {\n    this.methods = {\n      \'+\': (a ,b) => a + b,\n      \'-\': (a, b) => a - b\n    }\n\n    this.calculate = function(str) {\n      let arr = str.split(\' \')\n      let a = +arr[0]\n      let operator = arr[1]\n      let b = +arr[2]\n\n      if(!this.methods[operator] || isNaN(a) || isNaN(b)) {\n        return NaN\n      }\n\n      return this.methods[operator](a, b)\n    }\n\n    this.addMethod = function(name, func) {\n      this.methods[name] = func\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n关键词：对象方法 ｜ split\n\n\n# filter()\n\n\n# 过滤范围\n\n> 写一个函数 filterRange(arr, a, b) ，该函数获取一个数组 arr ，在其中查找数值大于或等于 a ，且小于或等于 b 的元素，并将结果以数组的形式返回。该函数不应该修改原数组。它应该返回新的数组。\n\n相关用例：\n\nlet arr = [5, 3, 8, 1];\nlet filtered = filterRange(arr, 1, 4);\nalert( filtered ); // 3,1（匹配值）\nalert( arr ); // 5,3,8,1（未修改）\n\n\n1\n2\n3\n4\n\n点击查看\n\nfunction filterRange(arr, a, b) {\n    return arr.filter((item) => item >= a && item <= b)\n  }\n\n\n1\n2\n3\n\n\n\n# 原位过滤范围\n\n与上一题类似，在原数组中，过滤（删除）不在 [a, b] 范围内的元素。该函数应该只修改数组。它不应该返回任何东西。\n\n相关用例：\n\nlet arr = [5, 3, 8, 1];\nfilterRangeInPlace(arr, 1, 4); // 删除了范围在 1 到 4 之外的所有值\nalert( arr ); // [3, 1]\n\n\n1\n2\n3\n\n点击查看\n\nfunction filterRangeInPlace(arr, a, b) {\n\n  for (let i = 0; i < arr.length; i++) {\n    let val = arr[i];\n\n    // 如果超出范围，则删除\n    if (val < a || val > b) {\n      arr.splice(i, 1);\n      i--;\n    }\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# map() 映射\n\n\n# 映射到 names\n\n> user 对象数组，每个对象都有 user.name ，将其转换为 names 数组的代码。\n\nlet john = { name: "John", age: 25 };\nlet pete = { name: "Pete", age: 30 };\nlet mary = { name: "Mary", age: 28 };\n\nlet users = [ john, pete, mary ];\nlet names = /* ... your code */\n\nconsole.log(names); // John, Pete, Mary\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n点击查看\n\nlet names = users.map((user) => user.name)\n\n\n1\n\n\n\n# 映射到对象\n\n> 以数组 users 为基础，创建另一个具有 id 和 fullName 的对象数组，其中 fullName 由 name 和 surname 生成。\n\nlet john = { name: "John", surname: "Smith", id: 1 };\nlet pete = { name: "Pete", surname: "Hunt", id: 2 };\nlet mary = { name: "Mary", surname: "Key", id: 3 };\n\nlet users = [ john, pete, mary ];\n\nlet usersMapped = /* ... your code ... */\n\n/*\nusersMapped = [\n  { fullName: "John Smith", id: 1 },\n  { fullName: "Pete Hunt", id: 2 },\n  { fullName: "Mary Key", id: 3 }\n]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n点击查看\n\nlet usersMapped = users.map((user) => ({\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n}))\n\n\n1\n2\n3\n4\n\n\n注意\n\n注意，在箭头函数中，返回一个对象需要使用额外的括号。如果只写一个 {} ，JavaScript 在这里会把 { 视为函数体的开始，而不是对象的开始。解决方法是将它们包装在普通括号 () 中。\n\n\n# sort() 数组排序\n\n\n# 根据对象中的数据排序\n\n> 编写函数 sortByAge(users) 获得对象数组的 age 属性，并根据 age 对这些对象数组进行排序。\n\nlet john = { name: "John", age: 25 };\nlet pete = { name: "Pete", age: 30 };\nlet mary = { name: "Mary", age: 28 };\n\nlet arr = [ pete, john, mary ];\n\nsortByAge(arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n点击查看\n\nfunction sortByAge(arr) {\n  arr.sort((a, b) => a.age - b.age)\n}\n\n\n1\n2\n3\n\n\n\n# 随机排序\n\n> 编写函数 shuffle(array) 将 let arr = [1, 2, 3]; 随机排序。所有元素顺序应该具有相等的概率。例如，可以将 [1,2,3] 重新排序为 [1,2,3] 或 [1,3,2] 或 [3,1,2] 等，每种情况的概率相等。\n\n点击查看\n\n思路：使用 Math.random() 生成一个 可能是正数或者负数的 随机数，这样 sort() 才能随机对数组中的元素重新排序。\n\n简单的使用 Math.random() - 0.5 ，但是这个方法得出所有的排列的概率不相同。\n\nfunction shuffle(array) {\n  array.sort((a, b) => (Math.random() - 0.5))\n}\n\n\n1\n2\n3\n\n\n能实现的一个算法「Fisher-Yates shuffle」，逆向遍历数组，并将每个元素与前面的随机的一个元素互换位置。能实现得出所有排列都以相同的概率出现，并且不需排序增加时间开销。\n\nfunction shuffle(array) {\n  for(let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1))\n    \n    // 一般交换\n    let temp = array[i]\n    array[i] = array[j]\n    array[j] = array[i]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 使用解构分配交换：\n> \n> [array[i], array[j]] = [array[j], array[i]]\n> \n> \n> 1\n\n关键字： Math.random() | sort()\n\n\n# reduce()\n\n\n# 计算平均值\n\n> 编写 getAverageAge(users) 函数，该函数获取一个具有 age 属性的对象数组，并返回平均年龄。\n\nlet john = { name: "John", age: 25 };\nlet pete = { name: "Pete", age: 30 };\nlet mary = { name: "Mary", age: 29 };\n\nlet arr = [ john, pete, mary ];\n\nalert( getAverageAge(arr) );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n点击查看\n\nfunction getAverageAge(arr) {\n  return arr.reduce((sum, item) => sum + item.age, 0) / arr.length\n}\n\n\n1\n2\n3\n\n\n\n# 从数组创建对象\n\n> 假设收到了一个用户数组，形式为： {id:..., name:..., age:... } 。\n> \n> 创建一个函数 groupById(arr) 从该数组创建对象，以 id 为键（key），数组项为值。\n\nlet users = [\n  {id: \'john\', name: "John Smith", age: 20},\n  {id: \'ann\', name: "Ann Smith", age: 24},\n  {id: \'pete\', name: "Pete Peterson", age: 31},\n];\n\nlet usersById = groupById(users);\n\n// after: \n/* \nusersById = {\n  john: {id: \'john\', name: "John Smith", age: 20},\n  ann: {id: \'ann\', name: "Ann Smith", age: 24},\n  pete: {id: \'pete\', name: "Pete Peterson", age: 31},\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n点击查看\n\nfunction groupById(array) {\n    return array.reduce((obj, item)=>{\n      obj[item.id] = item\n      return obj\n    },{})\n  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注意要将累加器的初始值设置为 {}\n\n\n# includes()\n\n\n# 数组去重\n\n> 创建一个函数 unique(arr) ，返回去除重复元素后的数组 arr 。\n\nfunction unique(arr) {\n  /* your code */\n}\n\nlet strings = ["Hare", "Krishna", "Hare", "Krishna",\n  "Krishna", "Krishna", "Hare", "Hare", ":-O"\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n点击查看\n\nfunction unique(arr){\n  let res = []\n  \n  for (let item of arr) {\n    if(!res.includes(item)){\n      res.push(item)\n    }\n  }\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# split() / join()\n\n\n# 转换短划线命名为驼峰命名\n\n> 编写函数 camelize(str) 。即：删除所有短横线，并将短横线后的每一个单词的首字母变为大写。例如 my-short-string 转换为 myshortstring 。\n\n相关用例：\n\ncamelize("background-color") == \'backgroundcolor\';\ncamelize("list-style-image") == \'liststyleimage\';\ncamelize("-webkit-transition") == \'webkittransition\';\n\n\n1\n2\n3\n\n点击查看\n\nfunction camelize(str) {\n    return str.split(\'-\').map((item, index)=> index === 0 ? item : item[0].touppercase() + item.slice(1)).join(\'\')\n}\n\n\n1\n2\n3\n\n\n涉及关键字 split / map / touppercase / join\n\n\n# 拓展的 calculator\n\n> 实现两部分功能：\n> \n>  * 现 calculate(str) 方法，该方法接受像 "1 + 2" 这样格式为 “数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 + 和减号 - 。\n>    \n>    let calc = new calculator;\n>    console.log( calc.calculate("3 + 7") ); \n>    \n>    \n>    1\n>    2\n>    \n> \n>  * 添加方法 addmethod(name, func) ，该方法教 calculator 进行新操作。它需要运算符 name 和实现它的双参数函数 func(a,b) 。\n>    \n>    let powercalc = new calculator;\n>    powercalc.addmethod("*", (a, b) => a * b);\n>    powercalc.addmethod("/", (a, b) => a / b);\n>    powercalc.addmethod("**", (a, b) => a ** b);\n>          \n>    let result = powercalc.calculate("2 ** 3");\n>    console.log(result); // 8\n>    \n>    \n>    1\n>    2\n>    3\n>    4\n>    5\n>    6\n>    7\n>    \n\n点击查看\n\n  function calculator() {\n    this.methods = {\n      \'+\': (a ,b) => a + b,\n      \'-\': (a, b) => a - b\n    }\n\n    this.calculate = function(str) {\n      let arr = str.split(\' \')\n      let a = +arr[0]\n      let operator = arr[1]\n      let b = +arr[2]\n\n      if(!this.methods[operator] || isnan(a) || isnan(b)) {\n        return nan\n      }\n\n      return this.methods[operator](a, b)\n    }\n\n    this.addmethod = function(name, func) {\n      this.methods[name] = func\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n关键词：对象方法 ｜ split\n\n\n# filter()\n\n\n# 过滤范围\n\n> 写一个函数 filterrange(arr, a, b) ，该函数获取一个数组 arr ，在其中查找数值大于或等于 a ，且小于或等于 b 的元素，并将结果以数组的形式返回。该函数不应该修改原数组。它应该返回新的数组。\n\n相关用例：\n\nlet arr = [5, 3, 8, 1];\nlet filtered = filterrange(arr, 1, 4);\nalert( filtered ); // 3,1（匹配值）\nalert( arr ); // 5,3,8,1（未修改）\n\n\n1\n2\n3\n4\n\n点击查看\n\nfunction filterrange(arr, a, b) {\n    return arr.filter((item) => item >= a && item <= b)\n  }\n\n\n1\n2\n3\n\n\n\n# 原位过滤范围\n\n与上一题类似，在原数组中，过滤（删除）不在 [a, b] 范围内的元素。该函数应该只修改数组。它不应该返回任何东西。\n\n相关用例：\n\nlet arr = [5, 3, 8, 1];\nfilterrangeinplace(arr, 1, 4); // 删除了范围在 1 到 4 之外的所有值\nalert( arr ); // [3, 1]\n\n\n1\n2\n3\n\n点击查看\n\nfunction filterrangeinplace(arr, a, b) {\n\n  for (let i = 0; i < arr.length; i++) {\n    let val = arr[i];\n\n    // 如果超出范围，则删除\n    if (val < a || val > b) {\n      arr.splice(i, 1);\n      i--;\n    }\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# map() 映射\n\n\n# 映射到 names\n\n> user 对象数组，每个对象都有 user.name ，将其转换为 names 数组的代码。\n\nlet john = { name: "john", age: 25 };\nlet pete = { name: "pete", age: 30 };\nlet mary = { name: "mary", age: 28 };\n\nlet users = [ john, pete, mary ];\nlet names = /* ... your code */\n\nconsole.log(names); // john, pete, mary\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n点击查看\n\nlet names = users.map((user) => user.name)\n\n\n1\n\n\n\n# 映射到对象\n\n> 以数组 users 为基础，创建另一个具有 id 和 fullname 的对象数组，其中 fullname 由 name 和 surname 生成。\n\nlet john = { name: "john", surname: "smith", id: 1 };\nlet pete = { name: "pete", surname: "hunt", id: 2 };\nlet mary = { name: "mary", surname: "key", id: 3 };\n\nlet users = [ john, pete, mary ];\n\nlet usersmapped = /* ... your code ... */\n\n/*\nusersmapped = [\n  { fullname: "john smith", id: 1 },\n  { fullname: "pete hunt", id: 2 },\n  { fullname: "mary key", id: 3 }\n]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n点击查看\n\nlet usersmapped = users.map((user) => ({\n  fullname: `${user.name} ${user.surname}`,\n  id: user.id\n}))\n\n\n1\n2\n3\n4\n\n\n注意\n\n注意，在箭头函数中，返回一个对象需要使用额外的括号。如果只写一个 {} ，javascript 在这里会把 { 视为函数体的开始，而不是对象的开始。解决方法是将它们包装在普通括号 () 中。\n\n\n# sort() 数组排序\n\n\n# 根据对象中的数据排序\n\n> 编写函数 sortbyage(users) 获得对象数组的 age 属性，并根据 age 对这些对象数组进行排序。\n\nlet john = { name: "john", age: 25 };\nlet pete = { name: "pete", age: 30 };\nlet mary = { name: "mary", age: 28 };\n\nlet arr = [ pete, john, mary ];\n\nsortbyage(arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n点击查看\n\nfunction sortbyage(arr) {\n  arr.sort((a, b) => a.age - b.age)\n}\n\n\n1\n2\n3\n\n\n\n# 随机排序\n\n> 编写函数 shuffle(array) 将 let arr = [1, 2, 3]; 随机排序。所有元素顺序应该具有相等的概率。例如，可以将 [1,2,3] 重新排序为 [1,2,3] 或 [1,3,2] 或 [3,1,2] 等，每种情况的概率相等。\n\n点击查看\n\n思路：使用 math.random() 生成一个 可能是正数或者负数的 随机数，这样 sort() 才能随机对数组中的元素重新排序。\n\n简单的使用 math.random() - 0.5 ，但是这个方法得出所有的排列的概率不相同。\n\nfunction shuffle(array) {\n  array.sort((a, b) => (math.random() - 0.5))\n}\n\n\n1\n2\n3\n\n\n能实现的一个算法「fisher-yates shuffle」，逆向遍历数组，并将每个元素与前面的随机的一个元素互换位置。能实现得出所有排列都以相同的概率出现，并且不需排序增加时间开销。\n\nfunction shuffle(array) {\n  for(let i = array.length - 1; i > 0; i--) {\n    let j = math.floor(math.random() * (i + 1))\n    \n    // 一般交换\n    let temp = array[i]\n    array[i] = array[j]\n    array[j] = array[i]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 使用解构分配交换：\n> \n> [array[i], array[j]] = [array[j], array[i]]\n> \n> \n> 1\n\n关键字： math.random() | sort()\n\n\n# reduce()\n\n\n# 计算平均值\n\n> 编写 getaverageage(users) 函数，该函数获取一个具有 age 属性的对象数组，并返回平均年龄。\n\nlet john = { name: "john", age: 25 };\nlet pete = { name: "pete", age: 30 };\nlet mary = { name: "mary", age: 29 };\n\nlet arr = [ john, pete, mary ];\n\nalert( getaverageage(arr) );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n点击查看\n\nfunction getaverageage(arr) {\n  return arr.reduce((sum, item) => sum + item.age, 0) / arr.length\n}\n\n\n1\n2\n3\n\n\n\n# 从数组创建对象\n\n> 假设收到了一个用户数组，形式为： {id:..., name:..., age:... } 。\n> \n> 创建一个函数 groupbyid(arr) 从该数组创建对象，以 id 为键（key），数组项为值。\n\nlet users = [\n  {id: \'john\', name: "john smith", age: 20},\n  {id: \'ann\', name: "ann smith", age: 24},\n  {id: \'pete\', name: "pete peterson", age: 31},\n];\n\nlet usersbyid = groupbyid(users);\n\n// after: \n/* \nusersbyid = {\n  john: {id: \'john\', name: "john smith", age: 20},\n  ann: {id: \'ann\', name: "ann smith", age: 24},\n  pete: {id: \'pete\', name: "pete peterson", age: 31},\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n点击查看\n\nfunction groupbyid(array) {\n    return array.reduce((obj, item)=>{\n      obj[item.id] = item\n      return obj\n    },{})\n  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注意要将累加器的初始值设置为 {}\n\n\n# includes()\n\n\n# 数组去重\n\n> 创建一个函数 unique(arr) ，返回去除重复元素后的数组 arr 。\n\nfunction unique(arr) {\n  /* your code */\n}\n\nlet strings = ["hare", "krishna", "hare", "krishna",\n  "krishna", "krishna", "hare", "hare", ":-o"\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n点击查看\n\nfunction unique(arr){\n  let res = []\n  \n  for (let item of arr) {\n    if(!res.includes(item)){\n      res.push(item)\n    }\n  }\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🖇 JavaScript 映射与集合应用实例",frontmatter:{title:"🖇 JavaScript 映射与集合应用实例",date:"2022-05-07T14:20:20.000Z",permalink:"/pages/183c8c/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/41.%20%F0%9F%96%87%20JavaScript%20%E6%98%A0%E5%B0%84%E4%B8%8E%E9%9B%86%E5%90%88%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/41. 🖇 JavaScript 映射与集合应用实例.md",key:"v-145b3250",path:"/pages/183c8c/",headers:[{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:2},{level:3,title:"过滤数组唯一的元素",slug:"过滤数组唯一的元素",normalizedTitle:"过滤数组唯一的元素",charIndex:10},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:415},{level:3,title:"过滤重复字谜",slug:"过滤重复字谜",normalizedTitle:"过滤重复字谜",charIndex:423},{level:3,title:"迭代键",slug:"迭代键",normalizedTitle:"迭代键",charIndex:1240}],headersStr:"Set 过滤数组唯一的元素 Map 过滤重复字谜 迭代键",content:'# Set\n\n\n# 过滤数组唯一的元素\n\n> 定义 arr 为一个数组。创建一个函数 unique(arr) ，该函数返回一个由 arr 中 所有唯一元素所组成的数组。\n\nlet values = ["Hare", "Krishna", "Hare", "Krishna",\n  "Krishna", "Krishna", "Hare", "Hare", ":-O"\n];\n\nfunction unique(arr) {\n  /* 你的代码 */\n}\n\nconsole.log(unique(values))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n点击查看\n\nfunction unique(arr){\n\treturn Array.from(new Set(arr))\n}\n\nconsole.log(unique(values))\n\n\n1\n2\n3\n4\n5\n\n\n关键词： Array.from ｜ new. Set()\n\n\n# Map\n\n\n# 过滤重复字谜\n\n> Anagrams 是具有相同数量相同字母但是顺序不同的单词。\n> \n> nap - pan\n> ear - are - era\n> cheaters - hectares - teachers\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 写一个函数 aclean(arr) ，它返回被清除了字谜（anagrams）的数组。\n\nlet arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];\n\n\n1\n\n点击查看\n\n方法一：使用 Map\n\nfunction aclean(arr) {\n  let map = new Map()\n  for (let word of arr) {\n    let sorted = word.toLowerCase().split(\'\').sort().join(\'\')\n    map.set(sorted, word)\n  }\n  return Array.from(map.values())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 利用排序后的单词作为键存储字谜，遇到重复设值的 map 会覆盖上一次的设值。因此，每个字母形式只有一个单词（并且是原来数组靠后的形式）。\n\n方法二：普通对象，因为键就是字符串。：\n\nfunction aclean(arr) {\n  let obj = {};\n  for (let i = 0; i < arr.length; i++) {\n    let sorted = arr[i].toLowerCase().split("").sort().join("");\n    obj[sorted] = arr[i];\n  }\n  return Object.values(obj);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 迭代键\n\n> 期望使用 map.keys() 得到一个数组，然后使用例如 .push 等特定的方法对其进行处理。\n> \n> let map = new Map();\n> map.set("name", "John");\n> let keys = map.keys();\n> keys.push("more");\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n点击查看\n\n因为 map.keys() 返回的是一个可迭代对象而非数组。需要使用 Array.from() 转换为数组。\n\nlet map = new Map();\nmap.set("name", "John");\nlet keys = Array.from(map.keys());\nkeys.push("more");\n\n\n1\n2\n3\n4\n\n\n或者使用 … ：\n\nkeys = [...keys]\n\n\n1\n',normalizedContent:'# set\n\n\n# 过滤数组唯一的元素\n\n> 定义 arr 为一个数组。创建一个函数 unique(arr) ，该函数返回一个由 arr 中 所有唯一元素所组成的数组。\n\nlet values = ["hare", "krishna", "hare", "krishna",\n  "krishna", "krishna", "hare", "hare", ":-o"\n];\n\nfunction unique(arr) {\n  /* 你的代码 */\n}\n\nconsole.log(unique(values))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n点击查看\n\nfunction unique(arr){\n\treturn array.from(new set(arr))\n}\n\nconsole.log(unique(values))\n\n\n1\n2\n3\n4\n5\n\n\n关键词： array.from ｜ new. set()\n\n\n# map\n\n\n# 过滤重复字谜\n\n> anagrams 是具有相同数量相同字母但是顺序不同的单词。\n> \n> nap - pan\n> ear - are - era\n> cheaters - hectares - teachers\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 写一个函数 aclean(arr) ，它返回被清除了字谜（anagrams）的数组。\n\nlet arr = ["nap", "teachers", "cheaters", "pan", "ear", "era", "hectares"];\n\n\n1\n\n点击查看\n\n方法一：使用 map\n\nfunction aclean(arr) {\n  let map = new map()\n  for (let word of arr) {\n    let sorted = word.tolowercase().split(\'\').sort().join(\'\')\n    map.set(sorted, word)\n  }\n  return array.from(map.values())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 利用排序后的单词作为键存储字谜，遇到重复设值的 map 会覆盖上一次的设值。因此，每个字母形式只有一个单词（并且是原来数组靠后的形式）。\n\n方法二：普通对象，因为键就是字符串。：\n\nfunction aclean(arr) {\n  let obj = {};\n  for (let i = 0; i < arr.length; i++) {\n    let sorted = arr[i].tolowercase().split("").sort().join("");\n    obj[sorted] = arr[i];\n  }\n  return object.values(obj);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 迭代键\n\n> 期望使用 map.keys() 得到一个数组，然后使用例如 .push 等特定的方法对其进行处理。\n> \n> let map = new map();\n> map.set("name", "john");\n> let keys = map.keys();\n> keys.push("more");\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n点击查看\n\n因为 map.keys() 返回的是一个可迭代对象而非数组。需要使用 array.from() 转换为数组。\n\nlet map = new map();\nmap.set("name", "john");\nlet keys = array.from(map.keys());\nkeys.push("more");\n\n\n1\n2\n3\n4\n\n\n或者使用 … ：\n\nkeys = [...keys]\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗑 JavaScript 弱映射与弱集合应用实例",frontmatter:{title:"🗑 JavaScript 弱映射与弱集合应用实例",date:"2022-05-07T15:16:11.000Z",permalink:"/pages/b5e223/",categories:["🚶🏻 前端巩固基础","📕 JavaScript 深入数据类型"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/32.%20%F0%9F%93%95%20JavaScript%20%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/42.%20%F0%9F%97%91%20JavaScript%20%E5%BC%B1%E6%98%A0%E5%B0%84%E4%B8%8E%E5%BC%B1%E9%9B%86%E5%90%88%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/32. 📕 JavaScript 深入数据类型/42. 🗑 JavaScript 弱映射与弱集合应用实例.md",key:"v-3fcbcc4a",path:"/pages/b5e223/",headers:[{level:2,title:"WeakSet",slug:"weakset",normalizedTitle:"weakset",charIndex:2},{level:3,title:"信息已读",slug:"信息已读",normalizedTitle:"信息已读",charIndex:14},{level:3,title:"保存阅读日期",slug:"保存阅读日期",normalizedTitle:"保存阅读日期",charIndex:1096}],headersStr:"WeakSet 信息已读 保存阅读日期",content:'# WeakSet\n\n\n# 信息已读\n\n> 有一个 messages 数组：\n> \n> let messages = [\n>   {text: "Hello", from: "John"},\n>   {text: "How goes?", from: "John"},\n>   {text: "See you soon", from: "Alice"}\n> ];\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 可以访问它，但是 message 是由其他人的代码管理的。该代码会定期添加新消息，删除旧消息，但是你不知道这些操作确切的发生时间。\n> \n> 应该使用什么数据结构来保存关于消息「是否已读」的信息？该结构必须很适合对给定的 message 对象给出「它读了吗？」的答案。\n> \n>  * 当一个消息被从 messages 中删除后，它应该也从你的数据结构中消失。\n>  * 不能修改 message 对象，例如向其添加属性。因为它们是由其他人的代码管理的，修改该数据可能会导致不好的后果。\n\n点击查看\n\nlet readMessages = new WeakSet()\n\nreadMessages.add(message[0]) // 读信息\nreadMessages.add(message[1]) // 读信息\n\n// 再次读信息\nreadMessages.add(message[0]) // 不再添加已读\n\n// 检查是否已读\nreadMessages.has(message[0]) // true 意味着信息已读\n\nmessages.shift(); // 信息被清理\n// readMessages 会跟随清理\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 使用 WeakSet 的代价：不能对它进行迭代，也不能直接从中获取「所有已读消息」。但是，可以通过遍历所有消息，然后找出存在于 set 的那些消息来完成这个功能。\n\n另一个解决方法：在读取消息后向消息添加诸如 message.isRead=true 之类的属性。由于 messages 对象是由另一个代码管理的，因此通常不建议这样做，但是可以使用 symbol 属性来避免冲突。\n\nlet isRead = Symbol("isRead");\nmessages[0][isRead] = true;\n\n\n1\n2\n\n\n现在，第三方代码可能看不到这个额外属性。尽管 symbol 可以降低出现问题的可能性，但从架构的角度来看，还是使用 WeakSet 更好。\n\n\n# 保存阅读日期\n\n> 与上题类似，但是保存阅读记录以外，还需要保存日期。并且它应该在消息被垃圾回收时也被从内存中清除。\n\n点击查看\n\nlet messages = [\n  {text: "Hello", from: "John"},\n  {text: "How goes?", from: "John"},\n  {text: "See you soon", from: "Alice"}\n];\n\nlet readMap = new WeakMap();\n\nreadMap.set(messages[0], new Date());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# weakset\n\n\n# 信息已读\n\n> 有一个 messages 数组：\n> \n> let messages = [\n>   {text: "hello", from: "john"},\n>   {text: "how goes?", from: "john"},\n>   {text: "see you soon", from: "alice"}\n> ];\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 可以访问它，但是 message 是由其他人的代码管理的。该代码会定期添加新消息，删除旧消息，但是你不知道这些操作确切的发生时间。\n> \n> 应该使用什么数据结构来保存关于消息「是否已读」的信息？该结构必须很适合对给定的 message 对象给出「它读了吗？」的答案。\n> \n>  * 当一个消息被从 messages 中删除后，它应该也从你的数据结构中消失。\n>  * 不能修改 message 对象，例如向其添加属性。因为它们是由其他人的代码管理的，修改该数据可能会导致不好的后果。\n\n点击查看\n\nlet readmessages = new weakset()\n\nreadmessages.add(message[0]) // 读信息\nreadmessages.add(message[1]) // 读信息\n\n// 再次读信息\nreadmessages.add(message[0]) // 不再添加已读\n\n// 检查是否已读\nreadmessages.has(message[0]) // true 意味着信息已读\n\nmessages.shift(); // 信息被清理\n// readmessages 会跟随清理\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 使用 weakset 的代价：不能对它进行迭代，也不能直接从中获取「所有已读消息」。但是，可以通过遍历所有消息，然后找出存在于 set 的那些消息来完成这个功能。\n\n另一个解决方法：在读取消息后向消息添加诸如 message.isread=true 之类的属性。由于 messages 对象是由另一个代码管理的，因此通常不建议这样做，但是可以使用 symbol 属性来避免冲突。\n\nlet isread = symbol("isread");\nmessages[0][isread] = true;\n\n\n1\n2\n\n\n现在，第三方代码可能看不到这个额外属性。尽管 symbol 可以降低出现问题的可能性，但从架构的角度来看，还是使用 weakset 更好。\n\n\n# 保存阅读日期\n\n> 与上题类似，但是保存阅读记录以外，还需要保存日期。并且它应该在消息被垃圾回收时也被从内存中清除。\n\n点击查看\n\nlet messages = [\n  {text: "hello", from: "john"},\n  {text: "how goes?", from: "john"},\n  {text: "see you soon", from: "alice"}\n];\n\nlet readmap = new weakmap();\n\nreadmap.set(messages[0], new date());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚝  JavaScript 函数递归与堆栈",frontmatter:{title:"🚝  JavaScript 函数递归与堆栈",date:"2022-05-08T00:46:20.000Z",permalink:"/pages/acdd55/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/01.%20%F0%9F%9A%9D%20%20JavaScript%20%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%E4%B8%8E%E5%A0%86%E6%A0%88.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/01. 🚝  JavaScript 函数递归与堆栈.md",key:"v-25736eb0",path:"/pages/acdd55/",headers:[{level:2,title:"函数递归",slug:"函数递归",normalizedTitle:"函数递归",charIndex:2},{level:2,title:"执行上下文和堆栈",slug:"执行上下文和堆栈",normalizedTitle:"执行上下文和堆栈",charIndex:307},{level:2,title:"🍎 递归遍历",slug:"递归遍历",normalizedTitle:"🍎 递归遍历",charIndex:568}],headersStr:"函数递归 执行上下文和堆栈 🍎 递归遍历",content:"# 函数递归\n\n🌰 例子 / 使用递归简单实现计算 x 的 n 次方：\n\nfunction pow(x, n) {\n  return (n == 1) ? x : x * pow(x, n - 1)\n}\n\n\n1\n2\n3\n\n\n> 在 JavaSript 引擎中限制 最大递归深度（嵌套调用次数）。引擎在最大迭代深度为 10000 及以下时是可靠的，有些引擎可能允许更大的最大深度，但是对于大多数引擎来说，100000 可能就超出限制了。有一些自动优化能够帮助减轻这种情况（尾部调用优化），但目前它们还没有被完全支持，只能用于简单场景。\n\n但是递归还是广泛应用，因为有很多事务使用递归更简洁并且更容易维护。\n\n\n# 执行上下文和堆栈\n\n执行上下文：有关正在运行的函数的执行过程的相关信息。\n\n> 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量， this 的值，以及其它的一些内部细节。\n> \n> 一个函数调用 仅具有一个 与其相关联的 执行上下文。\n\n进行函数的递归时，会发生：\n\n * 当前函数被暂停；\n * 与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；\n * 执行嵌套调用；\n * 嵌套调用结束后，从堆栈中 恢复 之前的执行上下文，并从停止的位置恢复外部函数。\n\n\n# 🍎 递归遍历\n\n🌰 例子 / 公司部门人员结构：\n\nlet company = {\n  sales: [{\n    name: 'John',\n    salary: 1000\n  }, {\n    name: 'Alice',\n    salary: 1600\n  }],\n\n  development: {\n    sites: [{\n      name: 'Peter',\n      salary: 2000\n    }, {\n      name: 'Alex',\n      salary: 1800\n    }],\n\n    internals: [{\n      name: 'Jack',\n      salary: 1300\n    }]\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 一家公司有很多部门：\n> \n>  * 一个部门可能有一 数组 的员工；\n>  * 一个部门可能会划分为几个子部门。\n>  * 一个子部门增长时，它也有可能被拆分成几个子部门。\n\n要循环完整个公司的员工信息，从第一层开始、到第二层 … 更多层。\n\n使用 递归遍历 实现：\n\nfunction sumSalaries(department) {\n  if (array.isArray(department)) {\n    return department.reduce((prev, cur) => {\n      prev += cur.salary\n    }, 0)\n  } else {\n\t\tlet sun = 0\n    for(let subDep of Object.values(department)) {\n    \tsum += sumSalaries(subDep)\n    }\n  }  \n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# 函数递归\n\n🌰 例子 / 使用递归简单实现计算 x 的 n 次方：\n\nfunction pow(x, n) {\n  return (n == 1) ? x : x * pow(x, n - 1)\n}\n\n\n1\n2\n3\n\n\n> 在 javasript 引擎中限制 最大递归深度（嵌套调用次数）。引擎在最大迭代深度为 10000 及以下时是可靠的，有些引擎可能允许更大的最大深度，但是对于大多数引擎来说，100000 可能就超出限制了。有一些自动优化能够帮助减轻这种情况（尾部调用优化），但目前它们还没有被完全支持，只能用于简单场景。\n\n但是递归还是广泛应用，因为有很多事务使用递归更简洁并且更容易维护。\n\n\n# 执行上下文和堆栈\n\n执行上下文：有关正在运行的函数的执行过程的相关信息。\n\n> 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量， this 的值，以及其它的一些内部细节。\n> \n> 一个函数调用 仅具有一个 与其相关联的 执行上下文。\n\n进行函数的递归时，会发生：\n\n * 当前函数被暂停；\n * 与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；\n * 执行嵌套调用；\n * 嵌套调用结束后，从堆栈中 恢复 之前的执行上下文，并从停止的位置恢复外部函数。\n\n\n# 🍎 递归遍历\n\n🌰 例子 / 公司部门人员结构：\n\nlet company = {\n  sales: [{\n    name: 'john',\n    salary: 1000\n  }, {\n    name: 'alice',\n    salary: 1600\n  }],\n\n  development: {\n    sites: [{\n      name: 'peter',\n      salary: 2000\n    }, {\n      name: 'alex',\n      salary: 1800\n    }],\n\n    internals: [{\n      name: 'jack',\n      salary: 1300\n    }]\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 一家公司有很多部门：\n> \n>  * 一个部门可能有一 数组 的员工；\n>  * 一个部门可能会划分为几个子部门。\n>  * 一个子部门增长时，它也有可能被拆分成几个子部门。\n\n要循环完整个公司的员工信息，从第一层开始、到第二层 … 更多层。\n\n使用 递归遍历 实现：\n\nfunction sumsalaries(department) {\n  if (array.isarray(department)) {\n    return department.reduce((prev, cur) => {\n      prev += cur.salary\n    }, 0)\n  } else {\n\t\tlet sun = 0\n    for(let subdep of object.values(department)) {\n    \tsum += sumsalaries(subdep)\n    }\n  }  \n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚅 JavaScript Rest 参数与 Spread 语法",frontmatter:{title:"🚅 JavaScript Rest 参数与 Spread 语法",date:"2022-05-08T00:47:18.000Z",permalink:"/pages/208b1a/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/02.%20%F0%9F%9A%85%20JavaScript%20Rest%20%E5%8F%82%E6%95%B0%E4%B8%8E%20Spread%20%E8%AF%AD%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/02. 🚅 JavaScript Rest 参数与 Spread 语法.md",key:"v-50873160",path:"/pages/208b1a/",headers:[{level:2,title:"Rest 参数",slug:"rest-参数",normalizedTitle:"rest 参数",charIndex:2},{level:3,title:"arguments 变量",slug:"arguments-变量",normalizedTitle:"arguments 变量",charIndex:651},{level:2,title:"Spread 语法",slug:"spread-语法",normalizedTitle:"spread 语法",charIndex:1145},{level:3,title:"复制对象 / 数组",slug:"复制对象-数组",normalizedTitle:"复制对象 / 数组",charIndex:1981},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2646}],headersStr:"Rest 参数 arguments 变量 Spread 语法 复制对象 / 数组 总结",content:'# Rest 参数\n\nRest 参数可以通过使用三个点 ... 并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中。这些点的字面意思是「将剩余参数收集到一个数组中」。\n\n🌰 例子：\n\nfunction sumAll(...args) { \n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nconsole.log(sumAll(1, 2, 3, 4, 5, 6))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子 / 有其他参数 ：\n\nfunction showName(firstName, lastName, ...titles) {\n  console.log( firstName + \' \' + lastName )\n  \n  console.log(titles[0])\n  console.log(titles[1])\n  console.log(titles.length)\n}\n\nshowName("Julius", "Caesar", "Consul", "Imperator");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意\n\nRest 参数必须放到参数列表的末尾。\n\n❌ 例如 / 错误示范：\n\nfunction f(arg1, ...rest, arg2) { // arg2 在 ...rest 后面？！\n  // error\n}\n\n\n1\n2\n3\n\n\n\n# arguments 变量\n\narguments 是一个特殊的类数组对象，按参数索引包含所有参数。\n\n🌰 例子 ：\n\nfunction showName() {\n  console.log( arguments.length );\n  console.log( arguments[0] );\n  console.log( arguments[1] );\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 以前的 JavaScript 中没有 Rest 参数，而使用 arguments 是获取函数所有参数的唯一方法。\n> \n> 但缺点是，尽管 arguments 是一个 类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 arguments.map(...) 等方法。此外，它始终包含所有参数，不能截取入参的一部分使用。\n> \n> 所以实际开发最好使用 ... Rest 参数。\n\n注意\n\n箭头函数中没有 arguments 。访问到的 arguments 并不属于箭头函数，而是属于箭头函数外部的 “普通” 函数。\n\n类似箭头函数没有自身的 this 。\n\n\n# Spread 语法\n\n与 Rest 参数需要接收多个参数相反，这里使用 ... 传递多个参数（可迭代对象）\n\n🌰 例子 / 以 Math.max() 为例，返回传入的参数中的最大值，但是不能传入一个 数组， Math.max() 要传入一个列表形式的数值型参数。\n\nlet arr = [3, 5, 1];\nconsole.log(Math.max(arr)); // error\n\n\n1\n2\n\n\n显然不可能手动取 [] 数组的每一个元素，因为有可能不确定数组的元素数量。因此，可以使用 Spread 语法 ：\n\nconsole.log(Math.max(...arr))\n\n\n1\n\n\n🌰 例子 / 可以传递多个 可迭代对象：\n\nconsole.log(Math.max(...arr1, ...arr2))\n\n\n1\n\n\n🌰 例子 / 可以是任何的可迭代对象，包括字符串，将字符串转换为字符数组：\n\nlet str = \'Hello\'\nconsole.log([...str])\n\n\n1\n2\n\n\n> Spread 语法内部使用了 迭代器 来收集元素，与 for..of 的方式相同。因此，对于一个字符串， for..of 会逐个返回该字符串中的字符， ...str 也同理会得到 "H","e","l","l","o" 这样的结果。随后，字符列表被传递给数组初始化器 [...str] 。\n> \n> 使用 Array.from(str) ：\n> \n> let str = \'Hello\'\n> console.log(Array.from(str))\n> \n> \n> 1\n> 2\n> \n> \n> Array.from(obj) 和 [...obj] 存在一个细微的差别：\n> \n>  * Array.from 适用于 类数组对象 也适用于 可迭代对象。\n>  * Spread 语法只适用于 可迭代对象。\n> \n> 所以 Array.from() 更加通用。\n\n\n# 复制对象 / 数组\n\n在 ⌛️ JavaScript 对象的复制与引用 中，使用 Object.assign() 进行对象的浅拷贝。此处使用 Spread 语法能实现同样的效果。\n\n🌰 例子 / 复制数组：\n\nlet arr = [1, 2, 3]\n\nlet arrCopy = [...arr]\n\n// 检查两个数组的内容是否相同\nconsole.log(JSON.stringify(arr) === JSON.stringify(arrCopy)) // true\n// 检查两个数组的引用是否相同\nconsole.log(arr === arrCopy) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\narr.push(4) // 修改原数组\nconsole.log(arr.copy) // 副本对象不受影响\n\n\n1\n2\n\n\n🌰 例子 / 复制对象：\n\nlet obj = { a: 1, b: 2, c: 3 };\n\nlet objCopy = { ...obj };\n\n// 检查两个对象的内容是否相同\nconsole.log(JSON.stringify(obj) === JSON.stringify(objCopy));\n\n// 检查两个对象的引用是否相同\nconsole.log(obj === objCopy); \n\nobj.d = 4 // 修改原对象\nconsole.log(objCopy) // 副本对象不受影响\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 总结\n\n * ... 的使用不是 Rest 参数，就是 Spread 语法。\n   \n   * 若 ... 出现在 函数参数列表的最后，那么它就是 Rest 参数，它会把参数列表中剩余的参数收集到一个数组中。\n   * ... 出现在 函数调用或类似的表达式 中，那它就是 Spread 语法，它会把一个数组展开为列表。\n\n * 使用场景的不同：\n   \n   * Rest 参数用于创建可接受任意数量参数的函数。\n   * Spread 语法用于将数组传递给通常需要含有许多参数的列表的函数。\n\n> 这两种方法的使用可以轻松的 转换数组为参数列表、数组和对象传递。',normalizedContent:'# rest 参数\n\nrest 参数可以通过使用三个点 ... 并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中。这些点的字面意思是「将剩余参数收集到一个数组中」。\n\n🌰 例子：\n\nfunction sumall(...args) { \n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nconsole.log(sumall(1, 2, 3, 4, 5, 6))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子 / 有其他参数 ：\n\nfunction showname(firstname, lastname, ...titles) {\n  console.log( firstname + \' \' + lastname )\n  \n  console.log(titles[0])\n  console.log(titles[1])\n  console.log(titles.length)\n}\n\nshowname("julius", "caesar", "consul", "imperator");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意\n\nrest 参数必须放到参数列表的末尾。\n\n❌ 例如 / 错误示范：\n\nfunction f(arg1, ...rest, arg2) { // arg2 在 ...rest 后面？！\n  // error\n}\n\n\n1\n2\n3\n\n\n\n# arguments 变量\n\narguments 是一个特殊的类数组对象，按参数索引包含所有参数。\n\n🌰 例子 ：\n\nfunction showname() {\n  console.log( arguments.length );\n  console.log( arguments[0] );\n  console.log( arguments[1] );\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 以前的 javascript 中没有 rest 参数，而使用 arguments 是获取函数所有参数的唯一方法。\n> \n> 但缺点是，尽管 arguments 是一个 类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 arguments.map(...) 等方法。此外，它始终包含所有参数，不能截取入参的一部分使用。\n> \n> 所以实际开发最好使用 ... rest 参数。\n\n注意\n\n箭头函数中没有 arguments 。访问到的 arguments 并不属于箭头函数，而是属于箭头函数外部的 “普通” 函数。\n\n类似箭头函数没有自身的 this 。\n\n\n# spread 语法\n\n与 rest 参数需要接收多个参数相反，这里使用 ... 传递多个参数（可迭代对象）\n\n🌰 例子 / 以 math.max() 为例，返回传入的参数中的最大值，但是不能传入一个 数组， math.max() 要传入一个列表形式的数值型参数。\n\nlet arr = [3, 5, 1];\nconsole.log(math.max(arr)); // error\n\n\n1\n2\n\n\n显然不可能手动取 [] 数组的每一个元素，因为有可能不确定数组的元素数量。因此，可以使用 spread 语法 ：\n\nconsole.log(math.max(...arr))\n\n\n1\n\n\n🌰 例子 / 可以传递多个 可迭代对象：\n\nconsole.log(math.max(...arr1, ...arr2))\n\n\n1\n\n\n🌰 例子 / 可以是任何的可迭代对象，包括字符串，将字符串转换为字符数组：\n\nlet str = \'hello\'\nconsole.log([...str])\n\n\n1\n2\n\n\n> spread 语法内部使用了 迭代器 来收集元素，与 for..of 的方式相同。因此，对于一个字符串， for..of 会逐个返回该字符串中的字符， ...str 也同理会得到 "h","e","l","l","o" 这样的结果。随后，字符列表被传递给数组初始化器 [...str] 。\n> \n> 使用 array.from(str) ：\n> \n> let str = \'hello\'\n> console.log(array.from(str))\n> \n> \n> 1\n> 2\n> \n> \n> array.from(obj) 和 [...obj] 存在一个细微的差别：\n> \n>  * array.from 适用于 类数组对象 也适用于 可迭代对象。\n>  * spread 语法只适用于 可迭代对象。\n> \n> 所以 array.from() 更加通用。\n\n\n# 复制对象 / 数组\n\n在 ⌛️ javascript 对象的复制与引用 中，使用 object.assign() 进行对象的浅拷贝。此处使用 spread 语法能实现同样的效果。\n\n🌰 例子 / 复制数组：\n\nlet arr = [1, 2, 3]\n\nlet arrcopy = [...arr]\n\n// 检查两个数组的内容是否相同\nconsole.log(json.stringify(arr) === json.stringify(arrcopy)) // true\n// 检查两个数组的引用是否相同\nconsole.log(arr === arrcopy) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\narr.push(4) // 修改原数组\nconsole.log(arr.copy) // 副本对象不受影响\n\n\n1\n2\n\n\n🌰 例子 / 复制对象：\n\nlet obj = { a: 1, b: 2, c: 3 };\n\nlet objcopy = { ...obj };\n\n// 检查两个对象的内容是否相同\nconsole.log(json.stringify(obj) === json.stringify(objcopy));\n\n// 检查两个对象的引用是否相同\nconsole.log(obj === objcopy); \n\nobj.d = 4 // 修改原对象\nconsole.log(objcopy) // 副本对象不受影响\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 总结\n\n * ... 的使用不是 rest 参数，就是 spread 语法。\n   \n   * 若 ... 出现在 函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。\n   * ... 出现在 函数调用或类似的表达式 中，那它就是 spread 语法，它会把一个数组展开为列表。\n\n * 使用场景的不同：\n   \n   * rest 参数用于创建可接受任意数量参数的函数。\n   * spread 语法用于将数组传递给通常需要含有许多参数的列表的函数。\n\n> 这两种方法的使用可以轻松的 转换数组为参数列表、数组和对象传递。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚈 JavaScript 变量作用域与闭包",frontmatter:{title:"🚈 JavaScript 变量作用域与闭包",date:"2022-05-08T00:48:01.000Z",permalink:"/pages/7b2364/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/03.%20%F0%9F%9A%88%20JavaScript%20%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/03. 🚈 JavaScript 变量作用域与闭包.md",key:"v-ddbd9348",path:"/pages/7b2364/",headers:[{level:2,title:"变量作用域",slug:"变量作用域",normalizedTitle:"变量作用域",charIndex:115},{level:3,title:"代码块",slug:"代码块",normalizedTitle:"代码块",charIndex:125},{level:3,title:"嵌套函数",slug:"嵌套函数",normalizedTitle:"嵌套函数",charIndex:845},{level:2,title:"词法环境",slug:"词法环境",normalizedTitle:"词法环境",charIndex:1471},{level:3,title:"对于变量",slug:"对于变量",normalizedTitle:"对于变量",charIndex:1480},{level:3,title:"对于函数声明",slug:"对于函数声明",normalizedTitle:"对于函数声明",charIndex:2354},{level:3,title:"内部和外部的词法环境",slug:"内部和外部的词法环境",normalizedTitle:"内部和外部的词法环境",charIndex:2758},{level:3,title:"对于函数调用",slug:"对于函数调用",normalizedTitle:"对于函数调用",charIndex:3527},{level:3,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:4309},{level:3,title:"垃圾收集",slug:"垃圾收集",normalizedTitle:"垃圾收集",charIndex:4538},{level:3,title:"实际开发",slug:"实际开发",normalizedTitle:"实际开发",charIndex:5233},{level:2,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:182},{level:3,title:"函数的最新内容",slug:"函数的最新内容",normalizedTitle:"函数的最新内容",charIndex:5843},{level:3,title:"可用的变量",slug:"可用的变量",normalizedTitle:"可用的变量",charIndex:6135},{level:3,title:"counter 独立性",slug:"counter-独立性",normalizedTitle:"counter 独立性",charIndex:6562},{level:3,title:"if 内的函数",slug:"if-内的函数",normalizedTitle:"if 内的函数",charIndex:6952},{level:3,title:"双括号的函数",slug:"双括号的函数",normalizedTitle:"双括号的函数",charIndex:7230},{level:3,title:"变量是否可见",slug:"变量是否可见",normalizedTitle:"变量是否可见",charIndex:7373},{level:3,title:"通过嵌套返回函数筛选数组元素",slug:"通过嵌套返回函数筛选数组元素",normalizedTitle:"通过嵌套返回函数筛选数组元素",charIndex:7744},{level:3,title:"通过嵌套返回函数按字段排序对象",slug:"通过嵌套返回函数按字段排序对象",normalizedTitle:"通过嵌套返回函数按字段排序对象",charIndex:8260},{level:3,title:"函数大军",slug:"函数大军",normalizedTitle:"函数大军",charIndex:8878}],headersStr:"变量作用域 代码块 嵌套函数 词法环境 对于变量 对于函数声明 内部和外部的词法环境 对于函数调用 闭包 垃圾收集 实际开发 例子 函数的最新内容 可用的变量 counter 独立性 if 内的函数 双括号的函数 变量是否可见 通过嵌套返回函数筛选数组元素 通过嵌套返回函数按字段排序对象 函数大军",content:"> 普遍 JavaScript 有三种声明变量的方法： let / const / var （已经不被推荐使用），这里一般使用 let 或者 const 声明变量解释 变量的作用域。（因为 var 的声明变量比较特殊。）\n\n\n# 变量作用域\n\n\n# 代码块\n\n{ } 看作是一个代码块，如果在这个代码块中声明变量，那么这个变量就只能在这个代码块中 可见。\n\n🌰 例子 ：\n\n{\n  let msg = 'hello'\n  console.log(msg)\n}\n\nconsole.log(msg) // Error: msg is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 利用 代码块的特性 声明仅属于该代码块的变量：\n\n{\n  let msg = 'hello'\n  console.log(msg)\n}\n\n{\n  let msg = 'goodbye'\n  console.log(msg)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果 msg 不分别放在对应的代码块，则会报错。因为使用 let 声明变量，不能重复声明同一个变量名称的变量，否则报错。\n\n🌰 例子 / 对于 if / for / while 的 { ... } 中声明的变量也仅在内部可见。\n\nif (true) {\n  let phrase = 'hello'\n  console.log(phrase)\n}\n\nconsole.log(phrase) // phrase 变量不可见\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 就算是， if 条件符合运行后也是取不到 phrase 变量。\n\n对于 for ：\n\nfor(let i = 0; i < 3; i++) {\n  console.log(i)\n}\n\nconsole.log(i)\n\n\n1\n2\n3\n4\n5\n\n\n> 虽然变量 i 的声明不在 { ... } 内，但是在 for 中声明的变量也被视为块的一部分。\n\n\n# 嵌套函数\n\n如果一个函数是在另一个函数中创建的，该函数就被称为「嵌套」函数。\n\n🌰 例子：\n\nfunction sayHiBye(firstName, lastName) {\n  function getFullName() {\n    return firstName + \" \" + lastName;\n  }\n  \n  console.log(\"Hello, \" + getFullName())\n  console.log(\"Bye, \" + getFullName())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这里创建的 嵌套 函数 getFullName() 是为了更加方便，可以访问外部变量，因此可以返回全名。嵌套函数在 JavaScript 中很常见。\n\n🌰 例子 / 返回一个嵌套函数作为新对象的属性或者作为结果返回，之后可以在其他地方使用。不论在哪里调用，它仍然可以访问相同的外部变量：\n\nfunction makeCounter() {\n  let count = 0\n  return function() {\n    return count++\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> makeCounter 创建了一个返回 counter 嵌套函数，该函数在每次调用时返回下一个数字。\n\n嵌套函数稍加变型就可以有很强的实际用途，比如可以封装一个 随机数生成器 生成用于自动化测试的随机数值。\n\n\n# 词法环境\n\n\n# 对于变量\n\n在 JavaScript 中，每个运行的函数、代码块 {...} 以及整个脚本，都有一个被称为 词法环境 的内部（隐藏）的关联对象。有两部分组成：\n\n * 环境记录：存储所有局部变量作为其 属性（包括一些信息，例如 this 的值）的对象。\n * 对 外部词法环境 的引用，与外部代码 相关联。\n\n「一个变量」 只是这个特殊的内部对象的一个属性。所以 「获取或者修改变量」 意味着 「获取或修改 词法环境 的一个属性」。\n\n * 变量是 词法环境 的属性，与当前正在执行的代码有关。\n * 操作变量实际上是操作该对象的属性。\n\n🌰 例子 ：一个变量被声明和修改值的过程：\n\n// excution start  ---- phrase <uninitialized> => null\n\nlet phrase; //     ---- phrase: undefiend\n\nphrase = 'hello'// ---- phrase: 'hello'\nphrase = 'bye'  // ---- phrase: 'bye'\n\n\n1\n2\n3\n4\n5\n6\n\n\n * 起初当脚本开始运行，词法环境先填充了所有声明的变量。\n   \n   最初，它们处于「未初始化（Uninitialized）」状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 let 声明前，不能引用它。几乎就像变量不存在一样。\n\n * 然后执行 let phrase 定义。它尚未被赋值，因此它的值为 undefined 。从这一刻起，就可以使用变量了。\n\n * phrase 被赋予了一个值。\n\n * phrase 的值被修改。\n\n> 词法环境是一个 规范对象： 意味着它仅仅是存在于 编程语言规范 中的 理论上 存在的，用于描述事物如何运作的对象，并不能在代码中获取该对象并且直接对其进行操作。\n> \n> 但是 JavaScript 引擎同样可以对它优化，比如 清除未被使用的变量以节省内存和执行其他内部技巧等。但是显性行为仍然不能直接操作。\n\n\n# 对于函数声明\n\n函数与变量相同，也可以看作是一个 值。不同之处在于 函数声明的初始化会被立即完成。\n\n当创建了一个词法环境，函数声明会立即变为 即用型函数（不像 let 那样直到声明处才可用）。这就是为什么函数可以在声明之前调用函数声明。\n\n🌰 例子：\n\n// execution start --- phrase <uninitialized> outer=>null\n//                      say: function\n\nlet phrase = 'hello' // --- ...\n\nfunction say(name) {\n  console.log(`${phrase}. ${name}`)\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这种行为只使用函数声明。不使用将函数分配给变量的函数表达式，如 let say = function(name) 。\n\n\n# 内部和外部的词法环境\n\n在一个函数运行时，在调用刚开始时，会自动创建一个 新的词法环境 以存储这个调用的 局部变量和参数。\n\n🌰 例子：\n\nlet phrase = 'hello'\n\nfunction say(name) {\n  console.log(`${phrase}. ${name}`)\n}\n\nsay('John')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// lexical environment of the call\n// name: 'john' outer=>| say: function    outer=> null\n//                     | phrase: 'hello'\n\n\n1\n2\n3\n\n\n> 在这个函数调用期间，有两个词法环境，内部一个（函数调用）和外部一个（全局）。\n> \n>  * 内部词法环境与函数当前的执行相对应。具有一个单独的属性 name （函数的参数）。调用该函数传入的是 John ，所以 name 为 John 。\n>  * 外部词法环境是全局词法环境。具有 phrase 变量和函数本身。\n\n内部词法环境引用了 outer 外部的词法环境。当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。\n\n如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。\n\n在上面的例子中，搜索的过程：对于 name 变量，当 say 中的 console.log() 试图访问 name 时，会立即在内部词法环境中找到它；当它试图访问 phrase 时，然而内部没有 phrase ，所以它顺着对 外部词法环境的引用 找到了它。\n\n\n# 对于函数调用\n\n在 makeCounter 例子中：\n\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n在每次 makeCounter() 调用的开始，都会创建一个新的词法环境对象，以存储该 makeCounter 运行时的变量。因此有两层的 嵌套 词法环境。\n\n不同的是，在执行 makeCounter() 的过程中创建了一个仅占一行的嵌套函数： return count++ ，尚未运行它，仅创建了它。\n\n所有的函数在「诞生」时都会记住创建它们的词法环境。：所有函数都有名为 [[Environment]] 的 隐藏属性，该属性保存了对创建该函数的词法环境的引用。\n\n\n\n因此， counter.[[Environment]] 有对 {count: 0} 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。\n\n[[Environment]] 引用在函数创建时被设置并永久保存。\n\n当调用 counter() 时，会为该调用创建一个 新的词法环境，并且其外部词法环境引用获取于 counter.[[Environment]] ：\n\n\n\n现在，当 counter() 中的代码查找 count 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 makeCounter() 的词法环境，并且在哪里找到就在哪里修改。\n\n在变量所在的词法环境中更新变量，执行后的状态：\n\n\n\n如果调用 counter() 多次， count 变量将在同一位置增加到 2 ， 3 等。\n\n\n# 闭包\n\n记住 外部变量 并且可以访问这些变量的 函数。在 JavaScript 中，所有的函数都是 「天生」闭包（一个例外：）\n\nJavaScript 中的函数会自动通过隐藏的 [[Environment]] 属性记住创建它们的位置，所以它们都可以访问外部变量。\n\n🍎 什么是闭包？\n\n>  * 闭包的定义。\n>  * JavaScript 中的函数为什么都是闭包。\n>  * 关于 [[Environment]] 属性和词法环境原理的技术细节。\n\n\n# 垃圾收集\n\n通常在函数调用完成后，会将 词法环境和其中的所有变量 从内存中删除。因为现在没有任何对它们的引用了（「不可达」）。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。\n\n但是，如果有一个嵌套的函数在函数结束后 仍可达，则它将具有 引用词法环境 的 [[Environment]] 属性。\n\n🌰 例子 / 即便在外部函数执行完成后，它的词法环境仍然可达：\n\nfunction f() {\n  let value = 123;\n\n  return function() {\n    console.log(value);\n  }\n}\n\nlet g = f(); // g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意，如果多次调用 f() ，并且返回的函数被保存，那么所有相应的词法环境对象也会保留在内存中。\n> \n> 多次调用 f() ：\n> \n> let arr = [f(), f(), f()]\n> \n> \n> 1\n\n当嵌套函数被删除后，其封闭的词法环境（以及其中的 value ）也会被从内存中删除：\n\nfunction f() {\n  let value = 123;\n\n  return function() {\n    alert(value);\n  }\n}\n\nlet g = f() // g 函数存在时，该值会被保留在内存中\ng = null    // g 函数不存在，从内存中删除\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 实际开发\n\n理论上当函数可达时，它外部的所有变量也都将存在。\n\n但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。\n\n🌰 例子 / 在 V8 引擎中（Chrome，Edge，Opera），此类变量在调试中将不可用。\n\nfunction f() {\n  let value = Math.random();\n\n  function g() {\n    debugger; // 在 Console 中：输入 alert(value); No such variable!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 虽然理论上应该可以访问，但是引擎把它优化掉了。\n\n🌰 例子 / 引擎优化坑导致有趣的调试问题，有同名的外部变量但是不是预期的变量。\n\nlet value = 'surprise'\n\nfunction (f) {\n  let value = 'the closest value'\n  \n  function g() {\n    debugger\n  }\n  \n  return g\n}\n\nlet g = f()\ng()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 例子\n\n\n# 函数的最新内容\n\n> 函数 sayHi 使用外部变量。当函数运行时，将使用哪个值？\n> \n> let name = 'john'\n> \n> function sayHi() {\n>   alert(\"Hi, \" + name);\n> }\n> \n> name = \"Pete\";\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n点击查看\n\n浏览器和服务器端开发中都很常见。一个函数可能被计划在创建之后一段时间后才执行，例如在用户行为或网络请求之后。\n\n旧变量值不会保存在任何地方。当一个函数想要一个变量时，它会从自己的词法环境或外部词法环境中获取当前值。\n\n\n# 可用的变量\n\n> function makeWorker() {\n>   let name = \"Pete\";\n> \n>   return function() {\n>     alert(name);\n>   };\n> }\n> \n> let name = \"John\";\n> \n> // create a function\n> let work = makeWorker();\n> \n> // call it\n> work(); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n\n点击查看\n\n函数 work() 在其被创建的位置通过外部词法环境引用获取 name ：\n\n\n\n但如果在 makeWorker() 中没有 let name ，那么将继续向外搜索并最终找到全局变量，正如可以从上图中看到的那样。在这种情况下，结果将是 \"John\" 。\n\n\n# counter 独立性\n\n> 用相同的 makeCounter 函数创建了两个计数器（counters）： counter 和 counter2 。\n> \n> unction makeCounter() {\n>   let count = 0;\n> \n>   return function() {\n>     return count++;\n>   };\n> }\n> \n> let counter = makeCounter();\n> let counter2 = makeCounter();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n点击查看\n\n函数 counter 和 counter2 是通过 makeCounter 的不同调用创建的。\n\n因此，它们具有独立的外部词法环境，每一个都有自己的 count 。\n\n\n# if 内的函数\n\n> let phrase = \"Hello\";\n> \n> if (true) {\n>   let user = \"John\";\n> \n>   function sayHi() {\n>     alert(`${phrase}, ${user}`);\n>   }\n> }\n> \n> sayHi();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n点击查看\n\n在 if 代码块中定义函数 sayHi ，所以它只存在于 if 中。外部是没有 sayHi 的。所以运行会报错。\n\n\n# 双括号的函数\n\n> sum(1)(2) = 3\n> sum(5)(-1) = 4\n> \n> \n> 1\n> 2\n\n点击查看\n\nfunction sum(a) {\n  return function(b) {\n    return a + b\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 变量是否可见\n\n> 在下面这段代码中：\n> \n> let x = 1\n> function func() {\n>   console.log(x)\n>   let x = 2\n> }\n> \n> func()\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n点击查看\n\n可以看出「不存在变量」和「未初始化」 变量之间的特殊差异。\n\n * 从程序执行进入代码块（或函数）的那一刻起，变量就开始进入「未初始化」状态。它一直保持未初始化状态，直至程序执行到相应的 let 语句。\n * 一个变量从技术的角度来讲是存在的，但是在 let 之前还不能使用。\n\n所以上面的代码：虽然知道 局部变量 x ，但是 x 一直处于未初始化的状态（无法使用），直到死区结束。\n\n> 死区：变量暂时无法使用的区域，从代码块到 let 。\n\n\n# 通过嵌套返回函数筛选数组元素\n\n> arr.filter(func) 方法可以通过函数 func 过滤函数，如果函数返回 true ，则元素会被返回到结果数据。\n> \n> 制造一系列 “即用型” 过滤器：\n> \n>  * inBetween(a, b) —— 在 a 和 b 之间或与它们相等（包括）。\n>  * inArray([...]) —— 包含在给定的数组中。\n> \n> 用法如下所示：\n> \n>  * arr.filter(inBetween(3,6)) —— 只挑选范围在 3 到 6 的值。\n>  * arr.filter(inArray([1,2,3])) —— 只挑选与 [1,2,3] 中的元素匹配的元素。\n\n点击查看\n\nfunction inBetween(a, b) {\n  return function(x) {\n    return x >= a || x <= b\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\nfunction inArray(arr){\n  return function(x) {\n    return arr.includes(x)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 通过嵌套返回函数按字段排序对象\n\n> 有一组要排序的对象：\n> \n> let users = [\n>   { name: \"John\", age: 20, surname: \"Johnson\" },\n>   { name: \"Pete\", age: 18, surname: \"Peterson\" },\n>   { name: \"Ann\", age: 19, surname: \"Hathaway\" }\n> ];\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 通常做法：\n> \n> user.sort((a, b) => a.name > b.name ? 1 : -1)\n> \n> \n> 1\n> \n> \n> 或者\n> \n> user.sort((a, b) => a.age > b.age ? 1 : -1)\n> \n> \n> 1\n> \n> \n> 要实现 只输入一个字段名称，就实现排序，如下：\n> \n> users.sort(byField('name'))\n> users.sort(byField('age'))\n> \n> \n> 1\n> 2\n\n:::\n\n编写函数 byField ：\n\nfunction byField(fieldName){\n    return ((a, b) => a[fieldName] > b[fieldName] ? 1 : -1) \n}\n\n\n1\n2\n3\n\n\n:::\n\n\n# 函数大军\n\n> 在下面代码中，期望每次循环到的 添加到数组中的 输出 shooter 的编号函数。但是最后调用时的都是同样的值？\n> \n> function makeArmy(){\n>   let shooters = []\n>   \n>   let i = 0\n>   while(i < 10) {\n>     let shooter = function() {\n>       console.log(i)\n>     }\n>     shooters.push(shooter)\n>     i++\n>   }\n>   \n>   return shooters\n> }\n> \n> let army = makeArmy()\n> army[0]() // 10\n> army[1]() // 10\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n\n点击查看\n\n分析代码的运行过程：\n\n 1. 首先创建了空数组 shooters 。\n\n 2. 在 while 循环中，通过 shooters.push(shooter) 填充 shooter 函数，相当于：\n    \n    shooters = [\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n    ];\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 3. 然后返回这个数组。\n\n 4. 创建数组并且填充数组之后，试图对数组中的任意数组项的函数进行调用。\n\n所有的数组项函数都输出同一个数值 i 的原因，因为 i 是来自这个函数的外部 词法环境的。\n\n * 所有的 shooter 函数都是在 makeArmy() 的词法环境中被创建的。\n * 当 army[5]() 被调用时， makeArmy 已经运行完了，最后 i 的值为 10 （ while 循环在 i=10 时停止）。\n * 因此，所有的 shooter 函数获得的都是外部词法环境中的同一个值，即最后的 i=10 。\n\n\n\n在 while {...} 块的每次迭代中，都会创建一个新的词法环境。\n\n要解决这个问题，可以通过\n\n * 将 i 的值复制到 while {...} 块内的变量中：\n   \n   // ... \n   let i = 0 \n   while (i < 10) {\n         let j = i;\n         let shooter = function() { // shooter 函数\n           alert( j ); // 应该显示它自己的编号\n         };\n       shooters.push(shooter);\n       i++;\n     }\n   // ... \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   > let j = i 声明了一个 “局部迭代” 变量 j ，并将 i 复制到其中。原始类型是「按值」复制的，因此实际上得到的是属于当前循环迭代的独立的 i 的副本。\n   > \n   > shooter 函数正确运行了，因为 i 值的位置更近了（译注：指转到了更内部的词法环境）。不是在 makeArmy() 的词法环境中，而是在与当前循环迭代相对应的词法环境中：\n\n * 使用 for 循环替代 while 循环：\n   \n   function makeArmy() {\n     let shooters = [];\n     for(let i = 0; i < 10; i++) {\n       let shooter = function() { // shooter 函数\n         alert( i ); // 应该显示它自己的编号\n       };\n       shooters.push(shooter);\n     }\n     return shooters;\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   > for 循环在每次迭代中，都会生成一个带有自己的变量 i 的新词法环境。因此，在每次迭代中生成的 shooter 函数引用的都是自己的 i 。",normalizedContent:"> 普遍 javascript 有三种声明变量的方法： let / const / var （已经不被推荐使用），这里一般使用 let 或者 const 声明变量解释 变量的作用域。（因为 var 的声明变量比较特殊。）\n\n\n# 变量作用域\n\n\n# 代码块\n\n{ } 看作是一个代码块，如果在这个代码块中声明变量，那么这个变量就只能在这个代码块中 可见。\n\n🌰 例子 ：\n\n{\n  let msg = 'hello'\n  console.log(msg)\n}\n\nconsole.log(msg) // error: msg is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 利用 代码块的特性 声明仅属于该代码块的变量：\n\n{\n  let msg = 'hello'\n  console.log(msg)\n}\n\n{\n  let msg = 'goodbye'\n  console.log(msg)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果 msg 不分别放在对应的代码块，则会报错。因为使用 let 声明变量，不能重复声明同一个变量名称的变量，否则报错。\n\n🌰 例子 / 对于 if / for / while 的 { ... } 中声明的变量也仅在内部可见。\n\nif (true) {\n  let phrase = 'hello'\n  console.log(phrase)\n}\n\nconsole.log(phrase) // phrase 变量不可见\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 就算是， if 条件符合运行后也是取不到 phrase 变量。\n\n对于 for ：\n\nfor(let i = 0; i < 3; i++) {\n  console.log(i)\n}\n\nconsole.log(i)\n\n\n1\n2\n3\n4\n5\n\n\n> 虽然变量 i 的声明不在 { ... } 内，但是在 for 中声明的变量也被视为块的一部分。\n\n\n# 嵌套函数\n\n如果一个函数是在另一个函数中创建的，该函数就被称为「嵌套」函数。\n\n🌰 例子：\n\nfunction sayhibye(firstname, lastname) {\n  function getfullname() {\n    return firstname + \" \" + lastname;\n  }\n  \n  console.log(\"hello, \" + getfullname())\n  console.log(\"bye, \" + getfullname())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这里创建的 嵌套 函数 getfullname() 是为了更加方便，可以访问外部变量，因此可以返回全名。嵌套函数在 javascript 中很常见。\n\n🌰 例子 / 返回一个嵌套函数作为新对象的属性或者作为结果返回，之后可以在其他地方使用。不论在哪里调用，它仍然可以访问相同的外部变量：\n\nfunction makecounter() {\n  let count = 0\n  return function() {\n    return count++\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> makecounter 创建了一个返回 counter 嵌套函数，该函数在每次调用时返回下一个数字。\n\n嵌套函数稍加变型就可以有很强的实际用途，比如可以封装一个 随机数生成器 生成用于自动化测试的随机数值。\n\n\n# 词法环境\n\n\n# 对于变量\n\n在 javascript 中，每个运行的函数、代码块 {...} 以及整个脚本，都有一个被称为 词法环境 的内部（隐藏）的关联对象。有两部分组成：\n\n * 环境记录：存储所有局部变量作为其 属性（包括一些信息，例如 this 的值）的对象。\n * 对 外部词法环境 的引用，与外部代码 相关联。\n\n「一个变量」 只是这个特殊的内部对象的一个属性。所以 「获取或者修改变量」 意味着 「获取或修改 词法环境 的一个属性」。\n\n * 变量是 词法环境 的属性，与当前正在执行的代码有关。\n * 操作变量实际上是操作该对象的属性。\n\n🌰 例子 ：一个变量被声明和修改值的过程：\n\n// excution start  ---- phrase <uninitialized> => null\n\nlet phrase; //     ---- phrase: undefiend\n\nphrase = 'hello'// ---- phrase: 'hello'\nphrase = 'bye'  // ---- phrase: 'bye'\n\n\n1\n2\n3\n4\n5\n6\n\n\n * 起初当脚本开始运行，词法环境先填充了所有声明的变量。\n   \n   最初，它们处于「未初始化（uninitialized）」状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 let 声明前，不能引用它。几乎就像变量不存在一样。\n\n * 然后执行 let phrase 定义。它尚未被赋值，因此它的值为 undefined 。从这一刻起，就可以使用变量了。\n\n * phrase 被赋予了一个值。\n\n * phrase 的值被修改。\n\n> 词法环境是一个 规范对象： 意味着它仅仅是存在于 编程语言规范 中的 理论上 存在的，用于描述事物如何运作的对象，并不能在代码中获取该对象并且直接对其进行操作。\n> \n> 但是 javascript 引擎同样可以对它优化，比如 清除未被使用的变量以节省内存和执行其他内部技巧等。但是显性行为仍然不能直接操作。\n\n\n# 对于函数声明\n\n函数与变量相同，也可以看作是一个 值。不同之处在于 函数声明的初始化会被立即完成。\n\n当创建了一个词法环境，函数声明会立即变为 即用型函数（不像 let 那样直到声明处才可用）。这就是为什么函数可以在声明之前调用函数声明。\n\n🌰 例子：\n\n// execution start --- phrase <uninitialized> outer=>null\n//                      say: function\n\nlet phrase = 'hello' // --- ...\n\nfunction say(name) {\n  console.log(`${phrase}. ${name}`)\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这种行为只使用函数声明。不使用将函数分配给变量的函数表达式，如 let say = function(name) 。\n\n\n# 内部和外部的词法环境\n\n在一个函数运行时，在调用刚开始时，会自动创建一个 新的词法环境 以存储这个调用的 局部变量和参数。\n\n🌰 例子：\n\nlet phrase = 'hello'\n\nfunction say(name) {\n  console.log(`${phrase}. ${name}`)\n}\n\nsay('john')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// lexical environment of the call\n// name: 'john' outer=>| say: function    outer=> null\n//                     | phrase: 'hello'\n\n\n1\n2\n3\n\n\n> 在这个函数调用期间，有两个词法环境，内部一个（函数调用）和外部一个（全局）。\n> \n>  * 内部词法环境与函数当前的执行相对应。具有一个单独的属性 name （函数的参数）。调用该函数传入的是 john ，所以 name 为 john 。\n>  * 外部词法环境是全局词法环境。具有 phrase 变量和函数本身。\n\n内部词法环境引用了 outer 外部的词法环境。当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。\n\n如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。\n\n在上面的例子中，搜索的过程：对于 name 变量，当 say 中的 console.log() 试图访问 name 时，会立即在内部词法环境中找到它；当它试图访问 phrase 时，然而内部没有 phrase ，所以它顺着对 外部词法环境的引用 找到了它。\n\n\n# 对于函数调用\n\n在 makecounter 例子中：\n\nfunction makecounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makecounter();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n在每次 makecounter() 调用的开始，都会创建一个新的词法环境对象，以存储该 makecounter 运行时的变量。因此有两层的 嵌套 词法环境。\n\n不同的是，在执行 makecounter() 的过程中创建了一个仅占一行的嵌套函数： return count++ ，尚未运行它，仅创建了它。\n\n所有的函数在「诞生」时都会记住创建它们的词法环境。：所有函数都有名为 [[environment]] 的 隐藏属性，该属性保存了对创建该函数的词法环境的引用。\n\n\n\n因此， counter.[[environment]] 有对 {count: 0} 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。\n\n[[environment]] 引用在函数创建时被设置并永久保存。\n\n当调用 counter() 时，会为该调用创建一个 新的词法环境，并且其外部词法环境引用获取于 counter.[[environment]] ：\n\n\n\n现在，当 counter() 中的代码查找 count 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 makecounter() 的词法环境，并且在哪里找到就在哪里修改。\n\n在变量所在的词法环境中更新变量，执行后的状态：\n\n\n\n如果调用 counter() 多次， count 变量将在同一位置增加到 2 ， 3 等。\n\n\n# 闭包\n\n记住 外部变量 并且可以访问这些变量的 函数。在 javascript 中，所有的函数都是 「天生」闭包（一个例外：）\n\njavascript 中的函数会自动通过隐藏的 [[environment]] 属性记住创建它们的位置，所以它们都可以访问外部变量。\n\n🍎 什么是闭包？\n\n>  * 闭包的定义。\n>  * javascript 中的函数为什么都是闭包。\n>  * 关于 [[environment]] 属性和词法环境原理的技术细节。\n\n\n# 垃圾收集\n\n通常在函数调用完成后，会将 词法环境和其中的所有变量 从内存中删除。因为现在没有任何对它们的引用了（「不可达」）。与 javascript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。\n\n但是，如果有一个嵌套的函数在函数结束后 仍可达，则它将具有 引用词法环境 的 [[environment]] 属性。\n\n🌰 例子 / 即便在外部函数执行完成后，它的词法环境仍然可达：\n\nfunction f() {\n  let value = 123;\n\n  return function() {\n    console.log(value);\n  }\n}\n\nlet g = f(); // g.[[environment]] 存储了对相应 f() 调用的词法环境的引用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意，如果多次调用 f() ，并且返回的函数被保存，那么所有相应的词法环境对象也会保留在内存中。\n> \n> 多次调用 f() ：\n> \n> let arr = [f(), f(), f()]\n> \n> \n> 1\n\n当嵌套函数被删除后，其封闭的词法环境（以及其中的 value ）也会被从内存中删除：\n\nfunction f() {\n  let value = 123;\n\n  return function() {\n    alert(value);\n  }\n}\n\nlet g = f() // g 函数存在时，该值会被保留在内存中\ng = null    // g 函数不存在，从内存中删除\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 实际开发\n\n理论上当函数可达时，它外部的所有变量也都将存在。\n\n但在实际中，javascript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。\n\n🌰 例子 / 在 v8 引擎中（chrome，edge，opera），此类变量在调试中将不可用。\n\nfunction f() {\n  let value = math.random();\n\n  function g() {\n    debugger; // 在 console 中：输入 alert(value); no such variable!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 虽然理论上应该可以访问，但是引擎把它优化掉了。\n\n🌰 例子 / 引擎优化坑导致有趣的调试问题，有同名的外部变量但是不是预期的变量。\n\nlet value = 'surprise'\n\nfunction (f) {\n  let value = 'the closest value'\n  \n  function g() {\n    debugger\n  }\n  \n  return g\n}\n\nlet g = f()\ng()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 例子\n\n\n# 函数的最新内容\n\n> 函数 sayhi 使用外部变量。当函数运行时，将使用哪个值？\n> \n> let name = 'john'\n> \n> function sayhi() {\n>   alert(\"hi, \" + name);\n> }\n> \n> name = \"pete\";\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n点击查看\n\n浏览器和服务器端开发中都很常见。一个函数可能被计划在创建之后一段时间后才执行，例如在用户行为或网络请求之后。\n\n旧变量值不会保存在任何地方。当一个函数想要一个变量时，它会从自己的词法环境或外部词法环境中获取当前值。\n\n\n# 可用的变量\n\n> function makeworker() {\n>   let name = \"pete\";\n> \n>   return function() {\n>     alert(name);\n>   };\n> }\n> \n> let name = \"john\";\n> \n> // create a function\n> let work = makeworker();\n> \n> // call it\n> work(); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n\n点击查看\n\n函数 work() 在其被创建的位置通过外部词法环境引用获取 name ：\n\n\n\n但如果在 makeworker() 中没有 let name ，那么将继续向外搜索并最终找到全局变量，正如可以从上图中看到的那样。在这种情况下，结果将是 \"john\" 。\n\n\n# counter 独立性\n\n> 用相同的 makecounter 函数创建了两个计数器（counters）： counter 和 counter2 。\n> \n> unction makecounter() {\n>   let count = 0;\n> \n>   return function() {\n>     return count++;\n>   };\n> }\n> \n> let counter = makecounter();\n> let counter2 = makecounter();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n点击查看\n\n函数 counter 和 counter2 是通过 makecounter 的不同调用创建的。\n\n因此，它们具有独立的外部词法环境，每一个都有自己的 count 。\n\n\n# if 内的函数\n\n> let phrase = \"hello\";\n> \n> if (true) {\n>   let user = \"john\";\n> \n>   function sayhi() {\n>     alert(`${phrase}, ${user}`);\n>   }\n> }\n> \n> sayhi();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n点击查看\n\n在 if 代码块中定义函数 sayhi ，所以它只存在于 if 中。外部是没有 sayhi 的。所以运行会报错。\n\n\n# 双括号的函数\n\n> sum(1)(2) = 3\n> sum(5)(-1) = 4\n> \n> \n> 1\n> 2\n\n点击查看\n\nfunction sum(a) {\n  return function(b) {\n    return a + b\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 变量是否可见\n\n> 在下面这段代码中：\n> \n> let x = 1\n> function func() {\n>   console.log(x)\n>   let x = 2\n> }\n> \n> func()\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n点击查看\n\n可以看出「不存在变量」和「未初始化」 变量之间的特殊差异。\n\n * 从程序执行进入代码块（或函数）的那一刻起，变量就开始进入「未初始化」状态。它一直保持未初始化状态，直至程序执行到相应的 let 语句。\n * 一个变量从技术的角度来讲是存在的，但是在 let 之前还不能使用。\n\n所以上面的代码：虽然知道 局部变量 x ，但是 x 一直处于未初始化的状态（无法使用），直到死区结束。\n\n> 死区：变量暂时无法使用的区域，从代码块到 let 。\n\n\n# 通过嵌套返回函数筛选数组元素\n\n> arr.filter(func) 方法可以通过函数 func 过滤函数，如果函数返回 true ，则元素会被返回到结果数据。\n> \n> 制造一系列 “即用型” 过滤器：\n> \n>  * inbetween(a, b) —— 在 a 和 b 之间或与它们相等（包括）。\n>  * inarray([...]) —— 包含在给定的数组中。\n> \n> 用法如下所示：\n> \n>  * arr.filter(inbetween(3,6)) —— 只挑选范围在 3 到 6 的值。\n>  * arr.filter(inarray([1,2,3])) —— 只挑选与 [1,2,3] 中的元素匹配的元素。\n\n点击查看\n\nfunction inbetween(a, b) {\n  return function(x) {\n    return x >= a || x <= b\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\nfunction inarray(arr){\n  return function(x) {\n    return arr.includes(x)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 通过嵌套返回函数按字段排序对象\n\n> 有一组要排序的对象：\n> \n> let users = [\n>   { name: \"john\", age: 20, surname: \"johnson\" },\n>   { name: \"pete\", age: 18, surname: \"peterson\" },\n>   { name: \"ann\", age: 19, surname: \"hathaway\" }\n> ];\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 通常做法：\n> \n> user.sort((a, b) => a.name > b.name ? 1 : -1)\n> \n> \n> 1\n> \n> \n> 或者\n> \n> user.sort((a, b) => a.age > b.age ? 1 : -1)\n> \n> \n> 1\n> \n> \n> 要实现 只输入一个字段名称，就实现排序，如下：\n> \n> users.sort(byfield('name'))\n> users.sort(byfield('age'))\n> \n> \n> 1\n> 2\n\n:::\n\n编写函数 byfield ：\n\nfunction byfield(fieldname){\n    return ((a, b) => a[fieldname] > b[fieldname] ? 1 : -1) \n}\n\n\n1\n2\n3\n\n\n:::\n\n\n# 函数大军\n\n> 在下面代码中，期望每次循环到的 添加到数组中的 输出 shooter 的编号函数。但是最后调用时的都是同样的值？\n> \n> function makearmy(){\n>   let shooters = []\n>   \n>   let i = 0\n>   while(i < 10) {\n>     let shooter = function() {\n>       console.log(i)\n>     }\n>     shooters.push(shooter)\n>     i++\n>   }\n>   \n>   return shooters\n> }\n> \n> let army = makearmy()\n> army[0]() // 10\n> army[1]() // 10\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n\n点击查看\n\n分析代码的运行过程：\n\n 1. 首先创建了空数组 shooters 。\n\n 2. 在 while 循环中，通过 shooters.push(shooter) 填充 shooter 函数，相当于：\n    \n    shooters = [\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n      function () { console.log(i); },\n    ];\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 3. 然后返回这个数组。\n\n 4. 创建数组并且填充数组之后，试图对数组中的任意数组项的函数进行调用。\n\n所有的数组项函数都输出同一个数值 i 的原因，因为 i 是来自这个函数的外部 词法环境的。\n\n * 所有的 shooter 函数都是在 makearmy() 的词法环境中被创建的。\n * 当 army[5]() 被调用时， makearmy 已经运行完了，最后 i 的值为 10 （ while 循环在 i=10 时停止）。\n * 因此，所有的 shooter 函数获得的都是外部词法环境中的同一个值，即最后的 i=10 。\n\n\n\n在 while {...} 块的每次迭代中，都会创建一个新的词法环境。\n\n要解决这个问题，可以通过\n\n * 将 i 的值复制到 while {...} 块内的变量中：\n   \n   // ... \n   let i = 0 \n   while (i < 10) {\n         let j = i;\n         let shooter = function() { // shooter 函数\n           alert( j ); // 应该显示它自己的编号\n         };\n       shooters.push(shooter);\n       i++;\n     }\n   // ... \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   > let j = i 声明了一个 “局部迭代” 变量 j ，并将 i 复制到其中。原始类型是「按值」复制的，因此实际上得到的是属于当前循环迭代的独立的 i 的副本。\n   > \n   > shooter 函数正确运行了，因为 i 值的位置更近了（译注：指转到了更内部的词法环境）。不是在 makearmy() 的词法环境中，而是在与当前循环迭代相对应的词法环境中：\n\n * 使用 for 循环替代 while 循环：\n   \n   function makearmy() {\n     let shooters = [];\n     for(let i = 0; i < 10; i++) {\n       let shooter = function() { // shooter 函数\n         alert( i ); // 应该显示它自己的编号\n       };\n       shooters.push(shooter);\n     }\n     return shooters;\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   > for 循环在每次迭代中，都会生成一个带有自己的变量 i 的新词法环境。因此，在每次迭代中生成的 shooter 函数引用的都是自己的 i 。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚂 JavaScript 全局对象",frontmatter:{title:"🚂 JavaScript 全局对象",date:"2022-05-08T00:48:22.000Z",permalink:"/pages/b89842/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/04.%20%F0%9F%9A%82%20JavaScript%20%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/04. 🚂 JavaScript 全局对象.md",key:"v-8eb7b8b2",path:"/pages/b89842/",headers:[{level:2,title:"Polyfills 给新功能提供兼容性",slug:"polyfills-给新功能提供兼容性",normalizedTitle:"polyfills 给新功能提供兼容性",charIndex:733}],headersStr:"Polyfills 给新功能提供兼容性",content:'全局对象提供可在 任何地方 使用的 变量 和 函数。默认情况下，这些全局变量 内建于语言或环境 中。\n\n对于不同的环境：\n\n * 浏览器中， window\n * Node.js 中， global\n * 标准名称 globalThis 。所有环境都应该支持该名称，所有主流浏览器都支持它。\n\n🌰 例子：\n\nalert("Hello");\n// 等同于\nwindow.alert("Hello");\n\n\n1\n2\n3\n\n\n🌰 例子 / 使用 var 声明的变量或函数会成为全局对象的属性。\n\nvar gVar = 5;\nconsole.log(window.gVar);\n\n\n1\n2\n\n\n> 使用 var 声明的函数具有与函数声明相同的效果（一般函数使用 function ，而不是函数表达式）。\n> \n> 现代 JavaScript 中一般使用 JavaScript 模块。\n\n🌰 例子 / 如果一个值非常重要，以至于它在全局范围内可用，那么可以直接将其作为属性写入：\n\nwindow.currentUser = {\n  name: \'Simon\'\n}\n\n// ...\n// 在代码中的另一个位置\nconsole.log(currentUser.name) // \'Simon\'\n\n// 当存在相同命名的变量时\n// 使用 window 显式获取\nconsole.log(window.currentUser.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n** 一般不建议这样使用全局变量。** 全局变量应该尽可能地少，与使用外部变量或全局变量相比，函数获取「输入」变量并产生特定「输出」的代码设计更加清晰，不易出错且更易于测试。\n\n\n# Polyfills 给新功能提供兼容性\n\nPolyfills 是 JavaScript 中用来为旧版本浏览器提供没有原生支持的新功能。能抹平不同浏览器对 API 的兼容性的差异。\n\n🌰 例子 / 测试是否存在内建的 Promise 对象（在版本特别旧的浏览器中不存在），如果没有，则创建 Polyfills 利用全局对象添加环境不支持但在现代标准中存在的功能。\n\nif (!window.Promise) {\n  alert("Your browser is really old!");\n  window.Promise = ... // 定制实现现代语言功能\n} \n\n\n1\n2\n3\n4\n',normalizedContent:'全局对象提供可在 任何地方 使用的 变量 和 函数。默认情况下，这些全局变量 内建于语言或环境 中。\n\n对于不同的环境：\n\n * 浏览器中， window\n * node.js 中， global\n * 标准名称 globalthis 。所有环境都应该支持该名称，所有主流浏览器都支持它。\n\n🌰 例子：\n\nalert("hello");\n// 等同于\nwindow.alert("hello");\n\n\n1\n2\n3\n\n\n🌰 例子 / 使用 var 声明的变量或函数会成为全局对象的属性。\n\nvar gvar = 5;\nconsole.log(window.gvar);\n\n\n1\n2\n\n\n> 使用 var 声明的函数具有与函数声明相同的效果（一般函数使用 function ，而不是函数表达式）。\n> \n> 现代 javascript 中一般使用 javascript 模块。\n\n🌰 例子 / 如果一个值非常重要，以至于它在全局范围内可用，那么可以直接将其作为属性写入：\n\nwindow.currentuser = {\n  name: \'simon\'\n}\n\n// ...\n// 在代码中的另一个位置\nconsole.log(currentuser.name) // \'simon\'\n\n// 当存在相同命名的变量时\n// 使用 window 显式获取\nconsole.log(window.currentuser.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n** 一般不建议这样使用全局变量。** 全局变量应该尽可能地少，与使用外部变量或全局变量相比，函数获取「输入」变量并产生特定「输出」的代码设计更加清晰，不易出错且更易于测试。\n\n\n# polyfills 给新功能提供兼容性\n\npolyfills 是 javascript 中用来为旧版本浏览器提供没有原生支持的新功能。能抹平不同浏览器对 api 的兼容性的差异。\n\n🌰 例子 / 测试是否存在内建的 promise 对象（在版本特别旧的浏览器中不存在），如果没有，则创建 polyfills 利用全局对象添加环境不支持但在现代标准中存在的功能。\n\nif (!window.promise) {\n  alert("your browser is really old!");\n  window.promise = ... // 定制实现现代语言功能\n} \n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚆 JavaScript 函数对象",frontmatter:{title:"🚆 JavaScript 函数对象",date:"2022-05-10T00:40:22.000Z",permalink:"/pages/577e1c/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/05.%20%F0%9F%9A%86%20JavaScript%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/05. 🚆 JavaScript 函数对象.md",key:"v-621fc681",path:"/pages/577e1c/",headers:[{level:2,title:"函数属性",slug:"函数属性",normalizedTitle:"函数属性",charIndex:100},{level:3,title:"name 函数名称",slug:"name-函数名称",normalizedTitle:"name 函数名称",charIndex:109},{level:3,title:"length",slug:"length",normalizedTitle:"length",charIndex:961},{level:3,title:"自定义属性",slug:"自定义属性",normalizedTitle:"自定义属性",charIndex:1735},{level:3,title:"命名函数表达式",slug:"命名函数表达式",normalizedTitle:"命名函数表达式",charIndex:2727},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4219},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:4678},{level:3,title:"利用函数属性给函数提供更多的方法",slug:"利用函数属性给函数提供更多的方法",normalizedTitle:"利用函数属性给函数提供更多的方法",charIndex:4685},{level:3,title:"创建自定义对象任意数量括号求和",slug:"创建自定义对象任意数量括号求和",normalizedTitle:"创建自定义对象任意数量括号求和",charIndex:5173}],headersStr:"函数属性 name 函数名称 length 自定义属性 命名函数表达式 总结 实例 利用函数属性给函数提供更多的方法 创建自定义对象任意数量括号求和",content:'JavaScript 中函数也是一种对象类型。可以把 函数 理解为可以被调用的 行为对象（Action Object），不仅可以调用它们，还可以当作对象来处理：增 / 删属性、按引用传递等。\n\n\n# 函数属性\n\n\n# name 函数名称\n\n函数对象中包含一些实用的属性。\n\n🌰 例子 / 通过属性 name 访问函数的名字：\n\nfunction sayHi() {\n  alert("Hi");\n}\n\nconsole.log(sayHi.name)\n\n\n1\n2\n3\n4\n5\n\n\n> 对于函数的名字复制：即便函数创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值。\n> \n> let sayHi = function() {\n>   alert("Hi");\n> };\n> \n> console.log(sayHi.name) // sayHi\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 以默认值方式完成赋值时也会自动赋予正确的函数名字：\n> \n> function f(sayHi = function() {}) {\n>   console.log(sayHi.name); // sayHi\n> }\n> \n> \n> \n> 1\n> 2\n> 3\n> 4\n\n这种函数命名方式为「上下文命名」。如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个。\n\n🌰 例子 / 对于对象中的函数也适用 上下文命名：\n\nlet user = {\n\n  sayHi() {\n    // ...\n  },\n\n  sayBye: function() {\n    // ...\n  }\n\n}\n\nconsole.log(user.sayHi.name)\nconsole.log(user.sayBye.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n🌰 例子 / 无法推测出函数名字的情况，函数是在数组中创建的：\n\nlet arr = [function() {}];\nconsole.log(arr[0].name) // \'\'\n\n\n1\n2\n\n\n> 由于引擎无法设置正确的函数名字，所以没有值。\n\n实际应用中，函数一般是由名字，方便调用。\n\n\n# length\n\n🌰 例子 / 函数的 length 属性返回函数入参的个数：\n\nfunction f1(a) {}\nfunction f2(a, b) {}\nfunction many(a, b, ...more) {}\n\nconsole.log(f1.length) // 1\nconsole.log(f2.length) // 2\nconsole.log(many.length) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n可以在上面的例子看出，Rest 语法的参数不计入参数的个数。\n\n🌰 例子 / 属性 length 有时在操作其它函数的函数中用于做 内省 / 运行时检查（introspection）。\n\nfunction ask(question, ...handlers) {\n  let isYes = confirm(question);\n\n  for(let handler of handlers) {\n    if (handler.length == 0) {\n      if (isYes) handler();\n    } else {\n      handler(isYes);\n    }\n  }\n\n}\n\n// 对于积极的回答，两个 handler 都会被调用\n// 对于负面的回答，只有第二个 handler 被调用\nask("Question?", () => alert(\'You said yes\'), result => alert(result));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 多态性 —— 根据参数的类型，或者根据在具体情景下的 length 来做不同的处理。这种思想在 JavaScript 的库里有应用。\n\n\n# 自定义属性\n\n在函数对象中可以添加自己的属性。\n\n🌰 例子：\n\nfunction sayHi() {\n  console.log("Hi");\n\n  // 计算调用次数\n  sayHi.counter++;\n}\nsayHi.counter = 0; \n\nsayHi(); // Hi\nsayHi(); // Hi\nconsole.log(`called ${sayHi.counter} times`) // called 2 times\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n注意\n\n函数中的属性不是变量。被赋值给函数的属性，比如 sayHi.counter = 0 ，不会 在函数内定义一个局部变量 counter 。换句话说，属性 counter 和变量 let counter 是毫不相关的两个东西。\n\n可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不是函数属性，反之亦然。它们之间是平行的。\n\n🌰 例子 / 函数对象中的属性可以用来替代 闭包：\n\nfunction makeCounter() {\n  // let count = 0\n  \n  function counter() {\n    return counter.count++\n  }\n  \n  counter.count = 0\n\treturn counter\n}\n\nlet counter = makeCounter()\nconsole.log(counter()) // 0\nconsole.log(counter()) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 现在 count 被直接存储在函数里，而不是它外部的词法环境。\n> \n> 对比 闭包 和 函数属性：两者最大的不同就是如果 count 的值位于外层（函数）变量中，那么外部的代码无法访问到它，只有嵌套的函数可以修改它。而如果它是绑定到函数的，那么就很容易：\n> \n> let counter = makeCounter();\n> \n> counter.count = 10;\n> console.log(counter()); // 10\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 所以选择哪一种方法依照实际情况选择。\n\n\n# 命名函数表达式\n\n命名函数表达式（NFE，Named Function Expression）：指 带有名字 的函数表达式的术语。\n\n🌰 例子：\n\nlet sayHi = function func(who) {\n  console.log(`Hello, ${who}`);\n};\n\n\n1\n2\n3\n\n\n> 加了 func 名字后仍然是一个 函数表达式，在 function 后面加一个名字 func 没有使它成为一个 函数声明，因为它仍然是作为赋值表达式中的一部分被创建的。添加这个名字当然也没有打破任何东西。\n\n函数仍然可以通过 sayHi 调用：\n\nsayHi(\'Simon\')\n\n\n1\n\n\n关于名字 func 有两个特殊的地方，这就是添加它的原因：\n\n 1. 它允许函数在内部引用自己。\n 2. 它在函数外是不可见的。\n\n🌰 例子 / 当函数没有带参数允许调用自身：\n\nlet sayHi = function func(who) {\n  if (who) {\n    console.log(`Hello, ${who}`);\n  } else {\n    func("Guest"); // 使用 func 再次调用函数自身\n  }\n};\n\nsayHi() // Hello, Guest\n\nfunc() // 在函数外不可见\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 如果仅仅使用 sayHi 的命名嵌套调用：\n> \n> let sayHi = function(who) {\n>   if (who) {\n>     console.log(`Hello, ${who}`);\n>   } else {\n>     sayHi("Guest");\n>   }\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 当函数的命名更换后：\n> \n> let welcome = sayHi\n> sayHi = null\n> \n> welcome() // Error\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 会报错，因为该函数从它的外部词法环境获取 sayHi 。没有局部的 sayHi 了，所以使用外部变量。而当调用时，外部的 sayHi 是 null 。\n> \n> 所以给函数表达式命名可以避免这个问题：\n> \n> let sayHi = function func(who) {\n>   if (who) {\n>     console.log(`Hello, ${who}`);\n>   } else {\n>     func("Guest"); // 现在一切正常\n>   }\n> };\n> \n> let welcome = sayHi;\n> sayHi = null;\n> \n> welcome();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 此时可用了，名字 func 是函数局部域的。它不是从外部获取的（而且它对外部也是不可见的）。规范确保它只会引用当前函数。\n> \n> 外部代码仍然有该函数的 sayHi 或 welcome 变量。而且 func 是一个「内部函数名」，可用于函数在自身内部进行自调用。\n\n注意\n\n对于 函数声明 中没有添加「内部」名的语法。「内部名」特性只针对 函数表达式，而不是函数声明。当需要一个可靠的内部名时，就可以 把函数声明重写成函数表达式 了。\n\n\n# 总结\n\n * 函数就是一个对象。\n * 函数有属性：\n   * name ：函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。\n   * length ：函数定义时的 入参的个数。Rest 参数不参与计数。\n * 函数的自定义属性：函数可以带有额外的属性。很多知名的 JavaScript 库都充分利用了这个功能。\n   * 可以创建创建一个「主」函数，然后给它附加很多其它「辅助」函数。jQuery 库创建了一个名为 $ 的函数。lodash 库创建一个 _ 函数，然后为其添加了 _.add 、 _.keyBy 以及其它属性。\n   * 实际上，它们这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量。这样就降低了命名冲突的可能性。\n * 命名函数表达式 NFE ：函数是通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字。这个名字可以用于该函数内部自我调用，并且外部不可见。\n\n\n# 实例\n\n\n# 利用函数属性给函数提供更多的方法\n\n> 修改 makeCounter() 代码，使得 counter 可以进行减一和设置值的操作：\n> \n>  * counter() 应该返回下一个数字。\n>  * counter.set(value) 应该将 count 设置为 value 。\n>  * counter.decrease() 应该把 count 减 1。\n\n点击查看\n\nfunction makeCounter() {\n  let count = 0\n  \n  function counter() {\n    return count++\n  }\n  \n  counter.set = (value) => count = value\n  counter.decrease = () => count--\n  \n  return counter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在局部变量中使用 count ，而进行加法操作的方法是直接写在 counter 中的。它们共享同一个外部词法环境，并且可以访问当前的 count 。\n\n\n# 创建自定义对象任意数量括号求和\n\n> 写一个函数 sum ，它有这样的功能：\n> \n> sum(1)(2) == 3; // 1 + 2\n> sum(1)(2)(3) == 6; // 1 + 2 + 3\n> sum(5)(-1)(2) == 6\n> sum(6)(-1)(-2)(-3) == 0\n> sum(0)(1)(2)(3)(4)(5) == 15\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction sum(a){\n  let currentSum = a\n  \n  function f(b) {\n    currentSum += b\n    return f\n  }\n  \n  f.toString() = function () {\n    return currentSum\n  }\n  \n  return f\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nsum 函数只工作一次，它返回了函数 f 。然后，接下来的每一次子调用， f 都会把自己的参数加到求和 currentSum 上，然后 f 自身。\n\n注意，在 f 的最后一行没有递归。 只是返回了函数自身，然后再按照需要才会被调用。',normalizedContent:'javascript 中函数也是一种对象类型。可以把 函数 理解为可以被调用的 行为对象（action object），不仅可以调用它们，还可以当作对象来处理：增 / 删属性、按引用传递等。\n\n\n# 函数属性\n\n\n# name 函数名称\n\n函数对象中包含一些实用的属性。\n\n🌰 例子 / 通过属性 name 访问函数的名字：\n\nfunction sayhi() {\n  alert("hi");\n}\n\nconsole.log(sayhi.name)\n\n\n1\n2\n3\n4\n5\n\n\n> 对于函数的名字复制：即便函数创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值。\n> \n> let sayhi = function() {\n>   alert("hi");\n> };\n> \n> console.log(sayhi.name) // sayhi\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 以默认值方式完成赋值时也会自动赋予正确的函数名字：\n> \n> function f(sayhi = function() {}) {\n>   console.log(sayhi.name); // sayhi\n> }\n> \n> \n> \n> 1\n> 2\n> 3\n> 4\n\n这种函数命名方式为「上下文命名」。如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个。\n\n🌰 例子 / 对于对象中的函数也适用 上下文命名：\n\nlet user = {\n\n  sayhi() {\n    // ...\n  },\n\n  saybye: function() {\n    // ...\n  }\n\n}\n\nconsole.log(user.sayhi.name)\nconsole.log(user.saybye.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n🌰 例子 / 无法推测出函数名字的情况，函数是在数组中创建的：\n\nlet arr = [function() {}];\nconsole.log(arr[0].name) // \'\'\n\n\n1\n2\n\n\n> 由于引擎无法设置正确的函数名字，所以没有值。\n\n实际应用中，函数一般是由名字，方便调用。\n\n\n# length\n\n🌰 例子 / 函数的 length 属性返回函数入参的个数：\n\nfunction f1(a) {}\nfunction f2(a, b) {}\nfunction many(a, b, ...more) {}\n\nconsole.log(f1.length) // 1\nconsole.log(f2.length) // 2\nconsole.log(many.length) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n可以在上面的例子看出，rest 语法的参数不计入参数的个数。\n\n🌰 例子 / 属性 length 有时在操作其它函数的函数中用于做 内省 / 运行时检查（introspection）。\n\nfunction ask(question, ...handlers) {\n  let isyes = confirm(question);\n\n  for(let handler of handlers) {\n    if (handler.length == 0) {\n      if (isyes) handler();\n    } else {\n      handler(isyes);\n    }\n  }\n\n}\n\n// 对于积极的回答，两个 handler 都会被调用\n// 对于负面的回答，只有第二个 handler 被调用\nask("question?", () => alert(\'you said yes\'), result => alert(result));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 多态性 —— 根据参数的类型，或者根据在具体情景下的 length 来做不同的处理。这种思想在 javascript 的库里有应用。\n\n\n# 自定义属性\n\n在函数对象中可以添加自己的属性。\n\n🌰 例子：\n\nfunction sayhi() {\n  console.log("hi");\n\n  // 计算调用次数\n  sayhi.counter++;\n}\nsayhi.counter = 0; \n\nsayhi(); // hi\nsayhi(); // hi\nconsole.log(`called ${sayhi.counter} times`) // called 2 times\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n注意\n\n函数中的属性不是变量。被赋值给函数的属性，比如 sayhi.counter = 0 ，不会 在函数内定义一个局部变量 counter 。换句话说，属性 counter 和变量 let counter 是毫不相关的两个东西。\n\n可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不是函数属性，反之亦然。它们之间是平行的。\n\n🌰 例子 / 函数对象中的属性可以用来替代 闭包：\n\nfunction makecounter() {\n  // let count = 0\n  \n  function counter() {\n    return counter.count++\n  }\n  \n  counter.count = 0\n\treturn counter\n}\n\nlet counter = makecounter()\nconsole.log(counter()) // 0\nconsole.log(counter()) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 现在 count 被直接存储在函数里，而不是它外部的词法环境。\n> \n> 对比 闭包 和 函数属性：两者最大的不同就是如果 count 的值位于外层（函数）变量中，那么外部的代码无法访问到它，只有嵌套的函数可以修改它。而如果它是绑定到函数的，那么就很容易：\n> \n> let counter = makecounter();\n> \n> counter.count = 10;\n> console.log(counter()); // 10\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 所以选择哪一种方法依照实际情况选择。\n\n\n# 命名函数表达式\n\n命名函数表达式（nfe，named function expression）：指 带有名字 的函数表达式的术语。\n\n🌰 例子：\n\nlet sayhi = function func(who) {\n  console.log(`hello, ${who}`);\n};\n\n\n1\n2\n3\n\n\n> 加了 func 名字后仍然是一个 函数表达式，在 function 后面加一个名字 func 没有使它成为一个 函数声明，因为它仍然是作为赋值表达式中的一部分被创建的。添加这个名字当然也没有打破任何东西。\n\n函数仍然可以通过 sayhi 调用：\n\nsayhi(\'simon\')\n\n\n1\n\n\n关于名字 func 有两个特殊的地方，这就是添加它的原因：\n\n 1. 它允许函数在内部引用自己。\n 2. 它在函数外是不可见的。\n\n🌰 例子 / 当函数没有带参数允许调用自身：\n\nlet sayhi = function func(who) {\n  if (who) {\n    console.log(`hello, ${who}`);\n  } else {\n    func("guest"); // 使用 func 再次调用函数自身\n  }\n};\n\nsayhi() // hello, guest\n\nfunc() // 在函数外不可见\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 如果仅仅使用 sayhi 的命名嵌套调用：\n> \n> let sayhi = function(who) {\n>   if (who) {\n>     console.log(`hello, ${who}`);\n>   } else {\n>     sayhi("guest");\n>   }\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 当函数的命名更换后：\n> \n> let welcome = sayhi\n> sayhi = null\n> \n> welcome() // error\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> 会报错，因为该函数从它的外部词法环境获取 sayhi 。没有局部的 sayhi 了，所以使用外部变量。而当调用时，外部的 sayhi 是 null 。\n> \n> 所以给函数表达式命名可以避免这个问题：\n> \n> let sayhi = function func(who) {\n>   if (who) {\n>     console.log(`hello, ${who}`);\n>   } else {\n>     func("guest"); // 现在一切正常\n>   }\n> };\n> \n> let welcome = sayhi;\n> sayhi = null;\n> \n> welcome();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 此时可用了，名字 func 是函数局部域的。它不是从外部获取的（而且它对外部也是不可见的）。规范确保它只会引用当前函数。\n> \n> 外部代码仍然有该函数的 sayhi 或 welcome 变量。而且 func 是一个「内部函数名」，可用于函数在自身内部进行自调用。\n\n注意\n\n对于 函数声明 中没有添加「内部」名的语法。「内部名」特性只针对 函数表达式，而不是函数声明。当需要一个可靠的内部名时，就可以 把函数声明重写成函数表达式 了。\n\n\n# 总结\n\n * 函数就是一个对象。\n * 函数有属性：\n   * name ：函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，javascript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。\n   * length ：函数定义时的 入参的个数。rest 参数不参与计数。\n * 函数的自定义属性：函数可以带有额外的属性。很多知名的 javascript 库都充分利用了这个功能。\n   * 可以创建创建一个「主」函数，然后给它附加很多其它「辅助」函数。jquery 库创建了一个名为 $ 的函数。lodash 库创建一个 _ 函数，然后为其添加了 _.add 、 _.keyby 以及其它属性。\n   * 实际上，它们这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量。这样就降低了命名冲突的可能性。\n * 命名函数表达式 nfe ：函数是通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字。这个名字可以用于该函数内部自我调用，并且外部不可见。\n\n\n# 实例\n\n\n# 利用函数属性给函数提供更多的方法\n\n> 修改 makecounter() 代码，使得 counter 可以进行减一和设置值的操作：\n> \n>  * counter() 应该返回下一个数字。\n>  * counter.set(value) 应该将 count 设置为 value 。\n>  * counter.decrease() 应该把 count 减 1。\n\n点击查看\n\nfunction makecounter() {\n  let count = 0\n  \n  function counter() {\n    return count++\n  }\n  \n  counter.set = (value) => count = value\n  counter.decrease = () => count--\n  \n  return counter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在局部变量中使用 count ，而进行加法操作的方法是直接写在 counter 中的。它们共享同一个外部词法环境，并且可以访问当前的 count 。\n\n\n# 创建自定义对象任意数量括号求和\n\n> 写一个函数 sum ，它有这样的功能：\n> \n> sum(1)(2) == 3; // 1 + 2\n> sum(1)(2)(3) == 6; // 1 + 2 + 3\n> sum(5)(-1)(2) == 6\n> sum(6)(-1)(-2)(-3) == 0\n> sum(0)(1)(2)(3)(4)(5) == 15\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction sum(a){\n  let currentsum = a\n  \n  function f(b) {\n    currentsum += b\n    return f\n  }\n  \n  f.tostring() = function () {\n    return currentsum\n  }\n  \n  return f\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nsum 函数只工作一次，它返回了函数 f 。然后，接下来的每一次子调用， f 都会把自己的参数加到求和 currentsum 上，然后 f 自身。\n\n注意，在 f 的最后一行没有递归。 只是返回了函数自身，然后再按照需要才会被调用。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚞 JavaScript 创建函数 new Function",frontmatter:{title:"🚞 JavaScript 创建函数 new Function",date:"2022-05-11T12:03:11.000Z",permalink:"/pages/b022f1/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/06.%20%F0%9F%9A%9E%20JavaScript%20%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%20new%20Function.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/06. 🚞 JavaScript 创建函数 new Function.md",key:"v-52852f48",path:"/pages/b022f1/",headers:[{level:2,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:642}],headersStr:"闭包",content:"这是另一种 比较少用的 创建函数的方法： new Function 。\n\n语法：\n\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n\n\n1\n\n\n> 通过使用给定的 参数 arg ... 和 函数体 functionBody 字符串创建函数。\n\n🌰 例子：\n\nlet sum = new Function('a', 'b', 'return a + b');\n\nconsole.log(sum(1, 2)); // 3\n\n\n1\n2\n3\n\n\n🌰 例子 / 没有参数的函数：\n\nlet sayHi = new Function('alert(\"Hello\")');\n\nsayHi()\n\n\n1\n2\n3\n\n\n这种创建函数的方法与已知的创建函数方法最大的不同在于，它实际上是通过运行时 通过参数传递过来的字符串 创建的。\n\n以往函数都要在脚本中编写并调用。 new Function 允许将任意字符串变为函数。意味着可以从服务器中接受一个 字符串 创建新的函数并执行它。\n\n🌰 例子：\n\nlet str = '...' // 动态地接收来自服务器的代码 ...\n\nlet func = new Function(str);\nfunc();\n\n\n1\n2\n3\n4\n\n\n> 使用 new Function 创建函数的应用场景非常特殊，比如在复杂需要从服务器 获取代码 或者 动态地从模板编译函数时 才会使用。\n\n\n# 闭包\n\n使用 new Function 创建一个函数，那么该函数的 [[Environment]] 并不指向当前的词法环境，而是指向全局环境。\n\n因此，此类函数无法访问外部变量，只能访问全局变量。这有助于降低我们代码出错的可能。并且，从代码架构上讲，显式地使用参数传值是一种更好的方法，并且避免了与使用压缩程序而产生冲突的问题。\n\n🌰 例子：\n\nfunction getFunc() {\n  let value = \"test\";\n\n  let func = new Function('alert(value)');\n\n  return func;\n}\n\ngetFunc()() // Error: value is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 与常规的函数声明对比：\n> \n> function getFunc() {\n>   let value = \"test\";\n> \n>   let func = function() { alert(value); };\n> \n>   return func;\n> }\n> \n> getFunc()(); // test\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9",normalizedContent:"这是另一种 比较少用的 创建函数的方法： new function 。\n\n语法：\n\nlet func = new function ([arg1, arg2, ...argn], functionbody);\n\n\n1\n\n\n> 通过使用给定的 参数 arg ... 和 函数体 functionbody 字符串创建函数。\n\n🌰 例子：\n\nlet sum = new function('a', 'b', 'return a + b');\n\nconsole.log(sum(1, 2)); // 3\n\n\n1\n2\n3\n\n\n🌰 例子 / 没有参数的函数：\n\nlet sayhi = new function('alert(\"hello\")');\n\nsayhi()\n\n\n1\n2\n3\n\n\n这种创建函数的方法与已知的创建函数方法最大的不同在于，它实际上是通过运行时 通过参数传递过来的字符串 创建的。\n\n以往函数都要在脚本中编写并调用。 new function 允许将任意字符串变为函数。意味着可以从服务器中接受一个 字符串 创建新的函数并执行它。\n\n🌰 例子：\n\nlet str = '...' // 动态地接收来自服务器的代码 ...\n\nlet func = new function(str);\nfunc();\n\n\n1\n2\n3\n4\n\n\n> 使用 new function 创建函数的应用场景非常特殊，比如在复杂需要从服务器 获取代码 或者 动态地从模板编译函数时 才会使用。\n\n\n# 闭包\n\n使用 new function 创建一个函数，那么该函数的 [[environment]] 并不指向当前的词法环境，而是指向全局环境。\n\n因此，此类函数无法访问外部变量，只能访问全局变量。这有助于降低我们代码出错的可能。并且，从代码架构上讲，显式地使用参数传值是一种更好的方法，并且避免了与使用压缩程序而产生冲突的问题。\n\n🌰 例子：\n\nfunction getfunc() {\n  let value = \"test\";\n\n  let func = new function('alert(value)');\n\n  return func;\n}\n\ngetfunc()() // error: value is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 与常规的函数声明对比：\n> \n> function getfunc() {\n>   let value = \"test\";\n> \n>   let func = function() { alert(value); };\n> \n>   return func;\n> }\n> \n> getfunc()(); // test\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚠 JavaScript 中的调度函数",frontmatter:{title:"🚠 JavaScript 中的调度函数",date:"2022-05-11T12:18:12.000Z",permalink:"/pages/222f6f/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/07.%20%F0%9F%9A%A0%20JavaScript%20%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/07. 🚠 JavaScript 中的调度函数.md",key:"v-9f196f3c",path:"/pages/222f6f/",headers:[{level:2,title:"setTimeout",slug:"settimeout",normalizedTitle:"settimeout",charIndex:84},{level:2,title:"setInterval",slug:"setinterval",normalizedTitle:"setinterval",charIndex:118},{level:2,title:"嵌套 setTimeout",slug:"嵌套-settimeout",normalizedTitle:"嵌套 settimeout",charIndex:1619},{level:2,title:"零延时的  setTimeout",slug:"零延时的-settimeout",normalizedTitle:"零延时的  settimeout",charIndex:null}],headersStr:"setTimeout setInterval 嵌套 setTimeout 零延时的  setTimeout",content:"在 JavaScript 中，如果不想立即执行一个函数，而是等待一段时间或者间隔执行这个函数，可以使用「计划调用」函数（scheduling a call）。\n\n * setTimeout ：将函数推迟到一段时间间隔之后再执行。\n * setInterval ：重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。\n\n> 这两个方法并不在 JavaScript 的规范中。但是大多数运行环境都有内建的调度程序，并且提供了这些方法。目前来讲，所有浏览器以及 Node.js 都支持这两个方法。\n\n\n# setTimeout\n\n使用语法：\n\nlet timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)\n\n\n1\n\n>  * func|code ：想要执行的函数或代码字符串。 一般传入的都是函数。（不建议传入代码字符串）\n>  * delay ：执行前的延时，以毫秒为单位（1000 ms = 1s），默认值是 0；\n>  * arg1 ， arg2 … ：要传入被执行函数（或代码字符串）的参数列表。\n\n🌰 例子 ：\n\nfunction sayHi() {\n  alert('Hello');\n}\n\nsetTimeout(sayHi, 1000);\n\n\n1\n2\n3\n4\n5\n\n\n> 注意，传入一个的是 函数的名称， 而不要在后面加上 () 成为传入函数的执行结果。\n\n🌰 例子 / 带参数的情况：\n\nfunction sayHi(phrase, who) {\n  alert( phrase + ', ' + who );\n}\n\nsetTimeout(sayHi, 1000, \"Hello\", \"John\");\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 使用箭头函数避免使用字符串形式：\n\nsetTimeout(() => alert('Hello'), 1000)\n\n\n1\n\n\n使用 clearTimeout 取消 setTimeout 调度，一般在使用 setTimeout 接受一个 timerId ：\n\nlet timer = setTimeout(...);\nclearTimeout(timerId);\n\n\n1\n2\n\n\n🌰 例子 ：\n\nlet timerId = setTimeout(() => alert(\"never happens\"), 1000);\nalert(timerId); // 定时器标识符\n\nclearTimeout(timerId);\nalert(timerId); // null\n\n\n1\n2\n3\n4\n5\n\n\n\n# setInterval\n\n与 setTimeout 的语法使用相同：\n\nlet timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)\n\n\n1\n\n\n🌰 例子 / 每间隔两秒就输出一条消息：\n\n// 每 2 秒重复一次\nlet timerId = setInterval(() => alert('tick'), 2000);\n\n// 5 秒之后停止\nsetTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);\n\n\n1\n2\n3\n4\n5\n\n\n提示\n\nalert 弹窗显示的时候计时器依然在进行计时。在大多数浏览器中，包括 Chrome 和 Firefox，在显示 alert/confirm/prompt 弹窗时，内部的定时器仍旧会继续 “嘀嗒”。\n\n所以，在运行上面的代码时，如果在一定时间内没有关掉 alert 弹窗，那么在你关闭弹窗后，下一个 alert 会立即显示。两次 alert 之间的时间间隔将小于 2 秒。\n\n\n# 嵌套 setTimeout\n\n🌰 例子 / 使用 setTimeout 同样可以实现周期性调用：\n\nlet timerId = setTimeout(function tick() {\n  alert('tick');\n  timerId = setTimeout(tick, 2000);\n}, 2000);\n\n\n1\n2\n3\n4\n\n\n> 嵌套的 setTimeout 要比 setInterval 灵活得多。采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同。\n\n🌰 例子 / 根据上一次的执行结果来执行下一次调用：\n\nlet delay = 5000\nlet timerId = setTimeout(function request(){\n  // ... 发送请求\n  \n  if ( ... ) { // ... 服务器过载发送请求失败 \n      delay *= 2\n  }\n  \n  timerId = setTimeout(request, delay)\n}, delay)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 实现一个服务（server），每间隔 5 秒向服务器发送一个数据请求，但如果服务器过载了，那么就要降低请求频率，比如将间隔增加到 10、20、40 秒等。\n> \n> 并且，如果调度的函数占用大量的 CPU，那么我们可以测量执行所需要花费的时间，并安排下次调用是应该提前还是推迟。\n\n嵌套的 setTimeout 能够精确地设置两次执行之间的延时，而 setInterval 却不能。\n\n🌰 例子：\n\n * 在 setInterval ：\n   \n   let i = 1\n   setInterval(function() {\n     func(i++);\n   }, 100);\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 使用嵌套 setTimeout ：\n   \n   let i = 1;\n   setTimeout(function run() {\n     func(i++);\n     setTimeout(run, 100);\n   }, 100);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n> 对 setInterval 而言，内部的调度程序会每间隔 100 毫秒执行一次 func(i++) ：使用 setInterval 时， func 函数的实际调用间隔要比代码中设定的时间间隔要短。 因为 func 的执行所花费的时间也算进了时间间隔中。\n> \n> 在这种情况下，JavaScript 引擎会等待 func 执行完成，然后检查调度程序，如果时间到了，则 立即 再次执行它。极端情况下，如果函数每次执行时间都超过 delay 设置的时间，那么每次调用之间将完全没有停顿。\n> \n> \n> \n> 对于 setTimeout ，** 嵌套的 setTimeout 就能确保延时的固定（这里是 100 毫秒）。** 因为下一次调用是在前一次调用完成时再调度的。\n\n提示\n\n垃圾回收和 setInterval / setTimeout 回调 （callback）：当一个函数传入 setInterval / setTimeout 时，将为其创建一个 内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。\n\n// 在调度程序调用这个函数之前，这个函数将一直存在于内存中\nsetTimeout(function() {...}, 100);\n\n\n1\n2\n\n\n但是 如果函数引用了外部变量（闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。\n\n\n# 零延时的 setTimeout\n\nsetTimeout 的特殊用法： setTimeout(func, 0) ，或者仅仅是 setTimeout(func) 。\n\n这样调度函数，可以让 func 尽快执行，但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。也就是说，该函数被调度在当前脚本执行完成「之后」立即执行。\n\n🌰 例子：\n\nsetTimeout(() => alert(\"World\"));\n\nalert(\"Hello\");\n\n\n1\n2\n3\n\n\n> 这段代码会先输出 Hello ，然后立即输出 World 。\n> \n> setTimeout 将调度安排到了 日程 0 毫秒处。但是调度程序只有在当前脚本执行完毕时才会去「检查日程」，所以先输出 Hello ，然后才输出 World 。\n\n点击查看\n\n在浏览器环境中零延时实际上不为零：在浏览器环境下，嵌套定时器的运行频率是受限制的。根据 HTML5 标准 所讲：「经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒」。\n\n🌰 例子 / setTimeout 调用会以零延时重新调度自身的调用。每次调用都会在 times 数组中记录上一次调用的实际时间。：\n\nlet start = Date.now();\nlet times = [];\n\nsetTimeout(function run() {\n  times.push(Date.now() - start); // 保存前一个调用的延时\n\n  if (start + 100 < Date.now()) alert(times); // 100 毫秒之后，显示延时信息\n  else setTimeout(run); // 否则重新调度\n});\n\n// 输出示例：\n// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在代码的第一次执行时，定时器是立即执行的。但接下来的调用，必须经过 4 毫秒以上的强制延时。 timer 数组里存放的是每次定时器运行的时刻与 start 的差值，所以数字只会越来越大，实际上前后调用的延时是数组值的差值。\n\n对于 setInterval 也会发生类似的情况： setInterval(f) 会以零延时运行几次 f ，然后以 4 毫秒以上的强制延时运行。\n\n对于服务端的 JavaScript，就没有这个限制，并且还有其他调度即时异步任务的方式。例如 Node.js 的 setImmediate。因此，这个提醒只是针对浏览器环境的。",normalizedContent:"在 javascript 中，如果不想立即执行一个函数，而是等待一段时间或者间隔执行这个函数，可以使用「计划调用」函数（scheduling a call）。\n\n * settimeout ：将函数推迟到一段时间间隔之后再执行。\n * setinterval ：重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。\n\n> 这两个方法并不在 javascript 的规范中。但是大多数运行环境都有内建的调度程序，并且提供了这些方法。目前来讲，所有浏览器以及 node.js 都支持这两个方法。\n\n\n# settimeout\n\n使用语法：\n\nlet timerid = settimeout(func|code, [delay], [arg1], [arg2], ...)\n\n\n1\n\n>  * func|code ：想要执行的函数或代码字符串。 一般传入的都是函数。（不建议传入代码字符串）\n>  * delay ：执行前的延时，以毫秒为单位（1000 ms = 1s），默认值是 0；\n>  * arg1 ， arg2 … ：要传入被执行函数（或代码字符串）的参数列表。\n\n🌰 例子 ：\n\nfunction sayhi() {\n  alert('hello');\n}\n\nsettimeout(sayhi, 1000);\n\n\n1\n2\n3\n4\n5\n\n\n> 注意，传入一个的是 函数的名称， 而不要在后面加上 () 成为传入函数的执行结果。\n\n🌰 例子 / 带参数的情况：\n\nfunction sayhi(phrase, who) {\n  alert( phrase + ', ' + who );\n}\n\nsettimeout(sayhi, 1000, \"hello\", \"john\");\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 使用箭头函数避免使用字符串形式：\n\nsettimeout(() => alert('hello'), 1000)\n\n\n1\n\n\n使用 cleartimeout 取消 settimeout 调度，一般在使用 settimeout 接受一个 timerid ：\n\nlet timer = settimeout(...);\ncleartimeout(timerid);\n\n\n1\n2\n\n\n🌰 例子 ：\n\nlet timerid = settimeout(() => alert(\"never happens\"), 1000);\nalert(timerid); // 定时器标识符\n\ncleartimeout(timerid);\nalert(timerid); // null\n\n\n1\n2\n3\n4\n5\n\n\n\n# setinterval\n\n与 settimeout 的语法使用相同：\n\nlet timerid = setinterval(func|code, [delay], [arg1], [arg2], ...)\n\n\n1\n\n\n🌰 例子 / 每间隔两秒就输出一条消息：\n\n// 每 2 秒重复一次\nlet timerid = setinterval(() => alert('tick'), 2000);\n\n// 5 秒之后停止\nsettimeout(() => { clearinterval(timerid); alert('stop'); }, 5000);\n\n\n1\n2\n3\n4\n5\n\n\n提示\n\nalert 弹窗显示的时候计时器依然在进行计时。在大多数浏览器中，包括 chrome 和 firefox，在显示 alert/confirm/prompt 弹窗时，内部的定时器仍旧会继续 “嘀嗒”。\n\n所以，在运行上面的代码时，如果在一定时间内没有关掉 alert 弹窗，那么在你关闭弹窗后，下一个 alert 会立即显示。两次 alert 之间的时间间隔将小于 2 秒。\n\n\n# 嵌套 settimeout\n\n🌰 例子 / 使用 settimeout 同样可以实现周期性调用：\n\nlet timerid = settimeout(function tick() {\n  alert('tick');\n  timerid = settimeout(tick, 2000);\n}, 2000);\n\n\n1\n2\n3\n4\n\n\n> 嵌套的 settimeout 要比 setinterval 灵活得多。采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同。\n\n🌰 例子 / 根据上一次的执行结果来执行下一次调用：\n\nlet delay = 5000\nlet timerid = settimeout(function request(){\n  // ... 发送请求\n  \n  if ( ... ) { // ... 服务器过载发送请求失败 \n      delay *= 2\n  }\n  \n  timerid = settimeout(request, delay)\n}, delay)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 实现一个服务（server），每间隔 5 秒向服务器发送一个数据请求，但如果服务器过载了，那么就要降低请求频率，比如将间隔增加到 10、20、40 秒等。\n> \n> 并且，如果调度的函数占用大量的 cpu，那么我们可以测量执行所需要花费的时间，并安排下次调用是应该提前还是推迟。\n\n嵌套的 settimeout 能够精确地设置两次执行之间的延时，而 setinterval 却不能。\n\n🌰 例子：\n\n * 在 setinterval ：\n   \n   let i = 1\n   setinterval(function() {\n     func(i++);\n   }, 100);\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 使用嵌套 settimeout ：\n   \n   let i = 1;\n   settimeout(function run() {\n     func(i++);\n     settimeout(run, 100);\n   }, 100);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n> 对 setinterval 而言，内部的调度程序会每间隔 100 毫秒执行一次 func(i++) ：使用 setinterval 时， func 函数的实际调用间隔要比代码中设定的时间间隔要短。 因为 func 的执行所花费的时间也算进了时间间隔中。\n> \n> 在这种情况下，javascript 引擎会等待 func 执行完成，然后检查调度程序，如果时间到了，则 立即 再次执行它。极端情况下，如果函数每次执行时间都超过 delay 设置的时间，那么每次调用之间将完全没有停顿。\n> \n> \n> \n> 对于 settimeout ，** 嵌套的 settimeout 就能确保延时的固定（这里是 100 毫秒）。** 因为下一次调用是在前一次调用完成时再调度的。\n\n提示\n\n垃圾回收和 setinterval / settimeout 回调 （callback）：当一个函数传入 setinterval / settimeout 时，将为其创建一个 内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（gc）将其回收。\n\n// 在调度程序调用这个函数之前，这个函数将一直存在于内存中\nsettimeout(function() {...}, 100);\n\n\n1\n2\n\n\n但是 如果函数引用了外部变量（闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。\n\n\n# 零延时的 settimeout\n\nsettimeout 的特殊用法： settimeout(func, 0) ，或者仅仅是 settimeout(func) 。\n\n这样调度函数，可以让 func 尽快执行，但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。也就是说，该函数被调度在当前脚本执行完成「之后」立即执行。\n\n🌰 例子：\n\nsettimeout(() => alert(\"world\"));\n\nalert(\"hello\");\n\n\n1\n2\n3\n\n\n> 这段代码会先输出 hello ，然后立即输出 world 。\n> \n> settimeout 将调度安排到了 日程 0 毫秒处。但是调度程序只有在当前脚本执行完毕时才会去「检查日程」，所以先输出 hello ，然后才输出 world 。\n\n点击查看\n\n在浏览器环境中零延时实际上不为零：在浏览器环境下，嵌套定时器的运行频率是受限制的。根据 html5 标准 所讲：「经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒」。\n\n🌰 例子 / settimeout 调用会以零延时重新调度自身的调用。每次调用都会在 times 数组中记录上一次调用的实际时间。：\n\nlet start = date.now();\nlet times = [];\n\nsettimeout(function run() {\n  times.push(date.now() - start); // 保存前一个调用的延时\n\n  if (start + 100 < date.now()) alert(times); // 100 毫秒之后，显示延时信息\n  else settimeout(run); // 否则重新调度\n});\n\n// 输出示例：\n// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在代码的第一次执行时，定时器是立即执行的。但接下来的调用，必须经过 4 毫秒以上的强制延时。 timer 数组里存放的是每次定时器运行的时刻与 start 的差值，所以数字只会越来越大，实际上前后调用的延时是数组值的差值。\n\n对于 setinterval 也会发生类似的情况： setinterval(f) 会以零延时运行几次 f ，然后以 4 毫秒以上的强制延时运行。\n\n对于服务端的 javascript，就没有这个限制，并且还有其他调度即时异步任务的方式。例如 node.js 的 setimmediate。因此，这个提醒只是针对浏览器环境的。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚃 JavaScript 装饰器模式和转发",frontmatter:{title:"🚃 JavaScript 装饰器模式和转发",date:"2022-05-11T14:01:03.000Z",permalink:"/pages/23d75e/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/08.%20%F0%9F%9A%83%20JavaScript%20%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%BD%AC%E5%8F%91.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/08. 🚃 JavaScript 装饰器模式和转发.md",key:"v-4e6c610e",path:"/pages/23d75e/",headers:[{level:2,title:"引子：透明缓存",slug:"引子-透明缓存",normalizedTitle:"引子：透明缓存",charIndex:66},{level:2,title:"func.call()",slug:"func-call",normalizedTitle:"func.call()",charIndex:1874},{level:2,title:"传递多个参数",slug:"传递多个参数",normalizedTitle:"传递多个参数",charIndex:3430},{level:2,title:"func.apply()",slug:"func-apply",normalizedTitle:"func.apply()",charIndex:5133},{level:3,title:"方法借用",slug:"方法借用",normalizedTitle:"方法借用",charIndex:5749},{level:2,title:"装饰器和函数属性",slug:"装饰器和函数属性",normalizedTitle:"装饰器和函数属性",charIndex:6006},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6229},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:6711},{level:3,title:"间谍",slug:"间谍",normalizedTitle:"间谍",charIndex:6718},{level:3,title:"延时",slug:"延时",normalizedTitle:"延时",charIndex:7245},{level:3,title:"防抖",slug:"防抖",normalizedTitle:"防抖",charIndex:7937},{level:3,title:"节流",slug:"节流",normalizedTitle:"节流",charIndex:8587}],headersStr:"引子：透明缓存 func.call() 传递多个参数 func.apply() 方法借用 装饰器和函数属性 总结 实例 间谍 延时 防抖 节流",content:'JavaScript 在处理函数时提供了非凡的灵活性。除了前面提到的 被传递，用作对象，还可以 转发调用 和 装饰 函数。\n\n\n# 引子：透明缓存\n\n🌰 例子 / 有一个 CPU 重负载的函数 slow(x) ，但它的结果是稳定的。换句话说，对于相同的 x ，它总是返回相同的结果。如果经常调用该函数，可能希望将 结果缓存 下来，以避免在重新计算上花费额外的时间。\n\n但是不是将这个功能添加到 slow() 中，而是创建一个 包装器函数（Wrapper），该函数增加了缓存功能。\n\nfunction slow(x) {\n  // ... \n  // ... 可能会有重负载的 CPU 密集型工作\n  // ,,, \n  console.log(`called with ${x}`)\n\treturn x\n}\n\n// 装饰器函数\nfunction cachingDecorator(func) {\n  let cache = new Map()\n  \n  return function(x) {\n    if(cache.has(x)) { // 如果缓存起有对应的结果\n      return cache.get(x) // 则从缓存中读取结果\n    }\n    \n    let result = func(x) // 否则就调用 func(x)\n    \n    cache.set(x, result) // 然后将 x 添加到缓存\n    return result\n  }\n}\n\nslow = cachingDecorator(slow)\nconsole.log(slow(1)) // slow(1) 被缓存下来并返回结果\nconsole.log(\'again\' + slow(1)) // 返回缓存中的结果\n\n\nconsole.log(slow(2)) // slow(2) 被缓存下来并返回结果\nconsole.log(\'again\' + slow(2)) // 返回缓存中的结果\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> cachingDecorator 是一个 装饰器（decorator）：一个特殊的函数，它接受另一个函数并改变它的行为。\n> \n> 思想：可以为任何一个函数调用 cachingDecorator ，它将返回缓存包装器。通过将缓存与主函数代码分开，使主函数代码变得更简单。\n> \n> cachingDecorator(func) 的结果是一个 “包装器”： function(x) 将 func(x) 的调用 “包装” 到缓存逻辑中：\n> \n> \n> \n> 从外部代码来看，包装的 slow 函数执行的仍然是与之前相同的操作。它只是在其行为上添加了缓存功能。\n\n使用 cachingDecorator 并不改变原来函数的代码的好处：\n\n * cachingDecorator 是可重用的。\n * 缓存逻辑是独立的，它没有增加 slow 本身的复杂性。\n * 如果需要，可以组合多个装饰器（其他装饰器将遵循同样的逻辑）。\n\n🌰 例子 / 上面的 缓存装饰器 不适用于 对象的方法：\n\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // ...\n    // ... CPU 过载任务\n    // ...\n    console.log("Called with " + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\n// function cachingDecorator(func) ... \n\nconsole.log(work.slow(1)) // 可用\n\nwork.slow = cachingDecorator(worker.slow)\nconsole.log(work.slow(2)) // 不可用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 因为装饰器试图访问 this.someMethod 时 ，这里的 this 为 undefined 。包装器将调用传递给原始方法，但没有上下文 this 。因此，发生了错误。\n\n\n# func.call()\n\n可以使用内建函数方法 func.call(content, ...args) 解决这个方法，它允许调用一个 显式设置 this 的函数。\n\n语法为： func.call(context, arg1, arg2, ...) 。\n\n🌰 例子 / call 的简单应用：\n\nfunc(1, 2, 3);\nfunc.call(obj, 1, 2, 3)\n\n\n1\n2\n\n\n> 这两种方法都是调用 func 函数，并且传入参数为 1, 2, 3 。唯一的区别是 func.call 还会将 this 设置为 obj 。\n\n🌰 例子：\n\nfunction sayHi() {\n  console.log(this.name);\n}\n\nlet user = { name: "John" };\nlet admin = { name: "Admin" };\n\n// 使用 call 将不同的对象传递为 "this"\nsayHi.call(user); // John\nsayHi.call(admin); // Admin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 有参数的指定上下文调用：\n> \n> function say(phrase) {\n>   console.log(this.name + \': \' + phrase)\n> }\n> \n> let user = {name: \'Simon\'}\n> say.call(user, \'hello\')\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n🌰 例子 / 修改先前的 缓存装饰器 例子：\n\n let worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // ...\n    // ... CPU 过载任务\n    // ...\n    console.log("Called with " + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\nfunction cachingDecorator(func) {\n  let cache = new Map()\n  return function(x) {\n    if(cache.has(x)) {\n      if(cache.has(x)) return cache.get(x)\n    }\n   \tlet result = func.call(this, x)\n    cache.set(x, result)\n  \treturn result\n  }\n}\n\nworker.slow = cachingDecorator(worker.slow)\nconsole.log(worker.slow(2))\nconsole.log(worker.slow(2)) // 调用缓存\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n> 在此之中 this 的传递过程：\n> \n>  * 在经过装饰之后， worker.slow 现在是包装器 function (x) { ... } 。\n>  * 因此，当 worker.slow(2) 执行时，包装器将 2 作为参数，并且 this=worker （它是点符号 . 之前的对象）。\n>  * 在包装器内部，假设结果尚未缓存， func.call(this, x) 将当前的 this （ =worker ）和当前的参数（ =2 ）传递给原始方法。\n\n\n# 传递多个参数\n\n如果要将 缓存装饰器 写得更加通用，就要使它可以接收多个参数的函数。\n\n例如，现在的 woker.slow 变成了多个参数的函数：\n\nlet worker = {\n  slow(min, max) {\n    // ... \n    return min + max \n  }\n}\n\nworker.slow = cachingDecorator(woker.slow) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 此处 cachingDecorator 应该要记住相同参数的调用。\n> \n> 在之前，对于单个参数 x ，可以只使用 cache.set(x, result) 来保存结果，并使用 cache.get(x) 来检索并获取结果。\n> \n> 但是现在，需要记住 参数组合 (min,max) 的结果。原生的 Map 仅将单个值作为键（key）。\n\n> 解决方案的方向：\n> \n>  * 实现一个新的（或使用第三方的）类似 map 的更通用并且允许多个键的数据结构。\n>  * 嵌套 Map： cache.set(min) 将是一个存储（键值）对 (max, result) 的 Map 。所以可以使用 cache.get(min).get(max) 来获取 result 。\n>  * 将两个值合并为一个。为了灵活性，可以允许为装饰器提供一个「哈希函数」，该函数知道如何将多个值合并为一个值。\n\n在实际应用中一般使用 「哈希函数」将多个值合并为一个值。\n\n在 func.call 时，传入的不再是一个 x ，如果是多个参数时，可以使用 Rest 语法的 ... 收集多个参数。所以写为 func.call(this, ...arguments) ， arguments 是一个包含所有参数的为数组。\n\n最后，改良过后的 cachingDecorator 为：\n\nlet worker = {\n  slow(min, max) {\n    alert(`Called with ${min},${max}`);\n    return min + max;\n  }\n};\n\nfunction cachingDecorator(func, hash) {\n  let cache = new Map();\n  return function() {\n    let key = hash(arguments); // (*)\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    let result = func.call(this, ...arguments); // (**)\n\n    cache.set(key, result);\n    return result;\n  };\n}\n\nfunction hash(args) {\n  return args[0] + \',\' + args[1];\n}\n\nworker.slow = cachingDecorator(worker.slow, hash);\n\nalert( worker.slow(3, 5) ); // works\nalert( "Again " + worker.slow(3, 5) ); // same (cached)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n> 现在这个包装器可以处理任意数量的参数了（尽管哈希函数还需要被进行调整以允许任意数量的参数）。\n> \n> 两个关键点：\n> \n>  * (*) 处：调用 hash 来从 arguments 创建一个单独的键。这里的 哈希函数 使用一个 连接符将两个参数连接在一起作为 Mapo 的键。\n>  * (**) ： 使用 func.call(this, ...arguments) 将包装器获取的上下文和所有参数传递给原始函数。\n\n\n# func.apply()\n\n可以使用 func.apply(this, arguments) 代替 func.call(this, ...arguments) 。\n\n使用语法： func.apply(context, args) 。\n\n * context ： 可以设置上下文对象。\n * args ： 类数组对象作为参数列表。\n\ncall 和 apply 唯一的区别是： call 期望一个参数列表，而 apply 期望一个包含这些参数的类数组对象。 其他方面，两个方法的调用都几乎是等效的。\n\nfunc.call(context, ...args);\nfunc.apply(context, args);\n\n\n1\n2\n\n\n> 关于 args 的微小区别：\n> \n>  * Spread 语法 ... 允许将 可迭代对象 args 作为列表传递给 call 。\n>  * apply 只接受 类数组 args 。\n\n对于即可迭代又是类数组的对象，例如一个真正的数组，使用 call 或 apply 均可，但是 apply 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。\n\n这种 将所有参数连同上下文 传递给另一个函数被称为 「呼叫转移」：\n\nlet wrapper = function() {\n  return func.apply(this, arguments);\n};\n\n\n1\n2\n3\n\n\n\n# 方法借用\n\n使用 func.apply 解决上面 哈希函数 可以接收任意数量的 args ：\n\n> 不可以直接使用 arguments.join() ，因为 arguments 只是类数组对象而不是真正的数组，不能使用数组的方法。\n\nfunction hash() {\n  [].join.call(arguments)\n}\n\n\n1\n2\n3\n\n\n这种用法为 方法借用。从常规数组 [] 中借用 join 方法，使用 [].join.call(arguments) 在 arguments 的上下文运行它。\n\n\n# 装饰器和函数属性\n\n通常，用装饰的函数替换一个函数或一个方法是安全的。\n\n但是如果原始函数有属性，例如 func.calledCount 或其他，则装饰后的函数将不再提供这些属性。因为这是装饰器。\n\n一些包装器可能会提供自己的属性。例如，装饰器会计算一个函数被调用了多少次以及花费了多少时间，并通过包装器属性暴露这些信息。\n\n存在一种创建装饰器的方法，该装饰器可保留对函数属性的访问权限，但这需要使用特殊的 Proxy 对象来包装函数。\n\n\n# 总结\n\n * 装饰器 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。（可以看作是添加函数额外功能的 切面，可以添加一个或者多个而不需要更改函数代码）\n\n * 实现函数 装饰器 使用两种方法：\n   \n   * func.call(context, arg1, arg2 ...) ：使用给定的上下文 对象 和 参数 调用 func .\n   * func.apply(context, args) ：调用 func 将 context 上下文对象作为 this 和 类数组 的 args 传递给参数列表。\n\n * 通常 呼叫转移 使用 apply 完成：\n   \n   let wrapper = function() {\n     return originalFunc.apply(this, arguments)\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 方法借用： 从一个对象中获取一个方法，在另一个对象的上下文中「调用」它。采用数组方法并将它们应用于 arguments 或者使用 Rest 参数对象。\n\n\n# 实例\n\n\n# 间谍\n\n> 创建一个装饰器 spy(func) ，它应该返回一个包装器，该包装器将 所有对函数的调用 保存在其 calls 属性中。每个调用都保存在一个 参数数组。\n\nfunction work(a, b) {\n  console.log( a + b ); // work 是一个任意的函数或方法\n}\n\nwork = spy(work);\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (let args of work.calls) {\n  console.log( \'call:\' + args.join() ); // "call:1,2", "call:4,5"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n点击查看\n\nfunction spy(func) {\n  function wrapper(...args) {\n    wrapper.calls.push(args)\n    return func.apply(this, args)\n  }\n  \n  wrapper.calls = []\n\treturn wrapper\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 延时\n\n> 创建一个装饰器 delay(f, ms) ，该装饰器将 f 的每次调用延时 ms 毫秒。\n\nfunction f(x) {\n  conosle.log(x);\n}\n\n// create wrappers\nlet f1000 = delay(f, 1000);\nlet f1500 = delay(f, 1500);\n\nf1000("test"); // 在 1000ms 后显示 "test"\nf1500("test"); // 在 1500ms 后显示 "test"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n点击查看\n\nfunction delay(f, ms) {\n  return function() {\n    setTimeout(()=> func.apply(this, arguments), ms)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 由于 箭头函数 没有自己的 this 和 arguments ，所以 f.apply(this, arguments) 从 当前包装器 中获取 this 和 arguments 。\n\n如果不使用箭头函数，需要通过中间变量传递正确的 this 。\n\nfunction delay(f, ms) {\n  return function(...args) {\n    let savedThis = this\n    setTimeout(function(){\n      f.apply(savedThis, args)\n    }, ms)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 防抖\n\n> 防抖处理可以看作装饰器 debounce(f, ms) 的结果是一个 包装起，该包装器暂停对 f 的调用，直到经过 ms 毫秒的「冷却期」，然后使用最新的参数调用 f 一次。\n> \n> 例如，一个函数 f 替换为 f = debounce(f, 1000) 。如果包装器函数 分别在 0 ms， 200 ms， 500 ms 时被调用了，之后没有其他调用，那么实际的 f 只会在 1500 ms 时被调用一次。简单的说，就是需要等待 最后一次调用时 经过 1000 ms 后 的冷却期。\n> \n> 实际应用：如果用户输入一些内容，在用户输入完成后才向服务器发送请求，而没有必要为每一个字符的输入都发送请求。要等待一段时间，才处理整个输入结果。一般 输入框 的发生输入变化时会调用一个事件处理函数，如果监听每一次变化则整个事件处理函数会被频繁调用，使用 防抖 debounce 延时 1000 ms 处理，只会在最后一次输入后的 1000 ms 后被调用一次事件处理函数。\n\n手写一个 debounce 防抖装饰器：\n\n点击查看\n\nfunction debounce(func, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout)\n    setTimeout(()=> func.apply(this, arguments), delay)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 节流\n\n> 节流装饰器 throttle(f, ms) 返回一个包装器，当被多次调用时，在每 ms 最多将调用传递给 f 一次。\n> \n> 与防抖装饰器区分：\n> \n>  * debouce 会在 「冷却期」之后运行函数一次。适合处理最终结果。\n>  * throttle 运行函数的频率 不会大于 所给定的时间 ms 。适用于 不应该经常进行的定时更新。\n>  * 防抖是接听电话的秘书，一直等到 ms 毫秒之后才会把信息传达给老板。而节流是接听电话的秘书，打扰老板的频率不能超过每 ms 一次。\n> \n> 实际应用：追踪鼠标指针的移动，以更新网页上的某些信息。但是没有必要将每一个微小的移动都绑定事件更新，高于每 100 ms 的更新频次没有意义。所以将其包装到 节流装饰器，使用 throttle(update, 1000) 作为每次鼠标移动时运行的函数，而不是原始的 update() 。装饰器会被频繁调用，但是最多每 100 ms 将调用装发给 update() 一次。\n\n点击查看\n\nfunction throttle(func, ms) {\n  let isThrottled = false,\n      savedArgs,\n      savedThis;\n  \n \tfunction wrapper() {\n    if(isThrottled) {\n      savedArgs = arguments\n      savedThis = this\n      return\n    }\n    isThrottled = true\n    \n    func.apply(this, arguments)\n    \n    setTimeout(function(){\n      isThrottled = false\n      if(savedArgs) {\n        wrapper.apply(savedThis, savedArgs)\n        savedArgs = savedThis = null\n      }\n    }, ms)\n  }\n  \n  return wrapper\n}\n\n\nfunction f(a){\n  console.log(a)\n}\n\nlet f1000 = throttle(f, 1000)\nf1000(1)\nf1000(2) \nf1000(3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n调用 throttle(func, ms) 返回 wrapper 。\n\n * 第一次调用时， wrapper 值运行 func 并设置冷却状态（ isThrottled = true ）。\n * 在这种状态下，所有调用都记忆在 savedArgs/savedThis 中。请注意，上下文和参数（arguments）同等重要，应该被记下来。\n * 经过 ms 毫秒后，触发 setTimeout 中的回调函数。冷却状态移除（ isThrottled = false ），如果忽略了调用，即将使用最后记忆的参数和上下文执行 wrapper （因为不仅仅需要执行 func ，还要进入 冷却状态并且设置 timeout 重制它）。\n\n所以在例子中， 只执行了 第一次 和 最后一次。',normalizedContent:'javascript 在处理函数时提供了非凡的灵活性。除了前面提到的 被传递，用作对象，还可以 转发调用 和 装饰 函数。\n\n\n# 引子：透明缓存\n\n🌰 例子 / 有一个 cpu 重负载的函数 slow(x) ，但它的结果是稳定的。换句话说，对于相同的 x ，它总是返回相同的结果。如果经常调用该函数，可能希望将 结果缓存 下来，以避免在重新计算上花费额外的时间。\n\n但是不是将这个功能添加到 slow() 中，而是创建一个 包装器函数（wrapper），该函数增加了缓存功能。\n\nfunction slow(x) {\n  // ... \n  // ... 可能会有重负载的 cpu 密集型工作\n  // ,,, \n  console.log(`called with ${x}`)\n\treturn x\n}\n\n// 装饰器函数\nfunction cachingdecorator(func) {\n  let cache = new map()\n  \n  return function(x) {\n    if(cache.has(x)) { // 如果缓存起有对应的结果\n      return cache.get(x) // 则从缓存中读取结果\n    }\n    \n    let result = func(x) // 否则就调用 func(x)\n    \n    cache.set(x, result) // 然后将 x 添加到缓存\n    return result\n  }\n}\n\nslow = cachingdecorator(slow)\nconsole.log(slow(1)) // slow(1) 被缓存下来并返回结果\nconsole.log(\'again\' + slow(1)) // 返回缓存中的结果\n\n\nconsole.log(slow(2)) // slow(2) 被缓存下来并返回结果\nconsole.log(\'again\' + slow(2)) // 返回缓存中的结果\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> cachingdecorator 是一个 装饰器（decorator）：一个特殊的函数，它接受另一个函数并改变它的行为。\n> \n> 思想：可以为任何一个函数调用 cachingdecorator ，它将返回缓存包装器。通过将缓存与主函数代码分开，使主函数代码变得更简单。\n> \n> cachingdecorator(func) 的结果是一个 “包装器”： function(x) 将 func(x) 的调用 “包装” 到缓存逻辑中：\n> \n> \n> \n> 从外部代码来看，包装的 slow 函数执行的仍然是与之前相同的操作。它只是在其行为上添加了缓存功能。\n\n使用 cachingdecorator 并不改变原来函数的代码的好处：\n\n * cachingdecorator 是可重用的。\n * 缓存逻辑是独立的，它没有增加 slow 本身的复杂性。\n * 如果需要，可以组合多个装饰器（其他装饰器将遵循同样的逻辑）。\n\n🌰 例子 / 上面的 缓存装饰器 不适用于 对象的方法：\n\nlet worker = {\n  somemethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // ...\n    // ... cpu 过载任务\n    // ...\n    console.log("called with " + x);\n    return x * this.somemethod(); // (*)\n  }\n};\n\n// function cachingdecorator(func) ... \n\nconsole.log(work.slow(1)) // 可用\n\nwork.slow = cachingdecorator(worker.slow)\nconsole.log(work.slow(2)) // 不可用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 因为装饰器试图访问 this.somemethod 时 ，这里的 this 为 undefined 。包装器将调用传递给原始方法，但没有上下文 this 。因此，发生了错误。\n\n\n# func.call()\n\n可以使用内建函数方法 func.call(content, ...args) 解决这个方法，它允许调用一个 显式设置 this 的函数。\n\n语法为： func.call(context, arg1, arg2, ...) 。\n\n🌰 例子 / call 的简单应用：\n\nfunc(1, 2, 3);\nfunc.call(obj, 1, 2, 3)\n\n\n1\n2\n\n\n> 这两种方法都是调用 func 函数，并且传入参数为 1, 2, 3 。唯一的区别是 func.call 还会将 this 设置为 obj 。\n\n🌰 例子：\n\nfunction sayhi() {\n  console.log(this.name);\n}\n\nlet user = { name: "john" };\nlet admin = { name: "admin" };\n\n// 使用 call 将不同的对象传递为 "this"\nsayhi.call(user); // john\nsayhi.call(admin); // admin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 有参数的指定上下文调用：\n> \n> function say(phrase) {\n>   console.log(this.name + \': \' + phrase)\n> }\n> \n> let user = {name: \'simon\'}\n> say.call(user, \'hello\')\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n🌰 例子 / 修改先前的 缓存装饰器 例子：\n\n let worker = {\n  somemethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // ...\n    // ... cpu 过载任务\n    // ...\n    console.log("called with " + x);\n    return x * this.somemethod(); // (*)\n  }\n};\n\nfunction cachingdecorator(func) {\n  let cache = new map()\n  return function(x) {\n    if(cache.has(x)) {\n      if(cache.has(x)) return cache.get(x)\n    }\n   \tlet result = func.call(this, x)\n    cache.set(x, result)\n  \treturn result\n  }\n}\n\nworker.slow = cachingdecorator(worker.slow)\nconsole.log(worker.slow(2))\nconsole.log(worker.slow(2)) // 调用缓存\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n> 在此之中 this 的传递过程：\n> \n>  * 在经过装饰之后， worker.slow 现在是包装器 function (x) { ... } 。\n>  * 因此，当 worker.slow(2) 执行时，包装器将 2 作为参数，并且 this=worker （它是点符号 . 之前的对象）。\n>  * 在包装器内部，假设结果尚未缓存， func.call(this, x) 将当前的 this （ =worker ）和当前的参数（ =2 ）传递给原始方法。\n\n\n# 传递多个参数\n\n如果要将 缓存装饰器 写得更加通用，就要使它可以接收多个参数的函数。\n\n例如，现在的 woker.slow 变成了多个参数的函数：\n\nlet worker = {\n  slow(min, max) {\n    // ... \n    return min + max \n  }\n}\n\nworker.slow = cachingdecorator(woker.slow) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 此处 cachingdecorator 应该要记住相同参数的调用。\n> \n> 在之前，对于单个参数 x ，可以只使用 cache.set(x, result) 来保存结果，并使用 cache.get(x) 来检索并获取结果。\n> \n> 但是现在，需要记住 参数组合 (min,max) 的结果。原生的 map 仅将单个值作为键（key）。\n\n> 解决方案的方向：\n> \n>  * 实现一个新的（或使用第三方的）类似 map 的更通用并且允许多个键的数据结构。\n>  * 嵌套 map： cache.set(min) 将是一个存储（键值）对 (max, result) 的 map 。所以可以使用 cache.get(min).get(max) 来获取 result 。\n>  * 将两个值合并为一个。为了灵活性，可以允许为装饰器提供一个「哈希函数」，该函数知道如何将多个值合并为一个值。\n\n在实际应用中一般使用 「哈希函数」将多个值合并为一个值。\n\n在 func.call 时，传入的不再是一个 x ，如果是多个参数时，可以使用 rest 语法的 ... 收集多个参数。所以写为 func.call(this, ...arguments) ， arguments 是一个包含所有参数的为数组。\n\n最后，改良过后的 cachingdecorator 为：\n\nlet worker = {\n  slow(min, max) {\n    alert(`called with ${min},${max}`);\n    return min + max;\n  }\n};\n\nfunction cachingdecorator(func, hash) {\n  let cache = new map();\n  return function() {\n    let key = hash(arguments); // (*)\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    let result = func.call(this, ...arguments); // (**)\n\n    cache.set(key, result);\n    return result;\n  };\n}\n\nfunction hash(args) {\n  return args[0] + \',\' + args[1];\n}\n\nworker.slow = cachingdecorator(worker.slow, hash);\n\nalert( worker.slow(3, 5) ); // works\nalert( "again " + worker.slow(3, 5) ); // same (cached)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n> 现在这个包装器可以处理任意数量的参数了（尽管哈希函数还需要被进行调整以允许任意数量的参数）。\n> \n> 两个关键点：\n> \n>  * (*) 处：调用 hash 来从 arguments 创建一个单独的键。这里的 哈希函数 使用一个 连接符将两个参数连接在一起作为 mapo 的键。\n>  * (**) ： 使用 func.call(this, ...arguments) 将包装器获取的上下文和所有参数传递给原始函数。\n\n\n# func.apply()\n\n可以使用 func.apply(this, arguments) 代替 func.call(this, ...arguments) 。\n\n使用语法： func.apply(context, args) 。\n\n * context ： 可以设置上下文对象。\n * args ： 类数组对象作为参数列表。\n\ncall 和 apply 唯一的区别是： call 期望一个参数列表，而 apply 期望一个包含这些参数的类数组对象。 其他方面，两个方法的调用都几乎是等效的。\n\nfunc.call(context, ...args);\nfunc.apply(context, args);\n\n\n1\n2\n\n\n> 关于 args 的微小区别：\n> \n>  * spread 语法 ... 允许将 可迭代对象 args 作为列表传递给 call 。\n>  * apply 只接受 类数组 args 。\n\n对于即可迭代又是类数组的对象，例如一个真正的数组，使用 call 或 apply 均可，但是 apply 可能会更快，因为大多数 javascript 引擎在内部对其进行了优化。\n\n这种 将所有参数连同上下文 传递给另一个函数被称为 「呼叫转移」：\n\nlet wrapper = function() {\n  return func.apply(this, arguments);\n};\n\n\n1\n2\n3\n\n\n\n# 方法借用\n\n使用 func.apply 解决上面 哈希函数 可以接收任意数量的 args ：\n\n> 不可以直接使用 arguments.join() ，因为 arguments 只是类数组对象而不是真正的数组，不能使用数组的方法。\n\nfunction hash() {\n  [].join.call(arguments)\n}\n\n\n1\n2\n3\n\n\n这种用法为 方法借用。从常规数组 [] 中借用 join 方法，使用 [].join.call(arguments) 在 arguments 的上下文运行它。\n\n\n# 装饰器和函数属性\n\n通常，用装饰的函数替换一个函数或一个方法是安全的。\n\n但是如果原始函数有属性，例如 func.calledcount 或其他，则装饰后的函数将不再提供这些属性。因为这是装饰器。\n\n一些包装器可能会提供自己的属性。例如，装饰器会计算一个函数被调用了多少次以及花费了多少时间，并通过包装器属性暴露这些信息。\n\n存在一种创建装饰器的方法，该装饰器可保留对函数属性的访问权限，但这需要使用特殊的 proxy 对象来包装函数。\n\n\n# 总结\n\n * 装饰器 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。（可以看作是添加函数额外功能的 切面，可以添加一个或者多个而不需要更改函数代码）\n\n * 实现函数 装饰器 使用两种方法：\n   \n   * func.call(context, arg1, arg2 ...) ：使用给定的上下文 对象 和 参数 调用 func .\n   * func.apply(context, args) ：调用 func 将 context 上下文对象作为 this 和 类数组 的 args 传递给参数列表。\n\n * 通常 呼叫转移 使用 apply 完成：\n   \n   let wrapper = function() {\n     return originalfunc.apply(this, arguments)\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 方法借用： 从一个对象中获取一个方法，在另一个对象的上下文中「调用」它。采用数组方法并将它们应用于 arguments 或者使用 rest 参数对象。\n\n\n# 实例\n\n\n# 间谍\n\n> 创建一个装饰器 spy(func) ，它应该返回一个包装器，该包装器将 所有对函数的调用 保存在其 calls 属性中。每个调用都保存在一个 参数数组。\n\nfunction work(a, b) {\n  console.log( a + b ); // work 是一个任意的函数或方法\n}\n\nwork = spy(work);\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (let args of work.calls) {\n  console.log( \'call:\' + args.join() ); // "call:1,2", "call:4,5"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n点击查看\n\nfunction spy(func) {\n  function wrapper(...args) {\n    wrapper.calls.push(args)\n    return func.apply(this, args)\n  }\n  \n  wrapper.calls = []\n\treturn wrapper\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 延时\n\n> 创建一个装饰器 delay(f, ms) ，该装饰器将 f 的每次调用延时 ms 毫秒。\n\nfunction f(x) {\n  conosle.log(x);\n}\n\n// create wrappers\nlet f1000 = delay(f, 1000);\nlet f1500 = delay(f, 1500);\n\nf1000("test"); // 在 1000ms 后显示 "test"\nf1500("test"); // 在 1500ms 后显示 "test"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n点击查看\n\nfunction delay(f, ms) {\n  return function() {\n    settimeout(()=> func.apply(this, arguments), ms)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 由于 箭头函数 没有自己的 this 和 arguments ，所以 f.apply(this, arguments) 从 当前包装器 中获取 this 和 arguments 。\n\n如果不使用箭头函数，需要通过中间变量传递正确的 this 。\n\nfunction delay(f, ms) {\n  return function(...args) {\n    let savedthis = this\n    settimeout(function(){\n      f.apply(savedthis, args)\n    }, ms)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 防抖\n\n> 防抖处理可以看作装饰器 debounce(f, ms) 的结果是一个 包装起，该包装器暂停对 f 的调用，直到经过 ms 毫秒的「冷却期」，然后使用最新的参数调用 f 一次。\n> \n> 例如，一个函数 f 替换为 f = debounce(f, 1000) 。如果包装器函数 分别在 0 ms， 200 ms， 500 ms 时被调用了，之后没有其他调用，那么实际的 f 只会在 1500 ms 时被调用一次。简单的说，就是需要等待 最后一次调用时 经过 1000 ms 后 的冷却期。\n> \n> 实际应用：如果用户输入一些内容，在用户输入完成后才向服务器发送请求，而没有必要为每一个字符的输入都发送请求。要等待一段时间，才处理整个输入结果。一般 输入框 的发生输入变化时会调用一个事件处理函数，如果监听每一次变化则整个事件处理函数会被频繁调用，使用 防抖 debounce 延时 1000 ms 处理，只会在最后一次输入后的 1000 ms 后被调用一次事件处理函数。\n\n手写一个 debounce 防抖装饰器：\n\n点击查看\n\nfunction debounce(func, delay) {\n  let timeout;\n  return function() {\n    cleartimeout(timeout)\n    settimeout(()=> func.apply(this, arguments), delay)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 节流\n\n> 节流装饰器 throttle(f, ms) 返回一个包装器，当被多次调用时，在每 ms 最多将调用传递给 f 一次。\n> \n> 与防抖装饰器区分：\n> \n>  * debouce 会在 「冷却期」之后运行函数一次。适合处理最终结果。\n>  * throttle 运行函数的频率 不会大于 所给定的时间 ms 。适用于 不应该经常进行的定时更新。\n>  * 防抖是接听电话的秘书，一直等到 ms 毫秒之后才会把信息传达给老板。而节流是接听电话的秘书，打扰老板的频率不能超过每 ms 一次。\n> \n> 实际应用：追踪鼠标指针的移动，以更新网页上的某些信息。但是没有必要将每一个微小的移动都绑定事件更新，高于每 100 ms 的更新频次没有意义。所以将其包装到 节流装饰器，使用 throttle(update, 1000) 作为每次鼠标移动时运行的函数，而不是原始的 update() 。装饰器会被频繁调用，但是最多每 100 ms 将调用装发给 update() 一次。\n\n点击查看\n\nfunction throttle(func, ms) {\n  let isthrottled = false,\n      savedargs,\n      savedthis;\n  \n \tfunction wrapper() {\n    if(isthrottled) {\n      savedargs = arguments\n      savedthis = this\n      return\n    }\n    isthrottled = true\n    \n    func.apply(this, arguments)\n    \n    settimeout(function(){\n      isthrottled = false\n      if(savedargs) {\n        wrapper.apply(savedthis, savedargs)\n        savedargs = savedthis = null\n      }\n    }, ms)\n  }\n  \n  return wrapper\n}\n\n\nfunction f(a){\n  console.log(a)\n}\n\nlet f1000 = throttle(f, 1000)\nf1000(1)\nf1000(2) \nf1000(3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n调用 throttle(func, ms) 返回 wrapper 。\n\n * 第一次调用时， wrapper 值运行 func 并设置冷却状态（ isthrottled = true ）。\n * 在这种状态下，所有调用都记忆在 savedargs/savedthis 中。请注意，上下文和参数（arguments）同等重要，应该被记下来。\n * 经过 ms 毫秒后，触发 settimeout 中的回调函数。冷却状态移除（ isthrottled = false ），如果忽略了调用，即将使用最后记忆的参数和上下文执行 wrapper （因为不仅仅需要执行 func ，还要进入 冷却状态并且设置 timeout 重制它）。\n\n所以在例子中， 只执行了 第一次 和 最后一次。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚡 JavaScript 函数绑定",frontmatter:{title:"🚡 JavaScript 函数绑定",date:"2022-05-13T18:19:55.000Z",permalink:"/pages/9c420b/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/09.%20%F0%9F%9A%A1%20JavaScript%20%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/09. 🚡 JavaScript 函数绑定.md",key:"v-6d6cd2d3",path:"/pages/9c420b/",headers:[{level:2,title:"引入例子：丢失的 this",slug:"引入例子-丢失的-this",normalizedTitle:"引入例子：丢失的 this",charIndex:60},{level:3,title:"解决方法：包装器",slug:"解决方法-包装器",normalizedTitle:"解决方法：包装器",charIndex:393},{level:3,title:"解决方法： bind",slug:"解决方法-bind",normalizedTitle:"解决方法： bind",charIndex:1002},{level:3,title:"偏函数",slug:"偏函数",normalizedTitle:"偏函数",charIndex:2526},{level:3,title:"仅绑定参数 partial",slug:"仅绑定参数-partial",normalizedTitle:"仅绑定参数 partial",charIndex:3149},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3913},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:4110},{level:3,title:"二次 bind",slug:"二次-bind",normalizedTitle:"二次 bind",charIndex:4117},{level:3,title:"bind 后的函数属性",slug:"bind-后的函数属性",normalizedTitle:"bind 后的函数属性",charIndex:4402}],headersStr:"引入例子：丢失的 this 解决方法：包装器 解决方法： bind 偏函数 仅绑定参数 partial 总结 实例 二次 bind bind 后的函数属性",content:"当将 对象方法 作为回调传递，例如传递给 setTimeout ，会存在一个常见的问题，丢失 this 对象。\n\n\n# 引入例子：丢失的 this\n\n🌰 例子：\n\nlet user = {\n  firstName: 'Simon',\n  sayHi() {\n    console.log(`Hello, ${this.firstName}！`)\n  }\n}\n\nsetTimeout(user.sayhi, 1000) // Hello, undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 传递 对象方法 给 setTimeout ，但是它与对象分离开了，丢失了 上下文对象 user 。在 浏览器 中的 setTimeout 方法中，如果没有指定 this 上下文，此时的 this = window 。对于 Node.js this 则会变为 计时器对象。\n\n\n# 解决方法：包装器\n\n使用一个 包装函数 解决。\n\n🌰 例子：\n\nlet user = {\n  firstName: 'Simon',\n  sayHi() {\n    console.log(`Hello, ${this.firstName}！`)\n  }\n}\n\nsetTimeout(function() {\n  user.sayHi()\n}, 1000)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n或者使用 箭头函数 形式：\n\nsetTimeout(() => user.sayHi(), 1000)\n\n\n1\n\n\n> 此时 user.sayHi() 从外部词法环境中获取到了 user 对象，所以可以正常的调用。\n\n🌰 例子 / 如果对象在 setTimeout 触发之前改变了，此时这种包装器方法就存在漏洞了：\n\nlet user = {\n  firstName: 'Simon',\n  sayHi() {\n    console.log(`Hello, ${this.firstName}！`)\n  }\n}\n\nsetTimeout(() => user.sayHi(), 1000)\n\nuser = {\n  sayHi() {\n    console.log('changed user sayhi()')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 解决方法： bind\n\n函数提供了一个 内建方法 bind ，可以绑定 this 对象。基本语法为：\n\nlet boundFunc = func.bind(context)\n\n\n1\n\n\n> func.bind(context) 的结果是一个 特殊的 类似于函数「外来对象」，可以像函数一样被调用，并且 透明地 将调用传递给 func 并且设定 this = context 。\n> \n> 简单的说，就是 boundFunc 的调用 是 绑定了 this 的 func 。\n\n🌰 例子：\n\nlet user = {\n  firstName = 'Simon'\n}\n\nfunction func() {\n  console.log(this.firstName) \n}\n\nlet funcUser = func.bind(user)\nfuncUser() // 'Simon'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> funcUser 将调用传递给了 func 同时 this = user 。\n\n🌰 例子 / bind 还会传递 所有的参数：\n\nfunction func(phrase) {\n  console.log(phrase + ', ' this.firstName);\n}\n\nlet funcUser = func.bind(user)\nfuncUser(\"hello\") // \"hello, Simon\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / bind 应用于 对象方法：\n\nlet user = {\n  firstName: 'Simon',\n  sayHi() {\n    console.log(`Hello, ${this.firstName}！`)\n  }\n}\n\nlet sayHi = user.sayHi.bind(user)\n\nsetTimeout(sayHi, 1000) \n\nuser = {\n  sayHi() {\n    console.log('changed user sayhi()')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 即使在 不到一秒时 改变了原来的对象 user ，这里 bind 取了方法 user.sayHi 将其绑定到 user ，所以 sayHi 是一个 绑定后的 方法，它可以被单独调用，也可以被传递给 setTimeout 。\n\n🌰 例子 / bind 应用于 对象方法 包括方法的参数：\n\nlet user = {\n  firstName: 'Simon',\n  sayHi(phrase) {\n    console.log(`${phrase}, ${this.firstName}！`)\n  }\n}\n\nlet say = user.sayHi.bind(user)\n\nsay(\"Hello\")\nsay(\"Bye\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n如果对象中有很多方法，并且都打算将它们传递出去，那么可以子啊一个循环中完成所有方法的绑定：\n\nfor (let key in user) {\n  if (typeof user[key] === 'function') {\n    user[key] = user[key].bind(user)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 在 JavaScript 库有提供方便批量绑定的函数，例如 loadash 中的 _.bindAll(object, methodNames) 。\n\n\n# 偏函数\n\nbind 的 完整语法：\n\nlet bound = func.bind(context, [arg1], [arg2], ... )\n\n\n1\n\n\n> 可以看到 bind 允许将 上下文 绑定为 this ，以及绑定函数的 初始参数。\n\n🌰 例子：\n\nfunction mul(a, b) {\n  return a * b\n}\n\n\n1\n2\n3\n\n\n使用 bind 在该函数基础上创建一个 double 函数：\n\nlet double = mul.bind(null, 2)\n\nconsole.log(double(3)) // 6\n\n\n1\n2\n3\n\n\n> 对 mul.bind(null, 2) 的调用创建了一个新函数 double ，它将调用传递到 mul ，将 null 绑定为上下文，并将 2 绑定为第一个参数。并且，参数均被原样传递。\n\n这种用法被称为 偏函数应用程序， 通过绑定 先有的函数 的一些参数来创建一个新的函数。上面的例子，因为没有用到上下文对象的地方，所以传入的是 null （没有也要传入参数）。\n\n> 使用偏参数的好处：\n> \n>  * 可以在原来的函数的基础上，创建一个具有 可读性高 的名字的独立函数（例如 double ， triple ） 。可以只使用它们而不用每次都提供相同的参数。\n>  * 当有一个 非常通用的 函数，并且希望有一个 通用型 更低的该函数的变体，使用 偏函数 非常有用。\n\n\n# 仅绑定参数 partial\n\n当想绑定一些参数到函数，但不需要用到 上下文 this ，原生的 bind 不允许这种情况（不可以省略 context 直接跳到参数）。\n\npartial 可以实现仅绑定参数的函数，用法：\n\nfunction partial(func, argsBound) {\n  return function(...args) {\n    retrun func.call(this, ...argsBound, ...args)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子：\n\nlet user = {\n  firstName: \"John\",\n  say(time, phrase) {\n   console.log(`[${time}] ${this.firstName}: ${phrase}!`);\n  }\n};\n\nuser.sayNow = partial(user.say, new Date.getHours() + ':' + new Date().getMinutes())\n\nuser.sayNow(\"Hello\") // \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> partial(func[, arg1, arg2...]) 调用的结果是一个包装器 ，它调用 func 并具有以下内容：\n> \n>  * 与它获得的函数具有相同的 this （对于 user.sayNow 调用来说，它是 user ）\n>  * 然后给它 ...argsBound —— 来自于 partial 调用的参数（ \"10:00\" ）\n>  * 然后给它 ...args —— 给包装器的参数（ \"Hello\" ）\n\n同样 lodash 库中有现成的 _.partial 实现\n\n\n# 总结\n\n * 方法 func.bind(context, ...args) 返回函数 func 绑定了 this （以及给定的一些参数）的 变体。\n   * 通常使用 bind 绑定 对象方法 的 this ，以便把它们传递到其他地方使用，而不丢失上下文对象。\n * 当绑定先有函数的一些参数，绑定后的函数为 偏函数。可以用于不想一遍一遍重复相同地传入参数时可以用 partial 。\n\n\n# 实例\n\n\n# 二次 bind\n\n> 当对一个函数应用 bind 绑定上下文对象两次时：\n> \n> function f() {\n>   console.log(this.name);\n> }\n> \n> f = f.bind( {name: \"John\"} ).bind( {name: \"Ann\" } );\n> \n> f();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n点击查看\n\n最后输出的结果是 John 。链式调用是应用于上一次方法调用后的结果。 bind( ... ) 返回的外来绑定函数仅在创建的时候记忆上下文。所以一个函数不能重绑定。\n\n\n# bind 后的函数属性\n\n> 当函数的属性中有一个值， bind 之后值还存在吗？\n> \n> function sayHi() {\n>   console.log( this.name );\n> }\n> sayHi.test = 5;\n> \n> let bound = sayHi.bind({\n>   name: \"John\"\n> });\n> \n> console.log(bound.test);\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n点击查看\n\nbind 的结果是另一个对象，它并没有 test 属性。",normalizedContent:"当将 对象方法 作为回调传递，例如传递给 settimeout ，会存在一个常见的问题，丢失 this 对象。\n\n\n# 引入例子：丢失的 this\n\n🌰 例子：\n\nlet user = {\n  firstname: 'simon',\n  sayhi() {\n    console.log(`hello, ${this.firstname}！`)\n  }\n}\n\nsettimeout(user.sayhi, 1000) // hello, undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 传递 对象方法 给 settimeout ，但是它与对象分离开了，丢失了 上下文对象 user 。在 浏览器 中的 settimeout 方法中，如果没有指定 this 上下文，此时的 this = window 。对于 node.js this 则会变为 计时器对象。\n\n\n# 解决方法：包装器\n\n使用一个 包装函数 解决。\n\n🌰 例子：\n\nlet user = {\n  firstname: 'simon',\n  sayhi() {\n    console.log(`hello, ${this.firstname}！`)\n  }\n}\n\nsettimeout(function() {\n  user.sayhi()\n}, 1000)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n或者使用 箭头函数 形式：\n\nsettimeout(() => user.sayhi(), 1000)\n\n\n1\n\n\n> 此时 user.sayhi() 从外部词法环境中获取到了 user 对象，所以可以正常的调用。\n\n🌰 例子 / 如果对象在 settimeout 触发之前改变了，此时这种包装器方法就存在漏洞了：\n\nlet user = {\n  firstname: 'simon',\n  sayhi() {\n    console.log(`hello, ${this.firstname}！`)\n  }\n}\n\nsettimeout(() => user.sayhi(), 1000)\n\nuser = {\n  sayhi() {\n    console.log('changed user sayhi()')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 解决方法： bind\n\n函数提供了一个 内建方法 bind ，可以绑定 this 对象。基本语法为：\n\nlet boundfunc = func.bind(context)\n\n\n1\n\n\n> func.bind(context) 的结果是一个 特殊的 类似于函数「外来对象」，可以像函数一样被调用，并且 透明地 将调用传递给 func 并且设定 this = context 。\n> \n> 简单的说，就是 boundfunc 的调用 是 绑定了 this 的 func 。\n\n🌰 例子：\n\nlet user = {\n  firstname = 'simon'\n}\n\nfunction func() {\n  console.log(this.firstname) \n}\n\nlet funcuser = func.bind(user)\nfuncuser() // 'simon'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> funcuser 将调用传递给了 func 同时 this = user 。\n\n🌰 例子 / bind 还会传递 所有的参数：\n\nfunction func(phrase) {\n  console.log(phrase + ', ' this.firstname);\n}\n\nlet funcuser = func.bind(user)\nfuncuser(\"hello\") // \"hello, simon\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / bind 应用于 对象方法：\n\nlet user = {\n  firstname: 'simon',\n  sayhi() {\n    console.log(`hello, ${this.firstname}！`)\n  }\n}\n\nlet sayhi = user.sayhi.bind(user)\n\nsettimeout(sayhi, 1000) \n\nuser = {\n  sayhi() {\n    console.log('changed user sayhi()')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 即使在 不到一秒时 改变了原来的对象 user ，这里 bind 取了方法 user.sayhi 将其绑定到 user ，所以 sayhi 是一个 绑定后的 方法，它可以被单独调用，也可以被传递给 settimeout 。\n\n🌰 例子 / bind 应用于 对象方法 包括方法的参数：\n\nlet user = {\n  firstname: 'simon',\n  sayhi(phrase) {\n    console.log(`${phrase}, ${this.firstname}！`)\n  }\n}\n\nlet say = user.sayhi.bind(user)\n\nsay(\"hello\")\nsay(\"bye\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n如果对象中有很多方法，并且都打算将它们传递出去，那么可以子啊一个循环中完成所有方法的绑定：\n\nfor (let key in user) {\n  if (typeof user[key] === 'function') {\n    user[key] = user[key].bind(user)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 在 javascript 库有提供方便批量绑定的函数，例如 loadash 中的 _.bindall(object, methodnames) 。\n\n\n# 偏函数\n\nbind 的 完整语法：\n\nlet bound = func.bind(context, [arg1], [arg2], ... )\n\n\n1\n\n\n> 可以看到 bind 允许将 上下文 绑定为 this ，以及绑定函数的 初始参数。\n\n🌰 例子：\n\nfunction mul(a, b) {\n  return a * b\n}\n\n\n1\n2\n3\n\n\n使用 bind 在该函数基础上创建一个 double 函数：\n\nlet double = mul.bind(null, 2)\n\nconsole.log(double(3)) // 6\n\n\n1\n2\n3\n\n\n> 对 mul.bind(null, 2) 的调用创建了一个新函数 double ，它将调用传递到 mul ，将 null 绑定为上下文，并将 2 绑定为第一个参数。并且，参数均被原样传递。\n\n这种用法被称为 偏函数应用程序， 通过绑定 先有的函数 的一些参数来创建一个新的函数。上面的例子，因为没有用到上下文对象的地方，所以传入的是 null （没有也要传入参数）。\n\n> 使用偏参数的好处：\n> \n>  * 可以在原来的函数的基础上，创建一个具有 可读性高 的名字的独立函数（例如 double ， triple ） 。可以只使用它们而不用每次都提供相同的参数。\n>  * 当有一个 非常通用的 函数，并且希望有一个 通用型 更低的该函数的变体，使用 偏函数 非常有用。\n\n\n# 仅绑定参数 partial\n\n当想绑定一些参数到函数，但不需要用到 上下文 this ，原生的 bind 不允许这种情况（不可以省略 context 直接跳到参数）。\n\npartial 可以实现仅绑定参数的函数，用法：\n\nfunction partial(func, argsbound) {\n  return function(...args) {\n    retrun func.call(this, ...argsbound, ...args)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子：\n\nlet user = {\n  firstname: \"john\",\n  say(time, phrase) {\n   console.log(`[${time}] ${this.firstname}: ${phrase}!`);\n  }\n};\n\nuser.saynow = partial(user.say, new date.gethours() + ':' + new date().getminutes())\n\nuser.saynow(\"hello\") // \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> partial(func[, arg1, arg2...]) 调用的结果是一个包装器 ，它调用 func 并具有以下内容：\n> \n>  * 与它获得的函数具有相同的 this （对于 user.saynow 调用来说，它是 user ）\n>  * 然后给它 ...argsbound —— 来自于 partial 调用的参数（ \"10:00\" ）\n>  * 然后给它 ...args —— 给包装器的参数（ \"hello\" ）\n\n同样 lodash 库中有现成的 _.partial 实现\n\n\n# 总结\n\n * 方法 func.bind(context, ...args) 返回函数 func 绑定了 this （以及给定的一些参数）的 变体。\n   * 通常使用 bind 绑定 对象方法 的 this ，以便把它们传递到其他地方使用，而不丢失上下文对象。\n * 当绑定先有函数的一些参数，绑定后的函数为 偏函数。可以用于不想一遍一遍重复相同地传入参数时可以用 partial 。\n\n\n# 实例\n\n\n# 二次 bind\n\n> 当对一个函数应用 bind 绑定上下文对象两次时：\n> \n> function f() {\n>   console.log(this.name);\n> }\n> \n> f = f.bind( {name: \"john\"} ).bind( {name: \"ann\" } );\n> \n> f();\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n点击查看\n\n最后输出的结果是 john 。链式调用是应用于上一次方法调用后的结果。 bind( ... ) 返回的外来绑定函数仅在创建的时候记忆上下文。所以一个函数不能重绑定。\n\n\n# bind 后的函数属性\n\n> 当函数的属性中有一个值， bind 之后值还存在吗？\n> \n> function sayhi() {\n>   console.log( this.name );\n> }\n> sayhi.test = 5;\n> \n> let bound = sayhi.bind({\n>   name: \"john\"\n> });\n> \n> console.log(bound.test);\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n点击查看\n\nbind 的结果是另一个对象，它并没有 test 属性。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛺 JavaScript 深入箭头函数",frontmatter:{title:"🛺 JavaScript 深入箭头函数",date:"2022-05-13T21:40:24.000Z",permalink:"/pages/92a793/",categories:["🚶🏻 前端巩固基础","📗 JavaScript 深入函数"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/33.%20%F0%9F%93%97%20JavaScript%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0/10.%20%F0%9F%9B%BA%20JavaScript%20%E6%B7%B1%E5%85%A5%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html",relativePath:"101. 🚶🏻 前端巩固基础/33. 📗 JavaScript 深入函数/10. 🛺 JavaScript 深入箭头函数.md",key:"v-6a714abe",path:"/pages/92a793/",headers:[{level:2,title:"箭头函数没有 this",slug:"箭头函数没有-this",normalizedTitle:"箭头函数没有 this",charIndex:258},{level:2,title:"箭头函数没有 arguments",slug:"箭头函数没有-arguments",normalizedTitle:"箭头函数没有 arguments",charIndex:868},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1489}],headersStr:"箭头函数没有 this 箭头函数没有 arguments 总结",content:"至此，JavaScript 中已经有不少的 例子 使用箭头函数简化代码。除了简化代码的好处，还有许多特殊有用的特性。\n\n在 JavaScript 中不少的实用方法 包括内建函数，都有用到传入一个 执行的回调函数（小函数）之处，可以使用箭头函数，例如：\n\n * arr.forEach(func) ：对数组中的每一个元素都执行 func 。\n * setTimeout(func) ： func 转为内建调度器执行。\n\n当创建一个函数并且将它传递到某一个地方，但是不想离开当前的上下文，就可以使用 箭头函数。\n\n\n# 箭头函数没有 this\n\n箭头函数没有 this ，如果要用到 this ，会从外部获取。\n\n🌰 例子：\n\nlet group = {\n  title: 'Group',\n  members: ['a', 'b', 'c'],\n  \n  showList() {\n    this.members.forEach(member => console.log(this.title + ': ' + member))\n  }\n}\n\ngroup.showList()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 此处 forEach() 中使用了 箭头函数，所以其中 this.title 的 this 从外部获取，与 showList 相同即 group 。\n> \n> 如果使用 function(student){...} 就会出错，因为这样声明函数的 this 的默认值为 this = undefined 。\n\n注意\n\n不能对箭头函数 ** 使用 new **。不具有 this 表明了另一种限制：箭头函数不能用作 构造器。所以不能用 new 调用箭头函数。\n\n提示\n\n箭头函数与 bind 对比：\n\n * bind 创建了一个原来函数的绑定上下文对象的版本。\n * 箭头函数没有创建任何的绑定，箭头函数只是没有 this 。 this 的查找与常规变量的搜索方式相同，在外部的词法环境中查找。\n\n\n# 箭头函数没有 arguments\n\n当需要使用 当前的 this 和 arguments 转发一个调用时，例如装饰器，使用 箭头函数 会更加方便。\n\n🌰 例子：\n\nfunction defer(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms)\n  }\n}\n\nfunction sayHi(who) {\n  console.log(`hello ${who}`)\n}\n\nlet sayHideferred = defer(sayHi, 1000)\nsayHideferred('Simon') \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 如果不使用箭头函数，而使用普通的函数声明，需要创建而外的变量获取上下文对象和参数列表，以便 setTimeout 内部的函数可以获取他们。\n> \n> function defer(f, ms) {\n>   return function(...args) {\n>     let context = this\n>     setTimeout(function(){\n>       return f.apply(context, args)\n>     })\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n\n\n# 总结\n\n * 箭头函数的特性有：\n   \n   * 没有 this\n   * 没有 arguments\n   * 不能使用 new 构造调用\n   * 没有 super\n\n * 箭头函数通常使用在 当前上下文中作用 的短代码。",normalizedContent:"至此，javascript 中已经有不少的 例子 使用箭头函数简化代码。除了简化代码的好处，还有许多特殊有用的特性。\n\n在 javascript 中不少的实用方法 包括内建函数，都有用到传入一个 执行的回调函数（小函数）之处，可以使用箭头函数，例如：\n\n * arr.foreach(func) ：对数组中的每一个元素都执行 func 。\n * settimeout(func) ： func 转为内建调度器执行。\n\n当创建一个函数并且将它传递到某一个地方，但是不想离开当前的上下文，就可以使用 箭头函数。\n\n\n# 箭头函数没有 this\n\n箭头函数没有 this ，如果要用到 this ，会从外部获取。\n\n🌰 例子：\n\nlet group = {\n  title: 'group',\n  members: ['a', 'b', 'c'],\n  \n  showlist() {\n    this.members.foreach(member => console.log(this.title + ': ' + member))\n  }\n}\n\ngroup.showlist()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 此处 foreach() 中使用了 箭头函数，所以其中 this.title 的 this 从外部获取，与 showlist 相同即 group 。\n> \n> 如果使用 function(student){...} 就会出错，因为这样声明函数的 this 的默认值为 this = undefined 。\n\n注意\n\n不能对箭头函数 ** 使用 new **。不具有 this 表明了另一种限制：箭头函数不能用作 构造器。所以不能用 new 调用箭头函数。\n\n提示\n\n箭头函数与 bind 对比：\n\n * bind 创建了一个原来函数的绑定上下文对象的版本。\n * 箭头函数没有创建任何的绑定，箭头函数只是没有 this 。 this 的查找与常规变量的搜索方式相同，在外部的词法环境中查找。\n\n\n# 箭头函数没有 arguments\n\n当需要使用 当前的 this 和 arguments 转发一个调用时，例如装饰器，使用 箭头函数 会更加方便。\n\n🌰 例子：\n\nfunction defer(f, ms) {\n  return function() {\n    settimeout(() => f.apply(this, arguments), ms)\n  }\n}\n\nfunction sayhi(who) {\n  console.log(`hello ${who}`)\n}\n\nlet sayhideferred = defer(sayhi, 1000)\nsayhideferred('simon') \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 如果不使用箭头函数，而使用普通的函数声明，需要创建而外的变量获取上下文对象和参数列表，以便 settimeout 内部的函数可以获取他们。\n> \n> function defer(f, ms) {\n>   return function(...args) {\n>     let context = this\n>     settimeout(function(){\n>       return f.apply(context, args)\n>     })\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n\n\n# 总结\n\n * 箭头函数的特性有：\n   \n   * 没有 this\n   * 没有 arguments\n   * 不能使用 new 构造调用\n   * 没有 super\n\n * 箭头函数通常使用在 当前上下文中作用 的短代码。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⛰ JavaScript 原型继承",frontmatter:{title:"⛰ JavaScript 原型继承",date:"2022-05-14T10:43:13.000Z",permalink:"/pages/0d9ae4/",categories:["🚶🏻 前端巩固基础","📘 JavaScript 原型与继承"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/34.%20%F0%9F%93%98%20JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/10.%20%E2%9B%B0%20JavaScript%20%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%20.html",relativePath:"101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/10. ⛰ JavaScript 原型继承 .md",key:"v-3e4b87bc",path:"/pages/0d9ae4/",headers:[{level:2,title:"[[Prototype]] 属性",slug:"prototype-属性",normalizedTitle:"[[prototype]] 属性",charIndex:139},{level:3,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:970},{level:3,title:"原型仅用于读取属性",slug:"原型仅用于读取属性",normalizedTitle:"原型仅用于读取属性",charIndex:1661},{level:3,title:"this 的值",slug:"this-的值",normalizedTitle:"this 的值",charIndex:2767},{level:3,title:"循环",slug:"循环",normalizedTitle:"循环",charIndex:3416},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4231},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:4527},{level:3,title:"搜索链",slug:"搜索链",normalizedTitle:"搜索链",charIndex:4534},{level:3,title:"仓鼠例子",slug:"仓鼠例子",normalizedTitle:"仓鼠例子",charIndex:5197}],headersStr:"[[Prototype]] 属性 原型链 原型仅用于读取属性 this 的值 循环 总结 实例 搜索链 仓鼠例子",content:'当已经存在一个 user 对象以及其属性与方法，想要将 admin 和 guest 作为基于 user 稍加修改的变体，在 user 基础之上构建一个新的对象。\n\nJavaScript 的 原型继承（Prototype inheritance） 特性帮助实现这个需求。\n\n\n# [[Prototype]] 属性\n\n在 JavaScript 中，对象有一个特殊的 隐藏属性 [[Prototype]] ：\n\n * 要么为 null ；\n\n * 要么就是对另一个对象的引用。该对象被称为「原型」。\n\n当尝试从一个对象 object 中获取一个 缺失的属性 时， JavaScript 会自动从 原型 中获取该属性。这个过程为「原型继承」。\n\n对象的 [[Prototype]] 属性是 在内部的 并且是 隐藏的。\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\nrabbit.__proto__ = animal; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当从 rabbit 中读取一个它不存在的属性，JavaScript 会从 animal 中获取：\n\nconsole.log(rabbit.eats) // true\n\n\n1\n\n\n> 这个例子中的 rabbit__proto__ = animal 将 animal 设置为 rabbit 的 原型。原来的 rabbit 对象并不存在 eats 属性，JavaScript 会顺着 [[Prototype]] 引用 在 animal 中查找（自下而上）。\n> \n> 这个例子可以称 「 animal 是 rabbit 的原型」 或者 「 rabbit 的原型是从 animal 继承而来的 」。当 animal 中有的属性和方法，都会自动变为在 rabbit 中可以使用（继承属性和方法）。\n\n当 animal 中有方法：\n\nlet animal = {\n  eats: true,\n  walk() {\n    console.log(\'animal walk\')\n  }\n}  \n\n\n1\n2\n3\n4\n5\n6\n\n\nrabbit.walk() // animal walk\n\n\n1\n\n\n\n# 原型链\n\n🌰 例子：\n\nlet animal = {\n  eats: true,\n  walk() {\n    alert("Animal walk");\n  }\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nlet longEar = {\n  earLength: 10,\n  __proto__: rabbit\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 现在，如果从 longEar 中读取一些它不存在的内容，JavaScript 会先在 rabbit 中查找，然后在 animal 中查找。\n> \n> 但是要遵循以下规则：\n> \n>  * 引用不能形成闭环。试图在闭环内分配 __prototype__ 会报错。\n>  * __proto__ 的值可以是 对象，也可以是 null 。而其他的类型都会被忽略。\n>  * 显然，一个对象只能有一个 [[prototype]] 。一个对象不能从其他两个对象中即成。\n\n> __proto__ 是 [[prototype]] 的访问器（ getter / setter ）（ __proto__ 与 [[prototype]] 要区别开）：\n> \n>  * __proto__ 属性有点过时了，它的存在是出于历史的原因。现代编程语言建议应该使用函数 Object.getPrototypeOf / Object.setPrototypeOf 来取代 __proto__ 去 get/set 原型。\n\n\n# 原型仅用于读取属性\n\n🌰 例子：\n\nlet animal = {\n  eats: true,\n  walk() {\n\t\t// ... \n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\nrabbit.walk = function() {\n  alert("Rabbit! Bounce-bounce!");\n};\n\nrabbit.walk() // Rabbit! Bounce-bounce!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 这个例子中， rabbit 中分配了自己的 walk 方法。\n> \n> 尽管 rabbit 的原型是 animal 。但是因为 rabbit 本身就有 walk 方法，所以可以在对象中找到该方法无需使用原型。\n\n尽管设置了原型在先，但是后来的 添加方法 操作，是在对象子身上进行的，不会再原型上进行（对于删除属性同理）。\n\n可以看出，原型仅用于读取属性。\n\n🌰 例子 / 访问器属性是 例外。因为分配操作是通过 setter 函数处理的，所以写入此属性的操作相当于 读取该属性。\n\nlet user = {\n  name: "John",\n  surname: "Smith",\n\n  set fullName(value) {\n    [this.name, this.surname] = value.split(" ");\n  },\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nlet admin = {\n  __proto__: user,\n  isAdmin: true\n};\n\nconsole.log(admin.fullName) // John Smith\nadmin.fullName = "Alice Cooper"\n\nconsole.log(admin.fullName) // Alice Cooper\nconsole.log(user.fullName) // John Smith\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> admin.fullName = "Alice Cooper" 可以正常运行，因为它的原型对象中有 fullName 的 setter 函数。\n> \n> 并且修改的是 admin 原型对象的内容，而不是 原来的对象（被保护）。\n\n\n# this 的值\n\nthis 不受原型的影响：无论在哪里找到该方法（在一个对象或者在原型中），在方法调用时， this 始终指向的是 . 前面的对象（调用的该方法的对象）。\n\n从上面的例子中可以知道，在 setter 被调用时， admin.fullName = \'...\' 是 admin 调用的方法，所以 this 指向的是 admin 。\n\n提示\n\n清楚 this 的值。有可能有一个带有很多方法的大对象，并且还有从其继承的对象。当继承的对象运行方法时，它们应该只修改自身的状态而不修改大对象的状态。\n\n🌰 例子 / 有一个方法是存储属性：\n\nlet animal = {\n  walk() {\n    if (!this.isSleeping) {\n      alert(`I walk`);\n    }\n  },\n  sleep() {\n    this.isSleeping = true;\n  }\n};\n\nlet rabbit = {\n  name: "White Rabbit",\n  __proto__: animal\n};\n\nrabbit.sleep();\nconsole.log(rabbit.isSleeping)  // true\nconsole.log(animal.isSleeping) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 原型方法共享，但是对象状态不是。\n\n\n# 循环\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n// 对于 Object.keys\nconsole.log(Object.keys(rabbit)) // jumps\n\n// 对于 for...in\nfor(let prop in rabbit) console.log(prop) // jumps, eats\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 可以看出 for ... in 循环会迭代 继承的属性。\n\n如果想 排除继承的属性 或者利用它们进行其他操作， 可以使用 obj.hasOwnProperty(key) 判断：如果 obj 具有自己的（非继承的） key 属性则返回 true 。\n\nfor(let prop in rabbit) {\n  let isOwn = rabbit.hasOwnProperty(prop)\n  \n  if(isOwn) {\n    console.log(`our: ${prop}`)\n  } else {\n    console.log(`inherited: ${prop}`)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> hasOwnProperty 方法是 rabbit 从 Object.prototype 中继承的（该方法是 Object.prototype.hasOwnProperty 提供的）。并且该方法是不可枚举的，所以 for ... in 没有列出。\n\n提示\n\n几乎所有的 其他键 / 值获取方法 都忽略继承的属性（例如 Object.keys 和 Object.values 等）。它们只会对对象 自身 进行操作。不考虑 继承自原型的属性。\n\n\n# 总结\n\n * [[prototype]] 是 对象 的隐藏属性，要么是另一个对象，要么为 null 。可以通过 obj.__proto__ 访问。\n * 通过 [[Prototype]] 引用的对象被称为「原型」。\n * 当读取 obj 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。\n   * 写 / 删除操作直接在 对象自身 上进行，不使用原型。\n   * this 的值是 谁调用该方法，就是哪个对象。\n * for ... in 循环时，除了自身的属性，继承的属性也会迭代列出。所有其他的键 / 值获取方法仅对对象本身起作用。\n\n\n# 实例\n\n\n# 搜索链\n\n> let head = {\n>   glasses: 1\n> };\n> \n> let table = {\n>   pen: 3\n> };\n> \n> let bed = {\n>   sheet: 1,\n>   pillow: 2\n> };\n> \n> let pockets = {\n>   money: 2000\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> \n>  1. 使用 __proto__ 来分配原型，以使得任何属性的查找都遵循以下路径： pockets → bed → table → head 。例如， pockets.pen 应该是 3 （在 table 中找到）， bed.glasses 应该是 1 （在 head 中找到）。\n>  2. 通过 pockets.glasses 或 head.glasses 获取 glasses ，哪个更快？必要时需要进行基准测试。\n\n点击查看\n * 在现代引擎中，从性能的角度来看，是从对象还是从原型链获取属性都是没区别的。它们（引擎）会记住在哪里找到的该属性，并在下一次请求中重用它。\n * 对于 pockets.glasses 来说，它们（引擎）会记得在哪里找到的 glasses （在 head 中），这样下次就会 直接在这个位置进行搜索。并且引擎足够聪明，一旦有内容更改，它们就会自动更新内部缓存，因此，该优化是安全的。\n\n\n# 仓鼠例子\n\n> 有两只仓鼠： speedy 和 lazy 都继承自普通的 hamster 对象。\n> \n> 当我们喂其中一只的时候，另一只也吃饱了。为什么？如何修复它？\n> \n> let hamster = {\n>   stomach: [],\n> \n>   eat(food) {\n>     this.stomach.push(food);\n>   }\n> };\n> \n> let speedy = {\n>   __proto__: hamster\n> };\n> \n> let lazy = {\n>   __proto__: hamster\n> };\n> \n> speedy.eat("apple");\n> console.log(speedy.stomach) // apple\n> console.log(lazy.stomach) // apple\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n\n点击查看\n\n由于每只仓鼠没有自身的 stomach ，在 push 操作时，只能顺着原型链找到 hamster 的 stomach 。\n\n> push 操作的是在原型链找到的 stomach 。但是 简单赋值 this.stomach 时不会出现这个种情况：\n> \n> // ...\n> \teat(food) {\n>     this.stomach = [food]\n>   }\n> // ...\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 因为 this.stomach =。 不会执行对 stomach 的查找。该值会被直接写入 this 对象。\n\n可以通过确保每只仓鼠都有自己的 stomach 解决：\n\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster,\n  stomach: []\n};\n\nlet lazy = {\n  __proto__: hamster,\n  stomach: []\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n所有描述特定对象状态的属性，例如上面的 stomach ，都应该被写入该对象中。这样可以避免此类问题。',normalizedContent:'当已经存在一个 user 对象以及其属性与方法，想要将 admin 和 guest 作为基于 user 稍加修改的变体，在 user 基础之上构建一个新的对象。\n\njavascript 的 原型继承（prototype inheritance） 特性帮助实现这个需求。\n\n\n# [[prototype]] 属性\n\n在 javascript 中，对象有一个特殊的 隐藏属性 [[prototype]] ：\n\n * 要么为 null ；\n\n * 要么就是对另一个对象的引用。该对象被称为「原型」。\n\n当尝试从一个对象 object 中获取一个 缺失的属性 时， javascript 会自动从 原型 中获取该属性。这个过程为「原型继承」。\n\n对象的 [[prototype]] 属性是 在内部的 并且是 隐藏的。\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\nrabbit.__proto__ = animal; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当从 rabbit 中读取一个它不存在的属性，javascript 会从 animal 中获取：\n\nconsole.log(rabbit.eats) // true\n\n\n1\n\n\n> 这个例子中的 rabbit__proto__ = animal 将 animal 设置为 rabbit 的 原型。原来的 rabbit 对象并不存在 eats 属性，javascript 会顺着 [[prototype]] 引用 在 animal 中查找（自下而上）。\n> \n> 这个例子可以称 「 animal 是 rabbit 的原型」 或者 「 rabbit 的原型是从 animal 继承而来的 」。当 animal 中有的属性和方法，都会自动变为在 rabbit 中可以使用（继承属性和方法）。\n\n当 animal 中有方法：\n\nlet animal = {\n  eats: true,\n  walk() {\n    console.log(\'animal walk\')\n  }\n}  \n\n\n1\n2\n3\n4\n5\n6\n\n\nrabbit.walk() // animal walk\n\n\n1\n\n\n\n# 原型链\n\n🌰 例子：\n\nlet animal = {\n  eats: true,\n  walk() {\n    alert("animal walk");\n  }\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nlet longear = {\n  earlength: 10,\n  __proto__: rabbit\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 现在，如果从 longear 中读取一些它不存在的内容，javascript 会先在 rabbit 中查找，然后在 animal 中查找。\n> \n> 但是要遵循以下规则：\n> \n>  * 引用不能形成闭环。试图在闭环内分配 __prototype__ 会报错。\n>  * __proto__ 的值可以是 对象，也可以是 null 。而其他的类型都会被忽略。\n>  * 显然，一个对象只能有一个 [[prototype]] 。一个对象不能从其他两个对象中即成。\n\n> __proto__ 是 [[prototype]] 的访问器（ getter / setter ）（ __proto__ 与 [[prototype]] 要区别开）：\n> \n>  * __proto__ 属性有点过时了，它的存在是出于历史的原因。现代编程语言建议应该使用函数 object.getprototypeof / object.setprototypeof 来取代 __proto__ 去 get/set 原型。\n\n\n# 原型仅用于读取属性\n\n🌰 例子：\n\nlet animal = {\n  eats: true,\n  walk() {\n\t\t// ... \n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\nrabbit.walk = function() {\n  alert("rabbit! bounce-bounce!");\n};\n\nrabbit.walk() // rabbit! bounce-bounce!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 这个例子中， rabbit 中分配了自己的 walk 方法。\n> \n> 尽管 rabbit 的原型是 animal 。但是因为 rabbit 本身就有 walk 方法，所以可以在对象中找到该方法无需使用原型。\n\n尽管设置了原型在先，但是后来的 添加方法 操作，是在对象子身上进行的，不会再原型上进行（对于删除属性同理）。\n\n可以看出，原型仅用于读取属性。\n\n🌰 例子 / 访问器属性是 例外。因为分配操作是通过 setter 函数处理的，所以写入此属性的操作相当于 读取该属性。\n\nlet user = {\n  name: "john",\n  surname: "smith",\n\n  set fullname(value) {\n    [this.name, this.surname] = value.split(" ");\n  },\n\n  get fullname() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nlet admin = {\n  __proto__: user,\n  isadmin: true\n};\n\nconsole.log(admin.fullname) // john smith\nadmin.fullname = "alice cooper"\n\nconsole.log(admin.fullname) // alice cooper\nconsole.log(user.fullname) // john smith\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> admin.fullname = "alice cooper" 可以正常运行，因为它的原型对象中有 fullname 的 setter 函数。\n> \n> 并且修改的是 admin 原型对象的内容，而不是 原来的对象（被保护）。\n\n\n# this 的值\n\nthis 不受原型的影响：无论在哪里找到该方法（在一个对象或者在原型中），在方法调用时， this 始终指向的是 . 前面的对象（调用的该方法的对象）。\n\n从上面的例子中可以知道，在 setter 被调用时， admin.fullname = \'...\' 是 admin 调用的方法，所以 this 指向的是 admin 。\n\n提示\n\n清楚 this 的值。有可能有一个带有很多方法的大对象，并且还有从其继承的对象。当继承的对象运行方法时，它们应该只修改自身的状态而不修改大对象的状态。\n\n🌰 例子 / 有一个方法是存储属性：\n\nlet animal = {\n  walk() {\n    if (!this.issleeping) {\n      alert(`i walk`);\n    }\n  },\n  sleep() {\n    this.issleeping = true;\n  }\n};\n\nlet rabbit = {\n  name: "white rabbit",\n  __proto__: animal\n};\n\nrabbit.sleep();\nconsole.log(rabbit.issleeping)  // true\nconsole.log(animal.issleeping) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 原型方法共享，但是对象状态不是。\n\n\n# 循环\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n// 对于 object.keys\nconsole.log(object.keys(rabbit)) // jumps\n\n// 对于 for...in\nfor(let prop in rabbit) console.log(prop) // jumps, eats\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 可以看出 for ... in 循环会迭代 继承的属性。\n\n如果想 排除继承的属性 或者利用它们进行其他操作， 可以使用 obj.hasownproperty(key) 判断：如果 obj 具有自己的（非继承的） key 属性则返回 true 。\n\nfor(let prop in rabbit) {\n  let isown = rabbit.hasownproperty(prop)\n  \n  if(isown) {\n    console.log(`our: ${prop}`)\n  } else {\n    console.log(`inherited: ${prop}`)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> hasownproperty 方法是 rabbit 从 object.prototype 中继承的（该方法是 object.prototype.hasownproperty 提供的）。并且该方法是不可枚举的，所以 for ... in 没有列出。\n\n提示\n\n几乎所有的 其他键 / 值获取方法 都忽略继承的属性（例如 object.keys 和 object.values 等）。它们只会对对象 自身 进行操作。不考虑 继承自原型的属性。\n\n\n# 总结\n\n * [[prototype]] 是 对象 的隐藏属性，要么是另一个对象，要么为 null 。可以通过 obj.__proto__ 访问。\n * 通过 [[prototype]] 引用的对象被称为「原型」。\n * 当读取 obj 的一个属性或者调用一个方法，并且它不存在，那么 javascript 就会尝试在原型中查找它。\n   * 写 / 删除操作直接在 对象自身 上进行，不使用原型。\n   * this 的值是 谁调用该方法，就是哪个对象。\n * for ... in 循环时，除了自身的属性，继承的属性也会迭代列出。所有其他的键 / 值获取方法仅对对象本身起作用。\n\n\n# 实例\n\n\n# 搜索链\n\n> let head = {\n>   glasses: 1\n> };\n> \n> let table = {\n>   pen: 3\n> };\n> \n> let bed = {\n>   sheet: 1,\n>   pillow: 2\n> };\n> \n> let pockets = {\n>   money: 2000\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> \n>  1. 使用 __proto__ 来分配原型，以使得任何属性的查找都遵循以下路径： pockets → bed → table → head 。例如， pockets.pen 应该是 3 （在 table 中找到）， bed.glasses 应该是 1 （在 head 中找到）。\n>  2. 通过 pockets.glasses 或 head.glasses 获取 glasses ，哪个更快？必要时需要进行基准测试。\n\n点击查看\n * 在现代引擎中，从性能的角度来看，是从对象还是从原型链获取属性都是没区别的。它们（引擎）会记住在哪里找到的该属性，并在下一次请求中重用它。\n * 对于 pockets.glasses 来说，它们（引擎）会记得在哪里找到的 glasses （在 head 中），这样下次就会 直接在这个位置进行搜索。并且引擎足够聪明，一旦有内容更改，它们就会自动更新内部缓存，因此，该优化是安全的。\n\n\n# 仓鼠例子\n\n> 有两只仓鼠： speedy 和 lazy 都继承自普通的 hamster 对象。\n> \n> 当我们喂其中一只的时候，另一只也吃饱了。为什么？如何修复它？\n> \n> let hamster = {\n>   stomach: [],\n> \n>   eat(food) {\n>     this.stomach.push(food);\n>   }\n> };\n> \n> let speedy = {\n>   __proto__: hamster\n> };\n> \n> let lazy = {\n>   __proto__: hamster\n> };\n> \n> speedy.eat("apple");\n> console.log(speedy.stomach) // apple\n> console.log(lazy.stomach) // apple\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n\n点击查看\n\n由于每只仓鼠没有自身的 stomach ，在 push 操作时，只能顺着原型链找到 hamster 的 stomach 。\n\n> push 操作的是在原型链找到的 stomach 。但是 简单赋值 this.stomach 时不会出现这个种情况：\n> \n> // ...\n> \teat(food) {\n>     this.stomach = [food]\n>   }\n> // ...\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 因为 this.stomach =。 不会执行对 stomach 的查找。该值会被直接写入 this 对象。\n\n可以通过确保每只仓鼠都有自己的 stomach 解决：\n\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster,\n  stomach: []\n};\n\nlet lazy = {\n  __proto__: hamster,\n  stomach: []\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n所有描述特定对象状态的属性，例如上面的 stomach ，都应该被写入该对象中。这样可以避免此类问题。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗻 JavaScript 原型构造",frontmatter:{title:"🗻 JavaScript 原型构造",date:"2022-05-14T10:43:27.000Z",permalink:"/pages/63877d/",categories:["🚶🏻 前端巩固基础","📘 JavaScript 原型与继承"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/34.%20%F0%9F%93%98%20JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/20.%20%F0%9F%97%BB%20JavaScript%20%E5%8E%9F%E5%9E%8B%E6%9E%84%E9%80%A0.html",relativePath:"101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/20. 🗻 JavaScript 原型构造.md",key:"v-7e3a34cb",path:"/pages/63877d/",headers:[{level:2,title:"F.prototype",slug:"f-prototype",normalizedTitle:"f.prototype",charIndex:2},{level:3,title:"默认的 F.prototype",slug:"默认的-f-prototype",normalizedTitle:"默认的 f.prototype",charIndex:1217},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2418}],headersStr:"F.prototype 默认的 F.prototype 总结",content:'# F.prototype\n\nJavaScript 中可以使用 new F() 这样的 构造器（构造函数）创建一个 新的对象。\n\n如果 F.prototype 是一个 对象，那么 new 操作符会使用它作为 新对象 设置 [[prototype]] 。（一个构造函数的原型，当使用构造函数创建一个新的对象时，对象的原型为这个构造函数的原型）\n\n这里的 F.prototype 指的是 F 对象的一个名为 prototype 的 常规属性。\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n\nRabbit.prototype = animal\nlet rabbit = new Rabbit("White Rabbit")\n\nconsole.log(rabit.eats) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 设置 Rabbit.prototype = animal 的字面意思是：创建一个 new Rabbit 时，把它的 [[[prototype]]] 赋值为 animal 。\n> \n> \n> \n> "prototype" 是一个水平箭头，表示一个常规属性， [[Prototype]] 是垂直的，表示 rabbit 继承自 animal 。\n\n提示\n\nF.prototype 仅能用在 new F 时，它为新对象的 [[Prototype]] 赋值。\n\n如果在创建之后， F.prototype 属性有了变化（ F.prototype = <another object> ），那么通过 new F 创建的 新对象 也将随之拥有 新的对象 作为 [[Prototype]] ，但已经存在的对象将 保持旧有的值。\n\n如果在创建之后，修改 F.prototype 的值（修改引用），对已经存在的对象也会受到影响。\n\n🌰 例子：\n\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit(); // 引用的是上面的prototyope\n\nRabbit.prototype = {\n  eats: false\n}\n\nlet rabbit2 = new Rabbit(); // 引用的是新的prototype\ndelete Rabbit.prototype.eats // 删除新定义的prototype的eats\n\nconsole.log(rabbit.eats) // true\nconsole.log(rabbit.eats) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 默认的 F.prototype\n\n即便没有提供 prototype 给函数，每个函数都有 prototype 属性。默认的 prototype 是一个只有属性 constructor 的对象，属性 constructor 指向 函数自身。\n\n🌰 例子：\n\nfunction Rabbit() {}\n\n/* default prototype\nRabbit.prototype = { constructor: Rabbit };\n*/\nconsole.log(Rabbit.prototype.constructor === Rabbit) // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n> \n\nlet rabbit = new Rabbit()\nconsole.log(rabbit.constructor === Rabbit) // true\n\n\n1\n2\n\n\n> 即便不显式操作， constructor 会通过 [[prototype]] 属性给所有的 rabbit （通过 new 创建的对象） 。\n\n🌰 例子 / 通过 constructor 创建一个新的对象，该对象使用 与对象相同的构造器：\n\nfunction Rabbit(name) {\n  this.name = name\n  console.log(name)\n}\n\nlet rabbit = new Rabbit("White Rabbit") \nlet rabbit2 = new rabbit.constructor("Black Rabit")\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当有一个对象，但是 不知道它使用了哪一个构造器（来自第三方库的对象），如果想要创建另一个类似的对象，就可以是使用这种方法。\n\n提示\n\n注意：JavaScript 自身并不能确保正确的 constructor 的函数值。 它存在于函数的默认 prototype 中，但仅此而已。之后会发生什么 ，完全取决于使用人。\n\n就是说，当把整个 默认的 prototype 替换掉，其中就不会有 constructor 了。\n\n为了确保有正确的 prototype ，可以选择 添加 / 删除 属性到默认 prototype ，而不是整个将它 覆盖。\n\n🌰 例子：\n\nfunction Rabbit() {}\n\nRabbit.prototype.jumps = true // 向 prototype 中添加属性\n\n\n1\n2\n3\n\n\n这样就可以将 默认的 prototype 保留下来。\n\n或者 手动重新创建 constructor 属性，这样 constructor 也能被保留下来：\n\nRabbit.prototype = {\n  jumps: true,\n  constructor: Rabbit\n};\n\n\n1\n2\n3\n4\n\n\n\n# 总结\n\n * 通过构造函数，可以设置创建新的对象的 [[prototype]] 。\n\n * F.prototype 属性在 new F 被调用时为新对象的 [[Prototype]] 赋值。\n\n * F.prototype 的值要么是一个对象，要么就是 null 。其他值都不起作用。\n\n * F.prototype 属性仅在设置了一个构造函数，并通过 new 调用时，才具有这种特殊的影响。为了保留这个构造函数，应该在其之上添加属性，而不应该整个覆盖。\n   \n   可以通过这个构造函数创建类似的对象，但是如果 constructor 被重写了就不起作用。',normalizedContent:'# f.prototype\n\njavascript 中可以使用 new f() 这样的 构造器（构造函数）创建一个 新的对象。\n\n如果 f.prototype 是一个 对象，那么 new 操作符会使用它作为 新对象 设置 [[prototype]] 。（一个构造函数的原型，当使用构造函数创建一个新的对象时，对象的原型为这个构造函数的原型）\n\n这里的 f.prototype 指的是 f 对象的一个名为 prototype 的 常规属性。\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n};\n\nfunction rabbit(name) {\n  this.name = name;\n}\n\nrabbit.prototype = animal\nlet rabbit = new rabbit("white rabbit")\n\nconsole.log(rabit.eats) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 设置 rabbit.prototype = animal 的字面意思是：创建一个 new rabbit 时，把它的 [[[prototype]]] 赋值为 animal 。\n> \n> \n> \n> "prototype" 是一个水平箭头，表示一个常规属性， [[prototype]] 是垂直的，表示 rabbit 继承自 animal 。\n\n提示\n\nf.prototype 仅能用在 new f 时，它为新对象的 [[prototype]] 赋值。\n\n如果在创建之后， f.prototype 属性有了变化（ f.prototype = <another object> ），那么通过 new f 创建的 新对象 也将随之拥有 新的对象 作为 [[prototype]] ，但已经存在的对象将 保持旧有的值。\n\n如果在创建之后，修改 f.prototype 的值（修改引用），对已经存在的对象也会受到影响。\n\n🌰 例子：\n\nfunction rabbit() {}\nrabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new rabbit(); // 引用的是上面的prototyope\n\nrabbit.prototype = {\n  eats: false\n}\n\nlet rabbit2 = new rabbit(); // 引用的是新的prototype\ndelete rabbit.prototype.eats // 删除新定义的prototype的eats\n\nconsole.log(rabbit.eats) // true\nconsole.log(rabbit.eats) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 默认的 f.prototype\n\n即便没有提供 prototype 给函数，每个函数都有 prototype 属性。默认的 prototype 是一个只有属性 constructor 的对象，属性 constructor 指向 函数自身。\n\n🌰 例子：\n\nfunction rabbit() {}\n\n/* default prototype\nrabbit.prototype = { constructor: rabbit };\n*/\nconsole.log(rabbit.prototype.constructor === rabbit) // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n> \n\nlet rabbit = new rabbit()\nconsole.log(rabbit.constructor === rabbit) // true\n\n\n1\n2\n\n\n> 即便不显式操作， constructor 会通过 [[prototype]] 属性给所有的 rabbit （通过 new 创建的对象） 。\n\n🌰 例子 / 通过 constructor 创建一个新的对象，该对象使用 与对象相同的构造器：\n\nfunction rabbit(name) {\n  this.name = name\n  console.log(name)\n}\n\nlet rabbit = new rabbit("white rabbit") \nlet rabbit2 = new rabbit.constructor("black rabit")\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当有一个对象，但是 不知道它使用了哪一个构造器（来自第三方库的对象），如果想要创建另一个类似的对象，就可以是使用这种方法。\n\n提示\n\n注意：javascript 自身并不能确保正确的 constructor 的函数值。 它存在于函数的默认 prototype 中，但仅此而已。之后会发生什么 ，完全取决于使用人。\n\n就是说，当把整个 默认的 prototype 替换掉，其中就不会有 constructor 了。\n\n为了确保有正确的 prototype ，可以选择 添加 / 删除 属性到默认 prototype ，而不是整个将它 覆盖。\n\n🌰 例子：\n\nfunction rabbit() {}\n\nrabbit.prototype.jumps = true // 向 prototype 中添加属性\n\n\n1\n2\n3\n\n\n这样就可以将 默认的 prototype 保留下来。\n\n或者 手动重新创建 constructor 属性，这样 constructor 也能被保留下来：\n\nrabbit.prototype = {\n  jumps: true,\n  constructor: rabbit\n};\n\n\n1\n2\n3\n4\n\n\n\n# 总结\n\n * 通过构造函数，可以设置创建新的对象的 [[prototype]] 。\n\n * f.prototype 属性在 new f 被调用时为新对象的 [[prototype]] 赋值。\n\n * f.prototype 的值要么是一个对象，要么就是 null 。其他值都不起作用。\n\n * f.prototype 属性仅在设置了一个构造函数，并通过 new 调用时，才具有这种特殊的影响。为了保留这个构造函数，应该在其之上添加属性，而不应该整个覆盖。\n   \n   可以通过这个构造函数创建类似的对象，但是如果 constructor 被重写了就不起作用。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🏕 JavaScript 原生的原型",frontmatter:{title:"🏕 JavaScript 原生的原型",date:"2022-05-14T12:59:26.000Z",permalink:"/pages/439d84/",categories:["🚶🏻 前端巩固基础","📘 JavaScript 原型与继承"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/34.%20%F0%9F%93%98%20JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/30.%20%F0%9F%8F%95%20JavaScript%20%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/30. 🏕 JavaScript 原生的原型.md",key:"v-0ba73a86",path:"/pages/439d84/",headers:[{level:2,title:"Object.prototype",slug:"object-prototype",normalizedTitle:"object.prototype",charIndex:60},{level:2,title:"其他内建对象的原型",slug:"其他内建对象的原型",normalizedTitle:"其他内建对象的原型",charIndex:778},{level:2,title:"基本数据类型的原型",slug:"基本数据类型的原型",normalizedTitle:"基本数据类型的原型",charIndex:1722},{level:3,title:"更改原型原型",slug:"更改原型原型",normalizedTitle:"更改原型原型",charIndex:2004},{level:3,title:"从原型中借用",slug:"从原型中借用",normalizedTitle:"从原型中借用",charIndex:2658},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3240},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:3617},{level:3,title:"给函数的原型添加方法",slug:"给函数的原型添加方法",normalizedTitle:"给函数的原型添加方法",charIndex:3624},{level:3,title:"给函数的原型添加装饰器方法",slug:"给函数的原型添加装饰器方法",normalizedTitle:"给函数的原型添加装饰器方法",charIndex:3924}],headersStr:"Object.prototype 其他内建对象的原型 基本数据类型的原型 更改原型原型 从原型中借用 总结 实例 给函数的原型添加方法 给函数的原型添加装饰器方法",content:'prototype 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内建构造函数都用到了它。\n\n\n# Object.prototype\n\n🌰 例子 / 输出一个空白对象：\n\nlet obj = {}\nconsole.log(obj) // [object Object]\n\n\n1\n2\n\n\n> obj = {} 相当于 obj = new Object() 。其中 Object 就是一个 内建的对象构造函数，其自身的 prototype 指向一个带有 toString 和其他方法的一个巨大的对象。\n> \n> \n> \n> 当 创建一个对象（ new Object() 被调用），按照前面的 构造原型，这个新的对象的 [[prototype]] 属性会被设置为 Object.prototype ：\n> \n> \n> \n> 所以当 这个新的对象（如上空白对象）要被输出时，调用 obj.toString() 方法是来自 Object.toString() 方法。\n> \n> 可以验证：\n> \n> console.log(obj.__proto__ === Object.prototype) // true\n> console.log(obj.toString === obj.__proto__.toString) // true\n> console.log(obj.toString === Object.prototype.toString) // true\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 对于 Object 已经是原型链的末端，上方没有更多的 [[prototype]] 。\n> \n> console.log(Object.prototype.__proto__) // null\n> \n> \n> 1\n\n\n# 其他内建对象的原型\n\n在 JavaScript 中的其他内建对象中，如 Array 、 Date 、 Function 及其他，都在 prototype 上挂载了方法。\n\n🌰 例子 / 数组：\n\n当创建一个数组，会在 内部默认使用 new Array() 构造器。因此， Array.prototype 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。\n\n并且，所有内建原型顶端都是 Object.prototype 。\n\n如下图：\n\n\n手动验证如下：\n\nlet arr = [1, 2, 3]\n\nconsole.log(arr.__proto__ === Array.prototype) // true\nconsole.log(arr.__proto__.__proto__ === Object.prototype) // true\nconsole.log(arr.__proto__.__proto__.__proto__) // null\n\n\n1\n2\n3\n4\n5\n\n\n对于可能重叠的方法，例如 toString() 方法：\n\n🌰 例子：\n\n在数组中 Array.prototype 有自己的 toString 方法列举出数组的所有元素。虽然 Object.prototype 也存在 toString 方法，但是 在原型链中，显然 Array.prototype 更近，所以输出一个数组时，数组对象原型上的方法会被调用。\n\n在浏览器的开发工具可以看到 对象的 原型继承。（内建对象使用 console.dir ）\n\n🌰 例子：\n\n对于函数 ，它们是内建构造器 Function 的对象，并且它们的方法（ call / apply 及其他）都取自 Function.prototype 。函数也有自己的 toString 方法。\n\nfunction f() {}\nconsole.log(f.__proto__ === Function.prototype) // true\nconsole.log(f.__proto__.proto === Object.prototype)) // true\n\n\n1\n2\n3\n\n\n\n# 基本数据类型的原型\n\n对于 字符串、数字、布尔值，它们并不是对象，如果试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 String 、 Number 和 Boolean 被创建。它们提供给操作字符串、数字和布尔值的方法然后消失。（ null 和 undefined 没有对象包装器，他们没有方法和属性，也没有相应的原型）\n\n这些对象是 无形地 创建出来的。这些对象的方法也驻留在它们的 prototype 中，可以通过 String.prototype 、 Number.prototype 和 Boolean.prototype 进行获取。\n\n\n# 更改原型原型\n\n🌰 例子 / 向 String.prototype 中添加一个方法，这时这个方法将对所有的字符串都是可用的：\n\nString.prototype.show = function() {\n  console.log(this);\n};\n\n"BOOM!".show(); // BOOM!\n\n\n1\n2\n3\n4\n5\n\n\n提示\n\n在开发中不建议将新的方法添加到 原生原型中：原型是全局的，所以很容易造成冲突。如果有两个库都添加了 String.prototype.show 方法，那么其中的一个方法将被另一个覆盖。\n\n🌰 例子 /polyfills 修改内建原型：在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。\n\nif (!String.prototype.repeat) { // 如果这儿没有这个方法\n  // 那就在 prototype 中添加它\n\n  String.prototype.repeat = function(n) {\n    // 重复传入的字符串 n 次\n\n    // 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）\n    // 但即使是不够完美的 polyfill 也常常被认为是足够好的\n    return new Array(n + 1).join(this);\n  };\n}\n\nconsole.log("La".reapeat(3))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 从原型中借用\n\n方法借用指 从一个对象中获取一个方法，并将其复制到另一个对象。一些原生的方法通常会被借用。\n\n🌰 例子：\n\nlet obj = {\n  0: \'hello\',\n  1: \'world\',\n  length: 2\n}\n\nobj.join = Array.prototype.join\nconsole.log(obj.join(\',\'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 上面这个例子，从数组方法中借用了 join ，因为 obj 对象与数组很类似，都有正确的索引和 length 属性。所以内建方法 join 可以适用这个对象借用，而不会检查这个对象是不是真正的数组。\n> \n> 全面借用数组方法，可以将 obj.__proto__ 设置为 Array.prototype ，这样 Array 中的方法就可以在 obj 中使用。\n> \n> 但是如果 obj 已经从另一个对象进行了继承，那么这种方法就不可行了（因为这样会覆盖掉已有的继承。此处 obj 其实已经从 Object 进行了继承，但是 Array 也继承自 Object ，所以此处的方法借用不会影响 obj 对原有继承的继承，因为 obj 通过原型链依旧继承了 Object ）。因为一次只能继承一个对象。\n\n方法借用很灵活，它允许在需要时混合来自不同对象的方法。\n\n\n# 总结\n\n * 所有的内建对象都遵循相同的模式：\n   \n   * 方法都存储在 prototype 中（例如， Array.prototype 、 Object.prototype 、 Date.prototype 等）。\n   * 对象本身只存储数据（数组元素、对象属性、日期）。\n\n * 原始数据类型也将方法存储在包装器对象的 prototype 中： Number.prototype 、 String.prototype 和 Boolean.prototype 。只有 undefined 和 null 没有包装器对象。\n\n * 内建原型可以被修改或被用新的方法填充。但是不建议更改它们。唯一允许的情况可能是，当我们添加一个还没有被 JavaScript 引擎支持，但已经被加入 JavaScript 规范的新标准时，才可能允许这样做。\n\n\n# 实例\n\n\n# 给函数的原型添加方法\n\n> 在所有函数的原型中添加 derfer(ms) 方法，该方法将在 ms 毫秒后运行该函数：\n> \n> function f() {\n>   alert("Hello!");\n> }\n> \n> f.defer(1000);\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nFunction.prototype.defer = function(ms) {\n  setTimeout(this, ms)\n}\n\nfunction f() {\nalert("Hello!");\n}\n\nf.defer(1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 给函数的原型添加装饰器方法\n\n> 在所有函数的原型中添加 defer(ms) 方法，该方法返回一个包装器，将函数调用延迟 ms 毫秒。注意参数应该传给原始函数：\n> \n> function f(a, b) {\n>   alert( a + b );\n> }\n> \n> f.defer(1000)(1, 2); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nFunction.prototype.defer = function(ms) {\n  let f = this\n  return function(...args) {\n    setTimeout(() => f.apply(this, args), ms)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 f.apply 中使用 this 以使装饰器适用于对象方法。\n\n例如：\n\nlet user = {\n  name: "John",\n  sayHi() {\n    alert(this.name);\n  }\n}\n\nuser.sayHi = user.sayHi.defer(1000);\nuser.sayHi()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'prototype 属性在 javascript 自身的核心部分中被广泛地应用。所有的内建构造函数都用到了它。\n\n\n# object.prototype\n\n🌰 例子 / 输出一个空白对象：\n\nlet obj = {}\nconsole.log(obj) // [object object]\n\n\n1\n2\n\n\n> obj = {} 相当于 obj = new object() 。其中 object 就是一个 内建的对象构造函数，其自身的 prototype 指向一个带有 tostring 和其他方法的一个巨大的对象。\n> \n> \n> \n> 当 创建一个对象（ new object() 被调用），按照前面的 构造原型，这个新的对象的 [[prototype]] 属性会被设置为 object.prototype ：\n> \n> \n> \n> 所以当 这个新的对象（如上空白对象）要被输出时，调用 obj.tostring() 方法是来自 object.tostring() 方法。\n> \n> 可以验证：\n> \n> console.log(obj.__proto__ === object.prototype) // true\n> console.log(obj.tostring === obj.__proto__.tostring) // true\n> console.log(obj.tostring === object.prototype.tostring) // true\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 对于 object 已经是原型链的末端，上方没有更多的 [[prototype]] 。\n> \n> console.log(object.prototype.__proto__) // null\n> \n> \n> 1\n\n\n# 其他内建对象的原型\n\n在 javascript 中的其他内建对象中，如 array 、 date 、 function 及其他，都在 prototype 上挂载了方法。\n\n🌰 例子 / 数组：\n\n当创建一个数组，会在 内部默认使用 new array() 构造器。因此， array.prototype 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。\n\n并且，所有内建原型顶端都是 object.prototype 。\n\n如下图：\n\n\n手动验证如下：\n\nlet arr = [1, 2, 3]\n\nconsole.log(arr.__proto__ === array.prototype) // true\nconsole.log(arr.__proto__.__proto__ === object.prototype) // true\nconsole.log(arr.__proto__.__proto__.__proto__) // null\n\n\n1\n2\n3\n4\n5\n\n\n对于可能重叠的方法，例如 tostring() 方法：\n\n🌰 例子：\n\n在数组中 array.prototype 有自己的 tostring 方法列举出数组的所有元素。虽然 object.prototype 也存在 tostring 方法，但是 在原型链中，显然 array.prototype 更近，所以输出一个数组时，数组对象原型上的方法会被调用。\n\n在浏览器的开发工具可以看到 对象的 原型继承。（内建对象使用 console.dir ）\n\n🌰 例子：\n\n对于函数 ，它们是内建构造器 function 的对象，并且它们的方法（ call / apply 及其他）都取自 function.prototype 。函数也有自己的 tostring 方法。\n\nfunction f() {}\nconsole.log(f.__proto__ === function.prototype) // true\nconsole.log(f.__proto__.proto === object.prototype)) // true\n\n\n1\n2\n3\n\n\n\n# 基本数据类型的原型\n\n对于 字符串、数字、布尔值，它们并不是对象，如果试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 string 、 number 和 boolean 被创建。它们提供给操作字符串、数字和布尔值的方法然后消失。（ null 和 undefined 没有对象包装器，他们没有方法和属性，也没有相应的原型）\n\n这些对象是 无形地 创建出来的。这些对象的方法也驻留在它们的 prototype 中，可以通过 string.prototype 、 number.prototype 和 boolean.prototype 进行获取。\n\n\n# 更改原型原型\n\n🌰 例子 / 向 string.prototype 中添加一个方法，这时这个方法将对所有的字符串都是可用的：\n\nstring.prototype.show = function() {\n  console.log(this);\n};\n\n"boom!".show(); // boom!\n\n\n1\n2\n3\n4\n5\n\n\n提示\n\n在开发中不建议将新的方法添加到 原生原型中：原型是全局的，所以很容易造成冲突。如果有两个库都添加了 string.prototype.show 方法，那么其中的一个方法将被另一个覆盖。\n\n🌰 例子 /polyfills 修改内建原型：在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。\n\nif (!string.prototype.repeat) { // 如果这儿没有这个方法\n  // 那就在 prototype 中添加它\n\n  string.prototype.repeat = function(n) {\n    // 重复传入的字符串 n 次\n\n    // 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）\n    // 但即使是不够完美的 polyfill 也常常被认为是足够好的\n    return new array(n + 1).join(this);\n  };\n}\n\nconsole.log("la".reapeat(3))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 从原型中借用\n\n方法借用指 从一个对象中获取一个方法，并将其复制到另一个对象。一些原生的方法通常会被借用。\n\n🌰 例子：\n\nlet obj = {\n  0: \'hello\',\n  1: \'world\',\n  length: 2\n}\n\nobj.join = array.prototype.join\nconsole.log(obj.join(\',\'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 上面这个例子，从数组方法中借用了 join ，因为 obj 对象与数组很类似，都有正确的索引和 length 属性。所以内建方法 join 可以适用这个对象借用，而不会检查这个对象是不是真正的数组。\n> \n> 全面借用数组方法，可以将 obj.__proto__ 设置为 array.prototype ，这样 array 中的方法就可以在 obj 中使用。\n> \n> 但是如果 obj 已经从另一个对象进行了继承，那么这种方法就不可行了（因为这样会覆盖掉已有的继承。此处 obj 其实已经从 object 进行了继承，但是 array 也继承自 object ，所以此处的方法借用不会影响 obj 对原有继承的继承，因为 obj 通过原型链依旧继承了 object ）。因为一次只能继承一个对象。\n\n方法借用很灵活，它允许在需要时混合来自不同对象的方法。\n\n\n# 总结\n\n * 所有的内建对象都遵循相同的模式：\n   \n   * 方法都存储在 prototype 中（例如， array.prototype 、 object.prototype 、 date.prototype 等）。\n   * 对象本身只存储数据（数组元素、对象属性、日期）。\n\n * 原始数据类型也将方法存储在包装器对象的 prototype 中： number.prototype 、 string.prototype 和 boolean.prototype 。只有 undefined 和 null 没有包装器对象。\n\n * 内建原型可以被修改或被用新的方法填充。但是不建议更改它们。唯一允许的情况可能是，当我们添加一个还没有被 javascript 引擎支持，但已经被加入 javascript 规范的新标准时，才可能允许这样做。\n\n\n# 实例\n\n\n# 给函数的原型添加方法\n\n> 在所有函数的原型中添加 derfer(ms) 方法，该方法将在 ms 毫秒后运行该函数：\n> \n> function f() {\n>   alert("hello!");\n> }\n> \n> f.defer(1000);\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction.prototype.defer = function(ms) {\n  settimeout(this, ms)\n}\n\nfunction f() {\nalert("hello!");\n}\n\nf.defer(1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 给函数的原型添加装饰器方法\n\n> 在所有函数的原型中添加 defer(ms) 方法，该方法返回一个包装器，将函数调用延迟 ms 毫秒。注意参数应该传给原始函数：\n> \n> function f(a, b) {\n>   alert( a + b );\n> }\n> \n> f.defer(1000)(1, 2); \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n点击查看\n\nfunction.prototype.defer = function(ms) {\n  let f = this\n  return function(...args) {\n    settimeout(() => f.apply(this, args), ms)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 f.apply 中使用 this 以使装饰器适用于对象方法。\n\n例如：\n\nlet user = {\n  name: "john",\n  sayhi() {\n    alert(this.name);\n  }\n}\n\nuser.sayhi = user.sayhi.defer(1000);\nuser.sayhi()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🏜 JavaScript 原型方法",frontmatter:{title:"🏜 JavaScript 原型方法",date:"2022-05-14T14:07:16.000Z",permalink:"/pages/ed1ff1/",categories:["🚶🏻 前端巩固基础","📘 JavaScript 原型与继承"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/34.%20%F0%9F%93%98%20JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/40.%20%F0%9F%8F%9C%20JavaScript%20%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/34. 📘 JavaScript 原型与继承/40. 🏜 JavaScript 原型方法.md",key:"v-4828f3e8",path:"/pages/ed1ff1/",headers:[{level:2,title:"普通对象 Plain Object",slug:"普通对象-plain-object",normalizedTitle:"普通对象 plain object",charIndex:850},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2101},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:2766},{level:3,title:"为对象添加不可枚举的方法",slug:"为对象添加不可枚举的方法",normalizedTitle:"为对象添加不可枚举的方法",charIndex:2773},{level:3,title:"调用方法的差异",slug:"调用方法的差异",normalizedTitle:"调用方法的差异",charIndex:3625}],headersStr:"普通对象 Plain Object 总结 实例 为对象添加不可枚举的方法 调用方法的差异",content:'__proto__ 已经被认为过时且不推荐使用的。在 JavaScript 规范中，proto 必须仅在浏览器环境下才能得到支持。\n\n在 现代 JavaScript 中，使用以下的 原型方法 替代 __proto__ 的使用：\n\n * Object.create(proto, [descriptors]) ：利用给定的 proto 作为 [[Prototype]] 和可选的 属性描述 创建一个空对象。\n * Object.getPrototypeOf(obj) ：获取对象 obj 的原型属性 [[Prototype]] 。\n * Object.setPrototypeOf(obj, proto) ：将对象 obj 的 [[Prototype]] 设置为 proto 。\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n}\n\n// 创建以 animal 为原型的对象\nlet rabbit = Object.create(animal)\n\n// 获取 rabbit 的原型\nconsole.log(Object.getPrototypeOf(rabbit) === animal) // true\n\n// 修改 rabbit 的原型\nObject.setPrototypeOf(rabbit, {});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n🌰 例子 / 使用 Object.create() 实现对象克隆，配合 获取对象的属性描述符：\n\nlet clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n\n\n1\n\n\n> 该克隆对 obj 对象进行完全真正准确的拷贝，包括所有的属性：枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 [[Prototype]] 。\n\n\n# 普通对象 Plain Object\n\n__proto__ 的使用可能会带来问题：\n\n🌰 例子：\n\nlet obj = {};\n\nlet key = prompt("What\'s the key?", "__proto__");\nobj[key] = "some value";\n\nconsole.log(obj[key]); // [object Object]\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这里可以看到，当对象存储 __proto__ 作为键时的属性时，这时赋值就会被忽略。（ __proto__ 属性必须是对象或者 null 。字符串不能成为 prototype。）尽管并不是真的想要意图向 __proto__ 赋值，但是键名为 __proto__ 的键值对没有被正确存储。\n> \n> 这是一个严重的漏洞。在其他情况下，可能会对对象进行赋值操作，然后原型可能就被更改了。结果，可能会导致完全意想不到的结果。当开发者不考虑这个情况，让这类 bug 很难被发现，甚至变成漏洞，尤其是在 JavaScript 被用在服务端的时候。\n> \n> 即使对在默认情况下为函数的 toString 以及其他内建方法执行赋值操作，也会出现意想不到的结果。\n\n要避免这样的问题，可以使用 Map 代替普通对象进行存储。\n\n想要将一个对象用作关联数组，并且摆脱此类问题，使用 Object.create(null) 创建了一个空对象，这个对象没有原型，所以使用 __proto__ 作为键没有问题 （ [[Prototype]] 是 null ）：\n\nlet obj = Object.create(null);\n\nlet key = prompt("What\'s the key?", "__proto__");\nobj[key] = "some value";\n\nconsole.log(obj[key]) // "some value"\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用 Object.create(null) 创建的对象被称为 「very plain」 或 「pure dictionary」 对象，因为它们甚至比通常的普通对象（plain object） {...} 还要简单。\n\n缺点是这样的对象没有任何内建的对象的方法，例如 toString ：\n\nlet obj = Object.create(null)\nconsole.log(obj)\n\n\n1\n2\n\n\n但是 对于与对象相关的方法（ Object.xxx(...) ）仍然可用，它们不在原型中：\n\nlet chineseDictionary = Object.create(null);\nchineseDictionary.hello = "你好";\nchineseDictionary.bye = "再见";\n\nconsole.log(Object.keys(chineseDictionary))\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\n现代 JavaScript 中直接访问原型的方法：\n\n * Object.create(proto, [descriptors]) ：利用给定的 proto 作为 [[Prototype]] 和可选的 属性描述 创建一个空对象。\n * Object.getPrototypeOf(obj) ：获取对象 obj 的原型属性 [[Prototype]] 。\n * Object.setPrototypeOf(obj, proto) ：将对象 obj 的 [[Prototype]] 设置为 proto 。\n\n更多方法：\n\n * Object.keys(obj) / Object.values(obj) / Object.entries ：返回一个可枚举的由 对象 自身的字符串属性名 / 值 / 键值对组成的数组。\n * Object.getOwnPropertySymbols(obj) ：返回对象所有的 symbol 类型的键组成的数组。\n * Object.getOwnPropertyNames(obk) ：返回一个由自身的所有字符串键组成的数组。\n * Reflect.ownKeys ：返回一个由自身所有键组成的数组。\n * obj.hasOwnProperty(key) ：如果 obj 拥有名为 key 的自身的属性（非继承而来的），则返回 true 。\n * 所有返回对象属性的方法（如 Object.keys 及其他）， 都返回「自身」的属性。如果想继承它们，我们可以使用 for...in 。\n\n\n# 实例\n\n\n# 为对象添加不可枚举的方法\n\n> 为该对象添加 dictionary.toString() 方法，该方法应该返回以逗号分隔的所有键的列表。并且 toString 方法不应该在使用 for...in 循环遍历数组的时候显现出来。\n> \n> let dictionary = Object.create(null);\n> \n> dictionary.apple = "Apple";\n> dictionary.__proto__ = "test";\n> \n> for(let key in dictionary) {\n>   alert(key); // "apple", then "__proto__"\n> }\n> \n> console.log(dictionary)\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n点击查看\n\nlet dictionary = Object.create(null, {\n  toString: {\n    value() {\n      return Object.keys(this).join()\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为了使 toString 不可枚举，使用一个 属性描述器 来定义它。 Object.create 语法允许为一个对象提供属性描述器作为 第二参数。当使用描述器创建一个属性，它的标识默认是 false 。因此在上面这段代码中， dictonary.toString 是不可枚举的。\n\n或者使用 Object.defineProperties ：\n\nObject.defineProperties(dictionary, "toString", {\n  value: function() {\n    return Object.keys(this).join()\n  },\n  enumerable: false\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 调用方法的差异\n\n> 创建一个新的 rabbit 对象：\n> \n> function Rabbit(name) {\n>   this.name = name;\n> }\n> Rabbit.prototype.sayHi = function() {\n>   alert(this.name);\n> };\n> \n> let rabbit = new Rabbit("Rabbit");\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 分析：\n> \n> rabbit.sayHi();\n> Rabbit.prototype.sayHi();\n> Object.getPrototypeOf(rabbit).sayHi();\n> rabbit.__proto__.sayHi();\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n点击查看\n\nrabbit.sayHi();                        // Rabbit\nRabbit.prototype.sayHi();              // undefined\nObject.getPrototypeOf(rabbit).sayHi(); // undefined\nrabbit.__proto__.sayHi();              // undefined\n\n\n1\n2\n3\n4\n\n\nthis 指向问题。\n\n所以，只有第一个调用显示 Rabbit ，其他的都显示的是 undefined 。',normalizedContent:'__proto__ 已经被认为过时且不推荐使用的。在 javascript 规范中，proto 必须仅在浏览器环境下才能得到支持。\n\n在 现代 javascript 中，使用以下的 原型方法 替代 __proto__ 的使用：\n\n * object.create(proto, [descriptors]) ：利用给定的 proto 作为 [[prototype]] 和可选的 属性描述 创建一个空对象。\n * object.getprototypeof(obj) ：获取对象 obj 的原型属性 [[prototype]] 。\n * object.setprototypeof(obj, proto) ：将对象 obj 的 [[prototype]] 设置为 proto 。\n\n🌰 例子：\n\nlet animal = {\n  eats: true\n}\n\n// 创建以 animal 为原型的对象\nlet rabbit = object.create(animal)\n\n// 获取 rabbit 的原型\nconsole.log(object.getprototypeof(rabbit) === animal) // true\n\n// 修改 rabbit 的原型\nobject.setprototypeof(rabbit, {});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n🌰 例子 / 使用 object.create() 实现对象克隆，配合 获取对象的属性描述符：\n\nlet clone = object.create(object.getprototypeof(obj), object.getownpropertydescriptors(obj));\n\n\n1\n\n\n> 该克隆对 obj 对象进行完全真正准确的拷贝，包括所有的属性：枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 [[prototype]] 。\n\n\n# 普通对象 plain object\n\n__proto__ 的使用可能会带来问题：\n\n🌰 例子：\n\nlet obj = {};\n\nlet key = prompt("what\'s the key?", "__proto__");\nobj[key] = "some value";\n\nconsole.log(obj[key]); // [object object]\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这里可以看到，当对象存储 __proto__ 作为键时的属性时，这时赋值就会被忽略。（ __proto__ 属性必须是对象或者 null 。字符串不能成为 prototype。）尽管并不是真的想要意图向 __proto__ 赋值，但是键名为 __proto__ 的键值对没有被正确存储。\n> \n> 这是一个严重的漏洞。在其他情况下，可能会对对象进行赋值操作，然后原型可能就被更改了。结果，可能会导致完全意想不到的结果。当开发者不考虑这个情况，让这类 bug 很难被发现，甚至变成漏洞，尤其是在 javascript 被用在服务端的时候。\n> \n> 即使对在默认情况下为函数的 tostring 以及其他内建方法执行赋值操作，也会出现意想不到的结果。\n\n要避免这样的问题，可以使用 map 代替普通对象进行存储。\n\n想要将一个对象用作关联数组，并且摆脱此类问题，使用 object.create(null) 创建了一个空对象，这个对象没有原型，所以使用 __proto__ 作为键没有问题 （ [[prototype]] 是 null ）：\n\nlet obj = object.create(null);\n\nlet key = prompt("what\'s the key?", "__proto__");\nobj[key] = "some value";\n\nconsole.log(obj[key]) // "some value"\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用 object.create(null) 创建的对象被称为 「very plain」 或 「pure dictionary」 对象，因为它们甚至比通常的普通对象（plain object） {...} 还要简单。\n\n缺点是这样的对象没有任何内建的对象的方法，例如 tostring ：\n\nlet obj = object.create(null)\nconsole.log(obj)\n\n\n1\n2\n\n\n但是 对于与对象相关的方法（ object.xxx(...) ）仍然可用，它们不在原型中：\n\nlet chinesedictionary = object.create(null);\nchinesedictionary.hello = "你好";\nchinesedictionary.bye = "再见";\n\nconsole.log(object.keys(chinesedictionary))\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\n现代 javascript 中直接访问原型的方法：\n\n * object.create(proto, [descriptors]) ：利用给定的 proto 作为 [[prototype]] 和可选的 属性描述 创建一个空对象。\n * object.getprototypeof(obj) ：获取对象 obj 的原型属性 [[prototype]] 。\n * object.setprototypeof(obj, proto) ：将对象 obj 的 [[prototype]] 设置为 proto 。\n\n更多方法：\n\n * object.keys(obj) / object.values(obj) / object.entries ：返回一个可枚举的由 对象 自身的字符串属性名 / 值 / 键值对组成的数组。\n * object.getownpropertysymbols(obj) ：返回对象所有的 symbol 类型的键组成的数组。\n * object.getownpropertynames(obk) ：返回一个由自身的所有字符串键组成的数组。\n * reflect.ownkeys ：返回一个由自身所有键组成的数组。\n * obj.hasownproperty(key) ：如果 obj 拥有名为 key 的自身的属性（非继承而来的），则返回 true 。\n * 所有返回对象属性的方法（如 object.keys 及其他）， 都返回「自身」的属性。如果想继承它们，我们可以使用 for...in 。\n\n\n# 实例\n\n\n# 为对象添加不可枚举的方法\n\n> 为该对象添加 dictionary.tostring() 方法，该方法应该返回以逗号分隔的所有键的列表。并且 tostring 方法不应该在使用 for...in 循环遍历数组的时候显现出来。\n> \n> let dictionary = object.create(null);\n> \n> dictionary.apple = "apple";\n> dictionary.__proto__ = "test";\n> \n> for(let key in dictionary) {\n>   alert(key); // "apple", then "__proto__"\n> }\n> \n> console.log(dictionary)\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n点击查看\n\nlet dictionary = object.create(null, {\n  tostring: {\n    value() {\n      return object.keys(this).join()\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为了使 tostring 不可枚举，使用一个 属性描述器 来定义它。 object.create 语法允许为一个对象提供属性描述器作为 第二参数。当使用描述器创建一个属性，它的标识默认是 false 。因此在上面这段代码中， dictonary.tostring 是不可枚举的。\n\n或者使用 object.defineproperties ：\n\nobject.defineproperties(dictionary, "tostring", {\n  value: function() {\n    return object.keys(this).join()\n  },\n  enumerable: false\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 调用方法的差异\n\n> 创建一个新的 rabbit 对象：\n> \n> function rabbit(name) {\n>   this.name = name;\n> }\n> rabbit.prototype.sayhi = function() {\n>   alert(this.name);\n> };\n> \n> let rabbit = new rabbit("rabbit");\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 分析：\n> \n> rabbit.sayhi();\n> rabbit.prototype.sayhi();\n> object.getprototypeof(rabbit).sayhi();\n> rabbit.__proto__.sayhi();\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n点击查看\n\nrabbit.sayhi();                        // rabbit\nrabbit.prototype.sayhi();              // undefined\nobject.getprototypeof(rabbit).sayhi(); // undefined\nrabbit.__proto__.sayhi();              // undefined\n\n\n1\n2\n3\n4\n\n\nthis 指向问题。\n\n所以，只有第一个调用显示 rabbit ，其他的都显示的是 undefined 。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⚽️ JavaScript 类的基本语法",frontmatter:{title:"⚽️ JavaScript 类的基本语法",date:"2022-05-16T17:36:50.000Z",permalink:"/pages/2864a5/",categories:["🚶🏻 前端巩固基础","📙 JavaScript 类"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/35.%20%F0%9F%93%99%20JavaScript%20%E7%B1%BB/01.%20%E2%9A%BD%EF%B8%8F%20JavaScript%20%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/01. ⚽️ JavaScript 类的基本语法.md",key:"v-08213124",path:"/pages/2864a5/",headers:[{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:159},{level:2,title:"理解 class",slug:"理解-class",normalizedTitle:"理解 class",charIndex:755},{level:2,title:"类的使用不仅仅是 语法糖",slug:"类的使用不仅仅是-语法糖",normalizedTitle:"类的使用不仅仅是 语法糖",charIndex:1356},{level:2,title:"类的表达式",slug:"类的表达式",normalizedTitle:"类的表达式",charIndex:2381},{level:2,title:"类的 getters / setters",slug:"类的-getters-setters",normalizedTitle:"类的 getters /setters",charIndex:null},{level:2,title:"类的计算属性",slug:"类的计算属性",normalizedTitle:"类的计算属性",charIndex:3518},{level:2,title:"类的字段",slug:"类的字段",normalizedTitle:"类的字段",charIndex:3672},{level:3,title:"利用类字段绑定方法",slug:"利用类字段绑定方法",normalizedTitle:"利用类字段绑定方法",charIndex:4229}],headersStr:"基本语法 理解 class 类的使用不仅仅是 语法糖 类的表达式 类的 getters / setters 类的计算属性 类的字段 利用类字段绑定方法",content:'JavaScript 中，要创建许多相同类型的对象，例如用户（users）、商品（goods）或者任何其他东西。\n\n构造器 和 操作符 new ，可以实现这种需求。\n\n但在现代 JavaScript 中，还有一个更高级的「类（class）」构造方式，它引入许多非常棒的新功能，这些功能对于面向对象编程很有用。\n\n\n# 基本语法\n\n创建一个类的语法\n\nclass myClass {\n  constructor() { ... }\n  \n  method1() { ... }\n  method2() { ... }\n  method3() { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后使用 new MyClass() 来创建具有上述列出的所有方法的新对象。 new 会自动调用 constructor() 方法，因此可以在 constructor() 中初始化对象。\n\n🌰 例子 / 使用例子。：\n\nclass User {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    alert(this.name);\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nlet user = new User("John");\nuser.sayHi();\n\n\n1\n2\n\n\n> new User("John") ：\n> \n>  * 一个新对象被创建。\n>  * constructor 使用给定的参数运行，并将其赋值给 this.name 。\n>  * 然后就可以调用 对象 中的方法 sayHi()\n\n注意\n\n类的方法之间没有逗号。不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。\n\n\n# 理解 class\n\nclass 的类型：\n\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\nalert(typeof User); // function\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 JavaScript 中，类是一种函数。\n\n实际上， class User {...} 构造有以下工作：\n\n * 创建一个名为 User 的函数，该函数称为类 声明 的结果。该函数的代码来自于 constructor 方法（如果没有则假定为空）。\n * 存储类中的方法，例如 User.prototype 中的 sayHi 。\n\n类被创建以后，当调用其方法时，它会从原型中获取对应的方法（ 类似 F.prototype ），因此，通过 new User 创建的对象可以 访问类中的方法：\n\nconsole.log(User = User.prototyope.constructor) // true\n\ncosole.log(User.prototype.sayHi) // 函数\n\nconsole.log(Object.getOwnPropertyNames(User.prototype)) // constructor, sayHi\n\n\n1\n2\n3\n4\n5\n\n\n\n# 类的使用不仅仅是 语法糖\n\n其实类完成的工作，相当于声明函数，将方法添加到函数，使用 new 创建对象：\n\n// 1. 创建构造器函数\nfunction User(name) {\n  this.name = name;\n}\n// 函数的原型（prototype）默认具有 "constructor" 属性，\n// 所以，我们不需要创建它\n\n// 2. 将方法添加到原型\nUser.prototype.sayHi = function() {\n  alert(this.name);\n};\n\n// 用法：\nlet user = new User("John");\nuser.sayHi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n但是 手动创建 与 类创建 的函数 有着重大差异：\n\n * 通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true 。因此，它与手动创建并不完全相同。\n   \n   class 创建的函数必须要使用 new 调用：\n   \n   class User {\n     constructor() {}\n   }\n   \n   console.log(typeof User); // function\n   User(); //  Error: Class constructor User cannot be invoked without \'new\'\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   大多数 JavaScript 引擎中的 类构造器的字符串 表示形式都以 class… 开头：\n   \n   class User {\n     constructor() {}\n   }\n   \n   console.log(User) // class User { ... }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 类的方法 不可枚举。类定义将 "prototype" 中的所有方法的 enumerable 标志设置为 false 。\n   \n   所以如果对一个对象调用 for ... in ， class 方法不会出现。\n\n * 类总是使用 use strict 。 在类构造中的所有代码都将自动进入严格模式。\n\n\n# 类的表达式\n\n与函数表达式一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。\n\n🌰 例子：\n\nlet User = class {\n  sayHi() {\n    alert("Hello");\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 类似于命名函数表达式，类表达式也可以有一个名字：\n\nlet User = class MyClass {\n  sayHi() {\n    alert(MyClass); // MyClass 这个名字仅在类内部可见\n  }\n};\n\nnew User().sayHi();\nconsole.log(MyClass) // 外部不可见\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子 / 动态创建类，函数的返回值是一个类：\n\nfunction makeClass(phrase) {\n  // 声明一个类并返回它\n  return class {\n    sayHi() {\n      alert(phrase);\n    }\n  };\n}\n\n// 创建一个新的类\nlet User = makeClass("Hello");\n\nnew User().sayHi(); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 类的 getters / setters\n\n就像 对象字面量，类可能包括 getters/setters，计算属性等。\n\n🌰 例子：\n\nclass User {\n\n  constructor(name) {\n    // 调用 setter\n    this.name = name;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  set name(value) {\n    if (value.length < 4) {\n      console.log("Name is too short.");\n      return;\n    }\n    this._name = value;\n  }\n\n}\n\nlet user = new User("John");\nconsole.log(user.name); // getters\nuser.name = "" // "Name is too short." setters\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 从技术上来讲，这样的类声明可以通过在 User.prototype 中创建 getters 和 setters 来实现。\n\n\n# 类的计算属性\n\n🌰 例子 / 使用中括号 [...] 的计算方法名：\n\nclass User {\n  [\'say\' + \'Hi\']() {\n    console.log("Hello");\n  }\n}\n\nnew User().sayHi(); // Hello\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 类的字段\n\n类的字段是一种允许添加任何属性的语法。只需在表达式中写 = 。\n\n🌰 例子 / 向类添加一个属性：\n\nclass User {\n  name = "John";\n\n  sayHi() {\n    console.log(`Hello, ${this.name}!`);\n  }\n}\n\nnew User().sayHi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在 User.prototype ：\n\nclass User {\n  name = "John";\n}\n\nlet user = new User();\nconsole.log(user.name); // John\nconsole.log(User.prototype.name); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子 / 在赋值时使用更复杂的表达式和函数调用：\n\nclass User {\n  name = prompt("Name, please?", "John");\n}\n\nlet user = new User();\nconsole.log(user.name); // John\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 利用类字段绑定方法\n\n在 函数绑定 中，JavaScript 中的函数具有动态的 this 。它取决于调用上下文。因此，如果一个对象方法被传递到某处，或者在另一个上下文中被调用，则 this 将不再是对其对象的引用。例如：\n\nclass Button {\n  constructor(value) {\n    this.value = value;\n  }\n\n  click() {\n    console.log(this.value);\n  }\n}\n\nlet button = new Button("hello");\n\nsetTimeout(button.click, 1000); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 在 setTimeout 中丢失了 this 。\n\n可以通过：\n\n * 传递一个包装函数，例如 setTimeout(() => button.click(), 1000) 。\n * 将方法绑定到对象，例如在 constructor 中。\n\n类字段 可以更加优雅地解决：\n\nclass Button {\n  constructor(value) {\n    this.value = value;\n  }\n  click = () => {\n    console.log(this.value);\n  }\n}\n\nlet button = new Button("hello");\nsetTimeout(button.click, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 类字段 click = () => {...} 是 基于每一个对象 被创建的，在这里对于每一个 Button 对象都有一个独立的方法，在内部都有一个指向此对象的 this 。\n> \n> 所以可以把 button.click 传递到任何地方，而且 this 的值总是正确的。',normalizedContent:'javascript 中，要创建许多相同类型的对象，例如用户（users）、商品（goods）或者任何其他东西。\n\n构造器 和 操作符 new ，可以实现这种需求。\n\n但在现代 javascript 中，还有一个更高级的「类（class）」构造方式，它引入许多非常棒的新功能，这些功能对于面向对象编程很有用。\n\n\n# 基本语法\n\n创建一个类的语法\n\nclass myclass {\n  constructor() { ... }\n  \n  method1() { ... }\n  method2() { ... }\n  method3() { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后使用 new myclass() 来创建具有上述列出的所有方法的新对象。 new 会自动调用 constructor() 方法，因此可以在 constructor() 中初始化对象。\n\n🌰 例子 / 使用例子。：\n\nclass user {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayhi() {\n    alert(this.name);\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nlet user = new user("john");\nuser.sayhi();\n\n\n1\n2\n\n\n> new user("john") ：\n> \n>  * 一个新对象被创建。\n>  * constructor 使用给定的参数运行，并将其赋值给 this.name 。\n>  * 然后就可以调用 对象 中的方法 sayhi()\n\n注意\n\n类的方法之间没有逗号。不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。\n\n\n# 理解 class\n\nclass 的类型：\n\nclass user {\n  constructor(name) { this.name = name; }\n  sayhi() { alert(this.name); }\n}\n\nalert(typeof user); // function\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 javascript 中，类是一种函数。\n\n实际上， class user {...} 构造有以下工作：\n\n * 创建一个名为 user 的函数，该函数称为类 声明 的结果。该函数的代码来自于 constructor 方法（如果没有则假定为空）。\n * 存储类中的方法，例如 user.prototype 中的 sayhi 。\n\n类被创建以后，当调用其方法时，它会从原型中获取对应的方法（ 类似 f.prototype ），因此，通过 new user 创建的对象可以 访问类中的方法：\n\nconsole.log(user = user.prototyope.constructor) // true\n\ncosole.log(user.prototype.sayhi) // 函数\n\nconsole.log(object.getownpropertynames(user.prototype)) // constructor, sayhi\n\n\n1\n2\n3\n4\n5\n\n\n\n# 类的使用不仅仅是 语法糖\n\n其实类完成的工作，相当于声明函数，将方法添加到函数，使用 new 创建对象：\n\n// 1. 创建构造器函数\nfunction user(name) {\n  this.name = name;\n}\n// 函数的原型（prototype）默认具有 "constructor" 属性，\n// 所以，我们不需要创建它\n\n// 2. 将方法添加到原型\nuser.prototype.sayhi = function() {\n  alert(this.name);\n};\n\n// 用法：\nlet user = new user("john");\nuser.sayhi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n但是 手动创建 与 类创建 的函数 有着重大差异：\n\n * 通过 class 创建的函数具有特殊的内部属性标记 [[isclassconstructor]]: true 。因此，它与手动创建并不完全相同。\n   \n   class 创建的函数必须要使用 new 调用：\n   \n   class user {\n     constructor() {}\n   }\n   \n   console.log(typeof user); // function\n   user(); //  error: class constructor user cannot be invoked without \'new\'\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   大多数 javascript 引擎中的 类构造器的字符串 表示形式都以 class… 开头：\n   \n   class user {\n     constructor() {}\n   }\n   \n   console.log(user) // class user { ... }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 类的方法 不可枚举。类定义将 "prototype" 中的所有方法的 enumerable 标志设置为 false 。\n   \n   所以如果对一个对象调用 for ... in ， class 方法不会出现。\n\n * 类总是使用 use strict 。 在类构造中的所有代码都将自动进入严格模式。\n\n\n# 类的表达式\n\n与函数表达式一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。\n\n🌰 例子：\n\nlet user = class {\n  sayhi() {\n    alert("hello");\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n🌰 例子 / 类似于命名函数表达式，类表达式也可以有一个名字：\n\nlet user = class myclass {\n  sayhi() {\n    alert(myclass); // myclass 这个名字仅在类内部可见\n  }\n};\n\nnew user().sayhi();\nconsole.log(myclass) // 外部不可见\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子 / 动态创建类，函数的返回值是一个类：\n\nfunction makeclass(phrase) {\n  // 声明一个类并返回它\n  return class {\n    sayhi() {\n      alert(phrase);\n    }\n  };\n}\n\n// 创建一个新的类\nlet user = makeclass("hello");\n\nnew user().sayhi(); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 类的 getters / setters\n\n就像 对象字面量，类可能包括 getters/setters，计算属性等。\n\n🌰 例子：\n\nclass user {\n\n  constructor(name) {\n    // 调用 setter\n    this.name = name;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  set name(value) {\n    if (value.length < 4) {\n      console.log("name is too short.");\n      return;\n    }\n    this._name = value;\n  }\n\n}\n\nlet user = new user("john");\nconsole.log(user.name); // getters\nuser.name = "" // "name is too short." setters\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 从技术上来讲，这样的类声明可以通过在 user.prototype 中创建 getters 和 setters 来实现。\n\n\n# 类的计算属性\n\n🌰 例子 / 使用中括号 [...] 的计算方法名：\n\nclass user {\n  [\'say\' + \'hi\']() {\n    console.log("hello");\n  }\n}\n\nnew user().sayhi(); // hello\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 类的字段\n\n类的字段是一种允许添加任何属性的语法。只需在表达式中写 = 。\n\n🌰 例子 / 向类添加一个属性：\n\nclass user {\n  name = "john";\n\n  sayhi() {\n    console.log(`hello, ${this.name}!`);\n  }\n}\n\nnew user().sayhi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在 user.prototype ：\n\nclass user {\n  name = "john";\n}\n\nlet user = new user();\nconsole.log(user.name); // john\nconsole.log(user.prototype.name); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子 / 在赋值时使用更复杂的表达式和函数调用：\n\nclass user {\n  name = prompt("name, please?", "john");\n}\n\nlet user = new user();\nconsole.log(user.name); // john\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 利用类字段绑定方法\n\n在 函数绑定 中，javascript 中的函数具有动态的 this 。它取决于调用上下文。因此，如果一个对象方法被传递到某处，或者在另一个上下文中被调用，则 this 将不再是对其对象的引用。例如：\n\nclass button {\n  constructor(value) {\n    this.value = value;\n  }\n\n  click() {\n    console.log(this.value);\n  }\n}\n\nlet button = new button("hello");\n\nsettimeout(button.click, 1000); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 在 settimeout 中丢失了 this 。\n\n可以通过：\n\n * 传递一个包装函数，例如 settimeout(() => button.click(), 1000) 。\n * 将方法绑定到对象，例如在 constructor 中。\n\n类字段 可以更加优雅地解决：\n\nclass button {\n  constructor(value) {\n    this.value = value;\n  }\n  click = () => {\n    console.log(this.value);\n  }\n}\n\nlet button = new button("hello");\nsettimeout(button.click, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 类字段 click = () => {...} 是 基于每一个对象 被创建的，在这里对于每一个 button 对象都有一个独立的方法，在内部都有一个指向此对象的 this 。\n> \n> 所以可以把 button.click 传递到任何地方，而且 this 的值总是正确的。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🏀 JavaScript 类继承",frontmatter:{title:"🏀 JavaScript 类继承",date:"2022-05-16T20:24:42.000Z",permalink:"/pages/5bccfe/",categories:["🚶🏻 前端巩固基础","📙 JavaScript 类"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/35.%20%F0%9F%93%99%20JavaScript%20%E7%B1%BB/02.%20%F0%9F%8F%80%20JavaScript%20%E7%B1%BB%E7%BB%A7%E6%89%BF.html",relativePath:"101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/02. 🏀 JavaScript 类继承.md",key:"v-0aa835c0",path:"/pages/5bccfe/",headers:[{level:2,title:"extends",slug:"extends",normalizedTitle:"extends",charIndex:23},{level:2,title:"重写方法",slug:"重写方法",normalizedTitle:"重写方法",charIndex:1398},{level:2,title:"重写 constructor",slug:"重写-constructor",normalizedTitle:"重写 constructor",charIndex:2764},{level:2,title:"重写类字段",slug:"重写类字段",normalizedTitle:"重写类字段",charIndex:3610},{level:2,title:"深入 内部探究 和 [[HomeObject]]",slug:"深入-内部探究-和-homeobject",normalizedTitle:"深入 内部探究 和 [[homeobject]]",charIndex:4442},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4493}],headersStr:"extends 重写方法 重写 constructor 重写类字段 深入 内部探究 和 [[HomeObject]] 总结",content:'继承可以 通过一个类 拓展另一个类。\n\n\n# extends\n\n🌰 例子：\n\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed = speed;\n    console.log(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    cnosole.log(`${this.name} stands still.`);\n  }\n}\n\nlet animal = new Animal(\'animal\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n要创建另一个 继承 Animal 的类 rabbit ，使用 extends 关键字，可以访问 animal 的方法，以便 Rabbit 类可以做「一般」动物可以做的事。\n\nclass Rabbit extends Animal {\n  hide() {\n    console.log(`${this.name} hides!`)\n  }\n}\n\nlet rabbit = new Rabbit(\'white rabbit\')\nrabbit.run(5) // 访问 Animal 中的方法\nrabbit.hide   // 访问 Rabbit 中的方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nClass Rabbit 的对象可以访问例如 rabbit.hide() 等 Rabbit 的方法，还可以访问例如 rabbit.run() 等 Animal 的方法。\n\n> 在内部，关键字 extends 使用了很好的旧的 原型机制 进行工作。它将 Rabbit.prototype.[[Prototype]] 设置为 Animal.prototype 。所以，如果在 Rabbit.prototype 中找不到一个方法，JavaScript 就会从 Animal.prototype 中获取该方法。\n> \n> \n> \n> 查找 run 方法的过程：\n> \n>  * 查找对象 rabbit （没有 run ）。\n>  * 查找它的原型，即 Rabbit.prototype （有 hide ，但没有 run ）。\n>  * 查找它的原型，即（由于 extends ） Animal.prototype ，在这儿找到了 run 方法。\n\n提示\n\n在 extends 后允许任意表达式。\n\n🌰 例子：\n\nfunction f(phrase) {\n  return class {\n    sayHi() { console.log(phrase); }\n  };\n}\n\nclass User extends f("Hello") {}\n\nnew User().sayHi(); // "Hello"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 这里 class User 继承自 f("Hello") 的结果。\n\n对于高级编程模式，例如当 根据许多条件使用函数生成类，并继承它们时来说可能很有用。\n\n\n# 重写方法\n\n🌰 例子 / Rabbit 继承 Animal 的例子中，重写 stop() ：\n\nclass Rabbit extends Animal {\n  stop() {\n    // ……现在这个将会被用作 rabbit.stop()\n    // 而不是来自于 class Animal 的 stop()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 通常不会完全重写父类的方法，而是 在父类的基础上调整或者拓展。\n\n可以使用 super 关键字\n\n * 执行 super.method(...) 来调用一个父类方法。\n * 执行 super(...) 来调用一个父类 constructor （只能在 constructor 中调用）。\n\n🌰 例子：\n\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  run(speed) {\n    this.speed = speed;\n    console.log(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  stop() {\n    this.speed = 0;\n    console.log(`${this.name} stands still.`);\n  }\n\n}\n\nclass Rabbit extends Animal {\n  hide() {\n    console.log(`${this.name} hides!`);\n  }\n\n  stop() {\n    super.stop(); // 调用父类的 stop\n    this.hide(); // 然后 hide\n  }\n}\n\nlet rabbit = new Rabbit("White Rabbit");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.stop(); // White Rabbit stands still. White Rabbit hides!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n> 在 Rabbit 的 stop 方法中，调用父类的 super.stop() 方法，所以 Rabbit 也具有了父类的 stop 方法。\n\n提示\n\n** 箭头函数没有 super 。** 如果被访问，它会从外部函数获取。例如：\n\nclass Rabbit extends Animal {\n  stop() {\n    setTimeout(() => super.stop(), 1000); // 1 秒后调用父类的 stop\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n但是对于普通的函数，这里会获取不到外部的 super ：\n\nsetTimeout(function() { super.stop() }, 1000); // Error\n\n\n1\n\n\n\n# 重写 constructor\n\n如果继承了父类的字类没有 constructor ，那么将生成下面这样的空 constructor ：\n\nclass Rabbit extends Animal {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n如果要添加 子类的 一个自定义的 constructor ，继承类的 constructor 必须调用 super(...) ，并且 一定要在使用 this 之前调用。\n\n> 在 JavaScript 中，继承类的构造函数与其他函数之间是有区别的。派生构造器具有特殊的内部属性 [[ConstructorKind]]:"derived" ，这是一个特殊的内部标签。该标签会影响它的 new 行为：\n> \n>  * 当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this 。\n>  * 但是当继承的 constructor 执行时，它不会执行此操作。它期望 父类的 constructor 来完成这项工作。\n> \n> 因此，派生的 constructor 必须调用 super 才能执行其 父类的 constructor ，否则 this 指向的那个对象将不会被创建。\n\n🌰 例子：\n\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n  constructor(name, earLength) {\n    super(name);\n    this.earLength = earLength;\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 重写类字段\n\n🌰 例子 / 当访问 被重写的字段时：\n\nclass Animal {\n  name = \'animal\';\n\n  constructor() {\n    alert(this.name); // (*)\n  }\n}\n\nclass Rabbit extends Animal {\n  name = \'rabbit\';\n}\n\nnew Animal(); // animal\nnew Rabbit(); // animal\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> Rabbit 继承自 Animal ，并且用它自己的值重写了 name 字段。\n> \n> 因为 Rabbit 中没有自己的构造器，所以 Animal 的构造器被调用了。这两种情况下，都打印了 animal 。\n> \n> 换句话说，父类构造器总是会使用它自己字段的值，而不是被重写的那一个。\n\n当父类构造器在派生的类中被调用时，它会使用被重写的方法。但对于类字段并非如此。正如前文所述，父类构造器总是使用父类的字段。\n\n实际上，原因在于字段初始化的顺序。类字段是这样初始化的：\n\n * 对于基类（还未继承任何东西的那种），在构造函数调用前初始化。\n * 对于派生类，在 super() 后立刻初始化。\n\n上面的例子中， Rabbit 是派生类，里面没有 constructor() 。正如先前所说，这相当于一个里面只有 super(...args) 的空构造器。\n\n所以， new Rabbit() 调用了 super() ，因此它执行了父类构造器，并且（根据派生类规则）只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候， Rabbit 还没有自己的类字段，这就是为什么 Animal 类字段被使用了。\n\n> 这种字段与方法之间微妙的区别只特定于 JavaScript。这种行为仅在一个被重写的字段被父类构造器使用时才会显现出来。\n\n\n# 深入 内部探究 和 [[HomeObject]]\n\n关于继承和 super 背后的内部机制。\n\n\n# 总结\n\n * 想要扩展一个类： class Child extends Parent\n   \n   * 这意味着 Child.prototype.__proto__ 将是 Parent.prototype ，所以方法会被继承。\n\n * 重写一个方法：\n   \n   * 可以在一个 Child 方法中使用 super.method() 来调用 Parent 方法\n\n * 重写一个 constructor ：\n   \n   * 在使用 this 之前，必须在 Child 的 constructor 中将父 constructor 调用为 super() 。\n   * 箭头函数没有自己的 this 或 super ，它们从外部上下文获取 this 和 super。',normalizedContent:'继承可以 通过一个类 拓展另一个类。\n\n\n# extends\n\n🌰 例子：\n\nclass animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed = speed;\n    console.log(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    cnosole.log(`${this.name} stands still.`);\n  }\n}\n\nlet animal = new animal(\'animal\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n要创建另一个 继承 animal 的类 rabbit ，使用 extends 关键字，可以访问 animal 的方法，以便 rabbit 类可以做「一般」动物可以做的事。\n\nclass rabbit extends animal {\n  hide() {\n    console.log(`${this.name} hides!`)\n  }\n}\n\nlet rabbit = new rabbit(\'white rabbit\')\nrabbit.run(5) // 访问 animal 中的方法\nrabbit.hide   // 访问 rabbit 中的方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nclass rabbit 的对象可以访问例如 rabbit.hide() 等 rabbit 的方法，还可以访问例如 rabbit.run() 等 animal 的方法。\n\n> 在内部，关键字 extends 使用了很好的旧的 原型机制 进行工作。它将 rabbit.prototype.[[prototype]] 设置为 animal.prototype 。所以，如果在 rabbit.prototype 中找不到一个方法，javascript 就会从 animal.prototype 中获取该方法。\n> \n> \n> \n> 查找 run 方法的过程：\n> \n>  * 查找对象 rabbit （没有 run ）。\n>  * 查找它的原型，即 rabbit.prototype （有 hide ，但没有 run ）。\n>  * 查找它的原型，即（由于 extends ） animal.prototype ，在这儿找到了 run 方法。\n\n提示\n\n在 extends 后允许任意表达式。\n\n🌰 例子：\n\nfunction f(phrase) {\n  return class {\n    sayhi() { console.log(phrase); }\n  };\n}\n\nclass user extends f("hello") {}\n\nnew user().sayhi(); // "hello"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 这里 class user 继承自 f("hello") 的结果。\n\n对于高级编程模式，例如当 根据许多条件使用函数生成类，并继承它们时来说可能很有用。\n\n\n# 重写方法\n\n🌰 例子 / rabbit 继承 animal 的例子中，重写 stop() ：\n\nclass rabbit extends animal {\n  stop() {\n    // ……现在这个将会被用作 rabbit.stop()\n    // 而不是来自于 class animal 的 stop()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 通常不会完全重写父类的方法，而是 在父类的基础上调整或者拓展。\n\n可以使用 super 关键字\n\n * 执行 super.method(...) 来调用一个父类方法。\n * 执行 super(...) 来调用一个父类 constructor （只能在 constructor 中调用）。\n\n🌰 例子：\n\nclass animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  run(speed) {\n    this.speed = speed;\n    console.log(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  stop() {\n    this.speed = 0;\n    console.log(`${this.name} stands still.`);\n  }\n\n}\n\nclass rabbit extends animal {\n  hide() {\n    console.log(`${this.name} hides!`);\n  }\n\n  stop() {\n    super.stop(); // 调用父类的 stop\n    this.hide(); // 然后 hide\n  }\n}\n\nlet rabbit = new rabbit("white rabbit");\n\nrabbit.run(5); // white rabbit runs with speed 5.\nrabbit.stop(); // white rabbit stands still. white rabbit hides!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n> 在 rabbit 的 stop 方法中，调用父类的 super.stop() 方法，所以 rabbit 也具有了父类的 stop 方法。\n\n提示\n\n** 箭头函数没有 super 。** 如果被访问，它会从外部函数获取。例如：\n\nclass rabbit extends animal {\n  stop() {\n    settimeout(() => super.stop(), 1000); // 1 秒后调用父类的 stop\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n但是对于普通的函数，这里会获取不到外部的 super ：\n\nsettimeout(function() { super.stop() }, 1000); // error\n\n\n1\n\n\n\n# 重写 constructor\n\n如果继承了父类的字类没有 constructor ，那么将生成下面这样的空 constructor ：\n\nclass rabbit extends animal {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n如果要添加 子类的 一个自定义的 constructor ，继承类的 constructor 必须调用 super(...) ，并且 一定要在使用 this 之前调用。\n\n> 在 javascript 中，继承类的构造函数与其他函数之间是有区别的。派生构造器具有特殊的内部属性 [[constructorkind]]:"derived" ，这是一个特殊的内部标签。该标签会影响它的 new 行为：\n> \n>  * 当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this 。\n>  * 但是当继承的 constructor 执行时，它不会执行此操作。它期望 父类的 constructor 来完成这项工作。\n> \n> 因此，派生的 constructor 必须调用 super 才能执行其 父类的 constructor ，否则 this 指向的那个对象将不会被创建。\n\n🌰 例子：\n\nclass animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  // ...\n}\n\nclass rabbit extends animal {\n\n  constructor(name, earlength) {\n    super(name);\n    this.earlength = earlength;\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 重写类字段\n\n🌰 例子 / 当访问 被重写的字段时：\n\nclass animal {\n  name = \'animal\';\n\n  constructor() {\n    alert(this.name); // (*)\n  }\n}\n\nclass rabbit extends animal {\n  name = \'rabbit\';\n}\n\nnew animal(); // animal\nnew rabbit(); // animal\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> rabbit 继承自 animal ，并且用它自己的值重写了 name 字段。\n> \n> 因为 rabbit 中没有自己的构造器，所以 animal 的构造器被调用了。这两种情况下，都打印了 animal 。\n> \n> 换句话说，父类构造器总是会使用它自己字段的值，而不是被重写的那一个。\n\n当父类构造器在派生的类中被调用时，它会使用被重写的方法。但对于类字段并非如此。正如前文所述，父类构造器总是使用父类的字段。\n\n实际上，原因在于字段初始化的顺序。类字段是这样初始化的：\n\n * 对于基类（还未继承任何东西的那种），在构造函数调用前初始化。\n * 对于派生类，在 super() 后立刻初始化。\n\n上面的例子中， rabbit 是派生类，里面没有 constructor() 。正如先前所说，这相当于一个里面只有 super(...args) 的空构造器。\n\n所以， new rabbit() 调用了 super() ，因此它执行了父类构造器，并且（根据派生类规则）只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候， rabbit 还没有自己的类字段，这就是为什么 animal 类字段被使用了。\n\n> 这种字段与方法之间微妙的区别只特定于 javascript。这种行为仅在一个被重写的字段被父类构造器使用时才会显现出来。\n\n\n# 深入 内部探究 和 [[homeobject]]\n\n关于继承和 super 背后的内部机制。\n\n\n# 总结\n\n * 想要扩展一个类： class child extends parent\n   \n   * 这意味着 child.prototype.__proto__ 将是 parent.prototype ，所以方法会被继承。\n\n * 重写一个方法：\n   \n   * 可以在一个 child 方法中使用 super.method() 来调用 parent 方法\n\n * 重写一个 constructor ：\n   \n   * 在使用 this 之前，必须在 child 的 constructor 中将父 constructor 调用为 super() 。\n   * 箭头函数没有自己的 this 或 super ，它们从外部上下文获取 this 和 super。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥏 JavaScript 类的静态属性和静态方法",frontmatter:{title:"🥏 JavaScript 类的静态属性和静态方法",date:"2022-05-16T22:03:53.000Z",permalink:"/pages/e02f65/",categories:["🚶🏻 前端巩固基础","📙 JavaScript 类"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/35.%20%F0%9F%93%99%20JavaScript%20%E7%B1%BB/03.%20%F0%9F%A5%8F%20JavaScript%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/03. 🥏 JavaScript 类的静态属性和静态方法.md",key:"v-c96a83c6",path:"/pages/e02f65/",headers:[{level:2,title:"静态方法",slug:"静态方法",normalizedTitle:"静态方法",charIndex:2},{level:2,title:"静态属性",slug:"静态属性",normalizedTitle:"静态属性",charIndex:1665},{level:2,title:"继承 静态方法和属性",slug:"继承-静态方法和属性",normalizedTitle:"继承 静态方法和属性",charIndex:1878},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2781}],headersStr:"静态方法 静态属性 继承 静态方法和属性 总结",content:'# 静态方法\n\nstatc 关键字修饰的方法，可以把一个方法作为 一个整体 赋值给类。\n\n🌰 例子：\n\nclass User {\n  static staticMethod() {\n    console.log(this === User);\n  }\n}\n\nUser.staticMethod(); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 跟直接将其作为属性赋值的作用相同：\n> \n> class User { }\n> User.staticMethod = function() {\n>   console.log(this === User);\n> };\n> User.staticMethod(); // true\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n上面的例子中， User.staticMethod() 调用中的 this 的值是类构造器 User 自身。\n\n通常，静态方法用于实现属于整个类，但不属于该类任何特定对象的函数。\n\n🌰 例子：\n\n例如，有对象 Article ，并且需要一个方法来 比较 它们。\n\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n  static compare(articleA, articleB) {\n    return articleA.date - articleB.date;\n  }\n}\n\nlet articles = [\n  new Article("HTML", new Date(2019, 1, 1)),\n  new Article("CSS", new Date(2019, 0, 1)),\n  new Article("JavaScript", new Date(2019, 11, 1))\n]\n\narticles.sort(Article.compare);\n\nconsole.log(articles[0].tilte) // CSS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 这里 Article.compare 方法代表上面的文章，意思是比较它们。它不是文章的方法，而是整个 class 的方法。\n\n🌰 例子 / 「工厂方法」：\n\n加入需要多种方法来创建一篇文章：\n\n * 通过用给定的参数来创建（ title ， date 等）\n * 使用今天的日期来创建一个空的文章\n * … 其他方法\n\n第一种方法可以使用 constructor 实现；第二种方法可以创建一个 静态方法 实现：\n\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n  static createTodays() {\n    // 记住 this = Article\n    return new this("Today\'s digest", new Date());\n  }\n}\n\nlet article = Article.createTodays();\nalert( article.title ); // Today\'s digest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> createTodays 不是一个文章的方法，而是整个 class 的方法。\n\n🌰 例子 / 静态方法可以用于 数据库相关 的公共类，用于搜索 / 保存 / 删除数据库中的条目：\n\n假设 Article 是一个用来管理文章的特殊类， remove 是通过 id 移除文章的方法：\n\nArticle.remove({id: 12345});\n\n\n1\n\n\n\n# 静态属性\n\n静态属性类似常规的类属性，但前面加有 static ：\n\n🌰 例子：\n\nclass Article {\n  static publisher = "Levi Ding";\n}\n\nalert( Article.publisher ); // Levi Ding\n\n\n1\n2\n3\n4\n5\n\n\n相当于给 Article 直接赋值：\n\nArticle.publisher = "Levi Ding";\n\n\n1\n\n\n\n# 继承 静态方法和属性\n\n静态属性和方法是可被继承的。\n\n🌰 例子：\n\nclass Animal {\n  static planet = "Earth";\n\n  constructor(name, speed) {\n    this.speed = speed;\n    this.name = name;\n  }\n\n  run(speed = 0) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  static compare(animalA, animalB) {\n    return animalA.speed - animalB.speed;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbits = [\n  new Rabbit("White Rabbit", 10),\n  new Rabbit("Black Rabbit", 5)\n];\n\nrabbits.sort(Rabbit.compare);\nconsole.log(rabbits) \nconsole.log(Rabbit.planet) // Earth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> 调用 Rabbit.compare 时，继承的 Animal.compare 将会被调用。\n\n实质上是利用原型继承，继承对常规方法和静态方法都有效：\n\nalert(Rabbit.__proto__ === Animal); // true\n\nalert(Rabbit.prototype.__proto__ === Animal.prototype); // true\n\n\n1\n2\n3\n\n\n\n# 总结\n\n * 静态方法被用于实现属于整个类的功能。它与具体的类实例无关。\n * 静态属性声明与直接给类本身赋值相同。\n * 静态属性和方法是可被继承的。',normalizedContent:'# 静态方法\n\nstatc 关键字修饰的方法，可以把一个方法作为 一个整体 赋值给类。\n\n🌰 例子：\n\nclass user {\n  static staticmethod() {\n    console.log(this === user);\n  }\n}\n\nuser.staticmethod(); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 跟直接将其作为属性赋值的作用相同：\n> \n> class user { }\n> user.staticmethod = function() {\n>   console.log(this === user);\n> };\n> user.staticmethod(); // true\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n上面的例子中， user.staticmethod() 调用中的 this 的值是类构造器 user 自身。\n\n通常，静态方法用于实现属于整个类，但不属于该类任何特定对象的函数。\n\n🌰 例子：\n\n例如，有对象 article ，并且需要一个方法来 比较 它们。\n\nclass article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n  static compare(articlea, articleb) {\n    return articlea.date - articleb.date;\n  }\n}\n\nlet articles = [\n  new article("html", new date(2019, 1, 1)),\n  new article("css", new date(2019, 0, 1)),\n  new article("javascript", new date(2019, 11, 1))\n]\n\narticles.sort(article.compare);\n\nconsole.log(articles[0].tilte) // css\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 这里 article.compare 方法代表上面的文章，意思是比较它们。它不是文章的方法，而是整个 class 的方法。\n\n🌰 例子 / 「工厂方法」：\n\n加入需要多种方法来创建一篇文章：\n\n * 通过用给定的参数来创建（ title ， date 等）\n * 使用今天的日期来创建一个空的文章\n * … 其他方法\n\n第一种方法可以使用 constructor 实现；第二种方法可以创建一个 静态方法 实现：\n\nclass article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n  static createtodays() {\n    // 记住 this = article\n    return new this("today\'s digest", new date());\n  }\n}\n\nlet article = article.createtodays();\nalert( article.title ); // today\'s digest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> createtodays 不是一个文章的方法，而是整个 class 的方法。\n\n🌰 例子 / 静态方法可以用于 数据库相关 的公共类，用于搜索 / 保存 / 删除数据库中的条目：\n\n假设 article 是一个用来管理文章的特殊类， remove 是通过 id 移除文章的方法：\n\narticle.remove({id: 12345});\n\n\n1\n\n\n\n# 静态属性\n\n静态属性类似常规的类属性，但前面加有 static ：\n\n🌰 例子：\n\nclass article {\n  static publisher = "levi ding";\n}\n\nalert( article.publisher ); // levi ding\n\n\n1\n2\n3\n4\n5\n\n\n相当于给 article 直接赋值：\n\narticle.publisher = "levi ding";\n\n\n1\n\n\n\n# 继承 静态方法和属性\n\n静态属性和方法是可被继承的。\n\n🌰 例子：\n\nclass animal {\n  static planet = "earth";\n\n  constructor(name, speed) {\n    this.speed = speed;\n    this.name = name;\n  }\n\n  run(speed = 0) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  static compare(animala, animalb) {\n    return animala.speed - animalb.speed;\n  }\n\n}\n\nclass rabbit extends animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbits = [\n  new rabbit("white rabbit", 10),\n  new rabbit("black rabbit", 5)\n];\n\nrabbits.sort(rabbit.compare);\nconsole.log(rabbits) \nconsole.log(rabbit.planet) // earth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> 调用 rabbit.compare 时，继承的 animal.compare 将会被调用。\n\n实质上是利用原型继承，继承对常规方法和静态方法都有效：\n\nalert(rabbit.__proto__ === animal); // true\n\nalert(rabbit.prototype.__proto__ === animal.prototype); // true\n\n\n1\n2\n3\n\n\n\n# 总结\n\n * 静态方法被用于实现属于整个类的功能。它与具体的类实例无关。\n * 静态属性声明与直接给类本身赋值相同。\n * 静态属性和方法是可被继承的。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🪀 JavaScript 类的私有和受保护的属性和方法",frontmatter:{title:"🪀 JavaScript 类的私有和受保护的属性和方法",date:"2022-05-26T17:38:58.000Z",permalink:"/pages/9fa26b/",categories:["🚶🏻 前端巩固基础","📙 JavaScript 类"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/35.%20%F0%9F%93%99%20JavaScript%20%E7%B1%BB/04.%20%F0%9F%AA%80%20JavaScript%20%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%92%8C%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.html",relativePath:"101. 🚶🏻 前端巩固基础/35. 📙 JavaScript 类/04. 🪀 JavaScript 类的私有和受保护的属性和方法.md",key:"v-48513a41",path:"/pages/9fa26b/",headers:[{level:2,title:"私有属性",slug:"私有属性",normalizedTitle:"私有属性",charIndex:2306},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3709}],headersStr:"私有属性 总结",content:"一般在 面向对象编程 中，属性应该分为两组：内部接口和外部接口：\n\n * 内部接口 ：可以通过该类的其他方法访问，但不能从外部访问的方法和属性。内部接口用于对象工作，一般处理细节。\n * 外部接口 ：可以从类的外部访问的类的方法和属性。使用一个对象时只需知道它的外部接口，可能不必知道内部如何工作的细节。\n\n所以在 JavaScript 的类中，有两种类型的对象字段（属性和方法）：\n\n * 公共的属性和方法：可从任何地方访问。它们构成了外部接口。\n\n * 私有的属性和方法：只能从类的内部访问。这些用于内部接口。\n\n * 受保护的属性和方法：只能从类的内部和基于其扩展的类的内部访问。它们对于内部接口也很有用。从某种意义上讲，它们比私有的属性和方法更为广泛，通常希望继承类来访问它们。\n   \n   > 受保护的字段不是在语言级别的 Javascript 中实现的。它们是在 Javascript 中模拟的类定义语法。\n\n🌰 咖啡机例子：\n\n * 咖啡机类：\n   \n   class CoffeeMachine {\n     waterAmount = 0;\n   \n     constructor(power) {\n       this.power = power;\n       console.log( `Created a coffee-machine, power: ${power}` );\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 创建实例、使用：\n   \n   // 创建咖啡机\n   let coffeeMachine = new CoffeeMachine(100);\n   \n   // 加水\n   coffeeMachine.waterAmount = 200;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 目前为止：属性 waterAmount 和 power 是公共的。可以轻松地从外部将它们获取或者设置成任何值。\n\n * 将 waterAmount 修改为受保护的属性：\n   \n   > 受保护的属性通常以下划线 _ 作为前缀。\n   \n   class CoffeeMachine {\n     _waterAmount = 0;\n   \n     set waterAmount(value) {\n       if (value < 0) {\n         value = 0;\n       }\n       this._waterAmount = value;\n     }\n   \n     get waterAmount() {\n       return this._waterAmount;\n     }\n   \n     constructor(power) {\n       this._power = power;\n     }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n * 创建实例、使用：\n   \n   // 创建咖啡机\n   let coffeeMachine = new CoffeeMachine(100);\n   \n   // 加水\n   coffeeMachine.waterAmount = -10; // _waterAmount 将变为 0，而不是 -10\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 此时因为 waterAmount 是「受保护的属性」，设值或成经过 set 方法控制。\n\n * 令 power 为只读属性：\n   \n   class CoffeeMachine {\n     // ...\n   \n     constructor(power) {\n       this._power = power;\n     }\n   \n     get power() {\n       return this._power;\n     }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   > 此时，试图修改 power 的操作都会报错，因为没有对应的 set 方法。\n\n提示\n\ngetter 和 setter 函数的用法：\n\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  setWaterAmount(value) {\n    if (value < 0) value = 0;\n    this._waterAmount = value;\n  }\n\n  getWaterAmount() {\n    return this._waterAmount;\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n函数更灵活。它们可以接受多个参数。\n\n但是 set / get 的简化方法也可用。\n\n提示\n\n因为 「受保护的属性」只是一个利用代码逻辑实现的字段，所以它是可以 被继承的。\n\n\n# 私有属性\n\n新添加的 JavaScript 特性：使用 # 开头定义 私有的属性和方法。它们只能在类的内部可以被访问。\n\n>  * 在语言级别， # 是该字段为私有的特殊标志。\n>  * 私有字段与公共字段不会发生冲突。可以同时拥有两个同名的 公共字段和私有字段。\n\n🌰 例子：\n\nclass CoffeeMachine {\n  #waterLimit = 200;\n\n  #fixWaterAmount(value) {\n    if (value < 0) return 0;\n    if (value > this.#waterLimit) return this.#waterLimit;\n  }\n\n  setWaterAmount(value) {\n    this.#waterLimit = this.#fixWaterAmount(value);\n  }\n}\n\nlet coffeeMachine = new CoffeeMachine();\n\n// 不能从类的外部访问类的私有属性和方法\ncoffeeMachine.#fixWaterAmount(123); // Error\ncoffeeMachine.#waterLimit = 1000; // Error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 使外部能访问私有属性，利用 getter 和 setter 访问器方法：\n   \n   class CoffeeMachine {\n   \n     #waterAmount = 0;\n   \n     get waterAmount() {\n       return this.#waterAmount;\n     }\n   \n     set waterAmount(value) {\n       if (value < 0) value = 0;\n       this.#waterAmount = value;\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n提示\n\n与受保护的字段不同，私有字段是语言级别的。所以私有字段并不能直接继承，只能通过访问器访问。\n\n🌰 例子：\n\nclass MegaCoffeeMachine extends CoffeeMachine {\n  method() {\n    console.log(this.#waterAmount); // Error: can only access from CoffeeMachine\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意\n\n私有字段不能通过 this[name] 方式访问。\n\n通常普通的字段可以通过 this[name] 访问：\n\nclass User {\n  ...\n  sayHi() {\n    let fieldName = \"name\";\n    console.log(`Hello, ${this[fieldName]}`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 假如有私有字段 #name ， this['#name'] 不起作用。\n\n\n# 总结\n\n * 隐藏内部接口，保护了内部的属性和方法，有效限制了来自外部的操作。可以隐藏内部的复杂实现细节，只提供给外部 方便简洁的访问方式。\n\n * 隐藏内部接口使用 受保护的字段 或者 私有字段：\n   \n   * 受保护的字段以 _ 开头。这是一个约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以 _ 开头的字段。\n   * 私有字段以 # 开头。是 JavaScript 语言级别的强制执行的。",normalizedContent:"一般在 面向对象编程 中，属性应该分为两组：内部接口和外部接口：\n\n * 内部接口 ：可以通过该类的其他方法访问，但不能从外部访问的方法和属性。内部接口用于对象工作，一般处理细节。\n * 外部接口 ：可以从类的外部访问的类的方法和属性。使用一个对象时只需知道它的外部接口，可能不必知道内部如何工作的细节。\n\n所以在 javascript 的类中，有两种类型的对象字段（属性和方法）：\n\n * 公共的属性和方法：可从任何地方访问。它们构成了外部接口。\n\n * 私有的属性和方法：只能从类的内部访问。这些用于内部接口。\n\n * 受保护的属性和方法：只能从类的内部和基于其扩展的类的内部访问。它们对于内部接口也很有用。从某种意义上讲，它们比私有的属性和方法更为广泛，通常希望继承类来访问它们。\n   \n   > 受保护的字段不是在语言级别的 javascript 中实现的。它们是在 javascript 中模拟的类定义语法。\n\n🌰 咖啡机例子：\n\n * 咖啡机类：\n   \n   class coffeemachine {\n     wateramount = 0;\n   \n     constructor(power) {\n       this.power = power;\n       console.log( `created a coffee-machine, power: ${power}` );\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 创建实例、使用：\n   \n   // 创建咖啡机\n   let coffeemachine = new coffeemachine(100);\n   \n   // 加水\n   coffeemachine.wateramount = 200;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 目前为止：属性 wateramount 和 power 是公共的。可以轻松地从外部将它们获取或者设置成任何值。\n\n * 将 wateramount 修改为受保护的属性：\n   \n   > 受保护的属性通常以下划线 _ 作为前缀。\n   \n   class coffeemachine {\n     _wateramount = 0;\n   \n     set wateramount(value) {\n       if (value < 0) {\n         value = 0;\n       }\n       this._wateramount = value;\n     }\n   \n     get wateramount() {\n       return this._wateramount;\n     }\n   \n     constructor(power) {\n       this._power = power;\n     }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n * 创建实例、使用：\n   \n   // 创建咖啡机\n   let coffeemachine = new coffeemachine(100);\n   \n   // 加水\n   coffeemachine.wateramount = -10; // _wateramount 将变为 0，而不是 -10\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 此时因为 wateramount 是「受保护的属性」，设值或成经过 set 方法控制。\n\n * 令 power 为只读属性：\n   \n   class coffeemachine {\n     // ...\n   \n     constructor(power) {\n       this._power = power;\n     }\n   \n     get power() {\n       return this._power;\n     }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   > 此时，试图修改 power 的操作都会报错，因为没有对应的 set 方法。\n\n提示\n\ngetter 和 setter 函数的用法：\n\nclass coffeemachine {\n  _wateramount = 0;\n\n  setwateramount(value) {\n    if (value < 0) value = 0;\n    this._wateramount = value;\n  }\n\n  getwateramount() {\n    return this._wateramount;\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n函数更灵活。它们可以接受多个参数。\n\n但是 set / get 的简化方法也可用。\n\n提示\n\n因为 「受保护的属性」只是一个利用代码逻辑实现的字段，所以它是可以 被继承的。\n\n\n# 私有属性\n\n新添加的 javascript 特性：使用 # 开头定义 私有的属性和方法。它们只能在类的内部可以被访问。\n\n>  * 在语言级别， # 是该字段为私有的特殊标志。\n>  * 私有字段与公共字段不会发生冲突。可以同时拥有两个同名的 公共字段和私有字段。\n\n🌰 例子：\n\nclass coffeemachine {\n  #waterlimit = 200;\n\n  #fixwateramount(value) {\n    if (value < 0) return 0;\n    if (value > this.#waterlimit) return this.#waterlimit;\n  }\n\n  setwateramount(value) {\n    this.#waterlimit = this.#fixwateramount(value);\n  }\n}\n\nlet coffeemachine = new coffeemachine();\n\n// 不能从类的外部访问类的私有属性和方法\ncoffeemachine.#fixwateramount(123); // error\ncoffeemachine.#waterlimit = 1000; // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 使外部能访问私有属性，利用 getter 和 setter 访问器方法：\n   \n   class coffeemachine {\n   \n     #wateramount = 0;\n   \n     get wateramount() {\n       return this.#wateramount;\n     }\n   \n     set wateramount(value) {\n       if (value < 0) value = 0;\n       this.#wateramount = value;\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n提示\n\n与受保护的字段不同，私有字段是语言级别的。所以私有字段并不能直接继承，只能通过访问器访问。\n\n🌰 例子：\n\nclass megacoffeemachine extends coffeemachine {\n  method() {\n    console.log(this.#wateramount); // error: can only access from coffeemachine\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意\n\n私有字段不能通过 this[name] 方式访问。\n\n通常普通的字段可以通过 this[name] 访问：\n\nclass user {\n  ...\n  sayhi() {\n    let fieldname = \"name\";\n    console.log(`hello, ${this[fieldname]}`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 假如有私有字段 #name ， this['#name'] 不起作用。\n\n\n# 总结\n\n * 隐藏内部接口，保护了内部的属性和方法，有效限制了来自外部的操作。可以隐藏内部的复杂实现细节，只提供给外部 方便简洁的访问方式。\n\n * 隐藏内部接口使用 受保护的字段 或者 私有字段：\n   \n   * 受保护的字段以 _ 开头。这是一个约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以 _ 开头的字段。\n   * 私有字段以 # 开头。是 javascript 语言级别的强制执行的。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍕 JavaScript DOM 树",frontmatter:{title:"🍕 JavaScript DOM 树",date:"2022-05-26T23:54:33.000Z",permalink:"/pages/0bac3b/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/01.%20%F0%9F%8D%95%20JavaScript%20DOM%20%E6%A0%91%20.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/01. 🍕 JavaScript DOM 树 .md",key:"v-33781e61",path:"/pages/0bac3b/",headers:[{level:2,title:"HTML DOM 树",slug:"html-dom-树",normalizedTitle:"html dom 树",charIndex:711},{level:2,title:"遍历 DOM",slug:"遍历-dom",normalizedTitle:"遍历 dom",charIndex:990},{level:3,title:"顶层树节点",slug:"顶层树节点",normalizedTitle:"顶层树节点",charIndex:1095},{level:3,title:"子节点",slug:"子节点",normalizedTitle:"子节点",charIndex:1360},{level:3,title:"父节点和兄弟节点",slug:"父节点和兄弟节点",normalizedTitle:"父节点和兄弟节点",charIndex:1960},{level:3,title:"纯元素节点导航",slug:"纯元素节点导航",normalizedTitle:"纯元素节点导航",charIndex:2446},{level:3,title:"通过特定标识获取元素",slug:"通过特定标识获取元素",normalizedTitle:"通过特定标识获取元素",charIndex:2760},{level:4,title:"getElementBy*",slug:"getelementby",normalizedTitle:"getelementby*",charIndex:2774},{level:4,title:"querySelector",slug:"queryselector",normalizedTitle:"queryselector",charIndex:3303},{level:4,title:"matches",slug:"matches",normalizedTitle:"matches",charIndex:3702},{level:4,title:"closet",slug:"closet",normalizedTitle:"closet",charIndex:4061},{level:3,title:"动态 / 静态集合",slug:"动态-静态集合",normalizedTitle:"动态 / 静态集合",charIndex:4459}],headersStr:"HTML DOM 树 遍历 DOM 顶层树节点 子节点 父节点和兄弟节点 纯元素节点导航 通过特定标识获取元素 getElementBy* querySelector matches closet 动态 / 静态集合",content:"关于 window 对象：\n\n * 是 JavaScript 代码中的 全局对象。\n * 代表 浏览器窗口。提供了 控制它的方法。\n\n关于 DOM 与 BOM：\n\n * DOM： 文档对象模型（Document Object Model），将 HTML 所有页面内容表示为可以修改的对象。 document 对象是页面的主要入口，可以利用它更改或者创建页面的内容。\n\n * BOM：浏览器对象模型（Browser Object Model），表示由浏览器（主机环境）提供的用于处理文档之外的所有内容的其他对象。\n   \n   > 🌰 例子 / 获取当前的 URL：\n   > \n   > location.href\n   > f (confirm(\"Go to Wikipedia?\")) {\n   >   location.href = \"https://wikipedia.org\"; // 将浏览器重定向到另一个 URL\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > 函数 alert/confirm/prompt 也是 BOM 的一部分：它们与文档（document）没有直接关系，但它代表了与用户通信的纯浏览器方法。\n\n关于 HTML 规范：描述 HTML 语言（例如标签）以及 BOM（浏览器对象模型）、 各种浏览器函数： setTimeout ， alert ， location 等。\n\nhttps://html.spec.whatwg.org。它采用了 DOM 规范，并使用了许多其他属性和方法对其进行了扩展。\n\n\n# HTML DOM 树\n\n * 通过 DOM 接口可以改变网页的内容、结构和样式。\n   \n   * 文档：一个页面就是一个文档，DOM 中使用 document 表示\n   \n   * 元素：页面中的所有标签都是元素，DOM 中使用 element 表示\n   \n   * 节点：网页中的所有内容都是节点（标签、属性、文本、注释等）， DOM 中使用 node 表示；\n\n * HTML 中的所有内容，甚至注释，都会成为 DOM 的一部分。\n\n * 当网页被加载时，浏览器会创建页面的 DOM。HTML DOM 会被构造为对象的树：\n   \n   \n\n\n# 遍历 DOM\n\nDOM 允许对元素和它们中的内容做任何事。首先需要 获取对应的 DOM 对象。对 DOM 的所有操作都是以 document 对象开始。它是 DOM 的主入口点。从它可以访问任何节点。\n\n\n# 顶层树节点\n\n最顶层的树节点可以直接作为 document 的属性来使用：\n\n * <html> 通过 document.documentElement 获取使用；\n * <body> 通过 document.body 获取使用；\n * <head> 通过 document.head 获取使用；\n\n> 当 元素不存在时。脚本无法访问在运行时不存在的元素。例如，在 <head> 中的脚本无法访问 document.body ，因为此时浏览器此时还无法读取 <body> 。\n> \n> 元素不存在时，获取为 null 。\n\n\n# 子节点\n\n🌰 例子：\n\n<body>\n  <div>Begin</div>\n  <ul>\n    <li>Information</li>\n  </ul>\n  <div>End</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfor(let i = 0; i < document.body.childNodes.length; i++) {\n  console.log(document.body.childNodes[i])\n}\n\n\n1\n2\n3\n\n\n> <body> 元素的子孙元素不仅包含直接的子元素 <div> 和 <ul> ，还包含像 <li> （ <ul> 的子元素）和 <b> （ <li> 的子元素）整个子树。\n\n * 子节点：对应的是 直系 的子元素。例如 <body> 是 <html> 的子节点元素。\n\n * 子孙元素：嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。\n\n * 使用 childNodes 获取所有的 子孙元素。（获取的结果是一个 类数组 集合，可以迭代，但是不能是有数组方法，要使用数组方法需要转换为数组；并且是 只读的，不能通过它 替换节点）（最好使用 for … of 迭代（使用 for…in 迭代的都是可枚举属性））\n\n * 使用 firstChild 和 lastChild 属性访问第一个和最后一个子元素。\n\n\n# 父节点和兄弟节点\n\n🌰 例子：\n\n<html>\n  <head>...</head>\n\t<body>...</body>\n</html>\n\n\n1\n2\n3\n4\n\n\nconsole.log(document.body.parentNode === document.documentElement) // true\nconsole.log(document.head.nextSibling) // HTMLBodyElement\nconsole.log(document.body.previousSibling) // HTMLHeadElement\n\n\n1\n2\n3\n\n\n在这个例子中， <head> 和 <body> 是兄弟节点，它们的父节点是 <body> 。 <body> 是 <head> 的下一个兄弟节点（右边）， <head> 是 <body> 的上一个兄弟节点（左边）。\n\n * 下一个兄弟节点在 nextSibling 属性中。\n * 上一个兄弟节点在 previousSibling 属性中。\n * 使用 parentNode 来访问父节点。\n\n\n# 纯元素节点导航\n\n要想获取 纯元素节点（代表标签和形成页面的节点），在上面的获取方法中添加 Element :\n\n * 作为元素节点的子节点： chidren ；\n * 第一个和最后一个元素子节点： firstElementChild，lastElementChild ；\n * 兄弟元素节点： previousElementSibling , nextElementSibling ；\n * 父元素节点： parentElement 。\n\n> 区分节点（Nodes） 和 Element 的使用。 parentElement 属性返回的是 元素类型 的父节点，而 parentNode 返回的是 任何类型 的父节点。\n\n\n# 通过特定标识获取元素\n\n# getElementBy*\n\n * 根据 id 获取元素 getElementById()\n   \n   🌰 例子：\n   \n   let idElem = document.getElementById('id名称');\n   \n   \n   1\n   \n   \n   > id 必须是唯一的。在文档中，只能有一个元素带有给定的 id 。\n\n * 根据标签名获取 getElementsByTagName ：\n   \n   document.getElementsByTagName('标签名');\n   \n   \n   1\n   \n\n * 根据元素的 class （类名）属性值查询一组元素节点对象：\n   \n   document.getElementsByClassName('类名')；\n   \n   \n   1\n   \n\n>  * getElements* ：返回的是一个对象的集合（伪数组），想要操作当中的元素就需要遍历 tagname[0]等 ；\n>  * getElement* ：返回的是元素对象，包括属性和方法；\n>  * 括号中的参数大小写敏感；\n>  * getElement ... 被在 document 对象上调用。\n\n# querySelector\n\n根据 CSS 选择器去页面中查询一个元素或者一组元素：如果匹配到的元素有多个，则它会返回查询到的第一个元素。\n\n * 根据指定的 选择器 返回第一个查询到的 元素对象：\n   \n   document.querySelector('选择器'); \n   \n   \n   1\n   \n\n * 根据指定的选择器返回所有 元素对象集合（伪数组）：\n   \n   document.querySelectorAll('选择器');\n   \n   \n   1\n   \n\n>  * 关于 CSS 选择器：🎮 CSS 选择器；除了常见的选择器，还支持 选择器的伪类。\n>  * querySelector... 能在 元素对象上使用，完整语法为 element.querySelectorAll(css) ，它返回 element 中与给定 CSS 选择器匹配的所有元素。\n\n# matches\n\nelement.matches 不搜索元素对象任何内容，只会检查 element 是否与给定的 CSS 选择器 匹配。它返回 true 或 false 。\n\n通常用于在遍历元素时筛选找到的元素对象。\n\n🌰 例子：\n\n<a href=\"http://example.com/file.zip\">...</a>\n<a href=\"http://ya.ru\">...</a>\n\n\n1\n2\n\n\nfor (let elem of document.body.children) {\n  if (elem.matches('a[href$=\"zip\"]')) {\n    alert(\"The archive reference: \" + elem.href );\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# closet\n\nelement.closest(css) 方法会查找在祖先中 与选择器匹配的 祖先元素， element 自身也会被搜索。\n\n🌰 例子：\n\n<div class=\"contents\">\n  <ul class=\"book\">\n    <li class=\"chapter\">Chapter 1</li>\n    <li class=\"chapter\">Chapter 2</li>\n  </ul>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\nlet chapter = document.querySelector('.chapter') // LI\n\nchapter.closet('.book') // UL\nchapter.closet('.contents') // DIV\nchapter.closet('h1') // null\n\n\n1\n2\n3\n4\n5\n\n\n\n# 动态 / 静态集合\n\n * 所有的 getElementsBy* 方法都会返回一个 实时的 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会自动更新。\n * querySelector 返回的是一个 静态的 集合。（元素对象的固定数组）\n\n🌰 例子：\n\n<div>First div</div>\n\n<script>\n  let divs = document.getElementsByTagName('div');\n  alert(divs.length); // 1\n<\/script>\n\n<div>Second div</div>\n\n<script>\n  alert(divs.length); // 2\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n<div>First div</div>\n\n<script>\n  let divs = document.querySelectorAll('div');\n  alert(divs.length); // 1\n<\/script>\n\n<div>Second div</div>\n\n<script>\n  alert(divs.length); // 1\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"关于 window 对象：\n\n * 是 javascript 代码中的 全局对象。\n * 代表 浏览器窗口。提供了 控制它的方法。\n\n关于 dom 与 bom：\n\n * dom： 文档对象模型（document object model），将 html 所有页面内容表示为可以修改的对象。 document 对象是页面的主要入口，可以利用它更改或者创建页面的内容。\n\n * bom：浏览器对象模型（browser object model），表示由浏览器（主机环境）提供的用于处理文档之外的所有内容的其他对象。\n   \n   > 🌰 例子 / 获取当前的 url：\n   > \n   > location.href\n   > f (confirm(\"go to wikipedia?\")) {\n   >   location.href = \"https://wikipedia.org\"; // 将浏览器重定向到另一个 url\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > 函数 alert/confirm/prompt 也是 bom 的一部分：它们与文档（document）没有直接关系，但它代表了与用户通信的纯浏览器方法。\n\n关于 html 规范：描述 html 语言（例如标签）以及 bom（浏览器对象模型）、 各种浏览器函数： settimeout ， alert ， location 等。\n\nhttps://html.spec.whatwg.org。它采用了 dom 规范，并使用了许多其他属性和方法对其进行了扩展。\n\n\n# html dom 树\n\n * 通过 dom 接口可以改变网页的内容、结构和样式。\n   \n   * 文档：一个页面就是一个文档，dom 中使用 document 表示\n   \n   * 元素：页面中的所有标签都是元素，dom 中使用 element 表示\n   \n   * 节点：网页中的所有内容都是节点（标签、属性、文本、注释等）， dom 中使用 node 表示；\n\n * html 中的所有内容，甚至注释，都会成为 dom 的一部分。\n\n * 当网页被加载时，浏览器会创建页面的 dom。html dom 会被构造为对象的树：\n   \n   \n\n\n# 遍历 dom\n\ndom 允许对元素和它们中的内容做任何事。首先需要 获取对应的 dom 对象。对 dom 的所有操作都是以 document 对象开始。它是 dom 的主入口点。从它可以访问任何节点。\n\n\n# 顶层树节点\n\n最顶层的树节点可以直接作为 document 的属性来使用：\n\n * <html> 通过 document.documentelement 获取使用；\n * <body> 通过 document.body 获取使用；\n * <head> 通过 document.head 获取使用；\n\n> 当 元素不存在时。脚本无法访问在运行时不存在的元素。例如，在 <head> 中的脚本无法访问 document.body ，因为此时浏览器此时还无法读取 <body> 。\n> \n> 元素不存在时，获取为 null 。\n\n\n# 子节点\n\n🌰 例子：\n\n<body>\n  <div>begin</div>\n  <ul>\n    <li>information</li>\n  </ul>\n  <div>end</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfor(let i = 0; i < document.body.childnodes.length; i++) {\n  console.log(document.body.childnodes[i])\n}\n\n\n1\n2\n3\n\n\n> <body> 元素的子孙元素不仅包含直接的子元素 <div> 和 <ul> ，还包含像 <li> （ <ul> 的子元素）和 <b> （ <li> 的子元素）整个子树。\n\n * 子节点：对应的是 直系 的子元素。例如 <body> 是 <html> 的子节点元素。\n\n * 子孙元素：嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。\n\n * 使用 childnodes 获取所有的 子孙元素。（获取的结果是一个 类数组 集合，可以迭代，但是不能是有数组方法，要使用数组方法需要转换为数组；并且是 只读的，不能通过它 替换节点）（最好使用 for … of 迭代（使用 for…in 迭代的都是可枚举属性））\n\n * 使用 firstchild 和 lastchild 属性访问第一个和最后一个子元素。\n\n\n# 父节点和兄弟节点\n\n🌰 例子：\n\n<html>\n  <head>...</head>\n\t<body>...</body>\n</html>\n\n\n1\n2\n3\n4\n\n\nconsole.log(document.body.parentnode === document.documentelement) // true\nconsole.log(document.head.nextsibling) // htmlbodyelement\nconsole.log(document.body.previoussibling) // htmlheadelement\n\n\n1\n2\n3\n\n\n在这个例子中， <head> 和 <body> 是兄弟节点，它们的父节点是 <body> 。 <body> 是 <head> 的下一个兄弟节点（右边）， <head> 是 <body> 的上一个兄弟节点（左边）。\n\n * 下一个兄弟节点在 nextsibling 属性中。\n * 上一个兄弟节点在 previoussibling 属性中。\n * 使用 parentnode 来访问父节点。\n\n\n# 纯元素节点导航\n\n要想获取 纯元素节点（代表标签和形成页面的节点），在上面的获取方法中添加 element :\n\n * 作为元素节点的子节点： chidren ；\n * 第一个和最后一个元素子节点： firstelementchild，lastelementchild ；\n * 兄弟元素节点： previouselementsibling , nextelementsibling ；\n * 父元素节点： parentelement 。\n\n> 区分节点（nodes） 和 element 的使用。 parentelement 属性返回的是 元素类型 的父节点，而 parentnode 返回的是 任何类型 的父节点。\n\n\n# 通过特定标识获取元素\n\n# getelementby*\n\n * 根据 id 获取元素 getelementbyid()\n   \n   🌰 例子：\n   \n   let idelem = document.getelementbyid('id名称');\n   \n   \n   1\n   \n   \n   > id 必须是唯一的。在文档中，只能有一个元素带有给定的 id 。\n\n * 根据标签名获取 getelementsbytagname ：\n   \n   document.getelementsbytagname('标签名');\n   \n   \n   1\n   \n\n * 根据元素的 class （类名）属性值查询一组元素节点对象：\n   \n   document.getelementsbyclassname('类名')；\n   \n   \n   1\n   \n\n>  * getelements* ：返回的是一个对象的集合（伪数组），想要操作当中的元素就需要遍历 tagname[0]等 ；\n>  * getelement* ：返回的是元素对象，包括属性和方法；\n>  * 括号中的参数大小写敏感；\n>  * getelement ... 被在 document 对象上调用。\n\n# queryselector\n\n根据 css 选择器去页面中查询一个元素或者一组元素：如果匹配到的元素有多个，则它会返回查询到的第一个元素。\n\n * 根据指定的 选择器 返回第一个查询到的 元素对象：\n   \n   document.queryselector('选择器'); \n   \n   \n   1\n   \n\n * 根据指定的选择器返回所有 元素对象集合（伪数组）：\n   \n   document.queryselectorall('选择器');\n   \n   \n   1\n   \n\n>  * 关于 css 选择器：🎮 css 选择器；除了常见的选择器，还支持 选择器的伪类。\n>  * queryselector... 能在 元素对象上使用，完整语法为 element.queryselectorall(css) ，它返回 element 中与给定 css 选择器匹配的所有元素。\n\n# matches\n\nelement.matches 不搜索元素对象任何内容，只会检查 element 是否与给定的 css 选择器 匹配。它返回 true 或 false 。\n\n通常用于在遍历元素时筛选找到的元素对象。\n\n🌰 例子：\n\n<a href=\"http://example.com/file.zip\">...</a>\n<a href=\"http://ya.ru\">...</a>\n\n\n1\n2\n\n\nfor (let elem of document.body.children) {\n  if (elem.matches('a[href$=\"zip\"]')) {\n    alert(\"the archive reference: \" + elem.href );\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# closet\n\nelement.closest(css) 方法会查找在祖先中 与选择器匹配的 祖先元素， element 自身也会被搜索。\n\n🌰 例子：\n\n<div class=\"contents\">\n  <ul class=\"book\">\n    <li class=\"chapter\">chapter 1</li>\n    <li class=\"chapter\">chapter 2</li>\n  </ul>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\nlet chapter = document.queryselector('.chapter') // li\n\nchapter.closet('.book') // ul\nchapter.closet('.contents') // div\nchapter.closet('h1') // null\n\n\n1\n2\n3\n4\n5\n\n\n\n# 动态 / 静态集合\n\n * 所有的 getelementsby* 方法都会返回一个 实时的 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会自动更新。\n * queryselector 返回的是一个 静态的 集合。（元素对象的固定数组）\n\n🌰 例子：\n\n<div>first div</div>\n\n<script>\n  let divs = document.getelementsbytagname('div');\n  alert(divs.length); // 1\n<\/script>\n\n<div>second div</div>\n\n<script>\n  alert(divs.length); // 2\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n<div>first div</div>\n\n<script>\n  let divs = document.queryselectorall('div');\n  alert(divs.length); // 1\n<\/script>\n\n<div>second div</div>\n\n<script>\n  alert(divs.length); // 1\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥘 JavaScript 浏览器事件",frontmatter:{title:"🥘 JavaScript 浏览器事件",date:"2022-05-27T22:09:56.000Z",permalink:"/pages/f3541c/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/04.%20%F0%9F%A5%98%20JavaScript%20%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/04. 🥘 JavaScript 浏览器事件.md",key:"v-34aea119",path:"/pages/f3541c/",headers:[{level:2,title:"浏览器事件简介",slug:"浏览器事件简介",normalizedTitle:"浏览器事件简介",charIndex:2},{level:2,title:"事件处理",slug:"事件处理",normalizedTitle:"事件处理",charIndex:498},{level:3,title:"对于 HTML 特性",slug:"对于-html-特性",normalizedTitle:"对于 html 特性",charIndex:543},{level:3,title:"对于 DOM 属性",slug:"对于-dom-属性",normalizedTitle:"对于 dom 属性",charIndex:933},{level:3,title:"元素 this",slug:"元素-this",normalizedTitle:"元素 this",charIndex:1560},{level:3,title:"注意问题",slug:"注意问题",normalizedTitle:"注意问题",charIndex:1769},{level:3,title:"事件监听 addEventListener",slug:"事件监听-addeventlistener",normalizedTitle:"事件监听 addeventlistener",charIndex:2516},{level:2,title:"事件对象",slug:"事件对象",normalizedTitle:"事件对象",charIndex:3830},{level:2,title:"对象处理程序",slug:"对象处理程序",normalizedTitle:"对象处理程序",charIndex:4388},{level:2,title:"冒泡",slug:"冒泡",normalizedTitle:"冒泡",charIndex:5844},{level:3,title:"目标元素 event.target",slug:"目标元素-event-target",normalizedTitle:"目标元素 event.target",charIndex:6790},{level:3,title:"停止冒泡",slug:"停止冒泡",normalizedTitle:"停止冒泡",charIndex:8275},{level:2,title:"捕获",slug:"捕获",normalizedTitle:"捕获",charIndex:8112},{level:2,title:"事件委托",slug:"事件委托",normalizedTitle:"事件委托",charIndex:10937},{level:3,title:"事件委托给 标记的行为",slug:"事件委托给-标记的行为",normalizedTitle:"事件委托给 标记的行为",charIndex:15076},{level:3,title:"行为模式",slug:"行为模式",normalizedTitle:"行为模式",charIndex:16224},{level:2,title:"浏览器事件默认行为",slug:"浏览器事件默认行为",normalizedTitle:"浏览器事件默认行为",charIndex:17844},{level:3,title:"阻止浏览器的默认行为",slug:"阻止浏览器的默认行为",normalizedTitle:"阻止浏览器的默认行为",charIndex:17940},{level:3,title:"passive",slug:"passive",normalizedTitle:"passive",charIndex:2846},{level:3,title:"阻止事件冒泡",slug:"阻止事件冒泡",normalizedTitle:"阻止事件冒泡",charIndex:20099},{level:2,title:"自定义事件",slug:"自定义事件",normalizedTitle:"自定义事件",charIndex:9009},{level:3,title:"事件的构造器",slug:"事件的构造器",normalizedTitle:"事件的构造器",charIndex:22011},{level:3,title:"调用自定义事件",slug:"调用自定义事件",normalizedTitle:"调用自定义事件",charIndex:22253},{level:3,title:"区分自定义事件",slug:"区分自定义事件",normalizedTitle:"区分自定义事件",charIndex:22622},{level:3,title:"自定义事件的冒泡",slug:"自定义事件的冒泡",normalizedTitle:"自定义事件的冒泡",charIndex:22766},{level:3,title:"自定义事件的类型",slug:"自定义事件的类型",normalizedTitle:"自定义事件的类型",charIndex:23300},{level:3,title:"自定义事件的事件类型",slug:"自定义事件的事件类型",normalizedTitle:"自定义事件的事件类型",charIndex:23986},{level:3,title:"自定义事件的默认行为",slug:"自定义事件的默认行为",normalizedTitle:"自定义事件的默认行为",charIndex:24586},{level:3,title:"事件的同步事件",slug:"事件的同步事件",normalizedTitle:"事件的同步事件",charIndex:25276}],headersStr:"浏览器事件简介 事件处理 对于 HTML 特性 对于 DOM 属性 元素 this 注意问题 事件监听 addEventListener 事件对象 对象处理程序 冒泡 目标元素 event.target 停止冒泡 捕获 事件委托 事件委托给 标记的行为 行为模式 浏览器事件默认行为 阻止浏览器的默认行为 passive 阻止事件冒泡 自定义事件 事件的构造器 调用自定义事件 区分自定义事件 自定义事件的冒泡 自定义事件的类型 自定义事件的事件类型 自定义事件的默认行为 事件的同步事件",content:'# 浏览器事件简介\n\nDOM 事件是在某个时刻触发的信号。\n\n常见的事件列表：\n\n * 鼠标事件：\n   \n   * click ：鼠标点击一个元素时（或者触摸屏点击元素）。\n   * contextmenu ：当鼠标右键点击一个元素时。\n   * mouseover / mouseout ： 当鼠标指针移入 / 离开一个元素时。\n   * mousedown / mouseup ：当在元素上按下 / 释放鼠标按钮时。\n   * mousemove ：当鼠标移动时。\n\n * 键盘事件：\n   \n   * keydown 和 keyup ：当按下和松开一个按键时。\n\n * 表单事件：\n   \n   * submit ：当访提交了一个 <form> 时。\n   * focus ：当访问者聚焦于一个表单元素时，例如聚焦于一个 <input> 。\n\n * 文档事件：\n   \n   * DOMContentLoaded ：当 HTML 的加载和处理均完成，DOM 被完全构建完成时。\n\n * CSS 事件：\n   \n   * transitionend ：当一个 CSS 动画完成时。\n\n\n# 事件处理\n\n要对事件响应，可以分配一个处理事件的程序：一个事件发生时运行的函数。\n\n\n# 对于 HTML 特性\n\n🌰 例子 / 点击按钮事件：\n\n<input value="Click me" onclick="alert(\'Click!\')" type="button">\n\n\n1\n\n\n🌰 例子 / 事件处理函数：\n\n<script>\n  function countRabbits() {\n    for(let i=1; i<=3; i++) {\n      alert("Rabbit number " + i);\n    }\n  }\n<\/script>\n\n<input type="button" onclick="countRabbits()" value="Count rabbits!">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n由于 HTML 中标签特性 大小写不敏感，所以事件特性命名可以随意，但是一般小写，例如 onclick 。\n\n\n# 对于 DOM 属性\n\n使用 DOM 属性 on<event> 分配事件处理程序。\n\n🌰 例子：\n\n<input id="elem" type="button" value="Click me">\n<script>\n  let elem = document.querySelector("#elem")\n  elem.onclick = function() {\n    alert(\'Thank you\');\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如果一个处理程序是通过 HTML 特性分配的，那么随后浏览器读取它，并从特性的内容创建一个新函数，并将这个函数写入 DOM 属性。\n\n注意\n\n注意 DOM 属性是大小写敏感的。\n\n初始化的顺序：\n\n🌰 例子：\n\n<input type="button" id="elem" onclick="alert(\'Before\')" value="Click me">\n<script>\n  elem.onclick = function() { // 覆盖了现有的处理程序\n    alert(\'After\'); // 只会显示此内容\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这个示例中，使用 JavaScript 添加了一个处理程序，覆盖了现有的处理程序。\n\n所以如果要溢出这个处理程序，赋值 elem.onclick = null 。\n\n\n# 元素 this\n\n处理程序中的 this 的值是对应的元素。就是处理程序所在的那个元素。\n\n🌰 例子：\n\n<button onclick="alert(this.innerHTML)">Click me</button>\n\n\n1\n\n\n::: demo[vanilla]\n\n<button onclick="alert(this.innerHTML)">Click me</button>\n\n\n1\n\n\n:::\n\n\n# 注意问题\n\n * 在脚本中，使用现存的函数作为事件的处理程序时，赋值时应该使用 函数名不带 () 的形式。\n   \n   🌰 例子：\n   \n   // 正确\n   button.onclick = sayThanks;\n   \n   // 错误\n   button.onclick = sayThanks();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 如果添加了 () ，那么就变成了 函数的调用，赋值的是 函数运行之后的结果（没有返回值则为 undefined ），并没有赋值任何的事件处理 handler 。\n\n * 在 HTML 特性中，分配事件处理程序需要加 () 。\n   \n   🌰 例子：\n   \n   <input type="button" id="button" onclick="sayThanks()">\n   \n   \n   1\n   \n   \n   > 因为给特性赋值，相当于给 属性赋值：\n   > \n   > button.onclick = function() {\n   >   sayThanks(); // <-- 特性（attribute）中的内容变到了这里\n   > };\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 所以这里需要 事件处理程序的执行。\n\n * 不要对处理程序使用 setAttribute ：\n   \n   🌰 例子：\n   \n   document.body.setAttribute(\'onclick\', function() { alert(1) }); // 无效\n   \n   \n   1\n   \n\n\n# 事件监听 addEventListener\n\n要为事件 分配多个处理程序时，使用 addEventListener 和 removeEventListener 管理处理程序。\n\n * 对元素添加处理程序：\n   \n   element.addEventListener(event, handler[, options]);\n   \n   \n   1\n   \n   * event ：事件名称。（例如 click ）\n   * handler ：处理程序。\n   * options ：附加可选对象：\n     * once ：如果为 true ，那么会在被触发后自动删除监听器。一次性事件处理。\n     * capture ：事件处理的阶段\n     * passive ：如果为 true ，那么处理程序将不会调用 preventDefault() （浏览器默认行为）。\n\n * 对元素移除处理程序：\n   \n   element.removeEventListener(event, handler[, options]);\n   \n   \n   1\n   \n   \n   > 移除的程序必须相同。所以存储在变量中。\n\n * 对元素添加多个处理程序：\n   多次调用 addEventListener :\n   \n   <input id="elem" type="button" value="Click me"/>\n   \n   <script>\n     function handler1() {\n       alert(\'Thanks!\');\n     };\n   \n     function handler2() {\n       alert(\'Thanks again!\');\n     }\n   \n     elem.onclick = () => alert("Hello");\n     elem.addEventListener("click", handler1); // Thanks!\n     elem.addEventListener("click", handler2); // Thanks again!\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 可以 同时 使用 DOM 属性和 addEventListener 来设置处理程序。通常我们只使用其中一种方式。\n\n> 对于某些事件只能使用 addEventListener 添加处理程序：\n> \n> 🌰 例子 / DOMContentLoaded 事件，该事件在文档加载完成并且 DOM 构建完成时触发。：\n> \n> document.addEventListener("DOMContentLoaded", function() {\n>   alert("DOM built");\n> });\n> \n> \n> 1\n> 2\n> 3\n\n\n# 事件对象\n\n当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序。\n\n🌰 例子 / 从 event 对象获取鼠标指针的坐标：\n\n<input type="button" value="Click me" id="elem">\n<script>\n  elem.onclick = function(event) {\n    // 显示事件类型、元素和点击的坐标\n    alert(event.type + " at " + event.currentTarget);\n    alert("Coordinates: " + event.clientX + ":" + event.clientY);\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n事件对象的一般属性：\n\n * event.type ： 事件的类型。\n * event.currentTarget ：处理事件的元素。与 this 相同，除非处理程序是一个箭头函数，或者它的 this 被绑定到了其他东西上，之后可以从 event.currentTarget 获取元素了。\n * event.clientX / event.clientY ：指针事件的指针的窗口相对坐标。\n\n\n# 对象处理程序\n\n处理事件的程序除了可以分配函数，还可以将一个 对象 分配为事件处理程序。回调用对象中的 handleEvent 方法。\n\n🌰 例子：\n\n<button id="elem">Click me</button>\n\n<script>\n  let obj = {\n    handleEvent(event) {\n      alert(event.type + " at " + event.currentTarget);\n    }\n  };\n\n  elem.addEventListener(\'click\', obj);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 / 使用一个类：\n\n<button id="elem">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      switch(event.type) {\n        case \'mousedown\':\n          elem.innerHTML = "Mouse button pressed";\n          break;\n        case \'mouseup\':\n          elem.innerHTML += "...and released.";\n          break;\n      }\n    }\n  }\n\n  let menu = new Menu();\n  elem.addEventListener(\'mousedown\', menu);\n  elem.addEventListener(\'mouseup\', menu);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n🌰 例子 / handleEvent 调用其他特定于事件的方法：\n\n<button id="elem">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      // mousedown -> onMousedown\n      let method = \'on\' + event.type[0].toUpperCase() + event.type.slice(1);\n      this[method](event);\n    }\n\n    onMousedown() {\n      elem.innerHTML = "Mouse button pressed";\n    }\n\n    onMouseup() {\n      elem.innerHTML += "...and released.";\n    }\n  }\n\n  let menu = new Menu();\n  elem.addEventListener(\'mousedown\', menu);\n  elem.addEventListener(\'mouseup\', menu);\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 将事件处理程序明确地分离了出来，这样更容易进行代码编写和后续维护。\n\n\n# 冒泡\n\n🌰 例子 / 引入：\n\n<div onclick="alert(\'The handler!\')">\n  <em>If you click on <code>EM</code>, the handler on <code>DIV</code> runs.</em>\n</div>\n\n\n1\n2\n3\n\n\n<html>\n  <div onclick="alert(\'The handler!\')">\n  <em>If you click on <code>EM</code>, the handler on <code>DIV</code> runs.</em>\n  </div>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n> 事件处理程序分配给标签 <div> 。但是点击其中嵌套的标签（ <em> 或 <code> ） 都会触发该事件处理程序。\n\n冒泡的原理（Bubbling）：当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。\n\n🌰 例子：\n\n::: demo[vanilla]\n\n<style>\n  #example * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n<html>\n  <form id="example" onclick="alert(\'form\')"> FORM\n    <div onclick="alert(\'div\')">DIV\n      <p onclick="alert(\'p\')">P</p>\n    </div>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n:::\n\n> 点击内部的 <p> 会首先运行 onclick ：\n> \n>  1. 在该 <p> 上的。\n>  2. 然后是外部 <div> 上的。\n>  3. 然后是外部 <form> 上的。\n>  4. 以此类推，直到最后的 document 对象。\n> \n> 这个过程就是冒泡。\n\n** 几乎所有事件都会冒泡。** 例外： focus 事件不会冒泡。\n\n\n# 目标元素 event.target\n\n父元素上的处理程序始终可以获取事件实际发生位置的详细信息。引发事件的那个嵌套层级最深的元素被称为目标元素 ，通过 event.target 访问。\n\nthis 与 event.target 的区别：\n\n * event.target ：引发事件的目标元素。冒泡过程不会变化。\n * this ：当前元素。随着冒泡过程，是当前正在运行的处理程序的元素。\n\n🌰 例子：\n\n<style>\n  #example2 {\n  background-color: green;\n  position: relative;\n  width: 150px;\n  height: 150px;\n  text-align: center;\n  cursor: pointer;\n}\n\n#example2 div {\n  background-color: blue;\n  position: absolute;\n  top: 25px;\n  left: 25px;\n  width: 100px;\n  height: 100px;\n}\n\n#example2 p {\n  background-color: red;\n  position: absolute;\n  top: 25px;\n  left: 25px;\n  width: 50px;\n  height: 50px;\n  line-height: 50px;\n  margin: 0;\n}\n</style>\n<html>\n  <body>\n  A click shows both <code>event.target</code> and <code>this</code> to compare:\n\n  <form id="example2">FORM\n    <div>DIV\n      <p>P</p>\n    </div>\n  </form>\n\n</body>\n</html>\n<script>\nexample2.onclick = function(event) {\n  event.target.style.backgroundColor = \'yellow\';\n\n  // chrome needs some time to paint yellow\n  setTimeout(() => {\n    alert("target = " + event.target.tagName + ", this=" + this.tagName);\n    event.target.style.backgroundColor = \'\'\n  }, 0);\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n> 这个例子中，处理程序 form.onclick ，那么它可以捕获表单内的所有点击。所以无论点击发生在哪个元素，都会冒泡到这个处理程序，所以此时：\n> \n>  * event.target ：实际被点击的元素；\n>  * this ： <form> 元素，因为处理程序在它上面运行。\n> \n> （ event.target 可以等于 this ，在点击发生在 <form> 时）\n\n\n# 停止冒泡\n\n用于停止冒泡的方法是 event.stopPropagation() 。\n\n> 事件的冒泡一旦发生，通常会一直上升到 <html> 再到 document ，甚至到达 window ，回调用路径上所有的处理程序。\n> \n> 但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。\n\n🌰 例子：\n\n<body onclick="alert(`the bubbling doesn\'t reach here`)">\n  <button onclick="event.stopPropagation()">Click me</button>\n</body>\n\n\n1\n2\n3\n\n\n<html>\n  <body onclick="alert(`the bubbling doesn\'t reach here`)">\n  <button onclick="event.stopPropagation()">Click me</button>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n> 这里的按钮的 body.onclick 事件会停止工作。\n\nevent.stopImmediatePropagation() 可以用于 停止冒泡，并且阻止当前元素上的处理程序运行，（意味着，其他处理程序不会执行）。\n\n注意\n\n非必要，不阻止。阻止冒泡后可能会出现的问题：\n\n * 当创建了一个嵌套菜单，每个子菜单各自处理对自己的元素的点击事件，并调用 stopPropagation ，以便不会触发外部菜单；当在外部要捕获窗口的 用户的点击时，阻止冒泡后，这个区域不能被捕获到。\n\n通常，没有真正的必要去阻止冒泡。如果真的要阻止冒泡，通常使用其他方法 如自定义事件；还可以数据写入一个处理程序中的 event 对象，并在另一个处理程序中读取该数据，这样就可以向父处理程序传递有关下层处理程序的信息。\n\n\n# 捕获\n\n> DOM 描述事件传播的三个阶段：\n> \n>  * 捕获阶段：事件（从 window）走进元素\n>  * 目标阶段：事件到达目标元素；\n>  * 冒泡阶段：事件从元素上开始冒泡。\n\n捕获阶段一般很少用到，所以通常看不见。\n\n为了在捕获阶段捕获事件，需要将处理程序的 capture 选项设置为 true （ addEventListener 中的选项参数）：\n\n * 为 false （默认值），则在冒泡阶段设置处理程序。\n * 为 true ，则在捕获阶段设置处理程序。\n\n> 虽然形式上有三个阶段，但实际上第二阶段没有被单独处理，捕获阶段和冒泡阶段的处理程序都在该阶段被触发。\n\n🌰 例子：\n\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form>FORM\n  <div>DIV\n    <p>P</p>\n  </div>\n</form>\n\n<script>\n  for(let elem of document.querySelectorAll(\'*\')) {\n    elem.addEventListener("click", e => alert(`Capturing: ${elem.tagName}`), true);\n    elem.addEventListener("click", e => alert(`Bubbling: ${elem.tagName}`));\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n<style>\n\t#example3 * {\n    margin: 10px;\n    border: 1px solid blue\n  }\n</style>\n<html>\n  <body>\n    <div id="example3">\n      <form>FORM\n        <div>DIV\n          <p>P</p>\n        </div>\n       </form>\n    </div>\n  </body>\n</html>\n<script>\n  for(let elem of document.querySelectorAll(\'#example3 *\')) {\n    elem.addEventListener("click", e => alert(`Capturing: ${elem.tagName}`), true);\n    elem.addEventListener("click", e => alert(`Bubbling: ${elem.tagName}`));\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n> 例子中，为文档中的 每个 元素都设置了点击处理程序，点击 <p> 时：\n> \n>  * HTML → BODY → FORM → DIV （捕获阶段第一个监听器）：\n>  * P （目标阶段，触发两次，因为设置了两个监听器：捕获和冒泡）\n>  * DIV → FORM → BODY → HTML （冒泡阶段，第二个监听器）。\n\nevent.eventPhase 可以获得事件的阶段数。但它很少被使用，因为通常是从处理程序中了解到它。\n\n提示\n\n * 要移除处理程序， removeEventListener 需要同一阶段。如果 addEventListener(..., true) ，那么应该在 removeEventListener(..., true) 中提到同一阶段，以正确删除处理程序。\n\n * 同一元素的同一阶段的监听器按其设置顺序运行。如果在同一阶段有多个事件处理程序，并通过 addEventListener 分配给了相同的元素，则它们的运行顺序与创建顺序相同：\n   \n   elem.addEventListener("click", e => alert(1)); // 会先被触发\n   elem.addEventListener("click", e => alert(2));\n   \n   \n   1\n   2\n   \n\n\n# 事件委托\n\n事件的捕获与冒泡阶段 允许了 事件的委托模式。\n\n> 思路：如果有类似的方式处理的元素，那么就不用为每一个元素都分配一个处理程序，而是要将单个处理程序放在共同的祖先。\n\n🌰 例子：\n\n<style>\n  #bagua-table th {\n  text-align: center;\n  font-weight: bold;\n}\n\n#bagua-table td {\n  width: 150px;\n  white-space: nowrap;\n  text-align: center;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 12px;\n}\n\n#bagua-table .nw {\n  background: #999;\n}\n\n#bagua-table .n {\n  background: #03f;\n  color: #fff;\n}\n\n#bagua-table .ne {\n  background: #ff6;\n}\n\n#bagua-table .w {\n  background: #ff0;\n}\n\n#bagua-table .c {\n  background: #60c;\n  color: #fff;\n}\n\n#bagua-table .e {\n  background: #09f;\n  color: #fff;\n}\n\n#bagua-table .sw {\n  background: #963;\n  color: #fff;\n}\n\n#bagua-table .s {\n  background: #f60;\n  color: #fff;\n}\n\n#bagua-table .se {\n  background: #0c3;\n  color: #fff;\n}\n\n#bagua-table .highlight {\n  background: red;\n}\n</style>\n<html>\n  <table id="bagua-table">\n    <tbody>\n      <tr>\n        <th colspan="3"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>\n      </tr>\n      <tr>\n        <td class="nw"><strong>Northwest</strong>\n          <br>Metal\n          <br>Silver\n          <br>Elders\n        </td>\n        <td class="n"><strong>North</strong>\n          <br>Water\n          <br>Blue\n          <br>Change\n        </td>\n        <td class="ne"><strong>Northeast</strong>\n          <br>Earth\n          <br>Yellow\n          <br>Direction\n        </td>\n      </tr>\n      <tr>\n        <td class="w"><strong>West</strong>\n          <br>Metal\n          <br>Gold\n          <br>Youth\n        </td>\n        <td class="c"><strong>Center</strong>\n          <br>All\n          <br>Purple\n          <br>Harmony\n        </td>\n        <td class="e"><strong>East</strong>\n          <br>Wood\n          <br>Blue\n          <br>Future\n        </td>\n      </tr>\n      <tr>\n        <td class="sw"><strong>Southwest</strong>\n          <br>Earth\n          <br>Brown\n          <br>Tranquility\n        </td>\n        <td class="s"><strong>South</strong>\n          <br>Fire\n          <br>Orange\n          <br>Fame\n        </td>\n        <td class="se highlight"><strong>Southeast</strong>\n          <br>Wood\n          <br>Green\n          <br>Romance\n        </td>\n      </tr>\n  \t</tbody>\n  </table>\n</html>\n  <script>\n    let table = document.getElementById(\'bagua-table\');\n\n    let selectedTd;\n\n    table.onclick = function(event) {\n      let target = event.target;\n\n      while (target != this) {\n        if (target.tagName == \'TD\') {\n          highlight(target);\n          return;\n        }\n        target = target.parentNode;\n      }\n    }\n\n    function highlight(node) {\n      if (selectedTd) {\n        selectedTd.classList.remove(\'highlight\');\n      }\n      selectedTd = node;\n      selectedTd.classList.add(\'highlight\');\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n\n\n\n> 要实现如上的 在点击时高亮显示该单元格。无论有多少个单元格，都可以分配处理的程序。\n\n可以在 table 元素上设置一个 捕获所有点击 的处理程序（利用事件的捕获阶段），这样不用担心表格有多少个单元格，也可以随时动态增加 / 移除 <td> 元素，点击高粱依然有效：\n\nlet selectedTd;\ntable.onclick = function(event) {\n  let target = event.target\n  if(target.tagName != \'TD\') {\n    return // 不处理没有点在td上的事件\n  }\n  highlisht(target)\n}\n\nfunction highlight(td) {\n  if (selectedTd) { // 移除现有的高亮显示，如果有的话\n    selectedTd.classList.remove(\'highlight\');\n  }\n  selectedTd = td;\n  selectedTd.classList.add(\'highlight\'); // 高亮显示新的 td\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 但由于 <td> 内部还有许多嵌套的元素标签，所以如果点击例如 <strong> 元素时， strong 元素称为 event.target ，这样也要考虑在 td 的范围内，改进为：\n> \n> table.onclick = function(event) {\n>   let td = event.target.closest(\'td\'); // (1)\n> \n>   if (!td) return; // (2)\n> \n>   if (!table.contains(td)) return; // (3)\n> \n>   highlight(td); // (4)\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> \n> \n> > 使用元素的 closet 属性，找到最近的祖先元素。\n\n\n# 事件委托给 标记的行为\n\n🌰 例子 / 如果要编写一个有 “保存”、“加载” 和 “搜索” 等按钮的菜单。并且，这里有一个具有 save 、 load 和 search 等方法的对象。\n\n要匹配它们对应到的事件，如果每次单独分配处理程序过于麻烦。可以考虑给整个菜单添加一个处理程序，并且为具有方法调用的按钮添加 data-action 特性：\n\n<button data-action="save">Click to Save</button>\n\n\n1\n\n\n完整代码：\n\n<html>\n  <div id="menu">\n    <button data-action="save">Save</button>\n    <button data-action="load">Load</button>\n    <button data-action="search">Search</button>\n    </div>\n</html>\n\n<script>\n  class Menu {\n    constructor(elem) {\n      this._elem = elem;\n      elem.onclick = this.onClick.bind(this); // (*)\n    }\n\n    save() {\n      alert(\'saving\');\n    }\n\n    load() {\n      alert(\'loading\');\n    }\n\n    search() {\n      alert(\'searching\');\n    }\n\n    onClick(event) {\n      let action = event.target.dataset.action;\n      if (action) {\n        this[action]();\n      }\n    };\n  }\n\n  new Menu(menu);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n> 注意： this.onclick.bind(this) 要绑定 Menu 对象的 this 上下文对象，否则在处理程序内部 引用的是 element 对象而不是 Menu 对象。\n\n提示\n\n使用事件委托的好处：\n\n * 不需要编写代码给每一个按钮分配单独的处理程序。只需要创建一个处理程序获取该元素的标记，以分配对应的行为；\n * 并且可以随时灵活移除 / 增加按钮。\n\n\n# 行为模式\n\n事件委托将行为以 声明的方式 添加到具有特殊特性和类的元素中。\n\n行为模式的两个部分：\n\n * 将自定义特性添加到描述其行为的元素。\n * 用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上，则执行行为。\n\n🌰 例子 / 计数器：\n\n<html>\n  Counter: <input type="button" value="1" data-counter>\n  <br>One more counter: <input type="button" value="2" data-counter>\n</html>\n<script>\n  document.addEventListener(\'click\', function(event) {\n\n    if (event.target.dataset.counter != undefined) { // 如果这个特性存在...\n      event.target.value++;\n    }\n\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n> 可以根据需要使用 data-counter 特性到相应的元素上。使用事件委托可以根据该行为特性处理事件。\n\n提示\n\n对于文档级的处理程序， 始终使用的是 addEventListener ：\n\n将事件处理程序分配给 document 对象时，应该始终使用 addEventListener ，而不是 document.on<event> ，因为后者会引起冲突：新的处理程序会覆盖旧的处理程序。\n\n对于实际项目来说。在 document 上有许多由代码的不同部分设置的处理程序，这是很正常的。\n\n🌰 例子 / 显示隐藏切换器 toggle：\n\n<html>\n  <button data-toggle-id="subscribe-mail">\n  Show the subscription form\n</button>\n\n  <form id="subscribe-mail" hidden>\n    Your mail: <input type="email">\n  </form>\n</html>\n\n<script>\n\tdocument.addEventListener(\'click\', function(event) {\n    let id = event.target.dataset.toggleId;\n    if (!id) return;\n\n    let elem = document.getElementById(id);\n\n    elem.hidden = !elem.hidden;\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n> 因为添加了对 toggleId 的行为的事件处理程序。所以现在向元素添加功能，只需要添加一个行为模式的特性 data-toggle-id ， 无需为每个这样的元素编写 JavaScript。只需要使用行为。文档级处理程序使其适用于页面的任意元素。\n\n提示\n\n事件委托的使用，通常用于为许多相似的元素添加相同的处理，但不仅限于此。\n\n好处：\n\n * 简化初始化并节省内存：无需添加许多处理程序。\n * 更少的代码：添加或移除元素时，无需添加 / 移除处理程序。\n\n局限：\n\n * 首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用 event.stopPropagation() 。\n * 其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。\n\n\n# 浏览器事件默认行为\n\n常见的默认行为：\n\n * 点击一个链接，触发导航到该 URL；\n * 点击表单的提交按钮，触发提交到服务器的行为；\n * 在文本上按下鼠标按钮并移动，选中文本；\n\n\n# 阻止浏览器的默认行为\n\n两种方法：\n\n * 使用 event 对象。有一个 event.preventDefault() 方法。\n * 使用 on<event> （而不是 addEventListener ）分配的，那返回 false 也同样有效。\n\n🌰 例子：\n\n<html>\n  <a href="/" onclick="return false">Click here</a>\n\tor\n\t<a href="/" onclick="event.preventDefault()">here</a>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n> 事件处理程序返回的值通常会被忽略。唯一的例外是从使用 on<event> 分配的处理程序中返回的 return false 。\n> \n> 在所有其他情况下， return 值都会被忽略。并且，返回 true 没有意义。\n\n🌰 例子 / 处理导航菜单的默认行为：\n\n<style>\n#menu li {\n  display: inline-block;\n  margin: 0;\n}\n\n#menu > li a {\n  display: inline-block;\n  margin: 0 2px;\n  outline: none;\n  text-align: center;\n  text-decoration: none;\n  font: 14px/100% sans-serif;\n  padding: .5em 2em .55em;\n  text-shadow: 0 1px 1px rgba(0, 0, 0, .3);\n  border-radius: .5em;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, .2);\n  color: #d9eef7;\n  border: solid 1px #0076a3;\n  background: #0095cd;\n}\n\n#menu > li:hover a {\n  text-decoration: none;\n  background: #007ead;\n}\n</style>\n<html>\n    <ul id="menu" class="menu">\n      <li><a href="/html">HTML</a></li>\n      <li><a href="/javascript">JavaScript</a></li>\n      <li><a href="/css">CSS</a></li>\n  \t</ul>\n</html>\n<script>\n  let menu = document.querySelector("#menu")\n\tmenu.onclick = function(event) {\n    if(event.target.nodeName != \'A\') return;\n    \n    let href = event.target.getAttribute(\'href\')\n    alert(href);\n    \n    return false; \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n<script>\n  let menu = document.querySelector("#menu")\n\tmenu.onclick = function(event) {\n    if(event.target.nodeName != \'A\') return;\n    \n    let href = event.target.getAttribute(\'href\')\n    alert(href);\n    \n    return false; \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# passive\n\naddEventListener 的可选项 passive: true 向浏览器发出信号，表明处理程序将不会调用 preventDefault() 。\n\n> 移动设备上会发生一些事件，例如 touchmove （当用户在屏幕上移动手指时），默认情况下会导致滚动，但是可以使用处理程序的 preventDefault() 来阻止滚动。\n> \n> 因此，当浏览器检测到此类事件时，它必须首先处理所有处理程序，然后如果没有任何地方调用 preventDefault ，则页面可以继续滚动。但这可能会导致 UI 中不必要的延迟和 “抖动”。\n> \n> passive: true 选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。\n> \n> 某些浏览器默认情况下， touchstart 和 touchmove 事件的 passive 为 true 。\n\n\n# 阻止事件冒泡\n\n可以使用 event.defaultPrevented 来代替 event.stopPropagation() ，来通知其他事件处理程序，该事件已经被处理。\n\n🌰 例子：\n\n默认情况下，浏览器在 contextmenu 事件（单击鼠标右键）时，显示带有标准选项的上下文菜单。可以阻止它并显示我们自定义的菜单：\n\n<html>\n  <button>Right-click shows browser context menu</button>\n\n<button oncontextmenu="alert(\'Draw our menu\'); return false">\n  Right-click shows our context menu\n</button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n除了对于特定的元素，还可以实现文档范围内的：\n\n<p>Right-click here for the document context menu</p>\n\n<button id="elem">Right-click here for the button context menu</button>\n\n  <script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert("Button context menu");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert("Document context menu");\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 这个例子中，点击 elem 时，会得到两个菜单：按钮级和文档级（事件冒泡）的菜单。\n> \n> 解决方案，阻止事件冒泡：\n> \n> <script>\n>   elem.oncontextmenu = function(event) {\n>     event.preventDefault();\n>     event.stopPropagation();\n>     alert("Button context menu");\n>   };\n> \n>   document.oncontextmenu = function(event) {\n>     event.preventDefault();\n>     alert("Document context menu");\n>   };\n> <\/script>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 但是阻止事件冒泡存在代价，现在 右键点击信息 相关的事件，都是被取消的。\n\n采用另一个解决方案，检查是否已经被阻止了默认行为即可，如果已经阻止就不用处理：\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert("Button context menu");\n  };\n\n  document.oncontextmenu = function(event) {\n    if (event.defaultPrevented) return;\n\n    event.preventDefault();\n    alert("Document context menu");\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 现在，如果有嵌套的元素，并且每个元素都有自己的上下文菜单，那么这也是可以运行的。只需确保检查每个 contextmenu 处理程序中的 event.defaultPrevented 。\n\n\n# 自定义事件\n\n自定义事件可用于创建图形组件。例如，基于 JavaScript 的菜单的根元素可能会触发 open （打开菜单）， select （有一项被选中）等事件来告诉菜单发生了什么。另一个代码可能会监听事件，并观察菜单发生了什么。\n\n不仅可以出于自身目的而创建的全新事件，还可以生成例如 click 和 mousedown 等内建事件。这可能会有助于自动化测试。\n\n\n# 事件的构造器\n\nlet evnet = new Event(type[, options])\n\n\n1\n\n\n * type ：事件类型；\n\n * options ：两个可选属性对象配置：\n   \n   * bubbles: true/false ：如果为 true ，那么事件会冒泡。\n   * cancelable: true/false ：如果为 true ，那么默认行为就会被阻止。\n   \n   默认情况下，两个配置都为 false ，即事件不冒泡并且不阻止默认行为。\n\n\n# 调用自定义事件\n\n使用 elem.dispatchEvent(event) 调用在元素上运行 event 。然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。\n\n🌰 例子：\n\n<button id="elem" onclick="alert(\'Click!\');">Autoclick</button>\n\n<script>\n  let elem = document.querySelector("#elem")\n  let event = new Event("click");\n  elem.dispatchEvent(event);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这个例子中， click 事件是用 JavaScript 初始化创建的。处理程序工作方式和点击按钮的方式相同。\n\n\n# 区分自定义事件\n\n使用 event.isTrusted 区分真实用户事件和 通过脚本生成的自定义事件：\n\n * 对于来自真实用户操作的事件， event.isTrusted 属性为 true ；\n * 对于脚本生成的事件， event.isTrusted 属性为 false 。\n\n\n# 自定义事件的冒泡\n\n🌰 例子 / 创建一个自定义的冒泡事件，并在 document 上捕获：\n\n<h1 id="elem">\n  Hello from the script\n</h1>\n\n<script>\n  // 在 document 捕获 hello 事件\n\tdocument.addEventListener("hello", function(event) {\n    alert("Hello from" + event.target.tagName)\n  })\n  \n  let event = new Event("hello", {bubbls: true});\n  elem.dispatch(event)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n>  * 应该对自定义事件使用 addEventListener ，因为 on<event> 仅存在于内建事件中， document.onhello 则无法运行。\n>  * 必须设置 bubbles:true ，否则事件不会向上冒泡。\n\n内建事件（ click ）和自定义事件（ hello ）的冒泡机制相同。自定义事件也有捕获阶段和冒泡阶段。\n\n\n# 自定义事件的类型\n\n通常的 UI 事件类有：\n\n * UIEvent\n * FocusEvent\n * MouseEvent\n * WheelEvent\n * KeyboardEvent\n * …\n\n> 相关的 UI 事件规定 https://www.w3.org/TR/uievents\n\n要创建这样类型的事件，使用它们而不是 new Event ，正确的构造器允许为该类型的事件指定标准属性。\n\n🌰 例子：\n\nlet event = new MouseEvent("click", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\nalert(event.clientX);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于通用的 Event 构造器，不允许这样：\n\nlet event = new Event("click", {\n  bubbles: true, // 构造器 Event 中只有 bubbles 和 cancelable 可以工作\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\nalert(event.clientX); // undefined，未知的属性被忽略了！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 技术上，可以通过在创建后直接分配 event.clientX=100 来解决这个问题。所以，这是一个方便和遵守规则的问题。浏览器生成的事件始终具有正确的类型。\n\n\n# 自定义事件的事件类型\n\n要全新自定义事件类型，使用 new CustomEvent 。\n\n> 从技术上讲，CustomEvent 和 Event 一样。除了一点不同。在第二个参数（对象）中，可以为想要与事件一起传递的 任何自定义信息添加一个附加的属性 detail 。\n\n> 事件类描述了它是「什么类型的事件」，如果事件是自定义的，那么应该使用 CustomEvent 来明确它是什么。\n\n🌰 例子：\n\n<h1 id="elem">Hello for John!</h1>\n\n<script>\n  // 事件附带给处理程序的其他详细信息\n  elem.addEventListener("hello", function(event) {\n    alert(event.detail.name);\n  });\n\n  elem.dispatchEvent(new CustomEvent("hello", {\n    detail: { name: "John" }\n  }));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> detail 属性可以有任何数据。\n> \n>  * 通常在创建后将任何属性分配给常规的 new Event 对象中。\n>  * 但是 CustomEvent 提供了特殊的 detail 字段，以避免与其他事件属性的冲突。\n\n\n# 自定义事件的默认行为\n\n对于新的自定义的事件，绝对没有默认的浏览器行为，但是分派此类事件的代码可能有自己的计划，触发该事件之后应该做什么。\n\n🌰 例子 /\n\n<pre id="rabbit">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_Y_/=\n   {>o<}\n</pre>\n<button onclick="hide()">Hide()</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<script>\n\tfunction hide() {\n    let event = new CustomEvent("hide", {\n      cancelable: true // 没有这个标志，preventDefault 将不起作用\n    });\n    if (!rabbit.dispatchEvent(event)) {\n      alert(\'The action was prevented by a handler\');\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addEventListener(\'hide\', function(event) {\n    if (confirm("Call preventDefault?")) {\n      event.preventDefault();\n    }\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 事件的同步事件\n\n通常事件是在队列中处理的。也就是说：如果浏览器正在处理 onclick ，这时发生了一个新的事件，例如鼠标移动了，那么它的处理程序会被排入队列，相应的 mousemove 处理程序将在 onclick 事件处理完成后被调用。\n\n例外：当一个事件是在另一个事件中发起的。例如使用 dispatchEvent 。这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序。\n\n🌰 例子 / menu-open 事件是在 onclick 事件执行过程中被调用的。它会被立即执行，而不必等待 onclick 处理程序结束：\n\n<button id="menu">Menu (click me)</button>\n<script>\n  menu.onclick = function() {\n    alert(1);\n\n    menu.dispatchEvent(new CustomEvent("menu-open", {\n      bubbles: true\n    }));\n\n    alert(2);\n  };\n\n  // 在 1 和 2 之间触发\n  document.addEventListener(\'menu-open\', () => alert(\'nested\'));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 嵌套事件 menu-open 会在 document 上被捕获。嵌套事件的传播和处理先被完成，然后处理过程才会返回到外部代码（ onclick ）。\n> \n> 这不只是与 dispatchEvent 有关，还有其他情况。如果一个事件处理程序调用了触发其他事件的方法 —— 它们同样也会被以嵌套的方式同步处理。\n> \n> 如果想让 onclick 不受 menu-open 或者其它嵌套事件的影响，优先被处理完毕。那么可以将 dispatchEvent （或另一个触发事件的调用）放在 onclick 末尾，或者最好将其包装到零延迟的 setTimeout 中：\n> \n> <script>\n>   menu.onclick = function() {\n>     alert(1);\n> \n>     setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {\n>       bubbles: true\n>     })));\n> \n>     alert(2);\n>   };\n> \n>   document.addEventListener(\'menu-open\', () => alert(\'nested\'));\n> <\/script>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> \n> \n> 现在， dispatchEvent 在当前代码执行完成之后异步运行，包括 menu.onclick ，因此，事件处理程序是完全独立的。',normalizedContent:'# 浏览器事件简介\n\ndom 事件是在某个时刻触发的信号。\n\n常见的事件列表：\n\n * 鼠标事件：\n   \n   * click ：鼠标点击一个元素时（或者触摸屏点击元素）。\n   * contextmenu ：当鼠标右键点击一个元素时。\n   * mouseover / mouseout ： 当鼠标指针移入 / 离开一个元素时。\n   * mousedown / mouseup ：当在元素上按下 / 释放鼠标按钮时。\n   * mousemove ：当鼠标移动时。\n\n * 键盘事件：\n   \n   * keydown 和 keyup ：当按下和松开一个按键时。\n\n * 表单事件：\n   \n   * submit ：当访提交了一个 <form> 时。\n   * focus ：当访问者聚焦于一个表单元素时，例如聚焦于一个 <input> 。\n\n * 文档事件：\n   \n   * domcontentloaded ：当 html 的加载和处理均完成，dom 被完全构建完成时。\n\n * css 事件：\n   \n   * transitionend ：当一个 css 动画完成时。\n\n\n# 事件处理\n\n要对事件响应，可以分配一个处理事件的程序：一个事件发生时运行的函数。\n\n\n# 对于 html 特性\n\n🌰 例子 / 点击按钮事件：\n\n<input value="click me" onclick="alert(\'click!\')" type="button">\n\n\n1\n\n\n🌰 例子 / 事件处理函数：\n\n<script>\n  function countrabbits() {\n    for(let i=1; i<=3; i++) {\n      alert("rabbit number " + i);\n    }\n  }\n<\/script>\n\n<input type="button" onclick="countrabbits()" value="count rabbits!">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n由于 html 中标签特性 大小写不敏感，所以事件特性命名可以随意，但是一般小写，例如 onclick 。\n\n\n# 对于 dom 属性\n\n使用 dom 属性 on<event> 分配事件处理程序。\n\n🌰 例子：\n\n<input id="elem" type="button" value="click me">\n<script>\n  let elem = document.queryselector("#elem")\n  elem.onclick = function() {\n    alert(\'thank you\');\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如果一个处理程序是通过 html 特性分配的，那么随后浏览器读取它，并从特性的内容创建一个新函数，并将这个函数写入 dom 属性。\n\n注意\n\n注意 dom 属性是大小写敏感的。\n\n初始化的顺序：\n\n🌰 例子：\n\n<input type="button" id="elem" onclick="alert(\'before\')" value="click me">\n<script>\n  elem.onclick = function() { // 覆盖了现有的处理程序\n    alert(\'after\'); // 只会显示此内容\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这个示例中，使用 javascript 添加了一个处理程序，覆盖了现有的处理程序。\n\n所以如果要溢出这个处理程序，赋值 elem.onclick = null 。\n\n\n# 元素 this\n\n处理程序中的 this 的值是对应的元素。就是处理程序所在的那个元素。\n\n🌰 例子：\n\n<button onclick="alert(this.innerhtml)">click me</button>\n\n\n1\n\n\n::: demo[vanilla]\n\n<button onclick="alert(this.innerhtml)">click me</button>\n\n\n1\n\n\n:::\n\n\n# 注意问题\n\n * 在脚本中，使用现存的函数作为事件的处理程序时，赋值时应该使用 函数名不带 () 的形式。\n   \n   🌰 例子：\n   \n   // 正确\n   button.onclick = saythanks;\n   \n   // 错误\n   button.onclick = saythanks();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 如果添加了 () ，那么就变成了 函数的调用，赋值的是 函数运行之后的结果（没有返回值则为 undefined ），并没有赋值任何的事件处理 handler 。\n\n * 在 html 特性中，分配事件处理程序需要加 () 。\n   \n   🌰 例子：\n   \n   <input type="button" id="button" onclick="saythanks()">\n   \n   \n   1\n   \n   \n   > 因为给特性赋值，相当于给 属性赋值：\n   > \n   > button.onclick = function() {\n   >   saythanks(); // <-- 特性（attribute）中的内容变到了这里\n   > };\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 所以这里需要 事件处理程序的执行。\n\n * 不要对处理程序使用 setattribute ：\n   \n   🌰 例子：\n   \n   document.body.setattribute(\'onclick\', function() { alert(1) }); // 无效\n   \n   \n   1\n   \n\n\n# 事件监听 addeventlistener\n\n要为事件 分配多个处理程序时，使用 addeventlistener 和 removeeventlistener 管理处理程序。\n\n * 对元素添加处理程序：\n   \n   element.addeventlistener(event, handler[, options]);\n   \n   \n   1\n   \n   * event ：事件名称。（例如 click ）\n   * handler ：处理程序。\n   * options ：附加可选对象：\n     * once ：如果为 true ，那么会在被触发后自动删除监听器。一次性事件处理。\n     * capture ：事件处理的阶段\n     * passive ：如果为 true ，那么处理程序将不会调用 preventdefault() （浏览器默认行为）。\n\n * 对元素移除处理程序：\n   \n   element.removeeventlistener(event, handler[, options]);\n   \n   \n   1\n   \n   \n   > 移除的程序必须相同。所以存储在变量中。\n\n * 对元素添加多个处理程序：\n   多次调用 addeventlistener :\n   \n   <input id="elem" type="button" value="click me"/>\n   \n   <script>\n     function handler1() {\n       alert(\'thanks!\');\n     };\n   \n     function handler2() {\n       alert(\'thanks again!\');\n     }\n   \n     elem.onclick = () => alert("hello");\n     elem.addeventlistener("click", handler1); // thanks!\n     elem.addeventlistener("click", handler2); // thanks again!\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 可以 同时 使用 dom 属性和 addeventlistener 来设置处理程序。通常我们只使用其中一种方式。\n\n> 对于某些事件只能使用 addeventlistener 添加处理程序：\n> \n> 🌰 例子 / domcontentloaded 事件，该事件在文档加载完成并且 dom 构建完成时触发。：\n> \n> document.addeventlistener("domcontentloaded", function() {\n>   alert("dom built");\n> });\n> \n> \n> 1\n> 2\n> 3\n\n\n# 事件对象\n\n当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序。\n\n🌰 例子 / 从 event 对象获取鼠标指针的坐标：\n\n<input type="button" value="click me" id="elem">\n<script>\n  elem.onclick = function(event) {\n    // 显示事件类型、元素和点击的坐标\n    alert(event.type + " at " + event.currenttarget);\n    alert("coordinates: " + event.clientx + ":" + event.clienty);\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n事件对象的一般属性：\n\n * event.type ： 事件的类型。\n * event.currenttarget ：处理事件的元素。与 this 相同，除非处理程序是一个箭头函数，或者它的 this 被绑定到了其他东西上，之后可以从 event.currenttarget 获取元素了。\n * event.clientx / event.clienty ：指针事件的指针的窗口相对坐标。\n\n\n# 对象处理程序\n\n处理事件的程序除了可以分配函数，还可以将一个 对象 分配为事件处理程序。回调用对象中的 handleevent 方法。\n\n🌰 例子：\n\n<button id="elem">click me</button>\n\n<script>\n  let obj = {\n    handleevent(event) {\n      alert(event.type + " at " + event.currenttarget);\n    }\n  };\n\n  elem.addeventlistener(\'click\', obj);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 / 使用一个类：\n\n<button id="elem">click me</button>\n\n<script>\n  class menu {\n    handleevent(event) {\n      switch(event.type) {\n        case \'mousedown\':\n          elem.innerhtml = "mouse button pressed";\n          break;\n        case \'mouseup\':\n          elem.innerhtml += "...and released.";\n          break;\n      }\n    }\n  }\n\n  let menu = new menu();\n  elem.addeventlistener(\'mousedown\', menu);\n  elem.addeventlistener(\'mouseup\', menu);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n🌰 例子 / handleevent 调用其他特定于事件的方法：\n\n<button id="elem">click me</button>\n\n<script>\n  class menu {\n    handleevent(event) {\n      // mousedown -> onmousedown\n      let method = \'on\' + event.type[0].touppercase() + event.type.slice(1);\n      this[method](event);\n    }\n\n    onmousedown() {\n      elem.innerhtml = "mouse button pressed";\n    }\n\n    onmouseup() {\n      elem.innerhtml += "...and released.";\n    }\n  }\n\n  let menu = new menu();\n  elem.addeventlistener(\'mousedown\', menu);\n  elem.addeventlistener(\'mouseup\', menu);\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 将事件处理程序明确地分离了出来，这样更容易进行代码编写和后续维护。\n\n\n# 冒泡\n\n🌰 例子 / 引入：\n\n<div onclick="alert(\'the handler!\')">\n  <em>if you click on <code>em</code>, the handler on <code>div</code> runs.</em>\n</div>\n\n\n1\n2\n3\n\n\n<html>\n  <div onclick="alert(\'the handler!\')">\n  <em>if you click on <code>em</code>, the handler on <code>div</code> runs.</em>\n  </div>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n> 事件处理程序分配给标签 <div> 。但是点击其中嵌套的标签（ <em> 或 <code> ） 都会触发该事件处理程序。\n\n冒泡的原理（bubbling）：当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。\n\n🌰 例子：\n\n::: demo[vanilla]\n\n<style>\n  #example * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n<html>\n  <form id="example" onclick="alert(\'form\')"> form\n    <div onclick="alert(\'div\')">div\n      <p onclick="alert(\'p\')">p</p>\n    </div>\n  </form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n:::\n\n> 点击内部的 <p> 会首先运行 onclick ：\n> \n>  1. 在该 <p> 上的。\n>  2. 然后是外部 <div> 上的。\n>  3. 然后是外部 <form> 上的。\n>  4. 以此类推，直到最后的 document 对象。\n> \n> 这个过程就是冒泡。\n\n** 几乎所有事件都会冒泡。** 例外： focus 事件不会冒泡。\n\n\n# 目标元素 event.target\n\n父元素上的处理程序始终可以获取事件实际发生位置的详细信息。引发事件的那个嵌套层级最深的元素被称为目标元素 ，通过 event.target 访问。\n\nthis 与 event.target 的区别：\n\n * event.target ：引发事件的目标元素。冒泡过程不会变化。\n * this ：当前元素。随着冒泡过程，是当前正在运行的处理程序的元素。\n\n🌰 例子：\n\n<style>\n  #example2 {\n  background-color: green;\n  position: relative;\n  width: 150px;\n  height: 150px;\n  text-align: center;\n  cursor: pointer;\n}\n\n#example2 div {\n  background-color: blue;\n  position: absolute;\n  top: 25px;\n  left: 25px;\n  width: 100px;\n  height: 100px;\n}\n\n#example2 p {\n  background-color: red;\n  position: absolute;\n  top: 25px;\n  left: 25px;\n  width: 50px;\n  height: 50px;\n  line-height: 50px;\n  margin: 0;\n}\n</style>\n<html>\n  <body>\n  a click shows both <code>event.target</code> and <code>this</code> to compare:\n\n  <form id="example2">form\n    <div>div\n      <p>p</p>\n    </div>\n  </form>\n\n</body>\n</html>\n<script>\nexample2.onclick = function(event) {\n  event.target.style.backgroundcolor = \'yellow\';\n\n  // chrome needs some time to paint yellow\n  settimeout(() => {\n    alert("target = " + event.target.tagname + ", this=" + this.tagname);\n    event.target.style.backgroundcolor = \'\'\n  }, 0);\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n> 这个例子中，处理程序 form.onclick ，那么它可以捕获表单内的所有点击。所以无论点击发生在哪个元素，都会冒泡到这个处理程序，所以此时：\n> \n>  * event.target ：实际被点击的元素；\n>  * this ： <form> 元素，因为处理程序在它上面运行。\n> \n> （ event.target 可以等于 this ，在点击发生在 <form> 时）\n\n\n# 停止冒泡\n\n用于停止冒泡的方法是 event.stoppropagation() 。\n\n> 事件的冒泡一旦发生，通常会一直上升到 <html> 再到 document ，甚至到达 window ，回调用路径上所有的处理程序。\n> \n> 但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。\n\n🌰 例子：\n\n<body onclick="alert(`the bubbling doesn\'t reach here`)">\n  <button onclick="event.stoppropagation()">click me</button>\n</body>\n\n\n1\n2\n3\n\n\n<html>\n  <body onclick="alert(`the bubbling doesn\'t reach here`)">\n  <button onclick="event.stoppropagation()">click me</button>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n> 这里的按钮的 body.onclick 事件会停止工作。\n\nevent.stopimmediatepropagation() 可以用于 停止冒泡，并且阻止当前元素上的处理程序运行，（意味着，其他处理程序不会执行）。\n\n注意\n\n非必要，不阻止。阻止冒泡后可能会出现的问题：\n\n * 当创建了一个嵌套菜单，每个子菜单各自处理对自己的元素的点击事件，并调用 stoppropagation ，以便不会触发外部菜单；当在外部要捕获窗口的 用户的点击时，阻止冒泡后，这个区域不能被捕获到。\n\n通常，没有真正的必要去阻止冒泡。如果真的要阻止冒泡，通常使用其他方法 如自定义事件；还可以数据写入一个处理程序中的 event 对象，并在另一个处理程序中读取该数据，这样就可以向父处理程序传递有关下层处理程序的信息。\n\n\n# 捕获\n\n> dom 描述事件传播的三个阶段：\n> \n>  * 捕获阶段：事件（从 window）走进元素\n>  * 目标阶段：事件到达目标元素；\n>  * 冒泡阶段：事件从元素上开始冒泡。\n\n捕获阶段一般很少用到，所以通常看不见。\n\n为了在捕获阶段捕获事件，需要将处理程序的 capture 选项设置为 true （ addeventlistener 中的选项参数）：\n\n * 为 false （默认值），则在冒泡阶段设置处理程序。\n * 为 true ，则在捕获阶段设置处理程序。\n\n> 虽然形式上有三个阶段，但实际上第二阶段没有被单独处理，捕获阶段和冒泡阶段的处理程序都在该阶段被触发。\n\n🌰 例子：\n\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form>form\n  <div>div\n    <p>p</p>\n  </div>\n</form>\n\n<script>\n  for(let elem of document.queryselectorall(\'*\')) {\n    elem.addeventlistener("click", e => alert(`capturing: ${elem.tagname}`), true);\n    elem.addeventlistener("click", e => alert(`bubbling: ${elem.tagname}`));\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n<style>\n\t#example3 * {\n    margin: 10px;\n    border: 1px solid blue\n  }\n</style>\n<html>\n  <body>\n    <div id="example3">\n      <form>form\n        <div>div\n          <p>p</p>\n        </div>\n       </form>\n    </div>\n  </body>\n</html>\n<script>\n  for(let elem of document.queryselectorall(\'#example3 *\')) {\n    elem.addeventlistener("click", e => alert(`capturing: ${elem.tagname}`), true);\n    elem.addeventlistener("click", e => alert(`bubbling: ${elem.tagname}`));\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n> 例子中，为文档中的 每个 元素都设置了点击处理程序，点击 <p> 时：\n> \n>  * html → body → form → div （捕获阶段第一个监听器）：\n>  * p （目标阶段，触发两次，因为设置了两个监听器：捕获和冒泡）\n>  * div → form → body → html （冒泡阶段，第二个监听器）。\n\nevent.eventphase 可以获得事件的阶段数。但它很少被使用，因为通常是从处理程序中了解到它。\n\n提示\n\n * 要移除处理程序， removeeventlistener 需要同一阶段。如果 addeventlistener(..., true) ，那么应该在 removeeventlistener(..., true) 中提到同一阶段，以正确删除处理程序。\n\n * 同一元素的同一阶段的监听器按其设置顺序运行。如果在同一阶段有多个事件处理程序，并通过 addeventlistener 分配给了相同的元素，则它们的运行顺序与创建顺序相同：\n   \n   elem.addeventlistener("click", e => alert(1)); // 会先被触发\n   elem.addeventlistener("click", e => alert(2));\n   \n   \n   1\n   2\n   \n\n\n# 事件委托\n\n事件的捕获与冒泡阶段 允许了 事件的委托模式。\n\n> 思路：如果有类似的方式处理的元素，那么就不用为每一个元素都分配一个处理程序，而是要将单个处理程序放在共同的祖先。\n\n🌰 例子：\n\n<style>\n  #bagua-table th {\n  text-align: center;\n  font-weight: bold;\n}\n\n#bagua-table td {\n  width: 150px;\n  white-space: nowrap;\n  text-align: center;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 12px;\n}\n\n#bagua-table .nw {\n  background: #999;\n}\n\n#bagua-table .n {\n  background: #03f;\n  color: #fff;\n}\n\n#bagua-table .ne {\n  background: #ff6;\n}\n\n#bagua-table .w {\n  background: #ff0;\n}\n\n#bagua-table .c {\n  background: #60c;\n  color: #fff;\n}\n\n#bagua-table .e {\n  background: #09f;\n  color: #fff;\n}\n\n#bagua-table .sw {\n  background: #963;\n  color: #fff;\n}\n\n#bagua-table .s {\n  background: #f60;\n  color: #fff;\n}\n\n#bagua-table .se {\n  background: #0c3;\n  color: #fff;\n}\n\n#bagua-table .highlight {\n  background: red;\n}\n</style>\n<html>\n  <table id="bagua-table">\n    <tbody>\n      <tr>\n        <th colspan="3"><em>bagua</em> chart: direction, element, color, meaning</th>\n      </tr>\n      <tr>\n        <td class="nw"><strong>northwest</strong>\n          <br>metal\n          <br>silver\n          <br>elders\n        </td>\n        <td class="n"><strong>north</strong>\n          <br>water\n          <br>blue\n          <br>change\n        </td>\n        <td class="ne"><strong>northeast</strong>\n          <br>earth\n          <br>yellow\n          <br>direction\n        </td>\n      </tr>\n      <tr>\n        <td class="w"><strong>west</strong>\n          <br>metal\n          <br>gold\n          <br>youth\n        </td>\n        <td class="c"><strong>center</strong>\n          <br>all\n          <br>purple\n          <br>harmony\n        </td>\n        <td class="e"><strong>east</strong>\n          <br>wood\n          <br>blue\n          <br>future\n        </td>\n      </tr>\n      <tr>\n        <td class="sw"><strong>southwest</strong>\n          <br>earth\n          <br>brown\n          <br>tranquility\n        </td>\n        <td class="s"><strong>south</strong>\n          <br>fire\n          <br>orange\n          <br>fame\n        </td>\n        <td class="se highlight"><strong>southeast</strong>\n          <br>wood\n          <br>green\n          <br>romance\n        </td>\n      </tr>\n  \t</tbody>\n  </table>\n</html>\n  <script>\n    let table = document.getelementbyid(\'bagua-table\');\n\n    let selectedtd;\n\n    table.onclick = function(event) {\n      let target = event.target;\n\n      while (target != this) {\n        if (target.tagname == \'td\') {\n          highlight(target);\n          return;\n        }\n        target = target.parentnode;\n      }\n    }\n\n    function highlight(node) {\n      if (selectedtd) {\n        selectedtd.classlist.remove(\'highlight\');\n      }\n      selectedtd = node;\n      selectedtd.classlist.add(\'highlight\');\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n\n\n\n> 要实现如上的 在点击时高亮显示该单元格。无论有多少个单元格，都可以分配处理的程序。\n\n可以在 table 元素上设置一个 捕获所有点击 的处理程序（利用事件的捕获阶段），这样不用担心表格有多少个单元格，也可以随时动态增加 / 移除 <td> 元素，点击高粱依然有效：\n\nlet selectedtd;\ntable.onclick = function(event) {\n  let target = event.target\n  if(target.tagname != \'td\') {\n    return // 不处理没有点在td上的事件\n  }\n  highlisht(target)\n}\n\nfunction highlight(td) {\n  if (selectedtd) { // 移除现有的高亮显示，如果有的话\n    selectedtd.classlist.remove(\'highlight\');\n  }\n  selectedtd = td;\n  selectedtd.classlist.add(\'highlight\'); // 高亮显示新的 td\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 但由于 <td> 内部还有许多嵌套的元素标签，所以如果点击例如 <strong> 元素时， strong 元素称为 event.target ，这样也要考虑在 td 的范围内，改进为：\n> \n> table.onclick = function(event) {\n>   let td = event.target.closest(\'td\'); // (1)\n> \n>   if (!td) return; // (2)\n> \n>   if (!table.contains(td)) return; // (3)\n> \n>   highlight(td); // (4)\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> \n> \n> > 使用元素的 closet 属性，找到最近的祖先元素。\n\n\n# 事件委托给 标记的行为\n\n🌰 例子 / 如果要编写一个有 “保存”、“加载” 和 “搜索” 等按钮的菜单。并且，这里有一个具有 save 、 load 和 search 等方法的对象。\n\n要匹配它们对应到的事件，如果每次单独分配处理程序过于麻烦。可以考虑给整个菜单添加一个处理程序，并且为具有方法调用的按钮添加 data-action 特性：\n\n<button data-action="save">click to save</button>\n\n\n1\n\n\n完整代码：\n\n<html>\n  <div id="menu">\n    <button data-action="save">save</button>\n    <button data-action="load">load</button>\n    <button data-action="search">search</button>\n    </div>\n</html>\n\n<script>\n  class menu {\n    constructor(elem) {\n      this._elem = elem;\n      elem.onclick = this.onclick.bind(this); // (*)\n    }\n\n    save() {\n      alert(\'saving\');\n    }\n\n    load() {\n      alert(\'loading\');\n    }\n\n    search() {\n      alert(\'searching\');\n    }\n\n    onclick(event) {\n      let action = event.target.dataset.action;\n      if (action) {\n        this[action]();\n      }\n    };\n  }\n\n  new menu(menu);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n> 注意： this.onclick.bind(this) 要绑定 menu 对象的 this 上下文对象，否则在处理程序内部 引用的是 element 对象而不是 menu 对象。\n\n提示\n\n使用事件委托的好处：\n\n * 不需要编写代码给每一个按钮分配单独的处理程序。只需要创建一个处理程序获取该元素的标记，以分配对应的行为；\n * 并且可以随时灵活移除 / 增加按钮。\n\n\n# 行为模式\n\n事件委托将行为以 声明的方式 添加到具有特殊特性和类的元素中。\n\n行为模式的两个部分：\n\n * 将自定义特性添加到描述其行为的元素。\n * 用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上，则执行行为。\n\n🌰 例子 / 计数器：\n\n<html>\n  counter: <input type="button" value="1" data-counter>\n  <br>one more counter: <input type="button" value="2" data-counter>\n</html>\n<script>\n  document.addeventlistener(\'click\', function(event) {\n\n    if (event.target.dataset.counter != undefined) { // 如果这个特性存在...\n      event.target.value++;\n    }\n\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n> 可以根据需要使用 data-counter 特性到相应的元素上。使用事件委托可以根据该行为特性处理事件。\n\n提示\n\n对于文档级的处理程序， 始终使用的是 addeventlistener ：\n\n将事件处理程序分配给 document 对象时，应该始终使用 addeventlistener ，而不是 document.on<event> ，因为后者会引起冲突：新的处理程序会覆盖旧的处理程序。\n\n对于实际项目来说。在 document 上有许多由代码的不同部分设置的处理程序，这是很正常的。\n\n🌰 例子 / 显示隐藏切换器 toggle：\n\n<html>\n  <button data-toggle-id="subscribe-mail">\n  show the subscription form\n</button>\n\n  <form id="subscribe-mail" hidden>\n    your mail: <input type="email">\n  </form>\n</html>\n\n<script>\n\tdocument.addeventlistener(\'click\', function(event) {\n    let id = event.target.dataset.toggleid;\n    if (!id) return;\n\n    let elem = document.getelementbyid(id);\n\n    elem.hidden = !elem.hidden;\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n> 因为添加了对 toggleid 的行为的事件处理程序。所以现在向元素添加功能，只需要添加一个行为模式的特性 data-toggle-id ， 无需为每个这样的元素编写 javascript。只需要使用行为。文档级处理程序使其适用于页面的任意元素。\n\n提示\n\n事件委托的使用，通常用于为许多相似的元素添加相同的处理，但不仅限于此。\n\n好处：\n\n * 简化初始化并节省内存：无需添加许多处理程序。\n * 更少的代码：添加或移除元素时，无需添加 / 移除处理程序。\n\n局限：\n\n * 首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用 event.stoppropagation() 。\n * 其次，委托可能会增加 cpu 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。\n\n\n# 浏览器事件默认行为\n\n常见的默认行为：\n\n * 点击一个链接，触发导航到该 url；\n * 点击表单的提交按钮，触发提交到服务器的行为；\n * 在文本上按下鼠标按钮并移动，选中文本；\n\n\n# 阻止浏览器的默认行为\n\n两种方法：\n\n * 使用 event 对象。有一个 event.preventdefault() 方法。\n * 使用 on<event> （而不是 addeventlistener ）分配的，那返回 false 也同样有效。\n\n🌰 例子：\n\n<html>\n  <a href="/" onclick="return false">click here</a>\n\tor\n\t<a href="/" onclick="event.preventdefault()">here</a>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n> 事件处理程序返回的值通常会被忽略。唯一的例外是从使用 on<event> 分配的处理程序中返回的 return false 。\n> \n> 在所有其他情况下， return 值都会被忽略。并且，返回 true 没有意义。\n\n🌰 例子 / 处理导航菜单的默认行为：\n\n<style>\n#menu li {\n  display: inline-block;\n  margin: 0;\n}\n\n#menu > li a {\n  display: inline-block;\n  margin: 0 2px;\n  outline: none;\n  text-align: center;\n  text-decoration: none;\n  font: 14px/100% sans-serif;\n  padding: .5em 2em .55em;\n  text-shadow: 0 1px 1px rgba(0, 0, 0, .3);\n  border-radius: .5em;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, .2);\n  color: #d9eef7;\n  border: solid 1px #0076a3;\n  background: #0095cd;\n}\n\n#menu > li:hover a {\n  text-decoration: none;\n  background: #007ead;\n}\n</style>\n<html>\n    <ul id="menu" class="menu">\n      <li><a href="/html">html</a></li>\n      <li><a href="/javascript">javascript</a></li>\n      <li><a href="/css">css</a></li>\n  \t</ul>\n</html>\n<script>\n  let menu = document.queryselector("#menu")\n\tmenu.onclick = function(event) {\n    if(event.target.nodename != \'a\') return;\n    \n    let href = event.target.getattribute(\'href\')\n    alert(href);\n    \n    return false; \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n<script>\n  let menu = document.queryselector("#menu")\n\tmenu.onclick = function(event) {\n    if(event.target.nodename != \'a\') return;\n    \n    let href = event.target.getattribute(\'href\')\n    alert(href);\n    \n    return false; \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# passive\n\naddeventlistener 的可选项 passive: true 向浏览器发出信号，表明处理程序将不会调用 preventdefault() 。\n\n> 移动设备上会发生一些事件，例如 touchmove （当用户在屏幕上移动手指时），默认情况下会导致滚动，但是可以使用处理程序的 preventdefault() 来阻止滚动。\n> \n> 因此，当浏览器检测到此类事件时，它必须首先处理所有处理程序，然后如果没有任何地方调用 preventdefault ，则页面可以继续滚动。但这可能会导致 ui 中不必要的延迟和 “抖动”。\n> \n> passive: true 选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。\n> \n> 某些浏览器默认情况下， touchstart 和 touchmove 事件的 passive 为 true 。\n\n\n# 阻止事件冒泡\n\n可以使用 event.defaultprevented 来代替 event.stoppropagation() ，来通知其他事件处理程序，该事件已经被处理。\n\n🌰 例子：\n\n默认情况下，浏览器在 contextmenu 事件（单击鼠标右键）时，显示带有标准选项的上下文菜单。可以阻止它并显示我们自定义的菜单：\n\n<html>\n  <button>right-click shows browser context menu</button>\n\n<button oncontextmenu="alert(\'draw our menu\'); return false">\n  right-click shows our context menu\n</button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n除了对于特定的元素，还可以实现文档范围内的：\n\n<p>right-click here for the document context menu</p>\n\n<button id="elem">right-click here for the button context menu</button>\n\n  <script>\n  elem.oncontextmenu = function(event) {\n    event.preventdefault();\n    alert("button context menu");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventdefault();\n    alert("document context menu");\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 这个例子中，点击 elem 时，会得到两个菜单：按钮级和文档级（事件冒泡）的菜单。\n> \n> 解决方案，阻止事件冒泡：\n> \n> <script>\n>   elem.oncontextmenu = function(event) {\n>     event.preventdefault();\n>     event.stoppropagation();\n>     alert("button context menu");\n>   };\n> \n>   document.oncontextmenu = function(event) {\n>     event.preventdefault();\n>     alert("document context menu");\n>   };\n> <\/script>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 但是阻止事件冒泡存在代价，现在 右键点击信息 相关的事件，都是被取消的。\n\n采用另一个解决方案，检查是否已经被阻止了默认行为即可，如果已经阻止就不用处理：\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventdefault();\n    alert("button context menu");\n  };\n\n  document.oncontextmenu = function(event) {\n    if (event.defaultprevented) return;\n\n    event.preventdefault();\n    alert("document context menu");\n  };\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 现在，如果有嵌套的元素，并且每个元素都有自己的上下文菜单，那么这也是可以运行的。只需确保检查每个 contextmenu 处理程序中的 event.defaultprevented 。\n\n\n# 自定义事件\n\n自定义事件可用于创建图形组件。例如，基于 javascript 的菜单的根元素可能会触发 open （打开菜单）， select （有一项被选中）等事件来告诉菜单发生了什么。另一个代码可能会监听事件，并观察菜单发生了什么。\n\n不仅可以出于自身目的而创建的全新事件，还可以生成例如 click 和 mousedown 等内建事件。这可能会有助于自动化测试。\n\n\n# 事件的构造器\n\nlet evnet = new event(type[, options])\n\n\n1\n\n\n * type ：事件类型；\n\n * options ：两个可选属性对象配置：\n   \n   * bubbles: true/false ：如果为 true ，那么事件会冒泡。\n   * cancelable: true/false ：如果为 true ，那么默认行为就会被阻止。\n   \n   默认情况下，两个配置都为 false ，即事件不冒泡并且不阻止默认行为。\n\n\n# 调用自定义事件\n\n使用 elem.dispatchevent(event) 调用在元素上运行 event 。然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。\n\n🌰 例子：\n\n<button id="elem" onclick="alert(\'click!\');">autoclick</button>\n\n<script>\n  let elem = document.queryselector("#elem")\n  let event = new event("click");\n  elem.dispatchevent(event);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这个例子中， click 事件是用 javascript 初始化创建的。处理程序工作方式和点击按钮的方式相同。\n\n\n# 区分自定义事件\n\n使用 event.istrusted 区分真实用户事件和 通过脚本生成的自定义事件：\n\n * 对于来自真实用户操作的事件， event.istrusted 属性为 true ；\n * 对于脚本生成的事件， event.istrusted 属性为 false 。\n\n\n# 自定义事件的冒泡\n\n🌰 例子 / 创建一个自定义的冒泡事件，并在 document 上捕获：\n\n<h1 id="elem">\n  hello from the script\n</h1>\n\n<script>\n  // 在 document 捕获 hello 事件\n\tdocument.addeventlistener("hello", function(event) {\n    alert("hello from" + event.target.tagname)\n  })\n  \n  let event = new event("hello", {bubbls: true});\n  elem.dispatch(event)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n>  * 应该对自定义事件使用 addeventlistener ，因为 on<event> 仅存在于内建事件中， document.onhello 则无法运行。\n>  * 必须设置 bubbles:true ，否则事件不会向上冒泡。\n\n内建事件（ click ）和自定义事件（ hello ）的冒泡机制相同。自定义事件也有捕获阶段和冒泡阶段。\n\n\n# 自定义事件的类型\n\n通常的 ui 事件类有：\n\n * uievent\n * focusevent\n * mouseevent\n * wheelevent\n * keyboardevent\n * …\n\n> 相关的 ui 事件规定 https://www.w3.org/tr/uievents\n\n要创建这样类型的事件，使用它们而不是 new event ，正确的构造器允许为该类型的事件指定标准属性。\n\n🌰 例子：\n\nlet event = new mouseevent("click", {\n  bubbles: true,\n  cancelable: true,\n  clientx: 100,\n  clienty: 100\n});\n\nalert(event.clientx);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于通用的 event 构造器，不允许这样：\n\nlet event = new event("click", {\n  bubbles: true, // 构造器 event 中只有 bubbles 和 cancelable 可以工作\n  cancelable: true,\n  clientx: 100,\n  clienty: 100\n});\n\nalert(event.clientx); // undefined，未知的属性被忽略了！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 技术上，可以通过在创建后直接分配 event.clientx=100 来解决这个问题。所以，这是一个方便和遵守规则的问题。浏览器生成的事件始终具有正确的类型。\n\n\n# 自定义事件的事件类型\n\n要全新自定义事件类型，使用 new customevent 。\n\n> 从技术上讲，customevent 和 event 一样。除了一点不同。在第二个参数（对象）中，可以为想要与事件一起传递的 任何自定义信息添加一个附加的属性 detail 。\n\n> 事件类描述了它是「什么类型的事件」，如果事件是自定义的，那么应该使用 customevent 来明确它是什么。\n\n🌰 例子：\n\n<h1 id="elem">hello for john!</h1>\n\n<script>\n  // 事件附带给处理程序的其他详细信息\n  elem.addeventlistener("hello", function(event) {\n    alert(event.detail.name);\n  });\n\n  elem.dispatchevent(new customevent("hello", {\n    detail: { name: "john" }\n  }));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> detail 属性可以有任何数据。\n> \n>  * 通常在创建后将任何属性分配给常规的 new event 对象中。\n>  * 但是 customevent 提供了特殊的 detail 字段，以避免与其他事件属性的冲突。\n\n\n# 自定义事件的默认行为\n\n对于新的自定义的事件，绝对没有默认的浏览器行为，但是分派此类事件的代码可能有自己的计划，触发该事件之后应该做什么。\n\n🌰 例子 /\n\n<pre id="rabbit">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_y_/=\n   {>o<}\n</pre>\n<button onclick="hide()">hide()</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<script>\n\tfunction hide() {\n    let event = new customevent("hide", {\n      cancelable: true // 没有这个标志，preventdefault 将不起作用\n    });\n    if (!rabbit.dispatchevent(event)) {\n      alert(\'the action was prevented by a handler\');\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addeventlistener(\'hide\', function(event) {\n    if (confirm("call preventdefault?")) {\n      event.preventdefault();\n    }\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 事件的同步事件\n\n通常事件是在队列中处理的。也就是说：如果浏览器正在处理 onclick ，这时发生了一个新的事件，例如鼠标移动了，那么它的处理程序会被排入队列，相应的 mousemove 处理程序将在 onclick 事件处理完成后被调用。\n\n例外：当一个事件是在另一个事件中发起的。例如使用 dispatchevent 。这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序。\n\n🌰 例子 / menu-open 事件是在 onclick 事件执行过程中被调用的。它会被立即执行，而不必等待 onclick 处理程序结束：\n\n<button id="menu">menu (click me)</button>\n<script>\n  menu.onclick = function() {\n    alert(1);\n\n    menu.dispatchevent(new customevent("menu-open", {\n      bubbles: true\n    }));\n\n    alert(2);\n  };\n\n  // 在 1 和 2 之间触发\n  document.addeventlistener(\'menu-open\', () => alert(\'nested\'));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 嵌套事件 menu-open 会在 document 上被捕获。嵌套事件的传播和处理先被完成，然后处理过程才会返回到外部代码（ onclick ）。\n> \n> 这不只是与 dispatchevent 有关，还有其他情况。如果一个事件处理程序调用了触发其他事件的方法 —— 它们同样也会被以嵌套的方式同步处理。\n> \n> 如果想让 onclick 不受 menu-open 或者其它嵌套事件的影响，优先被处理完毕。那么可以将 dispatchevent （或另一个触发事件的调用）放在 onclick 末尾，或者最好将其包装到零延迟的 settimeout 中：\n> \n> <script>\n>   menu.onclick = function() {\n>     alert(1);\n> \n>     settimeout(() => menu.dispatchevent(new customevent("menu-open", {\n>       bubbles: true\n>     })));\n> \n>     alert(2);\n>   };\n> \n>   document.addeventlistener(\'menu-open\', () => alert(\'nested\'));\n> <\/script>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> \n> \n> 现在， dispatchevent 在当前代码执行完成之后异步运行，包括 menu.onclick ，因此，事件处理程序是完全独立的。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥫 JavaScript 事件使用示例",frontmatter:{title:"🥫 JavaScript 事件使用示例",date:"2022-05-28T00:04:24.000Z",permalink:"/pages/5fe7c6/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/10.%20%F0%9F%A5%AB%20JavaScript%20%E4%BA%8B%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/10. 🥫 JavaScript 事件使用示例.md",key:"v-371f7877",path:"/pages/5fe7c6/",headers:[{level:2,title:"浏览器事件",slug:"浏览器事件",normalizedTitle:"浏览器事件",charIndex:2},{level:3,title:"鼠标点击足球移动",slug:"鼠标点击足球移动",normalizedTitle:"鼠标点击足球移动",charIndex:12},{level:3,title:"折叠菜单",slug:"折叠菜单",normalizedTitle:"折叠菜单",charIndex:747},{level:3,title:"轮播图实现",slug:"轮播图实现",normalizedTitle:"轮播图实现",charIndex:856},{level:2,title:"事件委托",slug:"事件委托",normalizedTitle:"事件委托",charIndex:1170},{level:3,title:"实现关闭消息",slug:"实现关闭消息",normalizedTitle:"实现关闭消息",charIndex:1179},{level:3,title:"树形菜单",slug:"树形菜单",normalizedTitle:"树形菜单",charIndex:1273}],headersStr:"浏览器事件 鼠标点击足球移动 折叠菜单 轮播图实现 事件委托 实现关闭消息 树形菜单",content:"# 浏览器事件\n\n\n# 鼠标点击足球移动\n\n> 点击球场中任意一点，让球在球场中移动。\n> \n> 要求：\n> \n>  * 足球的中心应该恰好在 点击时鼠标指针位置的下方；\n>  * 保证足球不能越过球场边界；\n>  * 页面滚动时，布局不被破坏；添加 CSS 动画；\n>  * 代码最好适用于任何大小的球场；\n\n点击查看\n\n * 首先选择定位足球的方法，不能使用 position: fixed ，因为滚动页面会造成足球被移出球场。所以应该使用 position: absolute 使得定位真实可靠 ，同时应该使 field 自身的定位使用 position: absolute ；\n\n * 接下来需要指定正确的 left / top 偏移，应该为相对于球场的坐标。\n   \n   以 left 为例：使用 event.clientX 获取点击位置的窗口相对坐标；要获取点击位置在球场中的相对坐标，减去球场相对于窗口的 left 以及 边框的宽度。同时要使足球在点击位置的中心，需要减去足球的一半宽度，使用 clientWidth 获取；\n   \n   所以最终足球的 left 为 event.clientX -fieldCoords.left - field.clientLeft - ball.offsetWidt / 2 ；\n   \n   \n\n * 考虑边界，如果计算出的 top / left 小于 0 ，则置为 0 ；超出边界则设置为 球场的边界。\n\n * 最后设置 ball.style.left 要添加字符串单位 px 。\n\nSee the Pen click to move football by simon1uo (@simon1uo) on CodePen.\n\n\n# 折叠菜单\n\n> 创建一个在点击时，会展示更多内容的菜单。\n\n点击查看 See the Pen collapsible menu item by simon1uo (@simon1uo) on CodePen.\n\n\n# 轮播图实现\n\nSee the Pen carousel by simon1uo (@simon1uo) on CodePen. 点击查看\n * 轮播图的展示可以使用 列表和图片 实现图像带。通常这样的图像带很宽，所以使用一个固定大小的 <div> 剪切出要当前轮博展示的部分。\n * 为了使列表水平展示，需要对 li 使用 display: inline-block 。并且要消除图片之间的保留空间，对 img 使用 display: block 覆盖原生的 inline 属性。\n * 通过移动 ul 来实现轮播图的滚动。可以通过 transform: translateX() 或者修改 margin-left 。\n\n\n# 事件委托\n\n\n# 实现关闭消息\n\n> 使用一个事件监听器实现。\n\nSee the Pen message-list hide by simon1uo (@simon1uo) on CodePen.\n\n\n# 树形菜单\n\n> 创建一个点击可以 显示 / 隐藏 子节点的树形菜单：\n> \n>  * 只能有一个事件处理程序；\n>  * 对节点标题以外（在空白处）的点击不会做任何处理；\n\nSee the Pen tree menu by simon1uo (@simon1uo) on CodePen.\n>  * JavaScript 将每个树节点的标题都包装到 <span> 中。然后可以在 :hover 使用 CSS 样式，并精准处理文本上的点击事件，因为 <span> 的宽度恰好是文本的宽度；\n>  * 为 tree 的跟节点设置一个处理程序，处理 <span> 标题上的点击事件；",normalizedContent:"# 浏览器事件\n\n\n# 鼠标点击足球移动\n\n> 点击球场中任意一点，让球在球场中移动。\n> \n> 要求：\n> \n>  * 足球的中心应该恰好在 点击时鼠标指针位置的下方；\n>  * 保证足球不能越过球场边界；\n>  * 页面滚动时，布局不被破坏；添加 css 动画；\n>  * 代码最好适用于任何大小的球场；\n\n点击查看\n\n * 首先选择定位足球的方法，不能使用 position: fixed ，因为滚动页面会造成足球被移出球场。所以应该使用 position: absolute 使得定位真实可靠 ，同时应该使 field 自身的定位使用 position: absolute ；\n\n * 接下来需要指定正确的 left / top 偏移，应该为相对于球场的坐标。\n   \n   以 left 为例：使用 event.clientx 获取点击位置的窗口相对坐标；要获取点击位置在球场中的相对坐标，减去球场相对于窗口的 left 以及 边框的宽度。同时要使足球在点击位置的中心，需要减去足球的一半宽度，使用 clientwidth 获取；\n   \n   所以最终足球的 left 为 event.clientx -fieldcoords.left - field.clientleft - ball.offsetwidt / 2 ；\n   \n   \n\n * 考虑边界，如果计算出的 top / left 小于 0 ，则置为 0 ；超出边界则设置为 球场的边界。\n\n * 最后设置 ball.style.left 要添加字符串单位 px 。\n\nsee the pen click to move football by simon1uo (@simon1uo) on codepen.\n\n\n# 折叠菜单\n\n> 创建一个在点击时，会展示更多内容的菜单。\n\n点击查看 see the pen collapsible menu item by simon1uo (@simon1uo) on codepen.\n\n\n# 轮播图实现\n\nsee the pen carousel by simon1uo (@simon1uo) on codepen. 点击查看\n * 轮播图的展示可以使用 列表和图片 实现图像带。通常这样的图像带很宽，所以使用一个固定大小的 <div> 剪切出要当前轮博展示的部分。\n * 为了使列表水平展示，需要对 li 使用 display: inline-block 。并且要消除图片之间的保留空间，对 img 使用 display: block 覆盖原生的 inline 属性。\n * 通过移动 ul 来实现轮播图的滚动。可以通过 transform: translatex() 或者修改 margin-left 。\n\n\n# 事件委托\n\n\n# 实现关闭消息\n\n> 使用一个事件监听器实现。\n\nsee the pen message-list hide by simon1uo (@simon1uo) on codepen.\n\n\n# 树形菜单\n\n> 创建一个点击可以 显示 / 隐藏 子节点的树形菜单：\n> \n>  * 只能有一个事件处理程序；\n>  * 对节点标题以外（在空白处）的点击不会做任何处理；\n\nsee the pen tree menu by simon1uo (@simon1uo) on codepen.\n>  * javascript 将每个树节点的标题都包装到 <span> 中。然后可以在 :hover 使用 css 样式，并精准处理文本上的点击事件，因为 <span> 的宽度恰好是文本的宽度；\n>  * 为 tree 的跟节点设置一个处理程序，处理 <span> 标题上的点击事件；",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌲 JavaScript DOM与BOM",frontmatter:{title:"🌲 JavaScript DOM与BOM",date:"2022-05-04T08:21:50.000Z",permalink:"/pages/2a600b/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/70.%20%F0%9F%8C%B2%20JavaScript%20DOM%E4%B8%8EBOM.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/70. 🌲 JavaScript DOM与BOM.md",key:"v-7bbab4e8",path:"/pages/2a600b/",headers:[{level:2,title:"BOM",slug:"bom",normalizedTitle:"bom",charIndex:2},{level:3,title:"构成",slug:"构成",normalizedTitle:"构成",charIndex:1025},{level:3,title:"常见事件",slug:"常见事件",normalizedTitle:"常见事件",charIndex:1233}],headersStr:"BOM 构成 常见事件",content:'# BOM\n\nBOM 即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window 。\n\n其他对象：\n\nnavigator ：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器；\n\n * 一般只会使用 userAgent 来判断浏览器的信息， userAgent 是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的 userAgent ；\n   \n   alert(navigator.appName);  \n   var ua = navigator.userAgent;  \n   console.log(ua);  \n   \n   \n   1\n   2\n   3\n   \n\nlocation ：代表当前浏览器的地址栏信息，通过 location 可以获取地址栏信息，或者操作浏览器跳转页面；\n\n * 直接打印 location ，则可以获取到地址栏的信息（当前页面的完整路径）；\n\n * 如果直接将 location 属性修改为一个完整的路径或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录：\n\n  location.assgin(); // 跳转到其他的页面\n  location.reload(); // 重新加载当前页面，作用和刷新按钮一样。参数为true时，则会强制清空缓存刷新页面\n  location.replace(); // 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面。不会生成历史记录，不能使用回退按钮回退\n\n\n1\n2\n3\n\n\nHistory ：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录；由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。而且该操作只在当次访问时有效；\nScreen ：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息；\n\n与 DOM 对比：\n\nDOM                BOM\n文档对象模型             浏览器对象模型\n把「文档」当做一个「对象」来看待   把「浏览器」当做一个「对象」来看待\n顶级对象是 document     顶级对象是 window\n操作页面元素             浏览器 == 窗口交互 == 的一些对象\n有 W3C 标准规范         浏览器厂商在各自浏览器上定义的，兼容性较差\n\n\n# 构成\n\nwindow 对象是浏览器的顶级对象，有双重角色；\n\n * 是 JavaScript 访问浏览器窗口的一个接口；\n * 是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法；\n\n在调用的时候可以省略 window ，对话框属于 window 对象方法，如 alert(), prompt() 等。\n\n * window 下的一个特殊属性 window.name ；\n\n\n# 常见事件\n\n窗口加载事件\n\nwindow.onload 是窗口 (页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件、CSS 文件等）， 就调用的处理函数。\n\n * 有了 window.onload 就可以把 JavaScript 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕，再去执行处理函数；\n * window.onload 传统注册事件方式只能写一次，如果有多个，会以最后一个 window.onload 为准；\n\nwindow.onload = function() {}\n\nwindow.addEventListener("load", function() {});\n\n\n1\n2\n3\n\n\ndocument.addEventListener 没有限制使用：\n\n * DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash 等等；\n * IE9 以上才支持；\n * 如果页面的图片很多的话，从用户访问到 onload 触发可能需要较长的时间，交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。\n\ndocument.addEventListener(\'DOMContentLoaded\',function(){})\n\n\n1\n\n\n窗口大小改变事件\n\nwindow.onresize 是调整窗口大小加载事件，当触发时就调用的处理函数。\n\n * 只要窗口大小发生像素变化，就会触发这个事件；\n\n * 我们经常利用这个事件完成响应式布局。\n   \n   window.innerWidth 当前屏幕的宽度；\n\nwindow.onresize = function(){}\nwindow.addEventListener("resize",function(){});\n\n\n1\n2\n\n\n定时器 setInterval() ：将一个函数每隔一个时间执行一次；\n\n * 第一个参数时回调函数；\n * 第二个参数时调用间隔的时间，单位毫秒；\n * 返回值是一个 Number 类型的数据，定时器的唯一标识；\n * 使用 clearInterval() 关闭一个定时器：接收有效的定时器的标识，则停止对应的定时器。\n\nvar num = 1;  \nvar timer = setInterval(function() {  \n\tcount.innerHTML = num++;  \n\tif(num == 11) {  \n\t\t//关闭定时器  \n\t\tclearInterval(timer);  \n\t}\n}, 1000);  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n延迟调用 setTimeout() ：一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次；\n\nvar timer = setTimeout(function(){\nconsole.log(num++);\n},3000);\n\n// 使用clearTimeout()来关闭一个延时调用\nclearTimeout(timer);\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# bom\n\nbom 即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window 。\n\n其他对象：\n\nnavigator ：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器；\n\n * 一般只会使用 useragent 来判断浏览器的信息， useragent 是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的 useragent ；\n   \n   alert(navigator.appname);  \n   var ua = navigator.useragent;  \n   console.log(ua);  \n   \n   \n   1\n   2\n   3\n   \n\nlocation ：代表当前浏览器的地址栏信息，通过 location 可以获取地址栏信息，或者操作浏览器跳转页面；\n\n * 直接打印 location ，则可以获取到地址栏的信息（当前页面的完整路径）；\n\n * 如果直接将 location 属性修改为一个完整的路径或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录：\n\n  location.assgin(); // 跳转到其他的页面\n  location.reload(); // 重新加载当前页面，作用和刷新按钮一样。参数为true时，则会强制清空缓存刷新页面\n  location.replace(); // 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面。不会生成历史记录，不能使用回退按钮回退\n\n\n1\n2\n3\n\n\nhistory ：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录；由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。而且该操作只在当次访问时有效；\nscreen ：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息；\n\n与 dom 对比：\n\ndom                bom\n文档对象模型             浏览器对象模型\n把「文档」当做一个「对象」来看待   把「浏览器」当做一个「对象」来看待\n顶级对象是 document     顶级对象是 window\n操作页面元素             浏览器 == 窗口交互 == 的一些对象\n有 w3c 标准规范         浏览器厂商在各自浏览器上定义的，兼容性较差\n\n\n# 构成\n\nwindow 对象是浏览器的顶级对象，有双重角色；\n\n * 是 javascript 访问浏览器窗口的一个接口；\n * 是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法；\n\n在调用的时候可以省略 window ，对话框属于 window 对象方法，如 alert(), prompt() 等。\n\n * window 下的一个特殊属性 window.name ；\n\n\n# 常见事件\n\n窗口加载事件\n\nwindow.onload 是窗口 (页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件、css 文件等）， 就调用的处理函数。\n\n * 有了 window.onload 就可以把 javascript 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕，再去执行处理函数；\n * window.onload 传统注册事件方式只能写一次，如果有多个，会以最后一个 window.onload 为准；\n\nwindow.onload = function() {}\n\nwindow.addeventlistener("load", function() {});\n\n\n1\n2\n3\n\n\ndocument.addeventlistener 没有限制使用：\n\n * domcontentloaded 事件触发时，仅当 dom 加载完成，不包括样式表，图片，flash 等等；\n * ie9 以上才支持；\n * 如果页面的图片很多的话，从用户访问到 onload 触发可能需要较长的时间，交互效果就不能实现，必然影响用户的体验，此时用 domcontentloaded 事件比较合适。\n\ndocument.addeventlistener(\'domcontentloaded\',function(){})\n\n\n1\n\n\n窗口大小改变事件\n\nwindow.onresize 是调整窗口大小加载事件，当触发时就调用的处理函数。\n\n * 只要窗口大小发生像素变化，就会触发这个事件；\n\n * 我们经常利用这个事件完成响应式布局。\n   \n   window.innerwidth 当前屏幕的宽度；\n\nwindow.onresize = function(){}\nwindow.addeventlistener("resize",function(){});\n\n\n1\n2\n\n\n定时器 setinterval() ：将一个函数每隔一个时间执行一次；\n\n * 第一个参数时回调函数；\n * 第二个参数时调用间隔的时间，单位毫秒；\n * 返回值是一个 number 类型的数据，定时器的唯一标识；\n * 使用 clearinterval() 关闭一个定时器：接收有效的定时器的标识，则停止对应的定时器。\n\nvar num = 1;  \nvar timer = setinterval(function() {  \n\tcount.innerhtml = num++;  \n\tif(num == 11) {  \n\t\t//关闭定时器  \n\t\tclearinterval(timer);  \n\t}\n}, 1000);  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n延迟调用 settimeout() ：一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次；\n\nvar timer = settimeout(function(){\nconsole.log(num++);\n},3000);\n\n// 使用cleartimeout()来关闭一个延时调用\ncleartimeout(timer);\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍩 JavaScript 事件循环",frontmatter:{title:"🍩 JavaScript 事件循环",date:"2022-05-27T09:43:16.000Z",permalink:"/pages/006f30/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/30.%20%F0%9F%8D%A9%20JavaScript%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/30. 🍩 JavaScript 事件循环.md",key:"v-3e2ba5ca",path:"/pages/006f30/",headers:[{level:2,title:"事件循环",slug:"事件循环",normalizedTitle:"事件循环",charIndex:40},{level:2,title:"宏任务 / 微任务",slug:"宏任务-微任务",normalizedTitle:"宏任务 / 微任务",charIndex:920},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1856}],headersStr:"事件循环 宏任务 / 微任务 总结",content:'浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。\n\n\n# 事件循环\n\n是一个在 JavaScript 引擎 等待任务，执行任务 和 进入休眠状态等待更多任务 这几个状态之间转换的无限循环。\n\n引擎的一般算法：\n\n 1. 当有任务时：从最先进入的任务开始执行。\n 2. 休眠直到出现任务，然后转到第 1 步。\n\n设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。\n\n> 一般浏览网页就是这种形式，JavaScript 引擎大多数时候不执行任何操作，它仅在脚本 / 处理程序 / 事件激活时执行。\n> \n> 浏览器任务一般有：\n> \n>  * 当外部脚本 <script src="..."> 加载完成时，任务就是执行它；\n>  * 当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序；\n>  * 当安排的（scheduled） setTimeout 时间到达时，任务就是执行其回调等。\n\n一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，为 宏任务队列 （V8 引擎）。\n\n🌰 例子：\n\n当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件， setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列。\n\n这个队列的任务基于 「先进先出」 的原则执行。当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序，依此类推。\n\n>  * 引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。\n>  * 如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如 “页面未响应” 之类的警报，建议终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。\n\n\n# 宏任务 / 微任务\n\n微任务仅来自于代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的「幕后」，因为它是 promise 处理的另一种形式。\n\n特殊的函数 queueMicrotask(func) ，它对 func 进行排队，以在微任务队列中执行。\n\n🌰 例子：\n\nsetTimeout(() => alert("timeout"));\n\nPromise.resolve()\n  .then(() => alert("promise"));\n\nalert("code");\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 按照上面的代码，执行顺序应该为：\n> \n>  * code 显示；\n>  * promise 第二个出现。因为 then 会通过微任务队列，并在当前代码之后执行。\n>  * timeout 最后显示，因为它是一个宏任务。\n\n按照更加详细的事件循环：（首先是脚本，然后是微任务，渲染等）\n\n * 微任务 会在执行任何其他事件处理，或渲染，或执行任何其他宏任务 之前完成。（这确保了微任务之间的应用程序环境基本相同）\n * 如果想异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么可以使用 queueMicrotask 来对其进行安排。\n\n🌰 例子 / 计数进度条的实现，使用了 queueMicrotask 安排：\n\n<div id="progress"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n    // 做繁重的任务的一部分 (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e6) {\n      queueMicrotask(count);\n    }\n\n  }\n  count();\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\n * 详细的 事件循环 算法：\n   \n   * 从 宏任务 队列中出队并执行最早的任务。\n   \n   * 执行所有的微任务：\n     \n     * 当微任务队列非空时：\n       * 出队并执行最早的微任务。\n   \n   * 如果有变更，则将变更渲染出来。\n   \n   * 如果宏任务队列为空，则休眠直到出现宏任务。\n   \n   * 转到步骤 1。\n\n * 安排新的宏任务：\n   \n   * 使用零延迟的 setTimeout(f) 。\n   \n   > 它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。\n   > \n   > 此外，也被用于在事件处理程序中，将一个行为安排在事件被完全处理（冒泡完成）后。\n\n * 安排新的为任务：\n   \n   * 使用 queueMicrotask(f) ；\n   * promise 处理程序也会通过微任务队列。\n   \n   > 在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。所以，可以使用 queueMicrotask 来在保持环境状态一致的情况下，异步地执行一个函数。\n\n提示\n\nWeb Workers 的使用，当有 不应该阻塞事件循环的耗时长的繁重计算任务，这时另一个并行线程运行代码的方式：\n\n * Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。\n * Web Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。',normalizedContent:'浏览器中 javascript 的执行流程和 node.js 中的流程都是基于 事件循环 的。理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。\n\n\n# 事件循环\n\n是一个在 javascript 引擎 等待任务，执行任务 和 进入休眠状态等待更多任务 这几个状态之间转换的无限循环。\n\n引擎的一般算法：\n\n 1. 当有任务时：从最先进入的任务开始执行。\n 2. 休眠直到出现任务，然后转到第 1 步。\n\n设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 cpu 资源）。\n\n> 一般浏览网页就是这种形式，javascript 引擎大多数时候不执行任何操作，它仅在脚本 / 处理程序 / 事件激活时执行。\n> \n> 浏览器任务一般有：\n> \n>  * 当外部脚本 <script src="..."> 加载完成时，任务就是执行它；\n>  * 当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序；\n>  * 当安排的（scheduled） settimeout 时间到达时，任务就是执行其回调等。\n\n一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，为 宏任务队列 （v8 引擎）。\n\n🌰 例子：\n\n当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件， settimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列。\n\n这个队列的任务基于 「先进先出」 的原则执行。当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 settimeout 处理程序，依此类推。\n\n>  * 引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 dom 的更改。\n>  * 如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如 “页面未响应” 之类的警报，建议终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。\n\n\n# 宏任务 / 微任务\n\n微任务仅来自于代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的「幕后」，因为它是 promise 处理的另一种形式。\n\n特殊的函数 queuemicrotask(func) ，它对 func 进行排队，以在微任务队列中执行。\n\n🌰 例子：\n\nsettimeout(() => alert("timeout"));\n\npromise.resolve()\n  .then(() => alert("promise"));\n\nalert("code");\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 按照上面的代码，执行顺序应该为：\n> \n>  * code 显示；\n>  * promise 第二个出现。因为 then 会通过微任务队列，并在当前代码之后执行。\n>  * timeout 最后显示，因为它是一个宏任务。\n\n按照更加详细的事件循环：（首先是脚本，然后是微任务，渲染等）\n\n * 微任务 会在执行任何其他事件处理，或渲染，或执行任何其他宏任务 之前完成。（这确保了微任务之间的应用程序环境基本相同）\n * 如果想异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么可以使用 queuemicrotask 来对其进行安排。\n\n🌰 例子 / 计数进度条的实现，使用了 queuemicrotask 安排：\n\n<div id="progress"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n    // 做繁重的任务的一部分 (*)\n    do {\n      i++;\n      progress.innerhtml = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e6) {\n      queuemicrotask(count);\n    }\n\n  }\n  count();\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\n * 详细的 事件循环 算法：\n   \n   * 从 宏任务 队列中出队并执行最早的任务。\n   \n   * 执行所有的微任务：\n     \n     * 当微任务队列非空时：\n       * 出队并执行最早的微任务。\n   \n   * 如果有变更，则将变更渲染出来。\n   \n   * 如果宏任务队列为空，则休眠直到出现宏任务。\n   \n   * 转到步骤 1。\n\n * 安排新的宏任务：\n   \n   * 使用零延迟的 settimeout(f) 。\n   \n   > 它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。\n   > \n   > 此外，也被用于在事件处理程序中，将一个行为安排在事件被完全处理（冒泡完成）后。\n\n * 安排新的为任务：\n   \n   * 使用 queuemicrotask(f) ；\n   * promise 处理程序也会通过微任务队列。\n   \n   > 在微任务之间没有 ui 或网络事件的处理：它们一个立即接一个地执行。所以，可以使用 queuemicrotask 来在保持环境状态一致的情况下，异步地执行一个函数。\n\n提示\n\nweb workers 的使用，当有 不应该阻塞事件循环的耗时长的繁重计算任务，这时另一个并行线程运行代码的方式：\n\n * web workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。\n * web workers 没有访问 dom 的权限，因此，它们对于同时使用多个 cpu 内核的计算非常有用。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥡 JavaScript 文档和资源加载",frontmatter:{title:"🥡 JavaScript 文档和资源加载",date:"2022-05-28T14:56:06.000Z",permalink:"/pages/883723/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/80.%20%F0%9F%A5%A1%20JavaScript%20%E6%96%87%E6%A1%A3%E5%92%8C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/80. 🥡 JavaScript 文档和资源加载.md",key:"v-4c9a8daf",path:"/pages/883723/",headers:[{level:2,title:"。页面生命周期",slug:"。页面生命周期",normalizedTitle:"。页面生命周期",charIndex:2},{level:3,title:"DOMContentLoaded",slug:"domcontentloaded",normalizedTitle:"domcontentloaded",charIndex:37},{level:4,title:"脚本",slug:"脚本",normalizedTitle:"脚本",charIndex:997},{level:4,title:"样式",slug:"样式",normalizedTitle:"样式",charIndex:90},{level:4,title:"浏览器表单自动填充",slug:"浏览器表单自动填充",normalizedTitle:"浏览器表单自动填充",charIndex:2005},{level:3,title:"window.onload",slug:"window-onload",normalizedTitle:"window.onload",charIndex:2237},{level:3,title:"window.onunload",slug:"window-onunload",normalizedTitle:"window.onunload",charIndex:2698},{level:3,title:"window.onbeforeunload",slug:"window-onbeforeunload",normalizedTitle:"window.onbeforeunload",charIndex:3497},{level:3,title:"readyState",slug:"readystate",normalizedTitle:"readystate",charIndex:3599},{level:3,title:"生命周期总结",slug:"生命周期总结",normalizedTitle:"生命周期总结",charIndex:4317},{level:2,title:"脚本加载类型 / 顺序",slug:"脚本加载类型-顺序",normalizedTitle:"脚本加载类型 / 顺序",charIndex:4992},{level:3,title:"defer",slug:"defer",normalizedTitle:"defer",charIndex:5396},{level:3,title:"async",slug:"async",normalizedTitle:"async",charIndex:1534},{level:3,title:"动态脚本",slug:"动态脚本",normalizedTitle:"动态脚本",charIndex:7774},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4321},{level:2,title:"资源加载",slug:"资源加载",normalizedTitle:"资源加载",charIndex:8621},{level:3,title:"加载脚本",slug:"加载脚本",normalizedTitle:"加载脚本",charIndex:8721},{level:4,title:"script.onlaod",slug:"script-onlaod",normalizedTitle:"script.onlaod",charIndex:8952},{level:4,title:"script.onerror",slug:"script-onerror",normalizedTitle:"script.onerror",charIndex:9326},{level:3,title:"其他资源加载",slug:"其他资源加载",normalizedTitle:"其他资源加载",charIndex:9873}],headersStr:"。页面生命周期 DOMContentLoaded 脚本 样式 浏览器表单自动填充 window.onload window.onunload window.onbeforeunload readyState 生命周期总结 脚本加载类型 / 顺序 defer async 动态脚本 总结 资源加载 加载脚本 script.onlaod script.onerror 其他资源加载",content:'# 。页面生命周期\n\nHTML 页面的生命周期包含三个重要事件：\n\n * DOMContentLoaded ：浏览器已完全加载 HTML，并构建了 DOM 树，但像 <img> 和样式表之类的外部资源可能尚未加载完成。\n * load ：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。\n * beforeunload / unload ： 当用户正在离开页面时。\n\n每个事件的详细用途：\n\n * DOMContentLoaded 事件：DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。\n * load 事件： 外部资源已加载完成，样式已被应用，图片大小也已知了。\n * beforeunload 事件：用户正在离开，可以检查用户否保存了更改，并询问他是否真的要离开。\n * unload ：用户几乎已经离开了，但是仍然可以启动一些操作，例如发送统计数据。\n\n\n# DOMContentLoaded\n\nDOMContentLoaded 事件发生在 document 对象上，必须使用 addEventListener 来捕获它：\n\ndocument.addEventListener("DOMContentLoaded", ready);\n\n\n1\n\n\n🌰 例子：\n\n<script>\n  function ready() {\n    alert(\'DOM is ready\');\n\n    // 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  }\n\n  document.addEventListener("DOMContentLoaded", ready);\n<\/script>\n\n<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> DOMContentLoaded 处理程序在文档加载完成后触发，所以它可以查看所有元素，包括它下面的 <img> 元素。\n> \n> 但是，它不会等待图片加载。因此， alert 显示其大小为零。\n\n# 脚本\n\n当浏览器处理一个 HTML 文档，并在文档中遇到 <script> 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 document.write 操作，所以 DOMContentLoaded 必须等待脚本执行结束。\n\n因此， DOMContentLoaded 肯定在下面的这些脚本执行结束之后发生：\n\n<script>\n  document.addEventListener("DOMContentLoaded", () => {\n    alert("DOM ready!");\n  });\n<\/script>\n\n<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"><\/script>\n\n<script>\n  alert("Library loaded, inline script executed");\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 所以先显示 Library loaded ，再显示 DOM ready 。\n\n提示\n\n两个例外：\n\n * 具有 async 特性（attribute）的脚本不会阻塞 DOMContentLoaded ；\n * 使用 document.createElement(\'script\') 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded 。\n\n# 样式\n\n外部样式表不会影响 DOM，因此 DOMContentLoaded 不会等待它们。但是如果样式后面有一个脚本，那么该脚本必须等待样式表加载完成：\n\n<link type="text/css" rel="stylesheet" href="style.css">\n<script>\n  // 在样式表加载完成之前，脚本都不会执行\n  alert(getComputedStyle(document.body).marginTop);\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n> 脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。\n> \n> 所以，当 DOMContentLoaded 等待脚本时，它现在也在等待脚本前面的样式。\n\n# 浏览器表单自动填充\n\n🌰 例子：\n如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 DOMContentLoaded 上，浏览器会尝试自动填充它们（如果得到了用户允许）。\n\n> 如果 DOMContentLoaded 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。\n> \n> 某些网站中，登录名 / 密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 DOMContentLoaded 事件之前的延迟。\n\n\n# window.onload\n\n当整个页面，包括样式、图片和其他资源被加载完成时，会触发 window 对象上的 load 事件。可以通过 onload 属性获取此事件。\n\n🌰 例子：\n\n<script>\n  window.onload = function() { // 也可以用 window.addEventListener(\'load\', (event) => {\n    alert(\'Page loaded\');\n\n    // 此时图片已经加载完成\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  };\n<\/script>\n\n<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 这个例子会正确显示了图片大小，因为 window.onload 会等待所有图片加载完毕。\n\n\n# window.onunload\n\n当访问者离开页面时， window 对象上的 unload 事件就会被触发。可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。\n\n特殊情况：发送分析数据：假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。当用户要离开的时候，我们希望通过 unload 事件将数据保存到我们的服务器上。\n\n特殊的 navigator.sendBeacon(url, data) 方法可以满足这种需求，它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 sendBeacon 。\n\n🌰 例子：\n\nlet analyticsData = { /* 带有收集的数据的对象 */ };\n\nwindow.addEventListener("unload", function() {\n  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));\n});\n\n\n1\n2\n3\n4\n5\n\n>  * 请求以 POST 方式发送。\n>  * 不仅能发送字符串，还能发送表单以及其他格式的数据。\n>  * 数据大小限制在 64kb。\n\n当 sendBeacon 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应。\n\n还有一个 keep-alive 标志，该标志用于在 fetch 方法中为通用的网络请求执行此类 “离开页面后” 的请求。\n\n如果要取消跳转到另一页面的操作，以使用另一个事件 onbeforeunload 。\n\n> , 浏览器内对 unload 内使用 fetch 等 api 发送统计数据的实现并不好，可能有 bug 导致统计数据失准。所以 MDN 里已经不推荐这样做了 https://volument.com/blog/s...\n\n\n# window.onbeforeunload\n\n如果访问者触发了离开页面的导航或试图关闭窗口， beforeunload 处理程序将要求进行更多确认。\n\n如果要取消事件，浏览器会询问用户是否确定。\n\n\n# readyState\n\n在某些情况下，不确定文档是否已经准备就绪。如果希望的函数在 DOM 加载完成时执行，无论现在还是以后。\n\ndocument.readyState 属性可以为提供当前加载状态的信息。三个可能的值：\n\n * loading ：文档正在被加载。\n * interactive ：文档被全部读取。\n * complete ：文档被全部读取，并且所有资源（例如图片等）都已加载完成。\n\n🌰 例子：\n\nfunction work() { /*...*/ }\n\nif (document.readyState == \'loading\') {\n  // 仍在加载，等待事件\n  document.addEventListener(\'DOMContentLoaded\', work);\n} else {\n  // DOM 已就绪！\n  work();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 检查 document.readyState 并设置一个处理程序，或在代码准备就绪时立即执行它。\n\nreadystatechange 事件，会在状态发生改变时触发，因此可以打印所有这些状态：\n\n// 当前状态\nconsole.log(document.readyState);\n\n// 状态改变时打印它\ndocument.addEventListener(\'readystatechange\', () => console.log(document.readyState));\n\n\n1\n2\n3\n4\n5\n\n\n> readystatechange 事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用。\n\n\n# 生命周期总结\n\n页面的生命周期事件：\n\n * DOMContentLoaded 事件： DOM 准备就绪时事件就会被触发。在这个阶段，可以将 JavaScript 应用于元素。\n   \n   * 诸如 <script>...<\/script> 或 <script src="..."><\/script> 之类的脚本会阻塞 DOMContentLoaded ，浏览器将等待它们执行结束。\n   * 图片和其他资源仍然可以继续被加载。\n\n * window.onload 事件：当页面和所有资源都加载完成时触发。\n\n * window.beforeunload 事件：在用户想要离开页面时。常用于要取消这个事件，浏览器就会询问我们是否真的要离开（例如，有未保存的更改）。\n\n * window.unload 事件：处理程序中，只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。可以使用 navigator.sendBeacon 来发送网络请求。\n\n获取当前文档的状态，使用 document.readyState 。可以在 readystatechange 事件中跟踪状态更改：\n\n * loading ：文档正在被加载。\n * interactive ：文档已被解析完成，与 DOMContentLoaded 几乎同时发生，但是在 DOMContentLoaded 之前发生。\n * complete ：文档和资源均已加载完成，与 window.onload 几乎同时发生，但是在 window.onload 之前发生。\n\n\n# 脚本加载类型 / 顺序\n\n在现代的网站中，脚本往往体量很大，需要长事件处理。\n\n当浏览器加载 HTML 时遇到 <script>...<\/script> 标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本 <script src="..."><\/script> 也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。\n\n这导致了两个问题：\n\n * ** 脚本不能访问它完成加载之前下面的 DOM 元素。** 因此脚本无法给它们添加处理程序等。\n\n * 如果页面顶部加载了一个大型的脚本，这会阻塞页面。在脚本下载和执行结束之前，用户都不能看见页面内容。\n   \n   <p>...content before script...</p>\n   \n   <script src="https://javascript.info/article/script-async-defer/long.js?speed=1"><\/script>\n   \n   \x3c!-- This isn\'t visible until the script loads --\x3e\n   <p>...content after script...</p>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n> 解决方法：将脚本放在页面的底部。这样脚本可以访问元素的同时，不会阻塞页面的加载。\n> \n> 但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。\n\n<script> 的两个特性可以解决这两个问题： defer / async\n\n\n# defer\n\n这个特性用于告诉浏览器 不要等待脚本的加载。浏览器可以继续处理 DOM，构建 DOM，同时脚本在 「后台下载」，等 DOM 构建完成后，脚本才会执行。\n\n🌰 例子：\n\n<p>...content before script...</p>\n\n<script>\n  document.addEventListener(\'DOMContentLoaded\', () => alert("DOM ready after defer!"));\n<\/script>\n\n<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"><\/script>\n\n\x3c!-- 立即可见 --\x3e\n<p>...content after script...</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用 defer 的 <script> ：\n\n * 脚本不会阻塞页面的加载；\n\n * 脚本总是等到 DOM 解析完毕，但是在 DOMContentedLoaded 事件之前执行。\n\n * 具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。\n   \n   例如两个 defer 特性的脚本：\n   \n   <script defer src="https://javascript.info/article/script-async-defer/long.js"><\/script>\n   <script defer src="https://javascript.info/article/script-async-defer/small.js"><\/script>\n   \n   \n   1\n   2\n   \n   \n   > 浏览器会扫描脚本，并行下载它们，以此提高性能，因此在下面的实例中，两个脚本是并行下载的，但是 defer 还会确保脚本执行的相对顺序。即使 small.js 先加载完成，它也需要等到 long.js 执行结束才会被执行。\n\ndefer 需要先加载 JavaScript 库，然后再加载依赖于它的脚本时，这可能会很有用。并且 ⚠️ defer 只能用于外部的脚本。（如果 <script> 脚本没有 src ，则会忽略 defer 特性。）\n\n\n# async\n\nasync 特性与 defer 有些类似。它也能够让脚本不阻塞页面。但是在行为上二者有着重要的区别。\n\nasync 特性意味着脚本是完全独立的：\n\n * 浏览器不会因 async 脚本而阻塞。\n * 其他脚本不会等待 async 脚本加载完成，同样， async 脚本也不会等待其他脚本。\n * DOMContentLoaded 和异步脚本不会彼此等待：\n   * DOMContentLoaded 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）\n   * DOMContentLoaded 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）\n\n⚠️ async 脚本会在后台加载，在加载就绪时运行；但是 DOM 和其他脚本不会等待它们加载并且 它们也不会等待其他东西；意味着是一个在加载完成时执行的完全独立的脚本。\n\n🌰 例子：\n\n<p>...content before scripts...</p>\n\n<script>\n  document.addEventListener(\'DOMContentLoaded\', () => alert("DOM ready!"));\n<\/script>\n\n<script async src="https://javascript.info/article/script-async-defer/long.js"><\/script>\n<script async src="https://javascript.info/article/script-async-defer/small.js"><\/script>\n\n<p>...content after scripts...</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 这个例子中的 外部脚本的引入，不会等待对方的加载，先加载完成的（可能是 small.js ）先执行。并且：\n> \n>  * 页面内容立刻显示出来：加载写有 async 的脚本不会阻塞页面渲染。\n>  * DOMContentLoaded 可能在 async 之前或之后触发，不能保证谁先谁后。\n>  * 异步脚本以加载优先的顺序执行。\n\n当使用 第三方脚本 集成到页面时，使用 异步脚本加载方式，可以不必等待它们加载就完成 DOM 的加载。与 defer 相同， async 特性仅适用于外部脚本。\n\n\n# 动态脚本\n\n这时一种向页面添加脚本的重要方式，可以使用 JavaScript 动态创建一个脚本，并将其附加到文档中。\n\n🌰 例子：\n\nlet script = document.createElement(\'script\');\nscript.src = "/article/script-async-defer/long.js";\ndocument.body.append(script); // (*)\n\n\n1\n2\n3\n\n\n> 利用 document.createElement ，当脚本被附加到文档 (*) 时，脚本就会立即开始加载。\n\n在默认的情况下动态脚本的行为是 异步的。\n\n * 不会等待任何东西，也会有东西等待它们；\n * 先加载完成的脚本先执行（加载优先顺序）。\n\n但是如果显式设置 script.async = false 就可以改变这个规则。脚本此时按照 defer 方式，脚本将按照脚本在文档中的顺序执行。\n\n🌰 例子：\n\nfunction loadScript(src) {\n  let script = document.createElement(\'script\');\n  script.src = src;\n  script.async = false;\n  document.body.append(script);\n}\n\n// long.js 先执行，因为代码中设置了 async=false\nloadScript("/article/script-async-defer/long.js");\nloadScript("/article/script-async-defer/small.js");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 总结\n\n * defer 一般用于需要整个 DOM 的脚本，和 / 或脚本的相对执行顺序很重要的时候。\n * async 一般用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。\n\n\n# 资源加载\n\n浏览器允许跟踪外部资源的加载，加载资源相关有两个事件：\n\n * onload ：成功加载；\n * onerror ：出现错误。\n\n> 外部资源包括，图片、 iframe 、图片。\n\n\n# 加载脚本\n\n对于加载 第三方的脚本，调用其中的函数，可以动态加载：\n\nlet script = document.createElement(\'script\');\nscript.src = "my.js";\n\ndocument.head.append(script);\n\n\n1\n2\n3\n4\n\n\n要运行该脚本中的函数，需要等待脚本的加载完成才能运行。\n\n> 使用 自定义的脚本，现在一般使用 🪤JavaScript 的模块管理。第三方库依照使用说明导入。\n\n# script.onlaod\n\nonlaod 事件，在脚本加载并执行完成时触发。\n\n🌰 例子：\n\nlet script = document.createElement(\'script\');\n\n// 可以从任意域（domain），加载任意脚本\nscript.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"\ndocument.head.append(script);\n\nscript.onload = function() {\n  // 该脚本创建了一个变量 "_"\n  alert( _.VERSION ); // 显示库的版本\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 在 onload 中可以使用脚本中的变量，运行函数。\n\n# script.onerror\n\n当脚本加载期间，出现的 error 会被 onerror 事件跟踪到。\n\n🌰 例子：\n\nlet script = document.createElement(\'script\');\nscript.src = "https://example.com/404.js"; // 没有这个脚本\ndocument.head.append(script);\n\nscript.onerror = function() {\n  alert("Error loading " + this.src); // Error loading https://example.com/404.js\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> onerror 无法获取更多 HTTP error 的详细信息。不能知道是 404 还是 500 或者其他情况。只知道是加载失败了。\n\n提示\n\nonload / onerror 事件仅跟踪加载本身。在脚本处理和执行期间可能发生的 error 超出了这些事件跟踪的范围。如果脚本成功加载，则即使脚本中有编程 error，也会触发 onload 事件。如果要跟踪脚本 error，可以使用 window.onerror 全局处理程序。\n\n\n# 其他资源加载\n\nonload / onerror 事件也同样适用于 其他资源（基本上具有外部 src 的任何资源）的加载。\n\n🌰 例子：\n\nlet img = document.createElement(\'img\');\nimg.src = "https://js.cx/clipart/train.gif"; \n\n\nimg.onload = function() {\n  alert(`Image loaded, size ${img.width}x${img.height}`);\n};\n\nimg.onerror = function() {\n  alert("Error occurred while loading image");\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n注意：\n\n * 大多数资源在被添加到文档中后，便开始加载。但是 <img> 是个例外。它要等到获得 src 才开始加载。\n * 对于 <iframe> 来说， iframe 加载完成时会触发 iframe.onload 事件，无论是成功加载还是出现 error 。',normalizedContent:'# 。页面生命周期\n\nhtml 页面的生命周期包含三个重要事件：\n\n * domcontentloaded ：浏览器已完全加载 html，并构建了 dom 树，但像 <img> 和样式表之类的外部资源可能尚未加载完成。\n * load ：浏览器不仅加载完成了 html，还加载完成了所有外部资源：图片，样式等。\n * beforeunload / unload ： 当用户正在离开页面时。\n\n每个事件的详细用途：\n\n * domcontentloaded 事件：dom 已经就绪，因此处理程序可以查找 dom 节点，并初始化接口。\n * load 事件： 外部资源已加载完成，样式已被应用，图片大小也已知了。\n * beforeunload 事件：用户正在离开，可以检查用户否保存了更改，并询问他是否真的要离开。\n * unload ：用户几乎已经离开了，但是仍然可以启动一些操作，例如发送统计数据。\n\n\n# domcontentloaded\n\ndomcontentloaded 事件发生在 document 对象上，必须使用 addeventlistener 来捕获它：\n\ndocument.addeventlistener("domcontentloaded", ready);\n\n\n1\n\n\n🌰 例子：\n\n<script>\n  function ready() {\n    alert(\'dom is ready\');\n\n    // 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0\n    alert(`image size: ${img.offsetwidth}x${img.offsetheight}`);\n  }\n\n  document.addeventlistener("domcontentloaded", ready);\n<\/script>\n\n<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> domcontentloaded 处理程序在文档加载完成后触发，所以它可以查看所有元素，包括它下面的 <img> 元素。\n> \n> 但是，它不会等待图片加载。因此， alert 显示其大小为零。\n\n# 脚本\n\n当浏览器处理一个 html 文档，并在文档中遇到 <script> 标签时，就会在继续构建 dom 之前运行它。这是一种防范措施，因为脚本可能想要修改 dom，甚至对其执行 document.write 操作，所以 domcontentloaded 必须等待脚本执行结束。\n\n因此， domcontentloaded 肯定在下面的这些脚本执行结束之后发生：\n\n<script>\n  document.addeventlistener("domcontentloaded", () => {\n    alert("dom ready!");\n  });\n<\/script>\n\n<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"><\/script>\n\n<script>\n  alert("library loaded, inline script executed");\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 所以先显示 library loaded ，再显示 dom ready 。\n\n提示\n\n两个例外：\n\n * 具有 async 特性（attribute）的脚本不会阻塞 domcontentloaded ；\n * 使用 document.createelement(\'script\') 动态生成并添加到网页的脚本也不会阻塞 domcontentloaded 。\n\n# 样式\n\n外部样式表不会影响 dom，因此 domcontentloaded 不会等待它们。但是如果样式后面有一个脚本，那么该脚本必须等待样式表加载完成：\n\n<link type="text/css" rel="stylesheet" href="style.css">\n<script>\n  // 在样式表加载完成之前，脚本都不会执行\n  alert(getcomputedstyle(document.body).margintop);\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n> 脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。\n> \n> 所以，当 domcontentloaded 等待脚本时，它现在也在等待脚本前面的样式。\n\n# 浏览器表单自动填充\n\n🌰 例子：\n如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 domcontentloaded 上，浏览器会尝试自动填充它们（如果得到了用户允许）。\n\n> 如果 domcontentloaded 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。\n> \n> 某些网站中，登录名 / 密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 domcontentloaded 事件之前的延迟。\n\n\n# window.onload\n\n当整个页面，包括样式、图片和其他资源被加载完成时，会触发 window 对象上的 load 事件。可以通过 onload 属性获取此事件。\n\n🌰 例子：\n\n<script>\n  window.onload = function() { // 也可以用 window.addeventlistener(\'load\', (event) => {\n    alert(\'page loaded\');\n\n    // 此时图片已经加载完成\n    alert(`image size: ${img.offsetwidth}x${img.offsetheight}`);\n  };\n<\/script>\n\n<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 这个例子会正确显示了图片大小，因为 window.onload 会等待所有图片加载完毕。\n\n\n# window.onunload\n\n当访问者离开页面时， window 对象上的 unload 事件就会被触发。可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。\n\n特殊情况：发送分析数据：假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。当用户要离开的时候，我们希望通过 unload 事件将数据保存到我们的服务器上。\n\n特殊的 navigator.sendbeacon(url, data) 方法可以满足这种需求，它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 sendbeacon 。\n\n🌰 例子：\n\nlet analyticsdata = { /* 带有收集的数据的对象 */ };\n\nwindow.addeventlistener("unload", function() {\n  navigator.sendbeacon("/analytics", json.stringify(analyticsdata));\n});\n\n\n1\n2\n3\n4\n5\n\n>  * 请求以 post 方式发送。\n>  * 不仅能发送字符串，还能发送表单以及其他格式的数据。\n>  * 数据大小限制在 64kb。\n\n当 sendbeacon 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应。\n\n还有一个 keep-alive 标志，该标志用于在 fetch 方法中为通用的网络请求执行此类 “离开页面后” 的请求。\n\n如果要取消跳转到另一页面的操作，以使用另一个事件 onbeforeunload 。\n\n> , 浏览器内对 unload 内使用 fetch 等 api 发送统计数据的实现并不好，可能有 bug 导致统计数据失准。所以 mdn 里已经不推荐这样做了 https://volument.com/blog/s...\n\n\n# window.onbeforeunload\n\n如果访问者触发了离开页面的导航或试图关闭窗口， beforeunload 处理程序将要求进行更多确认。\n\n如果要取消事件，浏览器会询问用户是否确定。\n\n\n# readystate\n\n在某些情况下，不确定文档是否已经准备就绪。如果希望的函数在 dom 加载完成时执行，无论现在还是以后。\n\ndocument.readystate 属性可以为提供当前加载状态的信息。三个可能的值：\n\n * loading ：文档正在被加载。\n * interactive ：文档被全部读取。\n * complete ：文档被全部读取，并且所有资源（例如图片等）都已加载完成。\n\n🌰 例子：\n\nfunction work() { /*...*/ }\n\nif (document.readystate == \'loading\') {\n  // 仍在加载，等待事件\n  document.addeventlistener(\'domcontentloaded\', work);\n} else {\n  // dom 已就绪！\n  work();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 检查 document.readystate 并设置一个处理程序，或在代码准备就绪时立即执行它。\n\nreadystatechange 事件，会在状态发生改变时触发，因此可以打印所有这些状态：\n\n// 当前状态\nconsole.log(document.readystate);\n\n// 状态改变时打印它\ndocument.addeventlistener(\'readystatechange\', () => console.log(document.readystate));\n\n\n1\n2\n3\n4\n5\n\n\n> readystatechange 事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用。\n\n\n# 生命周期总结\n\n页面的生命周期事件：\n\n * domcontentloaded 事件： dom 准备就绪时事件就会被触发。在这个阶段，可以将 javascript 应用于元素。\n   \n   * 诸如 <script>...<\/script> 或 <script src="..."><\/script> 之类的脚本会阻塞 domcontentloaded ，浏览器将等待它们执行结束。\n   * 图片和其他资源仍然可以继续被加载。\n\n * window.onload 事件：当页面和所有资源都加载完成时触发。\n\n * window.beforeunload 事件：在用户想要离开页面时。常用于要取消这个事件，浏览器就会询问我们是否真的要离开（例如，有未保存的更改）。\n\n * window.unload 事件：处理程序中，只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。可以使用 navigator.sendbeacon 来发送网络请求。\n\n获取当前文档的状态，使用 document.readystate 。可以在 readystatechange 事件中跟踪状态更改：\n\n * loading ：文档正在被加载。\n * interactive ：文档已被解析完成，与 domcontentloaded 几乎同时发生，但是在 domcontentloaded 之前发生。\n * complete ：文档和资源均已加载完成，与 window.onload 几乎同时发生，但是在 window.onload 之前发生。\n\n\n# 脚本加载类型 / 顺序\n\n在现代的网站中，脚本往往体量很大，需要长事件处理。\n\n当浏览器加载 html 时遇到 <script>...<\/script> 标签，浏览器就不能继续构建 dom。它必须立刻执行此脚本。对于外部脚本 <script src="..."><\/script> 也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。\n\n这导致了两个问题：\n\n * ** 脚本不能访问它完成加载之前下面的 dom 元素。** 因此脚本无法给它们添加处理程序等。\n\n * 如果页面顶部加载了一个大型的脚本，这会阻塞页面。在脚本下载和执行结束之前，用户都不能看见页面内容。\n   \n   <p>...content before script...</p>\n   \n   <script src="https://javascript.info/article/script-async-defer/long.js?speed=1"><\/script>\n   \n   \x3c!-- this isn\'t visible until the script loads --\x3e\n   <p>...content after script...</p>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n> 解决方法：将脚本放在页面的底部。这样脚本可以访问元素的同时，不会阻塞页面的加载。\n> \n> 但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 html 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 html 文档来说，这样可能会造成明显的延迟。\n\n<script> 的两个特性可以解决这两个问题： defer / async\n\n\n# defer\n\n这个特性用于告诉浏览器 不要等待脚本的加载。浏览器可以继续处理 dom，构建 dom，同时脚本在 「后台下载」，等 dom 构建完成后，脚本才会执行。\n\n🌰 例子：\n\n<p>...content before script...</p>\n\n<script>\n  document.addeventlistener(\'domcontentloaded\', () => alert("dom ready after defer!"));\n<\/script>\n\n<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"><\/script>\n\n\x3c!-- 立即可见 --\x3e\n<p>...content after script...</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用 defer 的 <script> ：\n\n * 脚本不会阻塞页面的加载；\n\n * 脚本总是等到 dom 解析完毕，但是在 domcontentedloaded 事件之前执行。\n\n * 具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。\n   \n   例如两个 defer 特性的脚本：\n   \n   <script defer src="https://javascript.info/article/script-async-defer/long.js"><\/script>\n   <script defer src="https://javascript.info/article/script-async-defer/small.js"><\/script>\n   \n   \n   1\n   2\n   \n   \n   > 浏览器会扫描脚本，并行下载它们，以此提高性能，因此在下面的实例中，两个脚本是并行下载的，但是 defer 还会确保脚本执行的相对顺序。即使 small.js 先加载完成，它也需要等到 long.js 执行结束才会被执行。\n\ndefer 需要先加载 javascript 库，然后再加载依赖于它的脚本时，这可能会很有用。并且 ⚠️ defer 只能用于外部的脚本。（如果 <script> 脚本没有 src ，则会忽略 defer 特性。）\n\n\n# async\n\nasync 特性与 defer 有些类似。它也能够让脚本不阻塞页面。但是在行为上二者有着重要的区别。\n\nasync 特性意味着脚本是完全独立的：\n\n * 浏览器不会因 async 脚本而阻塞。\n * 其他脚本不会等待 async 脚本加载完成，同样， async 脚本也不会等待其他脚本。\n * domcontentloaded 和异步脚本不会彼此等待：\n   * domcontentloaded 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）\n   * domcontentloaded 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 http 缓存中加载的）\n\n⚠️ async 脚本会在后台加载，在加载就绪时运行；但是 dom 和其他脚本不会等待它们加载并且 它们也不会等待其他东西；意味着是一个在加载完成时执行的完全独立的脚本。\n\n🌰 例子：\n\n<p>...content before scripts...</p>\n\n<script>\n  document.addeventlistener(\'domcontentloaded\', () => alert("dom ready!"));\n<\/script>\n\n<script async src="https://javascript.info/article/script-async-defer/long.js"><\/script>\n<script async src="https://javascript.info/article/script-async-defer/small.js"><\/script>\n\n<p>...content after scripts...</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 这个例子中的 外部脚本的引入，不会等待对方的加载，先加载完成的（可能是 small.js ）先执行。并且：\n> \n>  * 页面内容立刻显示出来：加载写有 async 的脚本不会阻塞页面渲染。\n>  * domcontentloaded 可能在 async 之前或之后触发，不能保证谁先谁后。\n>  * 异步脚本以加载优先的顺序执行。\n\n当使用 第三方脚本 集成到页面时，使用 异步脚本加载方式，可以不必等待它们加载就完成 dom 的加载。与 defer 相同， async 特性仅适用于外部脚本。\n\n\n# 动态脚本\n\n这时一种向页面添加脚本的重要方式，可以使用 javascript 动态创建一个脚本，并将其附加到文档中。\n\n🌰 例子：\n\nlet script = document.createelement(\'script\');\nscript.src = "/article/script-async-defer/long.js";\ndocument.body.append(script); // (*)\n\n\n1\n2\n3\n\n\n> 利用 document.createelement ，当脚本被附加到文档 (*) 时，脚本就会立即开始加载。\n\n在默认的情况下动态脚本的行为是 异步的。\n\n * 不会等待任何东西，也会有东西等待它们；\n * 先加载完成的脚本先执行（加载优先顺序）。\n\n但是如果显式设置 script.async = false 就可以改变这个规则。脚本此时按照 defer 方式，脚本将按照脚本在文档中的顺序执行。\n\n🌰 例子：\n\nfunction loadscript(src) {\n  let script = document.createelement(\'script\');\n  script.src = src;\n  script.async = false;\n  document.body.append(script);\n}\n\n// long.js 先执行，因为代码中设置了 async=false\nloadscript("/article/script-async-defer/long.js");\nloadscript("/article/script-async-defer/small.js");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 总结\n\n * defer 一般用于需要整个 dom 的脚本，和 / 或脚本的相对执行顺序很重要的时候。\n * async 一般用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。\n\n\n# 资源加载\n\n浏览器允许跟踪外部资源的加载，加载资源相关有两个事件：\n\n * onload ：成功加载；\n * onerror ：出现错误。\n\n> 外部资源包括，图片、 iframe 、图片。\n\n\n# 加载脚本\n\n对于加载 第三方的脚本，调用其中的函数，可以动态加载：\n\nlet script = document.createelement(\'script\');\nscript.src = "my.js";\n\ndocument.head.append(script);\n\n\n1\n2\n3\n4\n\n\n要运行该脚本中的函数，需要等待脚本的加载完成才能运行。\n\n> 使用 自定义的脚本，现在一般使用 🪤javascript 的模块管理。第三方库依照使用说明导入。\n\n# script.onlaod\n\nonlaod 事件，在脚本加载并执行完成时触发。\n\n🌰 例子：\n\nlet script = document.createelement(\'script\');\n\n// 可以从任意域（domain），加载任意脚本\nscript.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"\ndocument.head.append(script);\n\nscript.onload = function() {\n  // 该脚本创建了一个变量 "_"\n  alert( _.version ); // 显示库的版本\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 在 onload 中可以使用脚本中的变量，运行函数。\n\n# script.onerror\n\n当脚本加载期间，出现的 error 会被 onerror 事件跟踪到。\n\n🌰 例子：\n\nlet script = document.createelement(\'script\');\nscript.src = "https://example.com/404.js"; // 没有这个脚本\ndocument.head.append(script);\n\nscript.onerror = function() {\n  alert("error loading " + this.src); // error loading https://example.com/404.js\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> onerror 无法获取更多 http error 的详细信息。不能知道是 404 还是 500 或者其他情况。只知道是加载失败了。\n\n提示\n\nonload / onerror 事件仅跟踪加载本身。在脚本处理和执行期间可能发生的 error 超出了这些事件跟踪的范围。如果脚本成功加载，则即使脚本中有编程 error，也会触发 onload 事件。如果要跟踪脚本 error，可以使用 window.onerror 全局处理程序。\n\n\n# 其他资源加载\n\nonload / onerror 事件也同样适用于 其他资源（基本上具有外部 src 的任何资源）的加载。\n\n🌰 例子：\n\nlet img = document.createelement(\'img\');\nimg.src = "https://js.cx/clipart/train.gif"; \n\n\nimg.onload = function() {\n  alert(`image loaded, size ${img.width}x${img.height}`);\n};\n\nimg.onerror = function() {\n  alert("error occurred while loading image");\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n注意：\n\n * 大多数资源在被添加到文档中后，便开始加载。但是 <img> 是个例外。它要等到获得 src 才开始加载。\n * 对于 <iframe> 来说， iframe 加载完成时会触发 iframe.onload 事件，无论是成功加载还是出现 error 。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥢 JavaScript Fetch",frontmatter:{title:"🥢 JavaScript Fetch",date:"2022-05-29T23:54:06.000Z",permalink:"/pages/e0da75/",categories:["🚶🏻 前端巩固基础","🍯 JavaScript AJAX 网络请求"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/37.%20%F0%9F%8D%AF%20JavaScript%20AJAX%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/01.%20%F0%9F%A5%A2%20JavaScript%20Fetch.html",relativePath:"101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/01. 🥢 JavaScript Fetch.md",key:"v-7fb17d6f",path:"/pages/e0da75/",headers:[{level:2,title:"fetch 的使用",slug:"fetch-的使用",normalizedTitle:"fetch 的使用",charIndex:2},{level:3,title:"响应头 Response header",slug:"响应头-response-header",normalizedTitle:"响应头 response header",charIndex:1787},{level:3,title:"请求头 Request header",slug:"请求头-request-header",normalizedTitle:"请求头 request header",charIndex:2263},{level:3,title:"请求方法 method",slug:"请求方法-method",normalizedTitle:"请求方法 method",charIndex:2527},{level:2,title:"Fetch 的应用",slug:"fetch-的应用",normalizedTitle:"fetch 的应用",charIndex:4013},{level:3,title:"FormData",slug:"formdata",normalizedTitle:"formdata",charIndex:1054},{level:4,title:"FormData 表单上传文件",slug:"formdata-表单上传文件",normalizedTitle:"formdata 表单上传文件",charIndex:5690},{level:3,title:"Fetch 跨源请求",slug:"fetch-跨源请求",normalizedTitle:"fetch 跨源请求",charIndex:6309},{level:3,title:"Fetch  请求凭证",slug:"fetch-请求凭证",normalizedTitle:"fetch  请求凭证",charIndex:null}],headersStr:"fetch 的使用 响应头 Response header 请求头 Request header 请求方法 method Fetch 的应用 FormData FormData 表单上传文件 Fetch 跨源请求 Fetch  请求凭证",content:'# fetch 的使用\n\nfetch() 方法是一种现代通用网络请求的方法：\n\nlet promise = fetch(url, [options])\n\n\n1\n\n * url ：请求网络路径；\n * options ：可选参数（方法、请求头等）。没有可选参数，默认请求方法 get 。\n\n使用 fetch 发送网络请求后，获取来自服务器的响应需要经过两个阶段：\n\n * 第一阶段：当服务器发送了响应头， fetch 返回的 promise 就使用内建的 Response 类对象来 对响应头进行解析。\n   \n   > 可以在这个阶段，检查响应头，检查 HTTP 状态确定请求是否成功了，这个阶段还没有响应体。\n   > \n   >  * 如果 fetch 无法建立一个 HTTP 请求。例如，网络问题；请求网络地址不存在，此时 promise 就会 reject 。\n   >  * 异常的 HTTP 状态，例如 404 或 500，不会导致出现 error。\n   \n   请求 HTTP 状态可以通过两个属性查看：\n   \n   * status ：HTTP 状态码；\n   * ok ：布尔值，如果 HTTP 状态码为 200-299，则为 true 。\n   \n   🌰 例子：\n   \n   let response = await fetch(url);\n   \n   if (response.ok) { // 如果 HTTP 状态码为 200-299\n     // 获取 response body（此方法会在下面解释）\n     let json = await response.json();\n   } else {\n     alert("HTTP-Error: " + response.status);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 第二阶段：获取 response 响应体，使用一个其他的方法调用。\n   \n   Response 提供了多种基于 promise 的方法，来以不同的格式访问 resposne body：\n   \n   * response.text() ：读取 response ，并以文本形式返回 response；\n   * response.json() ：将 response 解析为 JSON；\n   * response.formData() ：以 FormData 对象的形式返回 response；\n   * response.blob() ：以 Blob 的形式返回 response；\n   * response.arrayBuffer() ：以 ArrayBuffer 形式返回 response；\n   * response.body ：是 ReadableStream 对象，允许逐块读取 body 。\n\n🌰 例子 / 获取响应的 JSON 对象：\n\nlet url = \'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits\';\nlet response = await fetch(url);\n\nlet commits = await response.json();\nconsole.log(commits[0].author.login)\n\n\n1\n2\n3\n4\n5\n\n\n或者使用纯 promise ：\n\nfetch(\'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits\')\n  .then(response => response.json())\n  .then(commits => alert(commits[0].author.login));\n\n\n1\n2\n3\n\n\n注意\n\n一般只能选择一种读取 body 的方法。例如，如果已经使用了 response.text() 来获取 response ， 那么再用 response.json() 不会生效。因为响应体内容已经被处理过了。\n\n\n# 响应头 Response header\n\nResponse header 是位于 response.headers 中的一个类似于 Map 的 header 对象。（不是真正的 Map 对象） 可以通过 名字 获取各个 header ，或者迭代。\n\n🌰 例子 / 获取响应头 Content-type ：\n\nlet response = await fetch(\'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits\');\n\n// 获取一个 header\nalert(response.headers.get(\'Content-Type\')); // application/json; charset=utf-8\n\n// 迭代所有 header\nfor (let [key, value] of response.headers) {\n  alert(`${key} = ${value}`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 请求头 Request header\n\n可以通过在使用 fetch 时，在选择参数中配置 headers 选项。\n\n🌰 例子：\n\nlet response = fetch(protectedUrl, {\n  headers: {\n    Authentication: \'secret\'\n  }\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 为了保证 HTTP 的正确性和安全性，存在不能控制的请求头：https://fetch.spec.whatwg.org/#forbidden-header-name。仅有浏览器控制。\n\n\n# 请求方法 method\n\n要使用 默认方法 GET 以外的请求方法，通过 method 选项配置 / 或者配置 body （request body， 常用 JSON）。\n\n🌰 例子 / 以 JSON 形式发送对象类型的请求：\n\nlet user = {\n  name: \'John\',\n  surname: \'Smith\'\n}\n\nlet response = await fetch(\'/article/fetch/post/user\', {\n  method: \'POST\',\n  headers: {\n    \'Content-Type\': \'application/json;charset=utf-8\'\n  },\n  body: JSON.stringify(user)\n});\n\nlet result = await response.json()\nconsole.log(result.message)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果请求的 body 是字符串，则 Content-Type 会默认设置为 text/plain;charset=UTF-8 。所以如果要发送 JSON，需要设置请求头 Content-type 控制编码类型。\n\n🌰 例子 / 获取 GitHub 用户信息。\n\n>  * 创建一个异步函数 getUsers(names) ，该函数接受 GitHub 登录名数组作为输入，查询 GitHub 以获取有关这些用户的信息，并返回 GitHub 用户数组。\n>  * GitHub 查询用户信息的 API：https://api.github.com/users/USERNAME\n\nasync function getUsers(names) {\n  let jobs = [];\n  \n  for (let name of names) {\n    let job = fetch(`https://api.github.com/users/${name}`).then(\n      response => {\n        if (response.status != 200) return null;\n        else return response.json();\n      }, \n      error => {\n        return null;\n      }\n    );\n    jobs.push(job)\n  }\n  \n  let results = await Promis.all(jobs)\n  return results;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n>  * 对于 每一个用户名都有一个 fetch 请求。求不应该相互等待。以便能够尽快获取到数据。如果任何一个请求失败了，或者没有这个用户，则函数应该返回 null 到结果数组中。\n>  * .then 调用紧跟在 fetch 后面，这样当收到响应时，它不会等待其他的 fetch ，而是立即开始读取 .json() 。通过将 .json() 直接添加到每个 fetch 中，就能确保每个 fetch 在收到响应时都会立即开始以 JSON 格式读取数据，而不会彼此等待。\n>  * 使用 await Promise.all 将会等到所有的 fetch 都获取到响应数据才开始解析。\n\n\n# Fetch 的应用\n\n\n# FormData\n\n用于发送 HTML 表单数据的类型对象。构造器使用如下：\n\nlet formData = new FormData([form])\n\n\n1\n\n\n> [form] 是选择性提供的。如果提供了 HTML form 元素，就会自动捕获该 from 元素字段。\n\nFormData 的特殊之处在于网络方法。例如 fetch 可以接受一个 FormData 对象作为 body。它会被编码并发送出去，带有 Content-Type: multipart/form-data 。\n\n对于服务器，只是普通的表达数据提交。\n\n🌰 例子 / 提交简单的表单数据：\n\n<form id="formElem">\n  <input type="text" name="name" value="John">\n  <input type="text" name="surname" value="Smith">\n  <input type="submit">\n</form>\n\n\n1\n2\n3\n4\n5\n\n\n<html>\n  <form id="formElem">\n    <input type="text" name="name" value="John">\n    <input type="text" name="surname" value="Smith">\n    <input type="submit">\n\t</form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\nlet formElem = document.querySelector("#formElem");\nformElem.onsubmit = async (e) => {\n  e.preventDefault\n  \n  let response = await fetch(\'/article/formdata/post/user\', {\n      method: \'POST\',\n      body: new FormData(formElem)\n  });\n  \n  let result = await response.json()\n  console.log(result.message)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nFormData 提供的方法修改其中的字段：\n\n * formData.append(name, value) ：添加具有给定 name 和 value 的表单字段；\n * formData.append(name, blob, fileName) ：添加一个相当于 <input type="file"> 输入类型的字段。第三个参数 fileName 设置文件名（而不是表单字段名），因为它是用户文件系统中文件的名称；\n * formData.delete(name) ：移除带有给定 name 的字段；\n * formData.get(name) ：获取带有给定 name 的字段值；\n * formData.has(name) ：如果存在带有给定 name 的字段，则返回 true ，否则返回 false 。\n\n> 技术上，可以拥有多个 相同名称 name 的字段。因此，多次调用 append 将会添加多个具有相同名称的字段。使用 set 方法，确保该字段只有一个唯一的值（移除之前存在的 name 字段）。\n\n * formData.set(name, value)\n\n * formData.set(name, blob, fileName)\n   \n   与使用 append 的方法相同。\n\n可以使用 for ... of 循环迭代 formData 中的字段与值：\n\nfor (let [name, value] of formData) {\n  console.log(`${name} = ${value}`)\n}\n\n\n1\n2\n3\n\n\n# FormData 表单上传文件\n\nFormData 表单类型始终带有请求头 Content-type: multipart/form-data 发送数据，这个编码允许发送文件 （ <input type="file"> 类型的输入框）。\n\n🌰 例子 / 上传图片：\n\n<form id="formElem">\n  <input type="text" name="firstName" value="John">\n  Picture: <input type="file" name="picture" accept="image/*">\n  <input type="submit">\n</form>\n\n\n1\n2\n3\n4\n5\n\n\nformElem.onsubmit = async (e) => {\n    e.preventDefault();\n\n    let response = await fetch(\'/article/formdata/post/user-avatar\', {\n      method: \'POST\',\n      body: new FormData(formElem)\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Fetch 跨源请求\n\n> 跨源请求（跨域） （跨源资源请求 Cross-Origin Resource Sharing / CORS ）：发送到其他域、协议或者端口的请求。\n\n允许跨源请求的两种请求类型：\n\n * 安全请求；\n * 所有的其他请求。\n\n安全的请求需要满足两个条件：\n\n * 安全的请求方法： GET 、 POST 、 HEAD ；\n * 安全的请求头 header 仅允许自定义下列的 header：\n   * Accept ，\n   * Accept-Language ，\n   * Content-Language ，\n   * Content-Type 的值为 application/x-www-form-urlencoded ， multipart/form-data 或 text/plain 。\n\n> 除了安全的请求，没有符合上述条件的请求都为非安全的请求。例如，使用 PUT 请求方法，或者具有除了上述的自定义的请求头部。\n> \n> 安全的请求与非安全的请求的本质区别：\n> \n>  * 可以使用 <form> / script 进行安全请求，无需特殊的方法。\n>    \n>    > 使用安全的请求能兼容较旧的服务器，不用进行特殊的处理。\n> \n>  * 而发送非安全的请求，无法进行同样的工作。\n>    \n>    > 旧的服务器可能会认为此类请求来自具有特权的来源。当尝试发送一个非安全请求时，浏览器会发送一个特殊的预检请求到服务器，询问服务是否接受此类跨源请求吗。\n>    > \n>    > 服务器需要明确通过 header 确认，否则非安全的请求无法发送。\n\n对于安全的请求 CORS：\n\n🌰 例子：\n\n从 https://somewhere.page 请求 https://anywhere.com/request ，发送的请求头为：\n\nGET /request\nHost: anywhere.com\nOrigin: https://somewhere.page\n\n\n1\n2\n3\n\n\n> 请求头的 Origin 会包含确切的请求来源（域名、协议、端口），没有路径。服务器检查 Origin ，如果同意接受请求，就会在响应中添加一个特殊的 header Access-Control-Allow-Origin 。该 header 包含了允许的源，或者一个星号 * 。然后响应成功，否则报错。\n> \n> 浏览器作为中间人：确保了发送的跨源请求带有正确的 Origin；检查响应头中是否带有许可 Access-Control-Allow-Origin ，如果存在，则允许 JavaScript 访问响应，否则将失败并报错。\n\n响应的请求头：\n\n200 OK\nContent-Type:text/html; charset=UTF-8\nAccess-Control-Allow-Origin: *\n\n\n1\n2\n3\n\n\n> 对于响应头 （Response Header）处理跨源请求时，JavaScript 只能访问 安全的响应头：\n> \n>  * Cache-Control\n>  * Content-Language\n>  * Content-Type\n>  * Expires\n>  * Last-Modified\n>  * Pragma\n> \n> 对于其他的响应头都会导致出错。\n> \n> 要授予 JavaScript 对任何其他请求的访问权限，服务器必须发送 Access-Control-Expose-Headers header。它包含一个以逗号分隔的应该被设置为可访问的非安全 header 名称列表。\n\n对于非安全的请求：\n\n为了使用任何的 HTTP 请求方法（不仅 GET / POST，还有可能是 PATCH、DELETE 或者其他）。\n\n * 浏览器发送预检请求，来请求许可：\n   \n   预检请求使用 OPTIONS 方法，它没有 body，但是有三个 header：\n   \n   * Access-Control-Request-Method header 带有非安全请求的方法。\n   * Access-Control-Request-Headers header 提供一个以逗号分隔的非安全 HTTP-header 列表。\n\n * 如果服务器同意处理请求，那么会进行响应以下响应头信息：\n   \n   * Access-Control-Allow-Origin 必须为 * 或进行请求的源才能允许此请求。\n   * Access-Control-Allow-Methods 必须具有允许的方法。\n   * Access-Control-Allow-Headers 必须具有一个允许的 header 列表。\n   * Access-Control-Max-Age 可以指定缓存此权限的秒数。因此，浏览器不是必须为满足给定权限的后续请求发送预检。\n\n🌰 例子：\n\n * 发送预检请求 /preflight request：\n   \n   OPTIONS /service.json\n   Host: site.com\n   Origin: https://somewhere.info\n   Access-Control-Request-Method: PATCH\n   Access-Control-Request-Headers: Content-Type,API-Key\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   >  * Origin ： 来源。\n   > \n   >  * Access-Control-Request-Method ： 请求方法。\n   >  * Access-Control-Request-Headers ： 以逗号分隔的非安全 header 列表。\n\n * 服务器响应预检响应 /preflight response：\n   \n   Access-Control-Allow-Origin: https://somewhere.page\n   Access-Control-Allow-Methods: PUT,PATCH,DELETE\n   Access-Control-Allow-Headers: Content-Type,API-Key\n   Access-Control-Max-Age: 86400\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 这将允许后续通信，否则会触发错误。如果服务器将来需要其他方法和 header，则可以通过将这些方法和 header 添加到列表中来预先允许它们。\n   > \n   > 可以看到 PATCH 在 Access-Control-Allow-Methods 中， Content-Type,API-Key 在列表 Access-Control-Allow-Headers 中，因此它将发送主请求。\n   > \n   > Access-Control-Max-Age 带有一个表示秒的数字，则在给定的时间内，预检权限会被缓存。上面的响应将被缓存 86400 秒，也就是一天。在此时间范围内，后续请求将不会触发预检。假设它们符合缓存的配额，则将直接发送它们。\n\n * 发送实际请求：\n   \n   最后的请求头：\n   \n   PATCH /service.json\n   Host: site.com\n   Content-Type: application/json\n   API-Key: secret\n   Origin: https://javascript.info\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   响应头应该添加 Access-Control-Allow-Origin 。\n   \n   例如：\n   \n   Access-Control-Allow-Origin: https://somewhere.pages\n   \n   \n   1\n   \n\n\n# Fetch 请求凭证\n\n默认情况下，由 JavaScript 代码发起的跨源请求，不会带任何凭据（cookies 或者 HTTP 网络认证）。\n\n> 因为具有凭据的请求比没有凭据的请求要强大得多。如果被允许，它会使用它们的凭据授予 JavaScript 代表用户行为和访问敏感信息的全部权力。\n\n所以要在 跨源请求 必须显式地带有允许请求的凭据和附加 header。\n\n例子：要在 fetch 中发送凭据，需要添加 credentials: "include" 选项：\n\nfetch(\'http://another.com\', {\n  credentials: "include"\n});\n\n\n1\n2\n3\n\n\n> 现在， fetch 将把源自 another.com 的 cookie 和我们的请求发送到该网站。\n\n如果服务器同意接受 带有凭据 的请求，则除了 Access-Control-Allow-Origin 外，服务器还应该在响应中添加 header Access-Control-Allow-Credentials: true 。\n\n响应头如下：\n\n200 OK\nAccess-Control-Allow-Origin: https://somewhere.pages\nAccess-Control-Allow-Credentials: true\n\n\n1\n2\n3\n\n\n注意：对于具有凭据的请求，禁止 Access-Control-Allow-Origin 使用星号 * 。如上所示，它必须有一个确切的源。这是另一项安全措施，以确保服务器真的知道它信任的发出此请求的是谁。',normalizedContent:'# fetch 的使用\n\nfetch() 方法是一种现代通用网络请求的方法：\n\nlet promise = fetch(url, [options])\n\n\n1\n\n * url ：请求网络路径；\n * options ：可选参数（方法、请求头等）。没有可选参数，默认请求方法 get 。\n\n使用 fetch 发送网络请求后，获取来自服务器的响应需要经过两个阶段：\n\n * 第一阶段：当服务器发送了响应头， fetch 返回的 promise 就使用内建的 response 类对象来 对响应头进行解析。\n   \n   > 可以在这个阶段，检查响应头，检查 http 状态确定请求是否成功了，这个阶段还没有响应体。\n   > \n   >  * 如果 fetch 无法建立一个 http 请求。例如，网络问题；请求网络地址不存在，此时 promise 就会 reject 。\n   >  * 异常的 http 状态，例如 404 或 500，不会导致出现 error。\n   \n   请求 http 状态可以通过两个属性查看：\n   \n   * status ：http 状态码；\n   * ok ：布尔值，如果 http 状态码为 200-299，则为 true 。\n   \n   🌰 例子：\n   \n   let response = await fetch(url);\n   \n   if (response.ok) { // 如果 http 状态码为 200-299\n     // 获取 response body（此方法会在下面解释）\n     let json = await response.json();\n   } else {\n     alert("http-error: " + response.status);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 第二阶段：获取 response 响应体，使用一个其他的方法调用。\n   \n   response 提供了多种基于 promise 的方法，来以不同的格式访问 resposne body：\n   \n   * response.text() ：读取 response ，并以文本形式返回 response；\n   * response.json() ：将 response 解析为 json；\n   * response.formdata() ：以 formdata 对象的形式返回 response；\n   * response.blob() ：以 blob 的形式返回 response；\n   * response.arraybuffer() ：以 arraybuffer 形式返回 response；\n   * response.body ：是 readablestream 对象，允许逐块读取 body 。\n\n🌰 例子 / 获取响应的 json 对象：\n\nlet url = \'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits\';\nlet response = await fetch(url);\n\nlet commits = await response.json();\nconsole.log(commits[0].author.login)\n\n\n1\n2\n3\n4\n5\n\n\n或者使用纯 promise ：\n\nfetch(\'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits\')\n  .then(response => response.json())\n  .then(commits => alert(commits[0].author.login));\n\n\n1\n2\n3\n\n\n注意\n\n一般只能选择一种读取 body 的方法。例如，如果已经使用了 response.text() 来获取 response ， 那么再用 response.json() 不会生效。因为响应体内容已经被处理过了。\n\n\n# 响应头 response header\n\nresponse header 是位于 response.headers 中的一个类似于 map 的 header 对象。（不是真正的 map 对象） 可以通过 名字 获取各个 header ，或者迭代。\n\n🌰 例子 / 获取响应头 content-type ：\n\nlet response = await fetch(\'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits\');\n\n// 获取一个 header\nalert(response.headers.get(\'content-type\')); // application/json; charset=utf-8\n\n// 迭代所有 header\nfor (let [key, value] of response.headers) {\n  alert(`${key} = ${value}`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 请求头 request header\n\n可以通过在使用 fetch 时，在选择参数中配置 headers 选项。\n\n🌰 例子：\n\nlet response = fetch(protectedurl, {\n  headers: {\n    authentication: \'secret\'\n  }\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 为了保证 http 的正确性和安全性，存在不能控制的请求头：https://fetch.spec.whatwg.org/#forbidden-header-name。仅有浏览器控制。\n\n\n# 请求方法 method\n\n要使用 默认方法 get 以外的请求方法，通过 method 选项配置 / 或者配置 body （request body， 常用 json）。\n\n🌰 例子 / 以 json 形式发送对象类型的请求：\n\nlet user = {\n  name: \'john\',\n  surname: \'smith\'\n}\n\nlet response = await fetch(\'/article/fetch/post/user\', {\n  method: \'post\',\n  headers: {\n    \'content-type\': \'application/json;charset=utf-8\'\n  },\n  body: json.stringify(user)\n});\n\nlet result = await response.json()\nconsole.log(result.message)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果请求的 body 是字符串，则 content-type 会默认设置为 text/plain;charset=utf-8 。所以如果要发送 json，需要设置请求头 content-type 控制编码类型。\n\n🌰 例子 / 获取 github 用户信息。\n\n>  * 创建一个异步函数 getusers(names) ，该函数接受 github 登录名数组作为输入，查询 github 以获取有关这些用户的信息，并返回 github 用户数组。\n>  * github 查询用户信息的 api：https://api.github.com/users/username\n\nasync function getusers(names) {\n  let jobs = [];\n  \n  for (let name of names) {\n    let job = fetch(`https://api.github.com/users/${name}`).then(\n      response => {\n        if (response.status != 200) return null;\n        else return response.json();\n      }, \n      error => {\n        return null;\n      }\n    );\n    jobs.push(job)\n  }\n  \n  let results = await promis.all(jobs)\n  return results;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n>  * 对于 每一个用户名都有一个 fetch 请求。求不应该相互等待。以便能够尽快获取到数据。如果任何一个请求失败了，或者没有这个用户，则函数应该返回 null 到结果数组中。\n>  * .then 调用紧跟在 fetch 后面，这样当收到响应时，它不会等待其他的 fetch ，而是立即开始读取 .json() 。通过将 .json() 直接添加到每个 fetch 中，就能确保每个 fetch 在收到响应时都会立即开始以 json 格式读取数据，而不会彼此等待。\n>  * 使用 await promise.all 将会等到所有的 fetch 都获取到响应数据才开始解析。\n\n\n# fetch 的应用\n\n\n# formdata\n\n用于发送 html 表单数据的类型对象。构造器使用如下：\n\nlet formdata = new formdata([form])\n\n\n1\n\n\n> [form] 是选择性提供的。如果提供了 html form 元素，就会自动捕获该 from 元素字段。\n\nformdata 的特殊之处在于网络方法。例如 fetch 可以接受一个 formdata 对象作为 body。它会被编码并发送出去，带有 content-type: multipart/form-data 。\n\n对于服务器，只是普通的表达数据提交。\n\n🌰 例子 / 提交简单的表单数据：\n\n<form id="formelem">\n  <input type="text" name="name" value="john">\n  <input type="text" name="surname" value="smith">\n  <input type="submit">\n</form>\n\n\n1\n2\n3\n4\n5\n\n\n<html>\n  <form id="formelem">\n    <input type="text" name="name" value="john">\n    <input type="text" name="surname" value="smith">\n    <input type="submit">\n\t</form>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\nlet formelem = document.queryselector("#formelem");\nformelem.onsubmit = async (e) => {\n  e.preventdefault\n  \n  let response = await fetch(\'/article/formdata/post/user\', {\n      method: \'post\',\n      body: new formdata(formelem)\n  });\n  \n  let result = await response.json()\n  console.log(result.message)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nformdata 提供的方法修改其中的字段：\n\n * formdata.append(name, value) ：添加具有给定 name 和 value 的表单字段；\n * formdata.append(name, blob, filename) ：添加一个相当于 <input type="file"> 输入类型的字段。第三个参数 filename 设置文件名（而不是表单字段名），因为它是用户文件系统中文件的名称；\n * formdata.delete(name) ：移除带有给定 name 的字段；\n * formdata.get(name) ：获取带有给定 name 的字段值；\n * formdata.has(name) ：如果存在带有给定 name 的字段，则返回 true ，否则返回 false 。\n\n> 技术上，可以拥有多个 相同名称 name 的字段。因此，多次调用 append 将会添加多个具有相同名称的字段。使用 set 方法，确保该字段只有一个唯一的值（移除之前存在的 name 字段）。\n\n * formdata.set(name, value)\n\n * formdata.set(name, blob, filename)\n   \n   与使用 append 的方法相同。\n\n可以使用 for ... of 循环迭代 formdata 中的字段与值：\n\nfor (let [name, value] of formdata) {\n  console.log(`${name} = ${value}`)\n}\n\n\n1\n2\n3\n\n\n# formdata 表单上传文件\n\nformdata 表单类型始终带有请求头 content-type: multipart/form-data 发送数据，这个编码允许发送文件 （ <input type="file"> 类型的输入框）。\n\n🌰 例子 / 上传图片：\n\n<form id="formelem">\n  <input type="text" name="firstname" value="john">\n  picture: <input type="file" name="picture" accept="image/*">\n  <input type="submit">\n</form>\n\n\n1\n2\n3\n4\n5\n\n\nformelem.onsubmit = async (e) => {\n    e.preventdefault();\n\n    let response = await fetch(\'/article/formdata/post/user-avatar\', {\n      method: \'post\',\n      body: new formdata(formelem)\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# fetch 跨源请求\n\n> 跨源请求（跨域） （跨源资源请求 cross-origin resource sharing / cors ）：发送到其他域、协议或者端口的请求。\n\n允许跨源请求的两种请求类型：\n\n * 安全请求；\n * 所有的其他请求。\n\n安全的请求需要满足两个条件：\n\n * 安全的请求方法： get 、 post 、 head ；\n * 安全的请求头 header 仅允许自定义下列的 header：\n   * accept ，\n   * accept-language ，\n   * content-language ，\n   * content-type 的值为 application/x-www-form-urlencoded ， multipart/form-data 或 text/plain 。\n\n> 除了安全的请求，没有符合上述条件的请求都为非安全的请求。例如，使用 put 请求方法，或者具有除了上述的自定义的请求头部。\n> \n> 安全的请求与非安全的请求的本质区别：\n> \n>  * 可以使用 <form> / script 进行安全请求，无需特殊的方法。\n>    \n>    > 使用安全的请求能兼容较旧的服务器，不用进行特殊的处理。\n> \n>  * 而发送非安全的请求，无法进行同样的工作。\n>    \n>    > 旧的服务器可能会认为此类请求来自具有特权的来源。当尝试发送一个非安全请求时，浏览器会发送一个特殊的预检请求到服务器，询问服务是否接受此类跨源请求吗。\n>    > \n>    > 服务器需要明确通过 header 确认，否则非安全的请求无法发送。\n\n对于安全的请求 cors：\n\n🌰 例子：\n\n从 https://somewhere.page 请求 https://anywhere.com/request ，发送的请求头为：\n\nget /request\nhost: anywhere.com\norigin: https://somewhere.page\n\n\n1\n2\n3\n\n\n> 请求头的 origin 会包含确切的请求来源（域名、协议、端口），没有路径。服务器检查 origin ，如果同意接受请求，就会在响应中添加一个特殊的 header access-control-allow-origin 。该 header 包含了允许的源，或者一个星号 * 。然后响应成功，否则报错。\n> \n> 浏览器作为中间人：确保了发送的跨源请求带有正确的 origin；检查响应头中是否带有许可 access-control-allow-origin ，如果存在，则允许 javascript 访问响应，否则将失败并报错。\n\n响应的请求头：\n\n200 ok\ncontent-type:text/html; charset=utf-8\naccess-control-allow-origin: *\n\n\n1\n2\n3\n\n\n> 对于响应头 （response header）处理跨源请求时，javascript 只能访问 安全的响应头：\n> \n>  * cache-control\n>  * content-language\n>  * content-type\n>  * expires\n>  * last-modified\n>  * pragma\n> \n> 对于其他的响应头都会导致出错。\n> \n> 要授予 javascript 对任何其他请求的访问权限，服务器必须发送 access-control-expose-headers header。它包含一个以逗号分隔的应该被设置为可访问的非安全 header 名称列表。\n\n对于非安全的请求：\n\n为了使用任何的 http 请求方法（不仅 get / post，还有可能是 patch、delete 或者其他）。\n\n * 浏览器发送预检请求，来请求许可：\n   \n   预检请求使用 options 方法，它没有 body，但是有三个 header：\n   \n   * access-control-request-method header 带有非安全请求的方法。\n   * access-control-request-headers header 提供一个以逗号分隔的非安全 http-header 列表。\n\n * 如果服务器同意处理请求，那么会进行响应以下响应头信息：\n   \n   * access-control-allow-origin 必须为 * 或进行请求的源才能允许此请求。\n   * access-control-allow-methods 必须具有允许的方法。\n   * access-control-allow-headers 必须具有一个允许的 header 列表。\n   * access-control-max-age 可以指定缓存此权限的秒数。因此，浏览器不是必须为满足给定权限的后续请求发送预检。\n\n🌰 例子：\n\n * 发送预检请求 /preflight request：\n   \n   options /service.json\n   host: site.com\n   origin: https://somewhere.info\n   access-control-request-method: patch\n   access-control-request-headers: content-type,api-key\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   >  * origin ： 来源。\n   > \n   >  * access-control-request-method ： 请求方法。\n   >  * access-control-request-headers ： 以逗号分隔的非安全 header 列表。\n\n * 服务器响应预检响应 /preflight response：\n   \n   access-control-allow-origin: https://somewhere.page\n   access-control-allow-methods: put,patch,delete\n   access-control-allow-headers: content-type,api-key\n   access-control-max-age: 86400\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 这将允许后续通信，否则会触发错误。如果服务器将来需要其他方法和 header，则可以通过将这些方法和 header 添加到列表中来预先允许它们。\n   > \n   > 可以看到 patch 在 access-control-allow-methods 中， content-type,api-key 在列表 access-control-allow-headers 中，因此它将发送主请求。\n   > \n   > access-control-max-age 带有一个表示秒的数字，则在给定的时间内，预检权限会被缓存。上面的响应将被缓存 86400 秒，也就是一天。在此时间范围内，后续请求将不会触发预检。假设它们符合缓存的配额，则将直接发送它们。\n\n * 发送实际请求：\n   \n   最后的请求头：\n   \n   patch /service.json\n   host: site.com\n   content-type: application/json\n   api-key: secret\n   origin: https://javascript.info\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   响应头应该添加 access-control-allow-origin 。\n   \n   例如：\n   \n   access-control-allow-origin: https://somewhere.pages\n   \n   \n   1\n   \n\n\n# fetch 请求凭证\n\n默认情况下，由 javascript 代码发起的跨源请求，不会带任何凭据（cookies 或者 http 网络认证）。\n\n> 因为具有凭据的请求比没有凭据的请求要强大得多。如果被允许，它会使用它们的凭据授予 javascript 代表用户行为和访问敏感信息的全部权力。\n\n所以要在 跨源请求 必须显式地带有允许请求的凭据和附加 header。\n\n例子：要在 fetch 中发送凭据，需要添加 credentials: "include" 选项：\n\nfetch(\'http://another.com\', {\n  credentials: "include"\n});\n\n\n1\n2\n3\n\n\n> 现在， fetch 将把源自 another.com 的 cookie 和我们的请求发送到该网站。\n\n如果服务器同意接受 带有凭据 的请求，则除了 access-control-allow-origin 外，服务器还应该在响应中添加 header access-control-allow-credentials: true 。\n\n响应头如下：\n\n200 ok\naccess-control-allow-origin: https://somewhere.pages\naccess-control-allow-credentials: true\n\n\n1\n2\n3\n\n\n注意：对于具有凭据的请求，禁止 access-control-allow-origin 使用星号 * 。如上所示，它必须有一个确切的源。这是另一项安全措施，以确保服务器真的知道它信任的发出此请求的是谁。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥤 JavaScript Fetch API",frontmatter:{title:"🥤 JavaScript Fetch API",date:"2022-06-01T14:32:25.000Z",permalink:"/pages/def96d/",categories:["🚶🏻 前端巩固基础","🍯 JavaScript AJAX 网络请求"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/37.%20%F0%9F%8D%AF%20JavaScript%20AJAX%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/02.%20%F0%9F%A5%A4%20JavaScript%20Fetch%20API.html",relativePath:"101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/02. 🥤 JavaScript Fetch API.md",key:"v-4f2a97f8",path:"/pages/def96d/",headers:[{level:3,title:"referrer / referrerPolocy",slug:"referrer-referrerpolocy",normalizedTitle:"referrer / referrerpolocy",charIndex:890},{level:3,title:"mode",slug:"mode",normalizedTitle:"mode",charIndex:474},{level:3,title:"credentials",slug:"credentials",normalizedTitle:"credentials",charIndex:513},{level:3,title:"cache",slug:"cache",normalizedTitle:"cache",charIndex:559},{level:3,title:"redirect",slug:"redirect",normalizedTitle:"redirect",charIndex:636},{level:3,title:"integrity",slug:"integrity",normalizedTitle:"integrity",charIndex:674},{level:3,title:"keepalive",slug:"keepalive",normalizedTitle:"keepalive",charIndex:730}],headersStr:"referrer / referrerPolocy mode credentials cache redirect integrity keepalive",content:'关于 Fetch 发送请求的一些选项 API。\n\n一个包含完全可能个 fetch 选项及默认值的列表：\n\nlet promise = fetch(url, {\n  method: "GET", // POST，PUT，DELETE，等。\n  headers: {\n    // 内容类型 header 值通常是自动设置的\n    // 取决于 request body\n    "Content-Type": "text/plain;charset=UTF-8"\n  },\n  body: undefined // string，FormData，Blob，BufferSource，或 URLSearchParams\n  referrer: "about:client", // 或 "" 以不发送 Referer header，\n  // 或者是当前源的 url\n  \n  referrerPolicy: "no-referrer-when-downgrade", // no-referrer，origin，same-origin...\n  mode: "cors", // same-origin，no-cors\n  credentials: "same-origin", // omit，include\n  cache: "default", // no-store，reload，no-cache，force-cache，或 only-if-cached\n  redirect: "follow", // manual，error\n  integrity: "", // 一个 hash，像 "sha256-abcdef1234567890"\n  keepalive: false, // true\n  signal: undefined, // AbortController 来中止请求\n  window: window // null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# referrer / referrerPolocy\n\n这些选项决定了 fetch 如何设置 HTTP 的 Referer header。通常，这个 header 是被自动设置的，并包含了发出请求的页面的 url。在大多数情况下，它一点也不重要，但有时出于安全考虑，删除或缩短它是有意义的。\n\n * ** referer 选项允许设置任何 Referer （在当前域的），或者移除它。** 要不发送 referer，可以将 referer 设置为空字符串：\n   \n   fetch(\'/page\', {\n     referrer: "" // 没有 Referer header\n   });\n   \n   \n   1\n   2\n   3\n   \n   \n   设置在当前域内的另一个 url：\n   \n   fetch(\'/page\', {\n     // 假设目前在 https://now.info\n     // 可以设置任何 Referer header，但必须是在当前域内的\n     referrer: "https://now.info/anotherpage"\n   });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * referrerPolicy 选项为 Referer 设置一般的规则。\n   \n   请求分为是那种类型：同源请求；跨源请求；从 HTTPS 到 HTTP 的请求 （从安全协议到不安全协议）。\n   \n   与 referrer 选项允许设置确切的 Referer 值不同， referrerPolicy 告诉浏览器针对各个请求类型的一般的规则。\n\n\n# mode\n\nmode 选项是一种安全措施，可以防止偶发的跨源请求。\n\n\n# credentials\n\ncredentials 选项指定 fetch 是否应该随请求发送 cookie 和 HTTP-Authorization header。\n\n\n# cache\n\n> 默认情况下， fetch 请求使用标准的 HTTP 缓存。就是说，它遵从 Expires ， Cache-Control header，发送 If-Modified-Since ，等。就像常规的 HTTP 请求那样。\n\n使用 cache 选项可以忽略 HTTP 缓存或者对其用法进行微调。\n\n\n# redirect\n\n通常来说， fetch 透明地遵循 HTTP 重定向，例如 301，302 等。\n\nredirect 选项允许对此进行更改。\n\n\n# integrity\n\nintegrity 选项允许检查响应是否与已知的预先校验和相匹配。\n\n\n# keepalive\n\nkeepalive 选项表示该请求可能会在网页关闭后继续存在。',normalizedContent:'关于 fetch 发送请求的一些选项 api。\n\n一个包含完全可能个 fetch 选项及默认值的列表：\n\nlet promise = fetch(url, {\n  method: "get", // post，put，delete，等。\n  headers: {\n    // 内容类型 header 值通常是自动设置的\n    // 取决于 request body\n    "content-type": "text/plain;charset=utf-8"\n  },\n  body: undefined // string，formdata，blob，buffersource，或 urlsearchparams\n  referrer: "about:client", // 或 "" 以不发送 referer header，\n  // 或者是当前源的 url\n  \n  referrerpolicy: "no-referrer-when-downgrade", // no-referrer，origin，same-origin...\n  mode: "cors", // same-origin，no-cors\n  credentials: "same-origin", // omit，include\n  cache: "default", // no-store，reload，no-cache，force-cache，或 only-if-cached\n  redirect: "follow", // manual，error\n  integrity: "", // 一个 hash，像 "sha256-abcdef1234567890"\n  keepalive: false, // true\n  signal: undefined, // abortcontroller 来中止请求\n  window: window // null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# referrer / referrerpolocy\n\n这些选项决定了 fetch 如何设置 http 的 referer header。通常，这个 header 是被自动设置的，并包含了发出请求的页面的 url。在大多数情况下，它一点也不重要，但有时出于安全考虑，删除或缩短它是有意义的。\n\n * ** referer 选项允许设置任何 referer （在当前域的），或者移除它。** 要不发送 referer，可以将 referer 设置为空字符串：\n   \n   fetch(\'/page\', {\n     referrer: "" // 没有 referer header\n   });\n   \n   \n   1\n   2\n   3\n   \n   \n   设置在当前域内的另一个 url：\n   \n   fetch(\'/page\', {\n     // 假设目前在 https://now.info\n     // 可以设置任何 referer header，但必须是在当前域内的\n     referrer: "https://now.info/anotherpage"\n   });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * referrerpolicy 选项为 referer 设置一般的规则。\n   \n   请求分为是那种类型：同源请求；跨源请求；从 https 到 http 的请求 （从安全协议到不安全协议）。\n   \n   与 referrer 选项允许设置确切的 referer 值不同， referrerpolicy 告诉浏览器针对各个请求类型的一般的规则。\n\n\n# mode\n\nmode 选项是一种安全措施，可以防止偶发的跨源请求。\n\n\n# credentials\n\ncredentials 选项指定 fetch 是否应该随请求发送 cookie 和 http-authorization header。\n\n\n# cache\n\n> 默认情况下， fetch 请求使用标准的 http 缓存。就是说，它遵从 expires ， cache-control header，发送 if-modified-since ，等。就像常规的 http 请求那样。\n\n使用 cache 选项可以忽略 http 缓存或者对其用法进行微调。\n\n\n# redirect\n\n通常来说， fetch 透明地遵循 http 重定向，例如 301，302 等。\n\nredirect 选项允许对此进行更改。\n\n\n# integrity\n\nintegrity 选项允许检查响应是否与已知的预先校验和相匹配。\n\n\n# keepalive\n\nkeepalive 选项表示该请求可能会在网页关闭后继续存在。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧉 JavaScript URL 对象",frontmatter:{title:"🧉 JavaScript URL 对象",date:"2022-06-01T14:46:00.000Z",permalink:"/pages/162aa2/",categories:["🚶🏻 前端巩固基础","🍯 JavaScript AJAX 网络请求"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/37.%20%F0%9F%8D%AF%20JavaScript%20AJAX%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/03.%F0%9F%A7%89%20JavaScript%20URL%20%E5%AF%B9%E8%B1%A1.html",relativePath:"101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/03.🧉 JavaScript URL 对象.md",key:"v-b9b0e048",path:"/pages/162aa2/",headers:[{level:2,title:"创建 URL 对象",slug:"创建-url-对象",normalizedTitle:"创建 url 对象",charIndex:97},{level:2,title:"URL 对象的组件属性",slug:"url-对象的组件属性",normalizedTitle:"url 对象的组件属性",charIndex:643},{level:2,title:"URL 对象中的参数",slug:"url-对象中的参数",normalizedTitle:"url 对象中的参数",charIndex:1228},{level:2,title:"编码 URL 字符串",slug:"编码-url-字符串",normalizedTitle:"编码 url 字符串",charIndex:2575}],headersStr:"创建 URL 对象 URL 对象的组件属性 URL 对象中的参数 编码 URL 字符串",content:"是 JavaScript 内建的 用于创建和解析 URL 的便捷接口。\n\n> 没有任何一个网络方法一定需要使用 URL 对象，字符串就足够了。使用 URL 对象可以对付一些特殊的情况。\n\n\n# 创建 URL 对象\n\nnew URL(url [, base])\n\n\n1\n\n\n * url ：完整的 URL 地址，或者设置了 base 可以只写路径。\n\n * base ： 可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL。\n\n🌰 例子：\n\nlet url = new URL('https://www.bilibili.com/');\n\n\n1\n\n\nlet url = new URL('https://www.bilibili.com/login');\n// 或者\nlet url = new URL('/login', 'https://www.bilibili.com/');\n\n\n1\n2\n3\n\n\n> 两种方式相同。\n\n🌰 例子 / 根据先用的 URL 对象创建新的 URL ：\n\nlet url = new URL('https://javascript.info/profile/admin');\nlet newUrl = new URL('tester', url);\n\nalert(newUrl); // https://javascript.info/profile/tester\n\n\n1\n2\n3\n4\n\n\n\n# URL 对象的组件属性\n\n * href ：完整的 URL，与 url.toString() 相同；\n * protocol ：网络协议。以冒号字符 : 结尾；\n * search ：以问号 ? 开头的一串参数；\n * hash ：以哈希字符 # 开头的数据。\n * 如果存在 HTTP 身份验证，则这里可能还会有 user 和 password 属性： http://login:password@site.com （较少用）\n\n🌰 例子：\n\nlet url = new URL('https://javascript.info/url');\n\nalert(url.protocol); // https:\nalert(url.host);     // javascript.info\nalert(url.pathname); // /url\n\n\n1\n2\n3\n4\n5\n\n\n\n\n> 可以将 URL 对象传递给其他方法（网络和大多数），而不是仅使用 URL 字符串。例如，在 fetch 或 XMLHttpRequest 中使用 URL 对象，几乎可以在任何需要 URL 字符串的地方都能使用 URL 对象。\n> \n> 通常， URL 对象可以替代字符串传递给任何方法，因为大多数方法都会执行字符串转换，这会将 URL 对象转换为具有完整 URL 的字符串。\n\n\n# URL 对象中的参数\n\n如果想要创建一个具有参数的 URL，例如： https://google.com/search?query=JavaScript 。可以在 URL 字符串中提供它们：\n\nnew URL('https://google.com/search?query=JavaScript')\n\n\n1\n\n\n> 当参数中包含空格，非拉丁字母等，参数就需要被编码。\n\n更多复杂的参数可以使用 URL 的属性 url.searchParams ，是 URL SearchParams 类型的对象。为搜索参数提供了简便的方法。\n\n * append(name, value) ：按照 name 和 value 添加参数；\n * delete(name) ：按照 name 移除参数；\n * get(name) ：按照 name 获取参数；\n * getAll(name) ：获取相同 name 的所有参数；\n * has(name) ：按照 name 检查参数是否存在；\n * set(name, value) ：set/replace 参数，\n * sort() ：按 name 对参数进行排序，很少使用；\n * …… 并且它是可迭代的，类似于 Map 。\n\n🌰 例子：\n\nlet url = new URL('https://google.com/search');\n\nurl.searchParams.set('q', 'test me!'); // 添加带有一个空格和一个 ! 的参数\nalert(url); // https://google.com/search?q=test+me%21\n\nurl.searchParams.set('tbs', 'qdr:y'); // 添加带有一个冒号 : 的参数\n\n// 参数会被自动编码\nalert(url); // https://google.com/search?q=test+me%21&tbs=qdr%3Ay\n\n// 遍历搜索参数（被解码）\nfor(let [name, value] of url.searchParams) {\n  alert(`${name}=${value}`); // q=test me!，然后是 tbs=qdr:y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nURL 的编码。\n\n> 标准定义了 URL 中允许哪些字符，不允许哪些字符。\n> \n> 那些不被允许的字符必须被编码，例如非拉丁字母和空格 —— 用其 UTF-8 代码代替，前缀为 % ，例如 %20 （由于历史原因，空格可以用 + 编码，但这是一个例外）。\n\n使用 URL 对象可以自动处理这些非规范的参数。\n\n🌰 例子：\n\nlet url = new URL('https://ru.wikipedia.org/wiki/Тест');\n\nurl.searchParams.set('key', 'ъ');\nalert(url); //https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A\n\n\n1\n2\n3\n4\n\n\n\n# 编码 URL 字符串\n\n在 URL 对象之前，使用 URL 字符串。可以通过一些内建函数 解码 / 编码 URL：\n\n * encodeURI ：编码整个 URL；\n * decodeURI ： 解码为编码前的状态；\n * encodeURIComponent ：编码 URL 组件，例如搜索参数，或者 hash，或者 pathname；\n * decodeURIComponent ：解码为编码前的状态；\n\n> encodeURI / encodeURIComponent 区别：\n> \n>  * 对于一个 URL 整体，可以使用 encodeURI ；对于 URL 参数，应该用 encodeURIComponent ；\n> \n>  * encodeURI 仅编码 URL 中完全禁止的字符。\n> \n>  * encodeURIComponent 也编码这类字符，此外，还编码 # ， $ ， & ， + ， , ， / ， : ， ; ， = ， ? 和 @ 字符。\n\n🌰 例子：\n\n// 在 url 路径中使用西里尔字符\nlet url = encodeURI('http://site.com/привет');\n\nalert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82\n\n\n1\n2\n3\n4\n\n\nlet music = encodeURIComponent('Rock&Roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=Rock%26Roll\n\n\n1\n2\n3\n4\n\n\n> 如果使用 encodeURI ：\n> \n> let music = encodeURI('Rock&Roll');\n> \n> let url = `https://google.com/search?q=${music}`;\n> alert(url); // https://google.com/search?q=Rock&Roll\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> encodeURI 没有对 & 进行编码，因为它对于整个 URL 来说是合法的字符。但是不应该拆分这个参数。\n\n所以对于每个搜索参数，应该使用 encodeURIComponent ，以将其正确地插入到 URL 字符串中。最安全的方式是对 name 和 value 都进行编码，除非能够绝对确保它只包含允许的字符。",normalizedContent:"是 javascript 内建的 用于创建和解析 url 的便捷接口。\n\n> 没有任何一个网络方法一定需要使用 url 对象，字符串就足够了。使用 url 对象可以对付一些特殊的情况。\n\n\n# 创建 url 对象\n\nnew url(url [, base])\n\n\n1\n\n\n * url ：完整的 url 地址，或者设置了 base 可以只写路径。\n\n * base ： 可选的 base url：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 url。\n\n🌰 例子：\n\nlet url = new url('https://www.bilibili.com/');\n\n\n1\n\n\nlet url = new url('https://www.bilibili.com/login');\n// 或者\nlet url = new url('/login', 'https://www.bilibili.com/');\n\n\n1\n2\n3\n\n\n> 两种方式相同。\n\n🌰 例子 / 根据先用的 url 对象创建新的 url ：\n\nlet url = new url('https://javascript.info/profile/admin');\nlet newurl = new url('tester', url);\n\nalert(newurl); // https://javascript.info/profile/tester\n\n\n1\n2\n3\n4\n\n\n\n# url 对象的组件属性\n\n * href ：完整的 url，与 url.tostring() 相同；\n * protocol ：网络协议。以冒号字符 : 结尾；\n * search ：以问号 ? 开头的一串参数；\n * hash ：以哈希字符 # 开头的数据。\n * 如果存在 http 身份验证，则这里可能还会有 user 和 password 属性： http://login:password@site.com （较少用）\n\n🌰 例子：\n\nlet url = new url('https://javascript.info/url');\n\nalert(url.protocol); // https:\nalert(url.host);     // javascript.info\nalert(url.pathname); // /url\n\n\n1\n2\n3\n4\n5\n\n\n\n\n> 可以将 url 对象传递给其他方法（网络和大多数），而不是仅使用 url 字符串。例如，在 fetch 或 xmlhttprequest 中使用 url 对象，几乎可以在任何需要 url 字符串的地方都能使用 url 对象。\n> \n> 通常， url 对象可以替代字符串传递给任何方法，因为大多数方法都会执行字符串转换，这会将 url 对象转换为具有完整 url 的字符串。\n\n\n# url 对象中的参数\n\n如果想要创建一个具有参数的 url，例如： https://google.com/search?query=javascript 。可以在 url 字符串中提供它们：\n\nnew url('https://google.com/search?query=javascript')\n\n\n1\n\n\n> 当参数中包含空格，非拉丁字母等，参数就需要被编码。\n\n更多复杂的参数可以使用 url 的属性 url.searchparams ，是 url searchparams 类型的对象。为搜索参数提供了简便的方法。\n\n * append(name, value) ：按照 name 和 value 添加参数；\n * delete(name) ：按照 name 移除参数；\n * get(name) ：按照 name 获取参数；\n * getall(name) ：获取相同 name 的所有参数；\n * has(name) ：按照 name 检查参数是否存在；\n * set(name, value) ：set/replace 参数，\n * sort() ：按 name 对参数进行排序，很少使用；\n * …… 并且它是可迭代的，类似于 map 。\n\n🌰 例子：\n\nlet url = new url('https://google.com/search');\n\nurl.searchparams.set('q', 'test me!'); // 添加带有一个空格和一个 ! 的参数\nalert(url); // https://google.com/search?q=test+me%21\n\nurl.searchparams.set('tbs', 'qdr:y'); // 添加带有一个冒号 : 的参数\n\n// 参数会被自动编码\nalert(url); // https://google.com/search?q=test+me%21&tbs=qdr%3ay\n\n// 遍历搜索参数（被解码）\nfor(let [name, value] of url.searchparams) {\n  alert(`${name}=${value}`); // q=test me!，然后是 tbs=qdr:y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nurl 的编码。\n\n> 标准定义了 url 中允许哪些字符，不允许哪些字符。\n> \n> 那些不被允许的字符必须被编码，例如非拉丁字母和空格 —— 用其 utf-8 代码代替，前缀为 % ，例如 %20 （由于历史原因，空格可以用 + 编码，但这是一个例外）。\n\n使用 url 对象可以自动处理这些非规范的参数。\n\n🌰 例子：\n\nlet url = new url('https://ru.wikipedia.org/wiki/тест');\n\nurl.searchparams.set('key', 'ъ');\nalert(url); //https://ru.wikipedia.org/wiki/%d0%a2%d0%b5%d1%81%d1%82?key=%d1%8a\n\n\n1\n2\n3\n4\n\n\n\n# 编码 url 字符串\n\n在 url 对象之前，使用 url 字符串。可以通过一些内建函数 解码 / 编码 url：\n\n * encodeuri ：编码整个 url；\n * decodeuri ： 解码为编码前的状态；\n * encodeuricomponent ：编码 url 组件，例如搜索参数，或者 hash，或者 pathname；\n * decodeuricomponent ：解码为编码前的状态；\n\n> encodeuri / encodeuricomponent 区别：\n> \n>  * 对于一个 url 整体，可以使用 encodeuri ；对于 url 参数，应该用 encodeuricomponent ；\n> \n>  * encodeuri 仅编码 url 中完全禁止的字符。\n> \n>  * encodeuricomponent 也编码这类字符，此外，还编码 # ， $ ， & ， + ， , ， / ， : ， ; ， = ， ? 和 @ 字符。\n\n🌰 例子：\n\n// 在 url 路径中使用西里尔字符\nlet url = encodeuri('http://site.com/привет');\n\nalert(url); // http://site.com/%d0%bf%d1%80%d0%b8%d0%b2%d0%b5%d1%82\n\n\n1\n2\n3\n4\n\n\nlet music = encodeuricomponent('rock&roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=rock%26roll\n\n\n1\n2\n3\n4\n\n\n> 如果使用 encodeuri ：\n> \n> let music = encodeuri('rock&roll');\n> \n> let url = `https://google.com/search?q=${music}`;\n> alert(url); // https://google.com/search?q=rock&roll\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> encodeuri 没有对 & 进行编码，因为它对于整个 url 来说是合法的字符。但是不应该拆分这个参数。\n\n所以对于每个搜索参数，应该使用 encodeuricomponent ，以将其正确地插入到 url 字符串中。最安全的方式是对 name 和 value 都进行编码，除非能够绝对确保它只包含允许的字符。",charsets:{cyrillic:!0,cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍶 JavaScript XMLHttpRequest",frontmatter:{title:"🍶 JavaScript XMLHttpRequest",date:"2022-06-01T15:30:02.000Z",permalink:"/pages/644542/",categories:["🚶🏻 前端巩固基础","🍯 JavaScript AJAX 网络请求"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/37.%20%F0%9F%8D%AF%20JavaScript%20AJAX%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/04.%20%F0%9F%8D%B6%20JavaScript%20XMLHttpRequest.html",relativePath:"101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/04. 🍶 JavaScript XMLHttpRequest.md",key:"v-0cbd5080",path:"/pages/644542/",headers:[{level:2,title:"使用 XMLHttpRequest",slug:"使用-xmlhttprequest",normalizedTitle:"使用 xmlhttprequest",charIndex:137},{level:3,title:"设置响应类型",slug:"设置响应类型",normalizedTitle:"设置响应类型",charIndex:2644}],headersStr:"使用 XMLHttpRequest 设置响应类型",content:"XMLHttpRequest 是一个内建的浏览器对象，它允许使用 JavaScript 发送 HTTP 请求。它可以操作任何数据，而不仅仅是 XML 格式。可以用它来上传 / 下载文件，跟踪进度等。\n\n> 如今 JavaScript 中一般使用 fetch 方法。\n\n\n# 使用 XMLHttpRequest\n\n一般使用它发送网络请求有两种执行模式：\n\n * 同步；\n * 异步；\n\n异步发送网络请求的步骤：\n\n * 创建 XMLHttpRequest ：\n   \n   let xhr = new XMLHttpRequest();\n   \n   \n   1\n   \n   \n   > XMLHttpRequest 的构造器没有参数。\n\n * 初始化 xhr ：\n   \n   xhr.open(method, URL, [async, user, password])\n   \n   \n   1\n   \n   * method ：HTTP 方法；\n   * URL ：请求 URL。通常是一个字符串或者是 URL 对象；\n   * async ：如果显式地设置为 false ，那么请求将会以同步的方式处理；\n   * user / password ：HTTP 基本身份验证（如果需要的话）的登录名和密码。\n\n * 发送请求， send 方法会建立连接，并将请求发送到服务器。：\n   \n   xhr.send([body])\n   \n   \n   1\n   \n   * body ：可选参数，包含了 request body。\n\n * 监听 xhr 事件以获取响应。常用的事件：\n   \n   * load ：当请求完成（即使 HTTP 状态为 400 或 500 等），并且响应已完全下载。\n   * error ：当无法发出请求，例如网络中断或者无效的 URL。\n   * progress ：在下载响应期间定期触发，报告已经下载了多少。\n   \n   xhr.onload = function() {\n     alert(`Loaded: ${xhr.status} ${xhr.response}`);\n   };\n   \n   xhr.onerror = function() { // 仅在根本无法发出请求时触发\n     alert(`Network Error`);\n   };\n   \n   xhr.onprogress = function(event) { // 定期触发\n     // event.loaded —— 已经下载了多少字节\n     // event.lengthComputable = true，当服务器发送了 Content-Length header 时\n     // event.total —— 总字节数（如果 lengthComputable 为 true）\n     alert(`Received ${event.loaded} of ${event.total}`);\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n🌰 例子 / 一个完整的 xhr 发送请求实例：\n\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/article/xmlhttprequest/example/load');\n\nxhr.send();\n\nxhr.onload = function() {\n  if (xhr.status != 200) { // 分析响应的 HTTP 状态\n    alert(`Error ${xhr.status}: ${xhr.statusText}`); // 例如 404: Not Found\n  } else { // 显示结果\n    alert(`Done, got ${xhr.response.length} bytes`); // response 是服务器响应\n  }\n};\n\nxhr.onprogress = function(event) {\n  if (event.lengthComputable) {\n    alert(`Received ${event.loaded} of ${event.total} bytes`);\n  } else {\n    alert(`Received ${event.loaded} bytes`); // 没有 Content-Length\n  }\n\n};\n\nxhr.onerror = function() {\n  alert(\"Request failed\");\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当服务器有了响应，则 xhr 属性中有：\n\n * status ：HTTP 状态码（ 200 ， 404 ， 403 等，如果出现非 HTTP 错误，则为 0 ）\n * statusText ：HTTP 状态消息（字符串）（状态码为 200 对应于 OK ， 404 对应于 Not Found ， 403 对应于 Forbidden 。）\n * response ：服务器响应体。\n\n对请求设置超时属性 timeout ：\n\nxhr.timeout = 10000; // timeout 单位是 ms，此处即 10 秒\n\n\n1\n\n\n> 如果在给定时间内请求没有成功执行，请求就会被取消，并且触发 timeout 事件。\n\n对请求 URL 设置参数：\n\nlet url = new URL('https://google.com/search');\nurl.searchParams.set('q', 'test me!');\n\n// 参数 'q' 被编码\nxhr.open('GET', url); // https://google.com/search?q=test+me%21\n\n\n1\n2\n3\n4\n5\n\n\n> 使用 URL 对象，并且 searchParams.set 方法，确保参数的正确编码。\n\n\n# 设置响应类型\n\n可以使用 xhr.responseType 属性来设置响应格式：\n\n * \"\" （默认）响应格式为字符串，\n * \"text\" —— 响应格式为字符串，\n * \"arraybuffer\" —— 响应格式为 ArrayBuffer （对于二进制数据，请参见 ArrayBuffer，二进制数组），\n * \"blob\" —— 响应格式为 Blob （对于二进制数据，请参见 Blob），\n * \"document\" —— 响应格式为 XML document（可以使用 XPath 和其他 XML 方法）或 HTML document（基于接收数据的 MIME 类型）\n * \"json\" —— 响应格式为 JSON（自动解析）。",normalizedContent:"xmlhttprequest 是一个内建的浏览器对象，它允许使用 javascript 发送 http 请求。它可以操作任何数据，而不仅仅是 xml 格式。可以用它来上传 / 下载文件，跟踪进度等。\n\n> 如今 javascript 中一般使用 fetch 方法。\n\n\n# 使用 xmlhttprequest\n\n一般使用它发送网络请求有两种执行模式：\n\n * 同步；\n * 异步；\n\n异步发送网络请求的步骤：\n\n * 创建 xmlhttprequest ：\n   \n   let xhr = new xmlhttprequest();\n   \n   \n   1\n   \n   \n   > xmlhttprequest 的构造器没有参数。\n\n * 初始化 xhr ：\n   \n   xhr.open(method, url, [async, user, password])\n   \n   \n   1\n   \n   * method ：http 方法；\n   * url ：请求 url。通常是一个字符串或者是 url 对象；\n   * async ：如果显式地设置为 false ，那么请求将会以同步的方式处理；\n   * user / password ：http 基本身份验证（如果需要的话）的登录名和密码。\n\n * 发送请求， send 方法会建立连接，并将请求发送到服务器。：\n   \n   xhr.send([body])\n   \n   \n   1\n   \n   * body ：可选参数，包含了 request body。\n\n * 监听 xhr 事件以获取响应。常用的事件：\n   \n   * load ：当请求完成（即使 http 状态为 400 或 500 等），并且响应已完全下载。\n   * error ：当无法发出请求，例如网络中断或者无效的 url。\n   * progress ：在下载响应期间定期触发，报告已经下载了多少。\n   \n   xhr.onload = function() {\n     alert(`loaded: ${xhr.status} ${xhr.response}`);\n   };\n   \n   xhr.onerror = function() { // 仅在根本无法发出请求时触发\n     alert(`network error`);\n   };\n   \n   xhr.onprogress = function(event) { // 定期触发\n     // event.loaded —— 已经下载了多少字节\n     // event.lengthcomputable = true，当服务器发送了 content-length header 时\n     // event.total —— 总字节数（如果 lengthcomputable 为 true）\n     alert(`received ${event.loaded} of ${event.total}`);\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n🌰 例子 / 一个完整的 xhr 发送请求实例：\n\nlet xhr = new xmlhttprequest();\n\nxhr.open('get', '/article/xmlhttprequest/example/load');\n\nxhr.send();\n\nxhr.onload = function() {\n  if (xhr.status != 200) { // 分析响应的 http 状态\n    alert(`error ${xhr.status}: ${xhr.statustext}`); // 例如 404: not found\n  } else { // 显示结果\n    alert(`done, got ${xhr.response.length} bytes`); // response 是服务器响应\n  }\n};\n\nxhr.onprogress = function(event) {\n  if (event.lengthcomputable) {\n    alert(`received ${event.loaded} of ${event.total} bytes`);\n  } else {\n    alert(`received ${event.loaded} bytes`); // 没有 content-length\n  }\n\n};\n\nxhr.onerror = function() {\n  alert(\"request failed\");\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当服务器有了响应，则 xhr 属性中有：\n\n * status ：http 状态码（ 200 ， 404 ， 403 等，如果出现非 http 错误，则为 0 ）\n * statustext ：http 状态消息（字符串）（状态码为 200 对应于 ok ， 404 对应于 not found ， 403 对应于 forbidden 。）\n * response ：服务器响应体。\n\n对请求设置超时属性 timeout ：\n\nxhr.timeout = 10000; // timeout 单位是 ms，此处即 10 秒\n\n\n1\n\n\n> 如果在给定时间内请求没有成功执行，请求就会被取消，并且触发 timeout 事件。\n\n对请求 url 设置参数：\n\nlet url = new url('https://google.com/search');\nurl.searchparams.set('q', 'test me!');\n\n// 参数 'q' 被编码\nxhr.open('get', url); // https://google.com/search?q=test+me%21\n\n\n1\n2\n3\n4\n5\n\n\n> 使用 url 对象，并且 searchparams.set 方法，确保参数的正确编码。\n\n\n# 设置响应类型\n\n可以使用 xhr.responsetype 属性来设置响应格式：\n\n * \"\" （默认）响应格式为字符串，\n * \"text\" —— 响应格式为字符串，\n * \"arraybuffer\" —— 响应格式为 arraybuffer （对于二进制数据，请参见 arraybuffer，二进制数组），\n * \"blob\" —— 响应格式为 blob （对于二进制数据，请参见 blob），\n * \"document\" —— 响应格式为 xml document（可以使用 xpath 和其他 xml 方法）或 html document（基于接收数据的 mime 类型）\n * \"json\" —— 响应格式为 json（自动解析）。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥃 JavaScript 长轮询 WebSocket",frontmatter:{title:"🥃 JavaScript 长轮询 WebSocket",date:"2022-06-01T15:56:48.000Z",permalink:"/pages/527bc8/",categories:["🚶🏻 前端巩固基础","🍯 JavaScript AJAX 网络请求"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/37.%20%F0%9F%8D%AF%20JavaScript%20AJAX%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/05.%20%F0%9F%A5%83%20JavaScript%20%E9%95%BF%E8%BD%AE%E8%AF%A2%20WebSocket.html",relativePath:"101. 🚶🏻 前端巩固基础/37. 🍯 JavaScript AJAX 网络请求/05. 🥃 JavaScript 长轮询 WebSocket.md",key:"v-e881c4e6",path:"/pages/527bc8/",headers:[{level:2,title:"常规轮询",slug:"常规轮询",normalizedTitle:"常规轮询",charIndex:90},{level:2,title:"长轮询",slug:"长轮询",normalizedTitle:"长轮询",charIndex:0},{level:2,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:40},{level:3,title:"建立连接",slug:"建立连接",normalizedTitle:"建立连接",charIndex:467},{level:3,title:"数据传输",slug:"数据传输",normalizedTitle:"数据传输",charIndex:4086},{level:3,title:"限速",slug:"限速",normalizedTitle:"限速",charIndex:5793},{level:3,title:"关闭连接",slug:"关闭连接",normalizedTitle:"关闭连接",charIndex:366},{level:3,title:"连接状态",slug:"连接状态",normalizedTitle:"连接状态",charIndex:6926},{level:2,title:"Server Sent Events",slug:"server-sent-events",normalizedTitle:"server sent events",charIndex:1372},{level:3,title:"获取消息",slug:"获取消息",normalizedTitle:"获取消息",charIndex:894},{level:3,title:"跨源请求",slug:"跨源请求",normalizedTitle:"跨源请求",charIndex:8203},{level:3,title:"重新连接",slug:"重新连接",normalizedTitle:"重新连接",charIndex:661},{level:3,title:"连接 id",slug:"连接-id",normalizedTitle:"连接 id",charIndex:9218},{level:3,title:"连接状态",slug:"连接状态-2",normalizedTitle:"连接状态",charIndex:6926},{level:3,title:"连接事件",slug:"连接事件",normalizedTitle:"连接事件",charIndex:9830}],headersStr:"常规轮询 长轮询 WebSocket 建立连接 数据传输 限速 关闭连接 连接状态 Server Sent Events 获取消息 跨源请求 重新连接 连接 id 连接状态 连接事件",content:'长轮询是 与服务器保持持久连接 的最简单的方式，它不使用任何特定的协议。（例如 WebSocket 或者 Server Sent Event）比较容易实现，适用较多场景。\n\n\n# 常规轮询\n\n定期轮询是从服务器获取新信息的最简单的方式（定期向服务器发送请求）。作为响应，服务器首先通知自己，客户端处于在线状态，然后发送目前为止的消息包。\n\n使用定期轮询的缺点：\n\n * 消息传递存在延迟（两个请求之间）；\n * 即使没有消息，服务器也会每隔 10 秒被请求轰炸一次，即使用户切换到其他地方或者处于休眠状态，也是如此。就性能而言，这是一个很大的负担。\n\n> 对于小型服务或许可行。\n\n\n# 长轮询\n\n是轮询服务器的一种更好的方式，容易实现，可以无延迟传递消息。长轮询流程为：\n\n * 请求发送到服务器；\n * 服务器在有消息时之前不会关闭连接；\n * 当消息出现时，服务器将对其做出响应；\n * 浏览器立即发送新的请求。\n\n对于此方法，浏览器发出一个请求并与服务器之间建立起一个 挂起的连接 的情况是标准的。仅在有消息被传递时，才会重新建立连接。\n\n🌰 例子 / 实现长轮询客户端的函数：\n\nasync function subscribe() {\n  let response = await fetch("/subsribe")\n  \n  if (response.status == 502) {\n    // 502 超时错误\n    // 超时导致连接挂起时间过长，远程服务器或者代理会关闭该连接\n    // 重新连接\n    await subsribe()\n  } else if (response.status != 200) {\n    // 发生错误时\n    showMessage(response.status) \n    \n    // 一秒后重新连接\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    await subsribe();\n  } else {\n    // 获取消息\n    let message = await response.text();\n  \t// 显示消息\n    showMessage(message)\n    // 调用 subsribe() 获取下一条消息\n    await subsribe();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> subscribe 函数发起了一个 fetch ，然后等待响应，处理它，并再次调用自身。\n\n提示\n\n对于服务器，应该可以处理许多挂起的连接。某些服务器架构是每个连接对应一个进程，导致进程数和连接数一样多，而每个进程都会消耗相当多的内存。因此，过多的连接会消耗掉全部内存。\n\n长轮询的使用场景：\n\n * 在消息很少的情况下，长轮询很有效。\n * 如果消息比较频繁，那么上面描绘的请求 - 接收消息的图表就会变成锯状状。每个消息都是一个单独的请求，并带有 header，身份验证等增加了开销。此时，应该选择另一种方法（WebSocket 或者 Server Sent Events）\n\n\n# WebSocket\n\n是一个提供浏览器和服务器之间 建立持久连接 来 交换数据 的方法协议。数据可以作为「数据包」在两个方向上传递，而不会断开连接和其他 HTTP 请求。\n\n对于需要连续数据交换的服务，例如网络游戏，实时交易系统等，WebSocket 尤其有用。\n\n * WebSocket 没有跨源限制。\n * 浏览器对 WebSocket 支持很好。\n * 可以发送 / 接收字符串和二进制数据。\n\n创建 WebSocket 连接，需要在 URL 使用特殊的协议 ws ：\n\nlet socket = new WebSocket("ws://javascript.info");\n\n\n1\n\n\n> 加密的 wss:// 协议，类似于 HTTPS。\n> \n> wss:// 协议不仅是被加密的，而且更可靠。因为 ws:// 中数据不是加密的，对于任何中间人来说其数据都是可见的。并且，旧的代理服务器不了解 WebSocket，可能会因为奇怪的 header 而中止连接； wss:// 是基于 TLS 的 WebSocket，类似于 HTTPS 是基于 TLS 的 HTTP），传输安全层在发送方对数据进行了加密，在接收方进行解密。因此，数据包是通过代理加密传输的。它们看不到传输的里面的内容，且会让这些数据通过。\n\nWebSocket 被建立后，就可以监听 socket 的事件：\n\n * open ：连接已建立；\n * message ：接收到数据；\n * error ：连接出错；\n * close ：连接已关闭；\n\n使用 WebSocket 发送数据使用 socket.send(data) 方法。\n\n🌰 例子 / 使用 WebSocket 发送数据：\n\nlet socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");\n\nsocket.onopen = function(e) {\n  alert("[open] Connection established");\n  alert("Sending to server");\n  socket.send("My name is John"); // 发送消息\n};\n\nsocket.onmessage = function(event) {\n  alert(`[message] Data received from server: ${event.data}`);\n};\n\nsocket.onclose = function(event) {\n  if (event.wasClean) {\n    alert(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);\n  } else {\n    // 例如服务器进程被杀死或网络中断\n    // 在这种情况下，event.code 通常为 1006\n    alert(\'[close] Connection died\');\n  }\n};\n\nsocket.onerror = function(error) {\n  alert(`[error] ${error.message}`);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 建立连接\n\n当 new WebSocket(url) 创建时，建立起了连接。\n\n连接期间，浏览器使用响应头 header 发送请求询问服务器是否支持 WebSocket， 如果支持才会以 WebSocket 协议继续进行。\n\n🌰 例子 / new WebSocket("wss://javascript.info/chat") 请求头内容：\n\nGET /chat\nHost: javascript.info\nOrigin: https://javascript.info\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\n\n\n1\n2\n3\n4\n5\n6\n7\n\n>  * Origin ：客户端页面的源。WebSocket 对象是 原生支持跨源 的。没有特殊的 header 或其他限制。~~ 旧的服务器无法处理 WebSocket，因此不存在兼容性问题。~~ 但是 Origin 很重要，它允许服务器决定是否使用 WebSocket 与该网站通信；\n>  * Connection: Upgrade ：表示客户端想要 更改协议；\n>  * Upgrade: websocket ：更改请求的协议为 websocket ；\n>  * Sec-WebSocket-Key ：浏览器随机生成的安全密钥。\n>  * Sec-WebSocket-Version ：WebSocket 协议版本，当前为 13。`\n\n注意不可以模拟 WebSocket 握手，例如使用 XMLHttpRequest 或 fetch 设置这些请求头的内容。\n\n如果服务器同意切换为 WebSocket 协议，则响应头内容为（响应码为 101 ）：\n\n101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n\n\n1\n2\n3\n4\n\n\n> 同时，这里的 Sec-WebSocket-Accept 是 Sec-WebSocket-Key ，浏览器使用它保证响应与请求相对应。\n\n然后就可以使用 WebSocket 协议传输数据。并且之后可以看到，它的结构不是 HTTP。\n\nWebSocket 拓展和子协议：\n\n点击查看\n\nWebSocket 的其他 header： Sec-WebSocket-Extensions 和 Sec-WebSocket-Protocol ，它们描述了扩展和子协议。\n\n * Sec-WebSocket-Extensions: deflate-frame ：表示浏览器 支持数据压缩。这个拓展与数据传输有关，拓展了 WebSocket 的协议的功能。\n   \n   Sec-WebSocket-Extensions header 由浏览器自动发送，其中包含其支持的所有扩展的列表。\n\n * Sec-WebSocket-Protocol: soap, wamp ：表示不仅要传输数据，还要传输 SOAP / WAMP 协议中的数据。\n   \n   这个可选的 header 是使用 new WebSocket 的第二个参数设置的。它是子协议数组，例如，如果想使用 SOAP 或 WAMP：\n   \n   let socket = new WebSocket("wss://javascript.info/chat", ["soap", "wamp"]);\n   \n   \n   1\n   \n\n服务器应该使用同意使用的协议和扩展的列表进行响应。\n\n例如：\n\n * 请求头 header：\n   \n   GET /chat\n   Host: javascript.info\n   Upgrade: websocket\n   Connection: Upgrade\n   Origin: https://javascript.info\n   Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\n   Sec-WebSocket-Version: 13\n   Sec-WebSocket-Extensions: deflate-frame\n   Sec-WebSocket-Protocol: soap, wamp\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 响应头 header：\n   \n   101 Switching Protocols\n   Upgrade: websocket\n   Connection: Upgrade\n   Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n   Sec-WebSocket-Extensions: deflate-frame\n   Sec-WebSocket-Protocol: soap\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 数据传输\n\nWebSocket 通信由 frames （即数据片段）组成，可以从任何一方发送，并且有以下几种类型：\n\n * text frames ：文本数据。\n * binary data frames ：二进制数据。\n * ping/pong frames ：用于检查服务器发送的链接。浏览器会自动响应它们。\n * conection close frames …\n\n在浏览器里，仅仅使用 文本数据或者二进制数据。\n\n使用 WebSocket 的 .send 方法发送文本或者二进制数据：\n\n * socket.send(body) 调用允许 body 是字符串或二进制格式，包括 Blob ， ArrayBuffer 等。不需要额外的设置：直接发送它们就可以了。\n\n当接收到数据，文本总是以 字符串 形式呈现。对于二进制数据，在 Blob 和 ArrayBuffer 格式之间选择。（由 socket.binaryType 属性设置的，默认为 "blob" ，因此二进制数据通常以 Blob 对象呈现。）\n\n> Blob 高级二进制对象，可以直接与 <a> ， <img> 及其他标签集成在一起。所以为默认的格式。\n> \n> 要访问单个数据字节，可以修改为 arrayBuffer ：\n> \n> socket.binaryType = "arraybuffer";\n> socket.onmessage = (event) => {\n>   // event.data 可以是文本（如果是文本），也可以是 arraybuffer（如果是二进制数据）\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n\n# 限速\n\n> 如果应用程序正在生成大量的数据，但是用户的网速很慢。\n> \n> 此时，可以反复调用 socket.send(data) 。但是数据将会被缓存（缓冲存储）在内存中，并且只能在网速允许的情况下尽快将数据发送出去。\n\nsocket.bufferedAmount 属性储存了 目前已缓冲的字节数，等待通过网络发送。\n\n🌰 例子 / 使用该属性查看 socket 是否真的可以用于传输：\n\nsetInterval(()=> {\n  if(socket.bufferedAmount == 0) {\n    socket.send(moreData());\n  }\n}, 100)\n\n\n1\n2\n3\n4\n5\n\n\n> 每 100 ms 检查一次 socket 。仅当所有现有的数据都已被发送出去时（即缓存中没有数据），再发送更多数据。\n\n\n# 关闭连接\n\n通常，当一方想要关闭连接时（浏览器和服务器都具有相同的权限），它们会发送一个带有 数字码 和文本形式的原因的 connection close frame 。\n\n关闭连接的方法：\n\nsocket.close([code], [reason])\n\n\n1\n\n * [code] ：可选的 特殊的 WebSocket 关闭码。\n * [reason] ：可选的 描述关闭原因的字符串。\n\n当另一方通过 close 事件处理器获取了 关闭码和关闭原因 时。例如：\n\n// 关闭方：\nsocket.close(1000, "Work complete");\n\n// 另一方\nsocket.onclose = event => {\n  // event.code === 1000\n  // event.reason === "Work complete"\n  // event.wasClean === true (clean close)\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 可以通过 event 获取这些属性。\n\n通常的 WebSocket 关闭码：\n\n点击查看\n>  * 1000 ：默认，正常关闭（如果没有指明 code 时使用它），\n>  * 1006 ：没有办法手动设定这个数字码，表示连接丢失（没有 close frame）。\n> \n> 其他数字码，例如：\n> \n>  * 1001 ：一方正在离开，例如服务器正在关闭，或者浏览器离开了该页面，\n>  * 1009 ：消息太大，无法处理，\n>  * 1011 ： 服务器上发生意外错误，\n>  * ……。\n> \n> RFC6455, §7.4.1\n\n注意，小于 1000 的码都是被保留的，如果我们尝试设置这样的码，将会出现错误。\n\n\n# 连接状态\n\n要获取连接状态，可以通过带有值的 socket.readyState 属性：\n\n * 0 —— “CONNECTING”：连接还未建立，\n * 1 —— “OPEN”：通信中，\n * 2 —— “CLOSING”：连接关闭中，\n * 3 —— “CLOSED”：连接已关闭。\n\n\n# Server Sent Events\n\nServer-Sent Event 规范描述了一个内建的类 EventSource 。能保持服务器的连接，并且允许从中接收事件。（与 WebSocket 连接类似，是持久的连接）\n\n> WebSocket 与 EventSource 的区别：\n> \n> WEBSOCKET          EVENTSOURCE\n> 双向：客户端和服务端都能交换消息   单向：仅服务端能发送消息\n> 二进制和文本数据           仅文本数据\n> WebSocket 协议       常规 HTTP 协议\n> \n> 相比 WebSocket， EventSource 更加简单。\n> \n> 当需要从服务器接收一个数据流，可能是 聊天消息或者其他信息。 EventSource 支持自动重新连接，而在 WebSocket 需要手动实现。并且它支持常规的 HTTP 协议。\n\n\n# 获取消息\n\n使用 new EventSource(url) 。浏览器将会连接到 url 并保持连接打开，等待事件。\n\n服务器响应的状态码应该为 200，header 为 Content-Type: text/event-stream ，然后保持此连接并以一种特殊的格式写入消息。例如：\n\ndata: Message 1\n\ndata: Message 2\n\ndata: Message 3\ndata: of two lines\n\n\n1\n2\n3\n4\n5\n6\n\n * data ：消息文本， : 后的空格可选；\n * 消息以两个换行符 \\n\\n 分隔。\n * 要发送一个换行符 \\n 的消息，在要换行的位置立即再发送一个 data: （上面的第三条消息）。\n\n实际运用中，复杂的消息一般使用 JSON 编码后发送。换行符在其中编码为 \\n ，因此不需要多行 data: 消息。\n\n🌰 例子：\n\ndata: {"user":"John","message":"First line\\n Second line"}\n\n\n1\n\n\n对于这样类型的信息，都会生成一个 message 事件：\n\nlet eventSource = new EventSource("/events/subsribe");\n\neventSource.onmessage = function(event) {\n  console.log("new Message", event.data) \n  // 对于上面的数据流将打印三次\n}\n// 或 eventSource.addEventListener(\'message\', ...)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 跨源请求\n\nEventSource 支持跨源请求，就像 fetch 和任何其他网络方法。\n\n所以 EventSource 可以使用任何 URL：\n\nlet source = new EventSource("https://another-site.com/events");\n\n\n1\n\n\n远程服务器将会获取到 Origin header，并且必须以 Access-Control-Allow-Origin 响应来处理。要传递凭证（credentials），应该设置附加选项 withCredentials ，如下：\n\nlet source = new EventSource("https://another-site.com/events", {\n  withCredentials: true\n});\n\n\n1\n2\n3\n\n\n\n# 重新连接\n\nnew EventSource 连接到服务器，如果连接断开，则重新连接。每次重新连接之间有一点小的延迟，默认为几秒钟。\n\n服务器可以使用 retry: 来 设置需要的延迟响应时间（以毫秒为单位）。\n\nretry: 15000\ndata: Hello, I set the reconnection delay to 15 seconds\n\n\n1\n2\n\n * retry: 既可以与某些数据一起出现，也可以作为独立的消息出现。\n\n在重新连接之前，浏览器需要等待设定的延迟响应时间。例如，如果浏览器知道（从操作系统）此时没有网络连接，它会等到连接出现，然后重试。\n\n * 如果服务器想要浏览器 停止重新连接，那么应该使用 HTTP 状态码 204 进行响应；\n\n * 如果浏览器想要 关闭连接，则应该调用 eventSource.close() ；\n   \n   let eventSource new EventSource(...);\n   \n   eventSource.close();\n   \n   \n   1\n   2\n   3\n   \n\n * 如果响应具有不正确的 Content-Type 或者 HTTP 状态码不是 301，307，200 和 204，则不会进行重新连接。在这种情况下，将会发出 error 错误事件，并且浏览器不会重新连接。\n\n> 当连接被关闭时，则无法「重新打开」该连接。如果要重新连接，就要重新创建 new EventSource() 。\n\n\n# 连接 id\n\n当一个连接由于网络问题而中断时，客户端和服务器都无法确定哪些消息已经收到哪些没有收到。为了正确地恢复连接，每条消息都应该有一个 id 字段，如下：\n\ndata: Message 1\nid: 1\n\ndata: Message 2\nid: 2\n\ndata: Message 3\ndata: of two lines\nid: 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当收到具有 id 的消息时，浏览器会：\n\n * 将属性 eventSource.lastEventId 设置为其值。\n * 重新连接后，发送带有 id 的 header Last-Event-ID ，以便服务器可以重新发送后面的消息。\n\n> 注意： id 被服务器附加到 data 消息后，以确保在收到消息后 lastEventId 会被更新。\n\n\n# 连接状态\n\nEventSource 对象有 readyState 连接状态属性，该属性具有：\n\n * EventSource.CONNECTING = 0; ：连接中或者重新连接中；\n * EventSource.OPEN = 1; ：已连接；\n * EventSource.CLOSED = 2; ：连接已关闭；\n\n对象创建完成或者连接断开后，它始终是 EventSource.CONNECTING （等于 0 ）。\n\n可以通过查询该属性获得 EventSource 的状态。\n\n\n# 连接事件\n\nEventSource 的对象会默认生成三个事件：\n\n * message ：收到消息，可以用 event.data 访问。\n * open ：连接已打开。\n * error ：无法建立连接，例如，服务器返回 HTTP 500 状态码。\n\n服务器可以在事件开始时使用 event: ... 指定另一种类型事件。\n\n🌰 例子：\n\nevent: join\ndata: Bob\n\ndata: Hello\n\nevent: leave\ndata: Bob\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n处理自定义事件 join ，必须使用 addEventListener ：\n\neventSource.addEventListener(\'join\', event => {\n  alert(`Joined ${event.data}`);\n});\n\neventSource.addEventListener(\'message\', event => {\n  alert(`Said: ${event.data}`);\n});\n\neventSource.addEventListener(\'leave\', event => {\n  alert(`Left ${event.data}`);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:'长轮询是 与服务器保持持久连接 的最简单的方式，它不使用任何特定的协议。（例如 websocket 或者 server sent event）比较容易实现，适用较多场景。\n\n\n# 常规轮询\n\n定期轮询是从服务器获取新信息的最简单的方式（定期向服务器发送请求）。作为响应，服务器首先通知自己，客户端处于在线状态，然后发送目前为止的消息包。\n\n使用定期轮询的缺点：\n\n * 消息传递存在延迟（两个请求之间）；\n * 即使没有消息，服务器也会每隔 10 秒被请求轰炸一次，即使用户切换到其他地方或者处于休眠状态，也是如此。就性能而言，这是一个很大的负担。\n\n> 对于小型服务或许可行。\n\n\n# 长轮询\n\n是轮询服务器的一种更好的方式，容易实现，可以无延迟传递消息。长轮询流程为：\n\n * 请求发送到服务器；\n * 服务器在有消息时之前不会关闭连接；\n * 当消息出现时，服务器将对其做出响应；\n * 浏览器立即发送新的请求。\n\n对于此方法，浏览器发出一个请求并与服务器之间建立起一个 挂起的连接 的情况是标准的。仅在有消息被传递时，才会重新建立连接。\n\n🌰 例子 / 实现长轮询客户端的函数：\n\nasync function subscribe() {\n  let response = await fetch("/subsribe")\n  \n  if (response.status == 502) {\n    // 502 超时错误\n    // 超时导致连接挂起时间过长，远程服务器或者代理会关闭该连接\n    // 重新连接\n    await subsribe()\n  } else if (response.status != 200) {\n    // 发生错误时\n    showmessage(response.status) \n    \n    // 一秒后重新连接\n    await new promise(resolve => settimeout(resolve, 1000));\n    await subsribe();\n  } else {\n    // 获取消息\n    let message = await response.text();\n  \t// 显示消息\n    showmessage(message)\n    // 调用 subsribe() 获取下一条消息\n    await subsribe();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> subscribe 函数发起了一个 fetch ，然后等待响应，处理它，并再次调用自身。\n\n提示\n\n对于服务器，应该可以处理许多挂起的连接。某些服务器架构是每个连接对应一个进程，导致进程数和连接数一样多，而每个进程都会消耗相当多的内存。因此，过多的连接会消耗掉全部内存。\n\n长轮询的使用场景：\n\n * 在消息很少的情况下，长轮询很有效。\n * 如果消息比较频繁，那么上面描绘的请求 - 接收消息的图表就会变成锯状状。每个消息都是一个单独的请求，并带有 header，身份验证等增加了开销。此时，应该选择另一种方法（websocket 或者 server sent events）\n\n\n# websocket\n\n是一个提供浏览器和服务器之间 建立持久连接 来 交换数据 的方法协议。数据可以作为「数据包」在两个方向上传递，而不会断开连接和其他 http 请求。\n\n对于需要连续数据交换的服务，例如网络游戏，实时交易系统等，websocket 尤其有用。\n\n * websocket 没有跨源限制。\n * 浏览器对 websocket 支持很好。\n * 可以发送 / 接收字符串和二进制数据。\n\n创建 websocket 连接，需要在 url 使用特殊的协议 ws ：\n\nlet socket = new websocket("ws://javascript.info");\n\n\n1\n\n\n> 加密的 wss:// 协议，类似于 https。\n> \n> wss:// 协议不仅是被加密的，而且更可靠。因为 ws:// 中数据不是加密的，对于任何中间人来说其数据都是可见的。并且，旧的代理服务器不了解 websocket，可能会因为奇怪的 header 而中止连接； wss:// 是基于 tls 的 websocket，类似于 https 是基于 tls 的 http），传输安全层在发送方对数据进行了加密，在接收方进行解密。因此，数据包是通过代理加密传输的。它们看不到传输的里面的内容，且会让这些数据通过。\n\nwebsocket 被建立后，就可以监听 socket 的事件：\n\n * open ：连接已建立；\n * message ：接收到数据；\n * error ：连接出错；\n * close ：连接已关闭；\n\n使用 websocket 发送数据使用 socket.send(data) 方法。\n\n🌰 例子 / 使用 websocket 发送数据：\n\nlet socket = new websocket("wss://javascript.info/article/websocket/demo/hello");\n\nsocket.onopen = function(e) {\n  alert("[open] connection established");\n  alert("sending to server");\n  socket.send("my name is john"); // 发送消息\n};\n\nsocket.onmessage = function(event) {\n  alert(`[message] data received from server: ${event.data}`);\n};\n\nsocket.onclose = function(event) {\n  if (event.wasclean) {\n    alert(`[close] connection closed cleanly, code=${event.code} reason=${event.reason}`);\n  } else {\n    // 例如服务器进程被杀死或网络中断\n    // 在这种情况下，event.code 通常为 1006\n    alert(\'[close] connection died\');\n  }\n};\n\nsocket.onerror = function(error) {\n  alert(`[error] ${error.message}`);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 建立连接\n\n当 new websocket(url) 创建时，建立起了连接。\n\n连接期间，浏览器使用响应头 header 发送请求询问服务器是否支持 websocket， 如果支持才会以 websocket 协议继续进行。\n\n🌰 例子 / new websocket("wss://javascript.info/chat") 请求头内容：\n\nget /chat\nhost: javascript.info\norigin: https://javascript.info\nconnection: upgrade\nupgrade: websocket\nsec-websocket-key: iv8io/9s+lyfgzwcxczp8q==\nsec-websocket-version: 13\n\n\n1\n2\n3\n4\n5\n6\n7\n\n>  * origin ：客户端页面的源。websocket 对象是 原生支持跨源 的。没有特殊的 header 或其他限制。~~ 旧的服务器无法处理 websocket，因此不存在兼容性问题。~~ 但是 origin 很重要，它允许服务器决定是否使用 websocket 与该网站通信；\n>  * connection: upgrade ：表示客户端想要 更改协议；\n>  * upgrade: websocket ：更改请求的协议为 websocket ；\n>  * sec-websocket-key ：浏览器随机生成的安全密钥。\n>  * sec-websocket-version ：websocket 协议版本，当前为 13。`\n\n注意不可以模拟 websocket 握手，例如使用 xmlhttprequest 或 fetch 设置这些请求头的内容。\n\n如果服务器同意切换为 websocket 协议，则响应头内容为（响应码为 101 ）：\n\n101 switching protocols\nupgrade: websocket\nconnection: upgrade\nsec-websocket-accept: hsblbudtkk24srzeotbulzalc2g=\n\n\n1\n2\n3\n4\n\n\n> 同时，这里的 sec-websocket-accept 是 sec-websocket-key ，浏览器使用它保证响应与请求相对应。\n\n然后就可以使用 websocket 协议传输数据。并且之后可以看到，它的结构不是 http。\n\nwebsocket 拓展和子协议：\n\n点击查看\n\nwebsocket 的其他 header： sec-websocket-extensions 和 sec-websocket-protocol ，它们描述了扩展和子协议。\n\n * sec-websocket-extensions: deflate-frame ：表示浏览器 支持数据压缩。这个拓展与数据传输有关，拓展了 websocket 的协议的功能。\n   \n   sec-websocket-extensions header 由浏览器自动发送，其中包含其支持的所有扩展的列表。\n\n * sec-websocket-protocol: soap, wamp ：表示不仅要传输数据，还要传输 soap / wamp 协议中的数据。\n   \n   这个可选的 header 是使用 new websocket 的第二个参数设置的。它是子协议数组，例如，如果想使用 soap 或 wamp：\n   \n   let socket = new websocket("wss://javascript.info/chat", ["soap", "wamp"]);\n   \n   \n   1\n   \n\n服务器应该使用同意使用的协议和扩展的列表进行响应。\n\n例如：\n\n * 请求头 header：\n   \n   get /chat\n   host: javascript.info\n   upgrade: websocket\n   connection: upgrade\n   origin: https://javascript.info\n   sec-websocket-key: iv8io/9s+lyfgzwcxczp8q==\n   sec-websocket-version: 13\n   sec-websocket-extensions: deflate-frame\n   sec-websocket-protocol: soap, wamp\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 响应头 header：\n   \n   101 switching protocols\n   upgrade: websocket\n   connection: upgrade\n   sec-websocket-accept: hsblbudtkk24srzeotbulzalc2g=\n   sec-websocket-extensions: deflate-frame\n   sec-websocket-protocol: soap\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 数据传输\n\nwebsocket 通信由 frames （即数据片段）组成，可以从任何一方发送，并且有以下几种类型：\n\n * text frames ：文本数据。\n * binary data frames ：二进制数据。\n * ping/pong frames ：用于检查服务器发送的链接。浏览器会自动响应它们。\n * conection close frames …\n\n在浏览器里，仅仅使用 文本数据或者二进制数据。\n\n使用 websocket 的 .send 方法发送文本或者二进制数据：\n\n * socket.send(body) 调用允许 body 是字符串或二进制格式，包括 blob ， arraybuffer 等。不需要额外的设置：直接发送它们就可以了。\n\n当接收到数据，文本总是以 字符串 形式呈现。对于二进制数据，在 blob 和 arraybuffer 格式之间选择。（由 socket.binarytype 属性设置的，默认为 "blob" ，因此二进制数据通常以 blob 对象呈现。）\n\n> blob 高级二进制对象，可以直接与 <a> ， <img> 及其他标签集成在一起。所以为默认的格式。\n> \n> 要访问单个数据字节，可以修改为 arraybuffer ：\n> \n> socket.binarytype = "arraybuffer";\n> socket.onmessage = (event) => {\n>   // event.data 可以是文本（如果是文本），也可以是 arraybuffer（如果是二进制数据）\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n\n# 限速\n\n> 如果应用程序正在生成大量的数据，但是用户的网速很慢。\n> \n> 此时，可以反复调用 socket.send(data) 。但是数据将会被缓存（缓冲存储）在内存中，并且只能在网速允许的情况下尽快将数据发送出去。\n\nsocket.bufferedamount 属性储存了 目前已缓冲的字节数，等待通过网络发送。\n\n🌰 例子 / 使用该属性查看 socket 是否真的可以用于传输：\n\nsetinterval(()=> {\n  if(socket.bufferedamount == 0) {\n    socket.send(moredata());\n  }\n}, 100)\n\n\n1\n2\n3\n4\n5\n\n\n> 每 100 ms 检查一次 socket 。仅当所有现有的数据都已被发送出去时（即缓存中没有数据），再发送更多数据。\n\n\n# 关闭连接\n\n通常，当一方想要关闭连接时（浏览器和服务器都具有相同的权限），它们会发送一个带有 数字码 和文本形式的原因的 connection close frame 。\n\n关闭连接的方法：\n\nsocket.close([code], [reason])\n\n\n1\n\n * [code] ：可选的 特殊的 websocket 关闭码。\n * [reason] ：可选的 描述关闭原因的字符串。\n\n当另一方通过 close 事件处理器获取了 关闭码和关闭原因 时。例如：\n\n// 关闭方：\nsocket.close(1000, "work complete");\n\n// 另一方\nsocket.onclose = event => {\n  // event.code === 1000\n  // event.reason === "work complete"\n  // event.wasclean === true (clean close)\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 可以通过 event 获取这些属性。\n\n通常的 websocket 关闭码：\n\n点击查看\n>  * 1000 ：默认，正常关闭（如果没有指明 code 时使用它），\n>  * 1006 ：没有办法手动设定这个数字码，表示连接丢失（没有 close frame）。\n> \n> 其他数字码，例如：\n> \n>  * 1001 ：一方正在离开，例如服务器正在关闭，或者浏览器离开了该页面，\n>  * 1009 ：消息太大，无法处理，\n>  * 1011 ： 服务器上发生意外错误，\n>  * ……。\n> \n> rfc6455, §7.4.1\n\n注意，小于 1000 的码都是被保留的，如果我们尝试设置这样的码，将会出现错误。\n\n\n# 连接状态\n\n要获取连接状态，可以通过带有值的 socket.readystate 属性：\n\n * 0 —— “connecting”：连接还未建立，\n * 1 —— “open”：通信中，\n * 2 —— “closing”：连接关闭中，\n * 3 —— “closed”：连接已关闭。\n\n\n# server sent events\n\nserver-sent event 规范描述了一个内建的类 eventsource 。能保持服务器的连接，并且允许从中接收事件。（与 websocket 连接类似，是持久的连接）\n\n> websocket 与 eventsource 的区别：\n> \n> websocket          eventsource\n> 双向：客户端和服务端都能交换消息   单向：仅服务端能发送消息\n> 二进制和文本数据           仅文本数据\n> websocket 协议       常规 http 协议\n> \n> 相比 websocket， eventsource 更加简单。\n> \n> 当需要从服务器接收一个数据流，可能是 聊天消息或者其他信息。 eventsource 支持自动重新连接，而在 websocket 需要手动实现。并且它支持常规的 http 协议。\n\n\n# 获取消息\n\n使用 new eventsource(url) 。浏览器将会连接到 url 并保持连接打开，等待事件。\n\n服务器响应的状态码应该为 200，header 为 content-type: text/event-stream ，然后保持此连接并以一种特殊的格式写入消息。例如：\n\ndata: message 1\n\ndata: message 2\n\ndata: message 3\ndata: of two lines\n\n\n1\n2\n3\n4\n5\n6\n\n * data ：消息文本， : 后的空格可选；\n * 消息以两个换行符 \\n\\n 分隔。\n * 要发送一个换行符 \\n 的消息，在要换行的位置立即再发送一个 data: （上面的第三条消息）。\n\n实际运用中，复杂的消息一般使用 json 编码后发送。换行符在其中编码为 \\n ，因此不需要多行 data: 消息。\n\n🌰 例子：\n\ndata: {"user":"john","message":"first line\\n second line"}\n\n\n1\n\n\n对于这样类型的信息，都会生成一个 message 事件：\n\nlet eventsource = new eventsource("/events/subsribe");\n\neventsource.onmessage = function(event) {\n  console.log("new message", event.data) \n  // 对于上面的数据流将打印三次\n}\n// 或 eventsource.addeventlistener(\'message\', ...)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 跨源请求\n\neventsource 支持跨源请求，就像 fetch 和任何其他网络方法。\n\n所以 eventsource 可以使用任何 url：\n\nlet source = new eventsource("https://another-site.com/events");\n\n\n1\n\n\n远程服务器将会获取到 origin header，并且必须以 access-control-allow-origin 响应来处理。要传递凭证（credentials），应该设置附加选项 withcredentials ，如下：\n\nlet source = new eventsource("https://another-site.com/events", {\n  withcredentials: true\n});\n\n\n1\n2\n3\n\n\n\n# 重新连接\n\nnew eventsource 连接到服务器，如果连接断开，则重新连接。每次重新连接之间有一点小的延迟，默认为几秒钟。\n\n服务器可以使用 retry: 来 设置需要的延迟响应时间（以毫秒为单位）。\n\nretry: 15000\ndata: hello, i set the reconnection delay to 15 seconds\n\n\n1\n2\n\n * retry: 既可以与某些数据一起出现，也可以作为独立的消息出现。\n\n在重新连接之前，浏览器需要等待设定的延迟响应时间。例如，如果浏览器知道（从操作系统）此时没有网络连接，它会等到连接出现，然后重试。\n\n * 如果服务器想要浏览器 停止重新连接，那么应该使用 http 状态码 204 进行响应；\n\n * 如果浏览器想要 关闭连接，则应该调用 eventsource.close() ；\n   \n   let eventsource new eventsource(...);\n   \n   eventsource.close();\n   \n   \n   1\n   2\n   3\n   \n\n * 如果响应具有不正确的 content-type 或者 http 状态码不是 301，307，200 和 204，则不会进行重新连接。在这种情况下，将会发出 error 错误事件，并且浏览器不会重新连接。\n\n> 当连接被关闭时，则无法「重新打开」该连接。如果要重新连接，就要重新创建 new eventsource() 。\n\n\n# 连接 id\n\n当一个连接由于网络问题而中断时，客户端和服务器都无法确定哪些消息已经收到哪些没有收到。为了正确地恢复连接，每条消息都应该有一个 id 字段，如下：\n\ndata: message 1\nid: 1\n\ndata: message 2\nid: 2\n\ndata: message 3\ndata: of two lines\nid: 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当收到具有 id 的消息时，浏览器会：\n\n * 将属性 eventsource.lasteventid 设置为其值。\n * 重新连接后，发送带有 id 的 header last-event-id ，以便服务器可以重新发送后面的消息。\n\n> 注意： id 被服务器附加到 data 消息后，以确保在收到消息后 lasteventid 会被更新。\n\n\n# 连接状态\n\neventsource 对象有 readystate 连接状态属性，该属性具有：\n\n * eventsource.connecting = 0; ：连接中或者重新连接中；\n * eventsource.open = 1; ：已连接；\n * eventsource.closed = 2; ：连接已关闭；\n\n对象创建完成或者连接断开后，它始终是 eventsource.connecting （等于 0 ）。\n\n可以通过查询该属性获得 eventsource 的状态。\n\n\n# 连接事件\n\neventsource 的对象会默认生成三个事件：\n\n * message ：收到消息，可以用 event.data 访问。\n * open ：连接已打开。\n * error ：无法建立连接，例如，服务器返回 http 500 状态码。\n\n服务器可以在事件开始时使用 event: ... 指定另一种类型事件。\n\n🌰 例子：\n\nevent: join\ndata: bob\n\ndata: hello\n\nevent: leave\ndata: bob\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n处理自定义事件 join ，必须使用 addeventlistener ：\n\neventsource.addeventlistener(\'join\', event => {\n  alert(`joined ${event.data}`);\n});\n\neventsource.addeventlistener(\'message\', event => {\n  alert(`said: ${event.data}`);\n});\n\neventsource.addeventlistener(\'leave\', event => {\n  alert(`left ${event.data}`);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⛴  JavaScript 回调函数引入",frontmatter:{title:"⛴  JavaScript 回调函数引入",date:"2022-05-15T10:01:00.000Z",permalink:"/pages/1d9ea1/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/01.%20%E2%9B%B4%20%20JavaScript%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%BC%95%E5%85%A5.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/01. ⛴  JavaScript 回调函数引入.md",key:"v-d47abc7a",path:"/pages/1d9ea1/",headers:[{level:2,title:"更好地理解 JavaScript 中的回调函数",slug:"更好地理解-javascript-中的回调函数",normalizedTitle:"更好地理解 javascript 中的回调函数",charIndex:2},{level:2,title:"回调中的回调",slug:"回调中的回调",normalizedTitle:"回调中的回调",charIndex:1326},{level:2,title:"回调中出错",slug:"回调中出错",normalizedTitle:"回调中出错",charIndex:1911},{level:2,title:"回调地狱 / 厄尔金字塔",slug:"回调地狱-厄尔金字塔",normalizedTitle:"回调地狱 / 厄尔金字塔",charIndex:2693},{level:3,title:"更多异步编程的例子",slug:"更多异步编程的例子",normalizedTitle:"更多异步编程的例子",charIndex:3888}],headersStr:"更好地理解 JavaScript 中的回调函数 回调中的回调 回调中出错 回调地狱 / 厄尔金字塔 更多异步编程的例子",content:"# 更好地理解 JavaScript 中的回调函数\n\n🌰 例子：\n\n封装一个 加载脚本到页面 的函数：\n\nfunction loadScript(src) {\n\tlet script = document.createElement('script');\n  script.src = src;\n  document.head.append(script);\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 这个函数使用给定的 src 将一个新的、动态创建的标签 <script src=\"…\"> 插入到文档中。浏览器将自动开始加载它，并在加载完成后执行它。\n\n使用时，在给定路径下加载并执行脚本：\n\nloadScript('/my/script.js');\n\n\n1\n\n\n但是，脚本是异步调用的。因为它从现在开始加载，但是这个家在函数执行完成后才能运行。\n\n如果 loadScript(...) 之下有 任何其他代码，它们不会等到 加载脚本完成后 才运行，如下：\n\n假设脚本中有函数，想要在加载完成之后，立即执行它：\n\nloadScript('/my/script.js'); // 这个脚本有 \"function newFunction() {…}\"\n\nnewFunction(); // 没有这个函数！\n\n\n1\n2\n3\n\n\n> 这样调用脚本里面的函数是没有效果的。因为浏览器可能没有时间家在脚本。并且 loadScript 函数并没有提供跟踪加载完成的方法。脚本加载并最终运行，仅此而已。\n\n要使用脚本中的函数和变量，要了解脚本何时加载完成。给 loadScript 函数 添加第二个参数 作为回调函数，该函数应该在脚本加载完成时执行：\n\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(script); //*\n\n  document.head.append(script);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在，要想调用脚本中的函数就可以在 callback 中写了：\n\nloadScript('/my/script.js', function() {\n  newFunction();\n  // ...\n});\n\n\n1\n2\n3\n4\n\n\n完整的使用例子：\n\nloadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n  alert(`Cool, the script ${script.src} is loaded`);\n  alert( _ ); // 所加载的脚本中声明的函数\n});\n\n\n1\n2\n3\n4\n\n\n通过这个 「加载脚本」的例子，了解到这是 「基于回调」的一步编程风格。异步执行某项功能的函数，应该提供一个 callback 参数用于在 相应事件完成时 调用。\n\n\n# 回调中的回调\n\n🌰 延续上面的 加载脚本 例子 / 如果想要在加载完第一个脚本后，加载另一个脚本、或者更多，把下一个加载写在回调中：\n\nloadScript('/my/script.js', function(script) {\n\n  alert(`Cool, the ${script.src} is loaded, let's load one more`);\n\n  loadScript('/my/script2.js', function(script) {\n    alert(`Cool, the second script is loaded`);\n  });\n\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n谁用例子：\n\nloadScript('/my/script.js', function(script) {\n\n  loadScript('/my/script2.js', function(script) {\n\n    loadScript('/my/script3.js', function(script) {\n      // ...加载完所有脚本后继续\n    });\n\n  });\n\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 每一个加载脚本的行为都写在了 回调 中。这样的代码行为其实并不好。\n\n\n# 回调中出错\n\n🌰 在上面 加载脚本 的例子，并没有处理 加载出错（无法读取文件） 的情况。所以要添加处理错误的步骤：\n\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果加载成功就运行 callback 。加载失败，就调用 callback(error) 。\n\n使用例子：\n\nloadScript('/my/script.js', function(error, script) {\n  if (error) {\n    // 处理 error\n  } else {\n    // 脚本加载成功\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这种处理错误的风格成为「错误有限回调」（error-first callback）：\n> \n>  * callback 的第一个参数是为 error 而保留的。一旦出现 error， callback(err) 就会被调用。\n>  * 第二个参数（和下一个参数，如果需要的话）用于成功的结果。此时 callback(null, result1, result2…) 就会被调用。\n> \n> 因此，这个单一的回调函数同时具有 处理错误（报告错误）和返回结果的作用。\n\n\n# 回调地狱 / 厄尔金字塔\n\n🌰 例子 / 继续 加载脚本 ，有很多脚本需要嵌套调用加载：\n\nloadScript('1.js', function(error, script) {\n\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', function(error, script) {\n      if (error) {\n        handleError(error);\n      } else {\n        // ...\n        loadScript('3.js', function(error, script) {\n          if (error) {\n            handleError(error);\n          } else {\n            // ...加载完所有脚本后继续 (*)\n          }\n        });\n\n      }\n    });\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n随着代码的嵌套增加，代码层次变得更深层，维护难度提高。\n\n虽然可以通过将每个回调划分出来独立的函数尝试解决这个问题：\n\nloadScript('1.js', step1);\n\nfunction step1(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', step2);\n  }\n}\n\nfunction step2(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('3.js', step3);\n  }\n}\n\nfunction step3(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...加载完所有脚本后继续 (*)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n但是代码的可读性很差，需要在各个代码块之间跳转。并且这些函数应该是一次性使用的， step 之类的命名带来命名空间的混乱。\n\n要避免 回调地狱 的问题，解决方法最好之一是 Promise 的使用。\n\n\n# 更多异步编程的例子\n\n异步编程相关例子（回调函数）：\n\n * fs 文件操作：\n   \n   require('fs').readFile('./index.html', (err,data)=>{})\n   \n   \n   1\n   \n\n * 数据库操作；\n\n * AJAX 请求：\n   \n     $.get('/server', (data)=>{})\n   \n   \n   1\n   \n\n * 定时器：\n   \n   setTimeout(()=>{}, 2000);\n   \n   \n   1\n   ",normalizedContent:"# 更好地理解 javascript 中的回调函数\n\n🌰 例子：\n\n封装一个 加载脚本到页面 的函数：\n\nfunction loadscript(src) {\n\tlet script = document.createelement('script');\n  script.src = src;\n  document.head.append(script);\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 这个函数使用给定的 src 将一个新的、动态创建的标签 <script src=\"…\"> 插入到文档中。浏览器将自动开始加载它，并在加载完成后执行它。\n\n使用时，在给定路径下加载并执行脚本：\n\nloadscript('/my/script.js');\n\n\n1\n\n\n但是，脚本是异步调用的。因为它从现在开始加载，但是这个家在函数执行完成后才能运行。\n\n如果 loadscript(...) 之下有 任何其他代码，它们不会等到 加载脚本完成后 才运行，如下：\n\n假设脚本中有函数，想要在加载完成之后，立即执行它：\n\nloadscript('/my/script.js'); // 这个脚本有 \"function newfunction() {…}\"\n\nnewfunction(); // 没有这个函数！\n\n\n1\n2\n3\n\n\n> 这样调用脚本里面的函数是没有效果的。因为浏览器可能没有时间家在脚本。并且 loadscript 函数并没有提供跟踪加载完成的方法。脚本加载并最终运行，仅此而已。\n\n要使用脚本中的函数和变量，要了解脚本何时加载完成。给 loadscript 函数 添加第二个参数 作为回调函数，该函数应该在脚本加载完成时执行：\n\nfunction loadscript(src, callback) {\n  let script = document.createelement('script');\n  script.src = src;\n\n  script.onload = () => callback(script); //*\n\n  document.head.append(script);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在，要想调用脚本中的函数就可以在 callback 中写了：\n\nloadscript('/my/script.js', function() {\n  newfunction();\n  // ...\n});\n\n\n1\n2\n3\n4\n\n\n完整的使用例子：\n\nloadscript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n  alert(`cool, the script ${script.src} is loaded`);\n  alert( _ ); // 所加载的脚本中声明的函数\n});\n\n\n1\n2\n3\n4\n\n\n通过这个 「加载脚本」的例子，了解到这是 「基于回调」的一步编程风格。异步执行某项功能的函数，应该提供一个 callback 参数用于在 相应事件完成时 调用。\n\n\n# 回调中的回调\n\n🌰 延续上面的 加载脚本 例子 / 如果想要在加载完第一个脚本后，加载另一个脚本、或者更多，把下一个加载写在回调中：\n\nloadscript('/my/script.js', function(script) {\n\n  alert(`cool, the ${script.src} is loaded, let's load one more`);\n\n  loadscript('/my/script2.js', function(script) {\n    alert(`cool, the second script is loaded`);\n  });\n\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n谁用例子：\n\nloadscript('/my/script.js', function(script) {\n\n  loadscript('/my/script2.js', function(script) {\n\n    loadscript('/my/script3.js', function(script) {\n      // ...加载完所有脚本后继续\n    });\n\n  });\n\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 每一个加载脚本的行为都写在了 回调 中。这样的代码行为其实并不好。\n\n\n# 回调中出错\n\n🌰 在上面 加载脚本 的例子，并没有处理 加载出错（无法读取文件） 的情况。所以要添加处理错误的步骤：\n\nfunction loadscript(src, callback) {\n  let script = document.createelement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new error(`script load error for ${src}`));\n\n  document.head.append(script);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果加载成功就运行 callback 。加载失败，就调用 callback(error) 。\n\n使用例子：\n\nloadscript('/my/script.js', function(error, script) {\n  if (error) {\n    // 处理 error\n  } else {\n    // 脚本加载成功\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这种处理错误的风格成为「错误有限回调」（error-first callback）：\n> \n>  * callback 的第一个参数是为 error 而保留的。一旦出现 error， callback(err) 就会被调用。\n>  * 第二个参数（和下一个参数，如果需要的话）用于成功的结果。此时 callback(null, result1, result2…) 就会被调用。\n> \n> 因此，这个单一的回调函数同时具有 处理错误（报告错误）和返回结果的作用。\n\n\n# 回调地狱 / 厄尔金字塔\n\n🌰 例子 / 继续 加载脚本 ，有很多脚本需要嵌套调用加载：\n\nloadscript('1.js', function(error, script) {\n\n  if (error) {\n    handleerror(error);\n  } else {\n    // ...\n    loadscript('2.js', function(error, script) {\n      if (error) {\n        handleerror(error);\n      } else {\n        // ...\n        loadscript('3.js', function(error, script) {\n          if (error) {\n            handleerror(error);\n          } else {\n            // ...加载完所有脚本后继续 (*)\n          }\n        });\n\n      }\n    });\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n随着代码的嵌套增加，代码层次变得更深层，维护难度提高。\n\n虽然可以通过将每个回调划分出来独立的函数尝试解决这个问题：\n\nloadscript('1.js', step1);\n\nfunction step1(error, script) {\n  if (error) {\n    handleerror(error);\n  } else {\n    // ...\n    loadscript('2.js', step2);\n  }\n}\n\nfunction step2(error, script) {\n  if (error) {\n    handleerror(error);\n  } else {\n    // ...\n    loadscript('3.js', step3);\n  }\n}\n\nfunction step3(error, script) {\n  if (error) {\n    handleerror(error);\n  } else {\n    // ...加载完所有脚本后继续 (*)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n但是代码的可读性很差，需要在各个代码块之间跳转。并且这些函数应该是一次性使用的， step 之类的命名带来命名空间的混乱。\n\n要避免 回调地狱 的问题，解决方法最好之一是 promise 的使用。\n\n\n# 更多异步编程的例子\n\n异步编程相关例子（回调函数）：\n\n * fs 文件操作：\n   \n   require('fs').readfile('./index.html', (err,data)=>{})\n   \n   \n   1\n   \n\n * 数据库操作；\n\n * ajax 请求：\n   \n     $.get('/server', (data)=>{})\n   \n   \n   1\n   \n\n * 定时器：\n   \n   settimeout(()=>{}, 2000);\n   \n   \n   1\n   ",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚊 Promise 的基本使用",frontmatter:{title:"🚊 Promise 的基本使用",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/948475/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/02.%20%F0%9F%9A%8A%20Promise%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/02. 🚊 Promise 的基本使用.md",key:"v-1609c2a2",path:"/pages/948475/",headers:[{level:2,title:"理解 Promise",slug:"理解-promise",normalizedTitle:"理解 promise",charIndex:2},{level:2,title:"Promis 语法",slug:"promis-语法",normalizedTitle:"promis 语法",charIndex:343},{level:3,title:"Promise 的简单使用案例",slug:"promise-的简单使用案例",normalizedTitle:"promise 的简单使用案例",charIndex:784},{level:3,title:"对比 Promise 与 回调模式",slug:"对比-promise-与-回调模式",normalizedTitle:"对比 promise 与 回调模式",charIndex:2571},{level:3,title:"Promise 的状态",slug:"promise-的状态",normalizedTitle:"promise 的状态",charIndex:2747},{level:3,title:"Promise 的结果",slug:"promise-的结果",normalizedTitle:"promise 的结果",charIndex:3025},{level:2,title:".then / .catch  / .finally",slug:"then-catch-finally",normalizedTitle:".then / .catch  / .finally",charIndex:null},{level:3,title:".then",slug:"then",normalizedTitle:".then",charIndex:1613},{level:3,title:".catch",slug:"catch",normalizedTitle:".catch",charIndex:3500},{level:3,title:".finally",slug:"finally",normalizedTitle:".finally",charIndex:3509},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6261},{level:3,title:"Promise 的基本流程",slug:"promise-的基本流程",normalizedTitle:"promise 的基本流程",charIndex:6268},{level:2,title:"Promise 的特点",slug:"promise-的特点",normalizedTitle:"promise 的特点",charIndex:6318}],headersStr:"理解 Promise Promis 语法 Promise 的简单使用案例 对比 Promise 与 回调模式 Promise 的状态 Promise 的结果 .then / .catch  / .finally .then .catch .finally 总结 Promise 的基本流程 Promise 的特点",content:'# 理解 Promise\n\n从抽象角度看：\n\n * Promise 是一门 ES6 规范下新的技术；\n\n * Promise 是 JavaScript 中进行异步编程的新解决方案；\n\n从具体角度看：\n\n * 从语法上来讲： Promise 是一个构造函数；\n * 从功能上来讲： Promise 对象用来封装一个异步操作并且可以获取其成功 / 失败的结果值。\n\n> 理解例子：\n> \n> 假如你是一名歌手，你向粉丝承诺会在（单曲发布）的第一时间发给他们。你给了粉丝们一个列表。他们可以在上面填写他们的电子邮件地址，以便当歌曲发布后，（单曲发布成功）让所有订阅了的人能够立即收到。即便遇到不测，例如录音室发生了火灾，以致你无法发布新歌，（单曲发布失败）他们也能及时收到相关通知。\n\n\n# Promis 语法\n\nPromise 的构造器语法：\n\nlet promise = new Promise(function(resolve, reject) {\n  // executor\n});\n\n\n1\n2\n3\n\n\n> 当 new Promise 被创建，executor 会自动运行。它包含最终应产出结果的生产者代码。它的参数 resolve 和 reject 是由 JavaScript 自身提供的回调。要执行的代码仅在 executor 的内部。\n> \n> 当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：\n> \n>  * resolve(value) ：如果任务成功完成并带有结果 value 。\n>  * reject(error) ：如果出现了错误， error 为错误对象。\n\n简而言之： executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 resolve ，如果出现错误则调用 reject 。\n\n\n# Promise 的简单使用案例\n\n🌰 例子 / 定时器：\n\nconst btn = document.querySelector(\'#btn\');\n// 绑定单击事件\nbtn.addEventListener(\'click\', function () {\n    /*setTimeout(() => {\n        // 获取从一到一百的随机数\n        let n = rand(1, 100);\n        // 判断\n        if (n <= 30) {\n            alert(\'中奖\')\n        } else {\n            alert(\'再接再厉\')\n        }\n    }, 1000)*/\n\n    // Promise 实现\n    const p = new Promise((resolve, reject) => {\n        // 成功时调用resolve，失败时调用reject（函数类型）\n        //包含一个函数\n        setTimeout(() => {\n            // 获取从一到一百的随机数\n            let n = rand(1, 100);\n            // 判断\n            if (n <= 30) {\n                resolve(n) // 将Promise对象状态设置为「成功」\n            } else {\n                reject(n) // 将Promise对象状态设置为「失败」\n            }\n        }, 1000)\n    })\n\n    // 第一个是成功时调用，第二个是失败时调用\n    // 在构造p时传给状态的值，不同状态分别为 value / reason\n    p.then((value) => {\n        alert(\'成功中奖，中奖数字为\' + value)\n    }, (reason) => {\n        alert(\'再接再厉，当前号码为\'+ reason)\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n🌰 例子 / 前文 加载脚本 例子：\n\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement(\'script\');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(`Script load error for ${src}`));\n\n    document.head.append(script);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 在加载脚本完成后返回一个新的 Promise 对象。所以在外部可以使用 处理程序 处理 成功或者失败时的结果。\n\nlet promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");\n\npromise.then(\n\tscript => console.log(`${script.src} is loaded`),\n  error => console.log(`Error: ${error.massage}`)\n)\n\npromise.then(\n\tscript => console.log("... another handler")\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 对比 Promise 与 回调模式\n\nPROMIS                            CALLBACKS\nPromises 允许按照自然顺序进行编码。            在调用要执行的函数 之前，必须知道如何处理结果（设定好回调）。\n可以根据需要，可以有多个处理结果的函数。（Promise 链）   只能有一个回调。\n\n\n# Promise 的状态\n\nPromise 状态（PromiseState）是 Promise 实例对象的一个属性，有三个值： pending （初始状态）、 resolved / fulfilled 、 rejected 。\n\n从上面简单使用 Promise 的例子中，可以看到 Promise 可以有两种转变：\n\n * pending ➡️ resolved\n * pending ➡️ rejected\n\n注意，Promise 只有这两种状态，并且每一个 Promise 对象 只能转变一次，无论转为成功还是失败，都会有一个与状态对应的结果：\n\n\n# Promise 的结果\n\n在 resolve(value) 被调用时（成功状态 fulfilled ）结果为 value ；在 reject(error) 被调用时（失败状态 rejected ） 结果为 error 。（ resolve 和 rejecet 只能有一个参数）\n\n提示\n\n * resolve / reject 可以立即进行。虽然通常 excutor 是异步执行某些操作，并在一段时间（经过判断）之后调用 resolve 和 reject ，但这不是必须的。也可以立即调用 resolve 和 reject 。\n   \n   let promise = new Promise(function(resolve, reject) {\n     // 不花时间去做这项工作\n     resolve(123); // 立即给出结果：123\n   });\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 状态和结果（ state 和 result ） 是内部的。无法直接访问它们。但可以对它们使用 .then / .catch / .finally 方法。\n\n\n# .then / .catch / .finally\n\nPromise 对象中是 执行函数（生产者代码 / 歌手） 与 消费函数（粉丝）之间的连接。消费函数将接收 结果（成果或者出错），可以通过使用 .then 、 .catch 、 .finally 为消费函数注册。\n\n\n# .then\n\npromise.then{\n  // 处理成功的结果的消费函数\n\tfunction(result) { /* ... */ }\n \n  // 处理出错结果的消费函数\n\tfunction(error) { /* ... */ }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子：\n\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve("done!"), 1000);\n});\n\n// resolve 运行 .then 中的第一个函数\npromise.then(\n  result => alert(result), // 1 秒后显示 "done!"\n  error => alert(error) // 不运行\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当回调中出错时：\n\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => reject(new Error("Whoops!")), 1000);\n});\n\n// reject 运行 .then 中的第二个函数\npromise.then(\n  result => alert(result), // 不运行\n  error => alert(error) // 1 秒后显示 "Error: Whoops!"\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n一般 .then 中可以只放处理成功时的结果的函数：\n\nlet promise = new Promise(resolve => {\n  setTimeout(() => resolve("done!"), 1000);\n});\n\npromise.then( result => alert(result) );\n// 简化为\npromise.then(alert)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# .catch\n\n.catch 一般用于处理出错的结果 error ：\n\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error("Whoops!")), 1000);\n});\n\npromise.catch(error => alert(error))\n// 简化为：\n// .catch(error) 与 promise.then(null, error) 一样\npromise.catch(alert); // 1 秒后显示 "Error: Whoops!"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（相当于 .then(null, error) ）\n\n\n# .finally\n\n就像常规 try {...} catch {...} 中的 finally 子句一样，Promise 中也有 finally 。\n\n.finally(f) 调用与 .then(f, f) 类似，在某种意义上， f 总是在 Promise 状态被确定时运行：即 Promise 被 resolve 或 reject。\n\nfinally 是执行清理（cleanup）的很好的处理程序（handler），例如无论结果如何，都停止使用不再需要的加载指示符（indicator）。\n\n🌰 例子：\n\nnew Promise((resolve, reject) => {\n  /* ... */\n})\n  // 在 promise 为 settled 时运行，无论成功与否\n  .finally(() => stop loading indicator)\n  // 所以，加载指示器（loading indicator）始终会在我们处理结果/错误之前停止\n  .then(result => show result, err => show error)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n.finally 与 .then 的区别：\n\n * finally 处理程序（handler）没有参数。在 finally 中，不必知道 Promise 成功出错与否， finally 执行的是常规的 定稿程序（finalizinig procedures）。\n\n * finally 将结果和出错（value 和 error） 传递给下一个处理程序：\n   \n   new Promise((resolve, reject) => {\n     setTimeout(() => resolve("result"), 2000)\n   })\n     .finally(() => alert("Promise ready"))\n     .then(result => alert(result)); // <-- .then 对结果进行处理\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   new Promise((resolve, reject) => {\n     throw new Error("error");\n   })\n     .finally(() => alert("Promise ready"))\n     .catch(err => alert(err));  // <-- .catch 对 error 对象进行处理\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 因为 finally 并不是意味着要处理 Promise 的结果，所以它将结果传递了下去。\n\n.then / .catch / .finally 三者为 Promise 状态确定后附加的处理程序。如果 Promise 为 pending 状态，这三种处理程序（handler）将等待它；否则，如果 Promise 已经是 settled 状态，它们就会运行。\n\n这给 Promise 带来更加灵活的特性。因为可以随时添加处理程序，如果结果已经存在了，它们就会执行。\n\n\n# 总结\n\n\n# Promise 的基本流程\n\n分析上述基本使用例子，得出 Promise 的基本流程：\n\n\n\n\n# Promise 的特点\n\n * 指定回调函数的方式更加灵活：\n   \n   * 在以前，回调函数必须在启动异步任务前指定。\n   \n   * Promise 下的流程为：启动异步任务 ➡️ 返回 Promise 对象 ➡️ 给 Promise 对象绑定回调函数 （甚至可以在异步任务将结束后指定多个）\n\n * 支持链式调用，可以解决「回调地狱」的问题：\n   \n   * 「回调地狱」：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件。回调地狱带来了 代码不便于阅读、不便与异常处理的缺点。使用 Promise 链式调用解决。\n   \n   * 终极的解决方案： async / await',normalizedContent:'# 理解 promise\n\n从抽象角度看：\n\n * promise 是一门 es6 规范下新的技术；\n\n * promise 是 javascript 中进行异步编程的新解决方案；\n\n从具体角度看：\n\n * 从语法上来讲： promise 是一个构造函数；\n * 从功能上来讲： promise 对象用来封装一个异步操作并且可以获取其成功 / 失败的结果值。\n\n> 理解例子：\n> \n> 假如你是一名歌手，你向粉丝承诺会在（单曲发布）的第一时间发给他们。你给了粉丝们一个列表。他们可以在上面填写他们的电子邮件地址，以便当歌曲发布后，（单曲发布成功）让所有订阅了的人能够立即收到。即便遇到不测，例如录音室发生了火灾，以致你无法发布新歌，（单曲发布失败）他们也能及时收到相关通知。\n\n\n# promis 语法\n\npromise 的构造器语法：\n\nlet promise = new promise(function(resolve, reject) {\n  // executor\n});\n\n\n1\n2\n3\n\n\n> 当 new promise 被创建，executor 会自动运行。它包含最终应产出结果的生产者代码。它的参数 resolve 和 reject 是由 javascript 自身提供的回调。要执行的代码仅在 executor 的内部。\n> \n> 当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：\n> \n>  * resolve(value) ：如果任务成功完成并带有结果 value 。\n>  * reject(error) ：如果出现了错误， error 为错误对象。\n\n简而言之： executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 resolve ，如果出现错误则调用 reject 。\n\n\n# promise 的简单使用案例\n\n🌰 例子 / 定时器：\n\nconst btn = document.queryselector(\'#btn\');\n// 绑定单击事件\nbtn.addeventlistener(\'click\', function () {\n    /*settimeout(() => {\n        // 获取从一到一百的随机数\n        let n = rand(1, 100);\n        // 判断\n        if (n <= 30) {\n            alert(\'中奖\')\n        } else {\n            alert(\'再接再厉\')\n        }\n    }, 1000)*/\n\n    // promise 实现\n    const p = new promise((resolve, reject) => {\n        // 成功时调用resolve，失败时调用reject（函数类型）\n        //包含一个函数\n        settimeout(() => {\n            // 获取从一到一百的随机数\n            let n = rand(1, 100);\n            // 判断\n            if (n <= 30) {\n                resolve(n) // 将promise对象状态设置为「成功」\n            } else {\n                reject(n) // 将promise对象状态设置为「失败」\n            }\n        }, 1000)\n    })\n\n    // 第一个是成功时调用，第二个是失败时调用\n    // 在构造p时传给状态的值，不同状态分别为 value / reason\n    p.then((value) => {\n        alert(\'成功中奖，中奖数字为\' + value)\n    }, (reason) => {\n        alert(\'再接再厉，当前号码为\'+ reason)\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n🌰 例子 / 前文 加载脚本 例子：\n\nfunction loadscript(src) {\n  return new promise(function(resolve, reject) {\n    let script = document.createelement(\'script\');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new error(`script load error for ${src}`));\n\n    document.head.append(script);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 在加载脚本完成后返回一个新的 promise 对象。所以在外部可以使用 处理程序 处理 成功或者失败时的结果。\n\nlet promise = loadscript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");\n\npromise.then(\n\tscript => console.log(`${script.src} is loaded`),\n  error => console.log(`error: ${error.massage}`)\n)\n\npromise.then(\n\tscript => console.log("... another handler")\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 对比 promise 与 回调模式\n\npromis                            callbacks\npromises 允许按照自然顺序进行编码。            在调用要执行的函数 之前，必须知道如何处理结果（设定好回调）。\n可以根据需要，可以有多个处理结果的函数。（promise 链）   只能有一个回调。\n\n\n# promise 的状态\n\npromise 状态（promisestate）是 promise 实例对象的一个属性，有三个值： pending （初始状态）、 resolved / fulfilled 、 rejected 。\n\n从上面简单使用 promise 的例子中，可以看到 promise 可以有两种转变：\n\n * pending ➡️ resolved\n * pending ➡️ rejected\n\n注意，promise 只有这两种状态，并且每一个 promise 对象 只能转变一次，无论转为成功还是失败，都会有一个与状态对应的结果：\n\n\n# promise 的结果\n\n在 resolve(value) 被调用时（成功状态 fulfilled ）结果为 value ；在 reject(error) 被调用时（失败状态 rejected ） 结果为 error 。（ resolve 和 rejecet 只能有一个参数）\n\n提示\n\n * resolve / reject 可以立即进行。虽然通常 excutor 是异步执行某些操作，并在一段时间（经过判断）之后调用 resolve 和 reject ，但这不是必须的。也可以立即调用 resolve 和 reject 。\n   \n   let promise = new promise(function(resolve, reject) {\n     // 不花时间去做这项工作\n     resolve(123); // 立即给出结果：123\n   });\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 状态和结果（ state 和 result ） 是内部的。无法直接访问它们。但可以对它们使用 .then / .catch / .finally 方法。\n\n\n# .then / .catch / .finally\n\npromise 对象中是 执行函数（生产者代码 / 歌手） 与 消费函数（粉丝）之间的连接。消费函数将接收 结果（成果或者出错），可以通过使用 .then 、 .catch 、 .finally 为消费函数注册。\n\n\n# .then\n\npromise.then{\n  // 处理成功的结果的消费函数\n\tfunction(result) { /* ... */ }\n \n  // 处理出错结果的消费函数\n\tfunction(error) { /* ... */ }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 例子：\n\nlet promise = new promise(function(resolve, reject) {\n  settimeout(() => resolve("done!"), 1000);\n});\n\n// resolve 运行 .then 中的第一个函数\npromise.then(\n  result => alert(result), // 1 秒后显示 "done!"\n  error => alert(error) // 不运行\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当回调中出错时：\n\nlet promise = new promise(function(resolve, reject) {\n  settimeout(() => reject(new error("whoops!")), 1000);\n});\n\n// reject 运行 .then 中的第二个函数\npromise.then(\n  result => alert(result), // 不运行\n  error => alert(error) // 1 秒后显示 "error: whoops!"\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n一般 .then 中可以只放处理成功时的结果的函数：\n\nlet promise = new promise(resolve => {\n  settimeout(() => resolve("done!"), 1000);\n});\n\npromise.then( result => alert(result) );\n// 简化为\npromise.then(alert)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# .catch\n\n.catch 一般用于处理出错的结果 error ：\n\nlet promise = new promise((resolve, reject) => {\n  settimeout(() => reject(new error("whoops!")), 1000);\n});\n\npromise.catch(error => alert(error))\n// 简化为：\n// .catch(error) 与 promise.then(null, error) 一样\npromise.catch(alert); // 1 秒后显示 "error: whoops!"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（相当于 .then(null, error) ）\n\n\n# .finally\n\n就像常规 try {...} catch {...} 中的 finally 子句一样，promise 中也有 finally 。\n\n.finally(f) 调用与 .then(f, f) 类似，在某种意义上， f 总是在 promise 状态被确定时运行：即 promise 被 resolve 或 reject。\n\nfinally 是执行清理（cleanup）的很好的处理程序（handler），例如无论结果如何，都停止使用不再需要的加载指示符（indicator）。\n\n🌰 例子：\n\nnew promise((resolve, reject) => {\n  /* ... */\n})\n  // 在 promise 为 settled 时运行，无论成功与否\n  .finally(() => stop loading indicator)\n  // 所以，加载指示器（loading indicator）始终会在我们处理结果/错误之前停止\n  .then(result => show result, err => show error)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n.finally 与 .then 的区别：\n\n * finally 处理程序（handler）没有参数。在 finally 中，不必知道 promise 成功出错与否， finally 执行的是常规的 定稿程序（finalizinig procedures）。\n\n * finally 将结果和出错（value 和 error） 传递给下一个处理程序：\n   \n   new promise((resolve, reject) => {\n     settimeout(() => resolve("result"), 2000)\n   })\n     .finally(() => alert("promise ready"))\n     .then(result => alert(result)); // <-- .then 对结果进行处理\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   new promise((resolve, reject) => {\n     throw new error("error");\n   })\n     .finally(() => alert("promise ready"))\n     .catch(err => alert(err));  // <-- .catch 对 error 对象进行处理\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 因为 finally 并不是意味着要处理 promise 的结果，所以它将结果传递了下去。\n\n.then / .catch / .finally 三者为 promise 状态确定后附加的处理程序。如果 promise 为 pending 状态，这三种处理程序（handler）将等待它；否则，如果 promise 已经是 settled 状态，它们就会运行。\n\n这给 promise 带来更加灵活的特性。因为可以随时添加处理程序，如果结果已经存在了，它们就会执行。\n\n\n# 总结\n\n\n# promise 的基本流程\n\n分析上述基本使用例子，得出 promise 的基本流程：\n\n\n\n\n# promise 的特点\n\n * 指定回调函数的方式更加灵活：\n   \n   * 在以前，回调函数必须在启动异步任务前指定。\n   \n   * promise 下的流程为：启动异步任务 ➡️ 返回 promise 对象 ➡️ 给 promise 对象绑定回调函数 （甚至可以在异步任务将结束后指定多个）\n\n * 支持链式调用，可以解决「回调地狱」的问题：\n   \n   * 「回调地狱」：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件。回调地狱带来了 代码不便于阅读、不便与异常处理的缺点。使用 promise 链式调用解决。\n   \n   * 终极的解决方案： async / await',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛞 Promise 链式调用",frontmatter:{title:"🛞 Promise 链式调用",date:"2022-05-15T16:54:22.000Z",permalink:"/pages/befb4f/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/03.%20%F0%9F%9B%9E%20Promise%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/03. 🛞 Promise 链式调用.md",key:"v-8fb1bcce",path:"/pages/befb4f/",headers:[{level:2,title:"在链式调用中返回 Promise",slug:"在链式调用中返回-promise",normalizedTitle:"在链式调用中返回 promise",charIndex:760},{level:2,title:"链式调用实例：fetch",slug:"链式调用实例-fetch",normalizedTitle:"链式调用实例：fetch",charIndex:null},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5392},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:2752},{level:3,title:"区分不同的 Promise 调用",slug:"区分不同的-promise-调用",normalizedTitle:"区分不同的 promise 调用",charIndex:5531}],headersStr:"在链式调用中返回 Promise 链式调用实例：fetch 总结 实例 区分不同的 Promise 调用",content:'🌰 例子 / Promise 链式调用：\n\nnew Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000)\n}).then(result => result * 2)\n  .then(result => result * 2)\n\t.then(result => console.log(result)) // 4\n\n\n1\n2\n3\n4\n5\n\n\n> Promise 返回的结果通过 .then 处理程序链进行传递。只所以可以传递是因为每个对 .then 的调用都会返回一个新的 Promise 结果。\n\n不会传递 Promise 的结果的情况（分开 .then ）：\n\n点击查看\n\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这里相当于是 平行的处理程序，彼此独立运行处理任务。这种属于极少情况。\n\n\n# 在链式调用中返回 Promise\n\n处理程序可以创建并返回一个 Promise，这样的情况下，其他的处理程序需要等待它的 状态确定（settled）获得其结果。\n\n🌰 例子：\n\nnew Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000);\n}).then(function(result) {\n  \n  return new Promise((resolve, reject) => { \n    setTimeout(() => resolve(result * 2), 1000);\n  });\n  \n}).then(function(result) { \n  \n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n  \n}).then(function(result) {\n  cosole.log(result) // 4\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 这个 Promise 的链式调用中有三个 .then 。第一个 .then 返回一个新的 Promise 一秒之后会进行 resolve ，然后结果 (result) 回传递给第二个 .then 。第二个 .then 的动作与第一个 .then 相同。\n\n返回 Promise 可以构建异步行为链。\n\n🌰 例子 / 加载脚本 的例子：\n\nloadScript("/article/promise-chaining/one.js")\n  .then(function(script) {\n    return loadScript("/article/promise-chaining/two.js");\n  })\n  .then(function(script) {\n    return loadScript("/article/promise-chaining/three.js");\n  })\n  .then(function(script) {\n    // 使用在脚本中声明的函数\n    // 以证明脚本确实被加载完成了\n    one();\n    two();\n    three();\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用箭头函数重写：\n\nloadScript("/article/promise-chaining/one.js")\n  .then(script => loadScript("/article/promise-chaining/two.js"))\n  .then(script => loadScript("/article/promise-chaining/three.js"))\n  .then(script => {\n    // 脚本加载完成，我们可以在这儿使用脚本中声明的函数\n    one();\n    two();\n    three();\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n提示\n\n准确的说，处理程序 返回的并不是一个 Promise，而是一个 「thenable」 对象，一个具有方法 .then 的任意对象，它可以当做是一个 Promise 来对待。\n\n可以自定义实现「Promise 兼容对象」：\n\n点击查看\n\n可以具有拓展的方法集，但也与原生的 Promise 兼容，因为它们实现了 .then 方法。\n\n🌰 例子：\n\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve); // function() { native code }\n    // 1 秒后使用 this.num*2 进行 resolve\n    setTimeout(() => resolve(this.num * 2), 1000); // (**)\n  }\n}\n\nnew Promise(resolve => resolve(1))\n  .then(result => {\n    return new Thenable(result); // (*)\n  })\n  .then(alert); // 1000ms 后显示 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 链式调用实例： fetch\n\n在前端中，通常使用 Promise 处理网络请求。\n\n🌰 例子 / 向 user.json 发送请求，并从服务器加载该文本：\n\nlet promise = fetch(url)\n\n\n1\n\n\nfetch(\'/article/promise-chaining/user.json\')\n\t.then((response) => response.text())\n\t.then((text) => console.log(text))\n\n\n1\n2\n3\n\n\n> 当全部文字内容从远程服务器下载完成后，它会返回一个 Promise，该 Promise 以刚刚下载完成的这个文本作为 result 进行 resolve 。\n\n可以将 response 的远程内容解析为 JSON：\n\nfetch(\'/article/promise-chaining/user.json\')\n  .then(response => response.json())\n  .then(user => alert(user.name));\n\n\n1\n2\n3\n\n\n🌰 例子 / 上面的例子上，再向 GitHub 发送一个请求，加载用户个人资料并显示头像：\n\nfetch(\'/article/promise-chaining/user.json\')\n  // 将其加载为 JSON\n  .then(response => response.json())\n  // 发送一个到 GitHub 的请求\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  // 将响应加载为 JSON\n  .then(response => response.json())\n  // 显示头像图片（githubUser.avatar_url）3 秒（也可以加上动画效果）\n  .then(githubUser => {\n    let img = document.createElement(\'img\');\n    img.src = githubUser.avatar_url;\n    img.className = "promise-avatar-example";\n    document.body.append(img);\n\n    setTimeout(() => img.remove(), 3000); // (*)\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n为了使得链可拓展，需要返回一个在头像显示结束时进行 resolve 的 Promise：\n\nfetch(\'/article/promise-chaining/user.json\')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubUser => new Promise(function(resolve, reject) { // (*)\n    let img = document.createElement(\'img\');\n    img.src = githubUser.avatar_url;\n    img.className = "promise-avatar-example";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser); // (**)\n    }, 3000);\n  }))\n  // 3 秒后触发\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n所以，为了能让其中的请求能服用（可控制），每次的异步行为都应该返回一个 Promise，可以使得后续的行为成为可能。\n\n最后，将代码拆分为可重用的函数：\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => response.json());\n}\n\nfunction loadGithubUser(name) {\n  return loadJson(`https://api.github.com/users/${name}`);\n}\n\nfunction showAvatar(githubUser) {\n  return new Promise(function(resolve, reject) {\n    let img = document.createElement(\'img\');\n    img.src = githubUser.avatar_url;\n    img.className = "promise-avatar-example";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n使用例子：\n\nloadJson(\'/article/promise-chaining/user.json\')\n  .then(user => loadGithubUser(user.name))\n  .then(showAvatar)\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n\n\n1\n2\n3\n4\n\n\n\n# 总结\n\n * .then （或者 .catch / .finally 处理程序）会返回一个 Promise 的结果（value 或者 error），可以进一步传递。\n * 也可以返回一个 新的 Promise，要等待它的 状态确定，其结果才能进一步传递。\n\n\n# 实例\n\n\n# 区分不同的 Promise 调用\n\n> promise\n>   .then(f1)\n>   .catch(f2);\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 与\n> \n> promise\n>   .then(f1, f2);\n> \n> \n> 1\n> 2\n\n点击查看\n\n这两种代码片段行为不相同。第一个中 f1 出现错误时，会被 catch(f2) 处理。但是在第二个中，不会被处理，因为 f1 下面没有处理来自 f1 的 Promise 结果（或者错误）的链。',normalizedContent:'🌰 例子 / promise 链式调用：\n\nnew promise(function(resolve, reject) {\n  settimeout(() => resolve(1), 1000)\n}).then(result => result * 2)\n  .then(result => result * 2)\n\t.then(result => console.log(result)) // 4\n\n\n1\n2\n3\n4\n5\n\n\n> promise 返回的结果通过 .then 处理程序链进行传递。只所以可以传递是因为每个对 .then 的调用都会返回一个新的 promise 结果。\n\n不会传递 promise 的结果的情况（分开 .then ）：\n\n点击查看\n\nlet promise = new promise(function(resolve, reject) {\n  settimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这里相当于是 平行的处理程序，彼此独立运行处理任务。这种属于极少情况。\n\n\n# 在链式调用中返回 promise\n\n处理程序可以创建并返回一个 promise，这样的情况下，其他的处理程序需要等待它的 状态确定（settled）获得其结果。\n\n🌰 例子：\n\nnew promise(function(resolve, reject) {\n  settimeout(() => resolve(1), 1000);\n}).then(function(result) {\n  \n  return new promise((resolve, reject) => { \n    settimeout(() => resolve(result * 2), 1000);\n  });\n  \n}).then(function(result) { \n  \n  return new promise((resolve, reject) => {\n    settimeout(() => resolve(result * 2), 1000);\n  });\n  \n}).then(function(result) {\n  cosole.log(result) // 4\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 这个 promise 的链式调用中有三个 .then 。第一个 .then 返回一个新的 promise 一秒之后会进行 resolve ，然后结果 (result) 回传递给第二个 .then 。第二个 .then 的动作与第一个 .then 相同。\n\n返回 promise 可以构建异步行为链。\n\n🌰 例子 / 加载脚本 的例子：\n\nloadscript("/article/promise-chaining/one.js")\n  .then(function(script) {\n    return loadscript("/article/promise-chaining/two.js");\n  })\n  .then(function(script) {\n    return loadscript("/article/promise-chaining/three.js");\n  })\n  .then(function(script) {\n    // 使用在脚本中声明的函数\n    // 以证明脚本确实被加载完成了\n    one();\n    two();\n    three();\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用箭头函数重写：\n\nloadscript("/article/promise-chaining/one.js")\n  .then(script => loadscript("/article/promise-chaining/two.js"))\n  .then(script => loadscript("/article/promise-chaining/three.js"))\n  .then(script => {\n    // 脚本加载完成，我们可以在这儿使用脚本中声明的函数\n    one();\n    two();\n    three();\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n提示\n\n准确的说，处理程序 返回的并不是一个 promise，而是一个 「thenable」 对象，一个具有方法 .then 的任意对象，它可以当做是一个 promise 来对待。\n\n可以自定义实现「promise 兼容对象」：\n\n点击查看\n\n可以具有拓展的方法集，但也与原生的 promise 兼容，因为它们实现了 .then 方法。\n\n🌰 例子：\n\nclass thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve); // function() { native code }\n    // 1 秒后使用 this.num*2 进行 resolve\n    settimeout(() => resolve(this.num * 2), 1000); // (**)\n  }\n}\n\nnew promise(resolve => resolve(1))\n  .then(result => {\n    return new thenable(result); // (*)\n  })\n  .then(alert); // 1000ms 后显示 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 链式调用实例： fetch\n\n在前端中，通常使用 promise 处理网络请求。\n\n🌰 例子 / 向 user.json 发送请求，并从服务器加载该文本：\n\nlet promise = fetch(url)\n\n\n1\n\n\nfetch(\'/article/promise-chaining/user.json\')\n\t.then((response) => response.text())\n\t.then((text) => console.log(text))\n\n\n1\n2\n3\n\n\n> 当全部文字内容从远程服务器下载完成后，它会返回一个 promise，该 promise 以刚刚下载完成的这个文本作为 result 进行 resolve 。\n\n可以将 response 的远程内容解析为 json：\n\nfetch(\'/article/promise-chaining/user.json\')\n  .then(response => response.json())\n  .then(user => alert(user.name));\n\n\n1\n2\n3\n\n\n🌰 例子 / 上面的例子上，再向 github 发送一个请求，加载用户个人资料并显示头像：\n\nfetch(\'/article/promise-chaining/user.json\')\n  // 将其加载为 json\n  .then(response => response.json())\n  // 发送一个到 github 的请求\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  // 将响应加载为 json\n  .then(response => response.json())\n  // 显示头像图片（githubuser.avatar_url）3 秒（也可以加上动画效果）\n  .then(githubuser => {\n    let img = document.createelement(\'img\');\n    img.src = githubuser.avatar_url;\n    img.classname = "promise-avatar-example";\n    document.body.append(img);\n\n    settimeout(() => img.remove(), 3000); // (*)\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n为了使得链可拓展，需要返回一个在头像显示结束时进行 resolve 的 promise：\n\nfetch(\'/article/promise-chaining/user.json\')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubuser => new promise(function(resolve, reject) { // (*)\n    let img = document.createelement(\'img\');\n    img.src = githubuser.avatar_url;\n    img.classname = "promise-avatar-example";\n    document.body.append(img);\n\n    settimeout(() => {\n      img.remove();\n      resolve(githubuser); // (**)\n    }, 3000);\n  }))\n  // 3 秒后触发\n  .then(githubuser => alert(`finished showing ${githubuser.name}`));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n所以，为了能让其中的请求能服用（可控制），每次的异步行为都应该返回一个 promise，可以使得后续的行为成为可能。\n\n最后，将代码拆分为可重用的函数：\n\nfunction loadjson(url) {\n  return fetch(url)\n    .then(response => response.json());\n}\n\nfunction loadgithubuser(name) {\n  return loadjson(`https://api.github.com/users/${name}`);\n}\n\nfunction showavatar(githubuser) {\n  return new promise(function(resolve, reject) {\n    let img = document.createelement(\'img\');\n    img.src = githubuser.avatar_url;\n    img.classname = "promise-avatar-example";\n    document.body.append(img);\n\n    settimeout(() => {\n      img.remove();\n      resolve(githubuser);\n    }, 3000);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n使用例子：\n\nloadjson(\'/article/promise-chaining/user.json\')\n  .then(user => loadgithubuser(user.name))\n  .then(showavatar)\n  .then(githubuser => alert(`finished showing ${githubuser.name}`));\n\n\n1\n2\n3\n4\n\n\n\n# 总结\n\n * .then （或者 .catch / .finally 处理程序）会返回一个 promise 的结果（value 或者 error），可以进一步传递。\n * 也可以返回一个 新的 promise，要等待它的 状态确定，其结果才能进一步传递。\n\n\n# 实例\n\n\n# 区分不同的 promise 调用\n\n> promise\n>   .then(f1)\n>   .catch(f2);\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> 与\n> \n> promise\n>   .then(f1, f2);\n> \n> \n> 1\n> 2\n\n点击查看\n\n这两种代码片段行为不相同。第一个中 f1 出现错误时，会被 catch(f2) 处理。但是在第二个中，不会被处理，因为 f1 下面没有处理来自 f1 的 promise 结果（或者错误）的链。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛟 Promise 错误处理",frontmatter:{title:"🛟 Promise 错误处理",date:"2022-05-15T19:12:29.000Z",permalink:"/pages/ac44b6/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/04.%20%F0%9F%9B%9F%20Promise%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/04. 🛟 Promise 错误处理.md",key:"v-76d59d22",path:"/pages/ac44b6/",headers:[{level:2,title:"隐式的 try...catch",slug:"隐式的-try-catch",normalizedTitle:"隐式的 try...catch",charIndex:937},{level:2,title:"再次派出",slug:"再次派出",normalizedTitle:"再次派出",charIndex:1668},{level:2,title:"未处理的错误",slug:"未处理的错误",normalizedTitle:"未处理的错误",charIndex:2640},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3632},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:3967},{level:3,title:"不能捕捉到的错误",slug:"不能捕捉到的错误",normalizedTitle:"不能捕捉到的错误",charIndex:3974}],headersStr:"隐式的 try...catch 再次派出 未处理的错误 总结 实例 不能捕捉到的错误",content:'Promise 链在错误处理中十分强大。当一个 Promise 被 reject 时，控制权将移交至 最近的处理程序。\n\n🌰 例子 / 网络请求失败时：\n\nfetch(\'https://no-such-server.blabla\') // rejects\n  .then(response => response.json())\n  .catch(err => alert(err))\n\n\n1\n2\n3\n\n\n> 可以看到， .catch 不必是立即的。它可能在一个或多个 .then 之后出现。\n\n所以，一般 .catch 放在 链的结尾。\n\n🌰 例子：\n\nfetch(\'/article/promise-chaining/user.json\')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubUser => new Promise((resolve, reject) => {\n    let img = document.createElement(\'img\');\n    img.src = githubUser.avatar_url;\n    img.className = "promise-avatar-example";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  }))\n  .catch(error => alert(error.message));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 通常，成功状态的结果不会触发 .catch 。但是如果上述任意一个 Promise 被 reject 出现错误结果， .catch 就会捕获到，\n\n\n# 隐式的 try...catch\n\nPromise 在执行行为周围和处理程序周围有一个「隐式的 try…catch 」。如果当中的行为发生异常，就会被 catch 捕获被视为 Promise 结果处理。\n\n🌰 例子：\n\nnew Promise((resolve, reject) => {\n  throw new Error("Whoops!");\n}).catch(alert); // Error: Whoops!\n\n\n1\n2\n3\n\n\n同理：\n\nnew Promise((resolve, reject) => {\n  reject(new Error("Whoops!"));\n}).catch(alert); // Error: Whoops!\n\n\n1\n2\n3\n\n\n🌰 例子 / 在 处理程序中：\n\nnew Promise((resolve, reject) => {\n  resolve("ok");\n}).then((result) => {\n  throw new Error("Whoops!"); // reject 这个 promise\n}).catch(alert); // Error: Whoops!\n\n\n1\n2\n3\n4\n5\n\n\n不仅仅对 throw 抛出的错误有效，代码错误也可以捕获：\n\nnew Promise((resolve, reject) => {\n  resolve("ok");\n}).then((result) => {\n  blabla(); // 没有这个函数\n}).catch(alert); // ReferenceError: blabla is not defined\n\n\n1\n2\n3\n4\n5\n\n\n\n# 再次派出\n\n在平常的 try...catch 结构中，如果最后 catch 不能处理错误，可以将错误再次抛出。对于 Promise 也是可以的。\n\n如果在 .catch 中 throw ，那么控制权就会被移交到下一个最近的错误处理程序。如果能处理该错误并正常完成，那么它将继续到最近的成功的 .then 处理程序。\n\n🌰 例子 / .catch 成功处理错误：\n\nnew Promise((resolve, reject) => {\n  throw new Error("Whoops!");\n}).catch(function(error) {\n  alert("The error is handled, continue normally");\n}).then(() => alert("Next successful handler runs"));\n\n\n1\n2\n3\n4\n5\n\n\n> 这里 .catch 块正常完成。所以下一个成功的 .then 处理程序（handler）就会被调用。\n\n🌰 例子 / catch 再次抛出错误：\n\nnew Promise((resolve, reject) => {\n  throw new Error("Whoops!");\n}).catch(function(error) {\n  if (error instanceof URIError) {\n    // 处理它\n  } else {\n    alert("Can\'t handle such error");\n    throw error; // 再次抛出此 error 或另外一个 error，执行将跳转至下一个 catch\n  }\n}).then(function() {\n  /* 不在这里运行 */\n}).catch(error => { // (**)\n  alert(`The unknown error has occurred: ${error}`);\n  // 不会返回任何内容 => 执行正常进行\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 没有处理的错误，会从上一个 .catch 跳转到最近的一个 .catch ，中间的 .then 处理程序不会运行。\n\n\n# 未处理的错误\n\n当一个错误没有被处理。\n\n🌰 例子： 当调用链中的末尾没有处理错误 .catch :\n\nnew Promise(function() {\n    noSuchFunction(); // 这里出现 error（没有这个函数）\n}).then(() => {\n    // 一个或多个成功的 promise 处理程序（handler）\n  });\n\n\n1\n2\n3\n4\n5\n\n\n如果出现 error，Promise 的状态将变为 rejected，然后执行应该跳转至最近的错误处理程序。如果没有错误处理程序，因此该错误会卡住，没有代码来处理它。\n\n相对于 try...catch 中没有被处理的错误，会在控制台留下错误信息。Promise 对于没有被处理的错误也是如此。\n\nJavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error。\n\n在浏览器中，可以使用 unhandledrejection 事件来捕获这类 error：\n\nwindow.addEventListener(\'unhandledrejection\', function(event) {\n  // 这个事件对象有两个特殊的属性：\n  alert(event.promise); // [object Promise] - 生成该全局 error 的 promise\n  alert(event.reason); // Error: Whoops! - 未处理的 error 对象\n});\n\nnew Promise(function() {\n  throw new Error("Whoops!");\n}); // 没有用来处理 error 的 catch\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 这个事件是 HTML 标准 的一部分。如果出现了一个 error，并且在这儿没有 .catch ，那么 unhandledrejection 处理程序就会被触发，并获取具有 error 相关信息的 event 对象，然后就可以根据这个错误进行后续处理。\n> \n> 通常此类 error 是无法恢复的，所以最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。在 Node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。\n\n\n# 总结\n\n * .catch 处理 promise 中的各种 error：在 reject() 调用中的，或者在处理程序中抛出的 error。\n * 应该将 .catch 准确地放到想要处理 error，并知道如何处理这些 error 的地方。处理程序应该分析 error（可以自定义 error 类来帮助分析）并再次抛出未知的 error（可能它们是编程错误）。\n * 如果没有办法从 error 中恢复的话，不使用 .catch 也可以。\n * 在任何情况下全局 unhandledrejection 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使的应用程序永远不会「卡住死掉」。\n\n\n# 实例\n\n\n# 不能捕捉到的错误\n\n> new Promise(function(resolve, reject) {\n>   setTimeout(() => {\n>     throw new Error("Whoops!");\n>   }, 1000);\n> }).catch(alert);\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 在 setTimeout 中抛出的错误能够被 .catch 捕捉？\n\n点击查看\n\n不会被触发。Promise 中 执行过程和处理程序周围的隐式 try...catch 处理 所有的同步错误。而 setTimeout 中的错误不是在执行过程中生成的，而是稍后生成的，因此， Promise 无法处理。',normalizedContent:'promise 链在错误处理中十分强大。当一个 promise 被 reject 时，控制权将移交至 最近的处理程序。\n\n🌰 例子 / 网络请求失败时：\n\nfetch(\'https://no-such-server.blabla\') // rejects\n  .then(response => response.json())\n  .catch(err => alert(err))\n\n\n1\n2\n3\n\n\n> 可以看到， .catch 不必是立即的。它可能在一个或多个 .then 之后出现。\n\n所以，一般 .catch 放在 链的结尾。\n\n🌰 例子：\n\nfetch(\'/article/promise-chaining/user.json\')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubuser => new promise((resolve, reject) => {\n    let img = document.createelement(\'img\');\n    img.src = githubuser.avatar_url;\n    img.classname = "promise-avatar-example";\n    document.body.append(img);\n\n    settimeout(() => {\n      img.remove();\n      resolve(githubuser);\n    }, 3000);\n  }))\n  .catch(error => alert(error.message));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 通常，成功状态的结果不会触发 .catch 。但是如果上述任意一个 promise 被 reject 出现错误结果， .catch 就会捕获到，\n\n\n# 隐式的 try...catch\n\npromise 在执行行为周围和处理程序周围有一个「隐式的 try…catch 」。如果当中的行为发生异常，就会被 catch 捕获被视为 promise 结果处理。\n\n🌰 例子：\n\nnew promise((resolve, reject) => {\n  throw new error("whoops!");\n}).catch(alert); // error: whoops!\n\n\n1\n2\n3\n\n\n同理：\n\nnew promise((resolve, reject) => {\n  reject(new error("whoops!"));\n}).catch(alert); // error: whoops!\n\n\n1\n2\n3\n\n\n🌰 例子 / 在 处理程序中：\n\nnew promise((resolve, reject) => {\n  resolve("ok");\n}).then((result) => {\n  throw new error("whoops!"); // reject 这个 promise\n}).catch(alert); // error: whoops!\n\n\n1\n2\n3\n4\n5\n\n\n不仅仅对 throw 抛出的错误有效，代码错误也可以捕获：\n\nnew promise((resolve, reject) => {\n  resolve("ok");\n}).then((result) => {\n  blabla(); // 没有这个函数\n}).catch(alert); // referenceerror: blabla is not defined\n\n\n1\n2\n3\n4\n5\n\n\n\n# 再次派出\n\n在平常的 try...catch 结构中，如果最后 catch 不能处理错误，可以将错误再次抛出。对于 promise 也是可以的。\n\n如果在 .catch 中 throw ，那么控制权就会被移交到下一个最近的错误处理程序。如果能处理该错误并正常完成，那么它将继续到最近的成功的 .then 处理程序。\n\n🌰 例子 / .catch 成功处理错误：\n\nnew promise((resolve, reject) => {\n  throw new error("whoops!");\n}).catch(function(error) {\n  alert("the error is handled, continue normally");\n}).then(() => alert("next successful handler runs"));\n\n\n1\n2\n3\n4\n5\n\n\n> 这里 .catch 块正常完成。所以下一个成功的 .then 处理程序（handler）就会被调用。\n\n🌰 例子 / catch 再次抛出错误：\n\nnew promise((resolve, reject) => {\n  throw new error("whoops!");\n}).catch(function(error) {\n  if (error instanceof urierror) {\n    // 处理它\n  } else {\n    alert("can\'t handle such error");\n    throw error; // 再次抛出此 error 或另外一个 error，执行将跳转至下一个 catch\n  }\n}).then(function() {\n  /* 不在这里运行 */\n}).catch(error => { // (**)\n  alert(`the unknown error has occurred: ${error}`);\n  // 不会返回任何内容 => 执行正常进行\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 没有处理的错误，会从上一个 .catch 跳转到最近的一个 .catch ，中间的 .then 处理程序不会运行。\n\n\n# 未处理的错误\n\n当一个错误没有被处理。\n\n🌰 例子： 当调用链中的末尾没有处理错误 .catch :\n\nnew promise(function() {\n    nosuchfunction(); // 这里出现 error（没有这个函数）\n}).then(() => {\n    // 一个或多个成功的 promise 处理程序（handler）\n  });\n\n\n1\n2\n3\n4\n5\n\n\n如果出现 error，promise 的状态将变为 rejected，然后执行应该跳转至最近的错误处理程序。如果没有错误处理程序，因此该错误会卡住，没有代码来处理它。\n\n相对于 try...catch 中没有被处理的错误，会在控制台留下错误信息。promise 对于没有被处理的错误也是如此。\n\njavascript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error。\n\n在浏览器中，可以使用 unhandledrejection 事件来捕获这类 error：\n\nwindow.addeventlistener(\'unhandledrejection\', function(event) {\n  // 这个事件对象有两个特殊的属性：\n  alert(event.promise); // [object promise] - 生成该全局 error 的 promise\n  alert(event.reason); // error: whoops! - 未处理的 error 对象\n});\n\nnew promise(function() {\n  throw new error("whoops!");\n}); // 没有用来处理 error 的 catch\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 这个事件是 html 标准 的一部分。如果出现了一个 error，并且在这儿没有 .catch ，那么 unhandledrejection 处理程序就会被触发，并获取具有 error 相关信息的 event 对象，然后就可以根据这个错误进行后续处理。\n> \n> 通常此类 error 是无法恢复的，所以最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。在 node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。\n\n\n# 总结\n\n * .catch 处理 promise 中的各种 error：在 reject() 调用中的，或者在处理程序中抛出的 error。\n * 应该将 .catch 准确地放到想要处理 error，并知道如何处理这些 error 的地方。处理程序应该分析 error（可以自定义 error 类来帮助分析）并再次抛出未知的 error（可能它们是编程错误）。\n * 如果没有办法从 error 中恢复的话，不使用 .catch 也可以。\n * 在任何情况下全局 unhandledrejection 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使的应用程序永远不会「卡住死掉」。\n\n\n# 实例\n\n\n# 不能捕捉到的错误\n\n> new promise(function(resolve, reject) {\n>   settimeout(() => {\n>     throw new error("whoops!");\n>   }, 1000);\n> }).catch(alert);\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 在 settimeout 中抛出的错误能够被 .catch 捕捉？\n\n点击查看\n\n不会被触发。promise 中 执行过程和处理程序周围的隐式 try...catch 处理 所有的同步错误。而 settimeout 中的错误不是在执行过程中生成的，而是稍后生成的，因此， promise 无法处理。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚉 Promise 相关 API",frontmatter:{title:"🚉 Promise 相关 API",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/6c6065/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/07.%20%F0%9F%9A%89%20Promise%20%E7%9B%B8%E5%85%B3%20API.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/07. 🚉 Promise 相关 API.md",key:"v-198322b5",path:"/pages/6c6065/",headers:[{level:3,title:"Promise 构造函数",slug:"promise-构造函数",normalizedTitle:"promise 构造函数",charIndex:2},{level:3,title:"Promise.prototype.then 方法",slug:"promise-prototype-then-方法",normalizedTitle:"promise.prototype.then 方法",charIndex:219},{level:3,title:"Promise.prototype.catch 方法",slug:"promise-prototype-catch-方法",normalizedTitle:"promise.prototype.catch 方法",charIndex:425},{level:3,title:"Promise.resolve 方法",slug:"promise-resolve-方法",normalizedTitle:"promise.resolve 方法",charIndex:707},{level:3,title:"Promise.reject 方法",slug:"promise-reject-方法",normalizedTitle:"promise.reject 方法",charIndex:1141},{level:3,title:"Promise.all 方法",slug:"promise-all-方法",normalizedTitle:"promise.all 方法",charIndex:1427},{level:3,title:"Promise.race 方法",slug:"promise-race-方法",normalizedTitle:"promise.race 方法",charIndex:1819},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2217},{level:2,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:2217}],headersStr:"Promise 构造函数 Promise.prototype.then 方法 Promise.prototype.catch 方法 Promise.resolve 方法 Promise.reject 方法 Promise.all 方法 Promise.race 方法 总结 总结",content:"# Promise 构造函数\n\nPromise (excutor) {}\n\n * executor 函数： 执行器 (resolve, reject) => {}\n * resolve 函数：内部定义成功时我们调用的函数 value => {}\n * reject 函数：内部定义失败时我们调用的函数 reason => {}\n\n说明： executor 会在 Promise 内部立即同步调用（⚠️），异步操作在执行器中执行。\n\n\n# Promise.prototype.then 方法\n\n(onResolved, onRejected) => {}\n\n * onResolved 函数：成功的回调函数 (value) => {}\n * onRejected 函数：失败的回调函数 (reason) => {}\n\n说明：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调，返回一个新的 Promise 对象。\n\n\n# Promise.prototype.catch 方法\n\n(onRejected) => {}\n\n * onRejected 函数：失败的回调函数 (reason) => {}\n\n说明： then() 的语法糖，相当于： then(undefined, onRejected)\n\n🌰 例子：\n\n点击查看\n\nlet p = new Promise((resolve, reject)=>{\n  reject('error')\n})\n\np.catch(reason => {\n  console.log(reason)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Promise.resolve 方法\n\n(value) => {}\n\n * value ：成功的数据或 Promise 对象\n\n说明：返回一个成功 / 失败的 Promise 对象\n\n🌰 例子：\n\nlet p1 = Promise.resolve(111)\nconsole.log(p1) // 传入的参数为非Promise类型的对象，则返回的结果为成功的Promise对象\n\n// 如果传入的参数为Promise对象，参数的结果决定了resolve的结果\nlet p2 = Promise.resolve(new Promise((resolve, reject)=>{\n  // resolve(\"success\")\n  reject(\"Error\")\n}))\n// console.log(p2);\np2.catch(reason => {\n  console.log(reason)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Promise.reject 方法\n\n(reason) => {}\n\n * reason ：失败的原因。\n\n说明：返回一个失败的 Promise 对象。\n\n🌰 例子：\n\nlet p = Promise.reject(666) // 无论传入什么类型的值都返回失败的Promise对象\nlet p2 = Promise.reject(new Promise((resolve, reject)=>{\n  resolve(\"success\")\n}))\nconsole.log(p2) // p2的状态为失败，值为传入Promise对象的值\n\n\n1\n2\n3\n4\n5\n\n\n\n# Promise.all 方法\n\n(promises) => {}\n\n * promises ：包含 n 个 Promise 的数组\n\n说明：返回一个新的 Promise，只有所有的 Promise 都成功才成功，只要有一个失败了就直接失败。\n\nlet p1 = new Promise((resolve, reject) => {\n  resolve('OK');\n})\n// let p2 = Promise.resolve('Success');\nlet p2 = Promise.reject('Error');\nlet p3 = Promise.resolve('Oh Yeah');\n\n//\nconst result = Promise.all([p1, p2, p3]);\nconsole.log(result);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Promise.race 方法\n\n(promises) => {}\n\n * promises ：包含 n 个 Promise 对象的数组。\n\n说明：返回一个新的 Promise，第一个完成的 Promise 的结果状态就是最终的结果状态。\n\n🌰 例子：\n\nlet p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('OK');\n  }, 1000);})\nlet p2 = Promise.resolve('Success');\nlet p3 = Promise.resolve('Oh Yeah');\n\nconst result = Promise.race([p1,p2,p3])\nconsole.log(result) // p2的结果状态\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 总结\n\n\n# 总结\n\nPromise 类有 6 种静态方法：\n\n 1. Promise.all(promises) ：等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 Promise.all 的 error，所有其他 promise 的结果都会被忽略。\n\n 2. Promise.allSettled(promises)\n    \n    \n    1\n    \n    \n    （ES2020 新增方法） 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：\n    \n    * status : \"fulfilled\" 或 \"rejected\"\n    * value （如果 fulfilled）或 reason （如果 rejected）。\n\n 3. Promise.race(promises) —— 等待第一个 settle 的 promise，并将其 result/error 作为结果返回。\n\n 4. Promise.any(promises) （ES2021 新增方法）： 等待第一个 fulfilled 的 promise，并将其结果作为结果返回。如果所有 promise 都 rejected， Promise.any 则会抛出 AggregateError 错误类型的 error 实例。\n\n 5. Promise.resolve(value) ：使用给定 value 创建一个 resolved 的 promise。\n\n 6. Promise.reject(error) ： 使用给定 error 创建一个 rejected 的 promise。\n\n> Promise.all 可能是在实战中使用最多的。",normalizedContent:"# promise 构造函数\n\npromise (excutor) {}\n\n * executor 函数： 执行器 (resolve, reject) => {}\n * resolve 函数：内部定义成功时我们调用的函数 value => {}\n * reject 函数：内部定义失败时我们调用的函数 reason => {}\n\n说明： executor 会在 promise 内部立即同步调用（⚠️），异步操作在执行器中执行。\n\n\n# promise.prototype.then 方法\n\n(onresolved, onrejected) => {}\n\n * onresolved 函数：成功的回调函数 (value) => {}\n * onrejected 函数：失败的回调函数 (reason) => {}\n\n说明：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调，返回一个新的 promise 对象。\n\n\n# promise.prototype.catch 方法\n\n(onrejected) => {}\n\n * onrejected 函数：失败的回调函数 (reason) => {}\n\n说明： then() 的语法糖，相当于： then(undefined, onrejected)\n\n🌰 例子：\n\n点击查看\n\nlet p = new promise((resolve, reject)=>{\n  reject('error')\n})\n\np.catch(reason => {\n  console.log(reason)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# promise.resolve 方法\n\n(value) => {}\n\n * value ：成功的数据或 promise 对象\n\n说明：返回一个成功 / 失败的 promise 对象\n\n🌰 例子：\n\nlet p1 = promise.resolve(111)\nconsole.log(p1) // 传入的参数为非promise类型的对象，则返回的结果为成功的promise对象\n\n// 如果传入的参数为promise对象，参数的结果决定了resolve的结果\nlet p2 = promise.resolve(new promise((resolve, reject)=>{\n  // resolve(\"success\")\n  reject(\"error\")\n}))\n// console.log(p2);\np2.catch(reason => {\n  console.log(reason)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# promise.reject 方法\n\n(reason) => {}\n\n * reason ：失败的原因。\n\n说明：返回一个失败的 promise 对象。\n\n🌰 例子：\n\nlet p = promise.reject(666) // 无论传入什么类型的值都返回失败的promise对象\nlet p2 = promise.reject(new promise((resolve, reject)=>{\n  resolve(\"success\")\n}))\nconsole.log(p2) // p2的状态为失败，值为传入promise对象的值\n\n\n1\n2\n3\n4\n5\n\n\n\n# promise.all 方法\n\n(promises) => {}\n\n * promises ：包含 n 个 promise 的数组\n\n说明：返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败。\n\nlet p1 = new promise((resolve, reject) => {\n  resolve('ok');\n})\n// let p2 = promise.resolve('success');\nlet p2 = promise.reject('error');\nlet p3 = promise.resolve('oh yeah');\n\n//\nconst result = promise.all([p1, p2, p3]);\nconsole.log(result);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# promise.race 方法\n\n(promises) => {}\n\n * promises ：包含 n 个 promise 对象的数组。\n\n说明：返回一个新的 promise，第一个完成的 promise 的结果状态就是最终的结果状态。\n\n🌰 例子：\n\nlet p1 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('ok');\n  }, 1000);})\nlet p2 = promise.resolve('success');\nlet p3 = promise.resolve('oh yeah');\n\nconst result = promise.race([p1,p2,p3])\nconsole.log(result) // p2的结果状态\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 总结\n\n\n# 总结\n\npromise 类有 6 种静态方法：\n\n 1. promise.all(promises) ：等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 promise.all 的 error，所有其他 promise 的结果都会被忽略。\n\n 2. promise.allsettled(promises)\n    \n    \n    1\n    \n    \n    （es2020 新增方法） 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：\n    \n    * status : \"fulfilled\" 或 \"rejected\"\n    * value （如果 fulfilled）或 reason （如果 rejected）。\n\n 3. promise.race(promises) —— 等待第一个 settle 的 promise，并将其 result/error 作为结果返回。\n\n 4. promise.any(promises) （es2021 新增方法）： 等待第一个 fulfilled 的 promise，并将其结果作为结果返回。如果所有 promise 都 rejected， promise.any 则会抛出 aggregateerror 错误类型的 error 实例。\n\n 5. promise.resolve(value) ：使用给定 value 创建一个 resolved 的 promise。\n\n 6. promise.reject(error) ： 使用给定 error 创建一个 rejected 的 promise。\n\n> promise.all 可能是在实战中使用最多的。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛰 Promise 的几个关键问题",frontmatter:{title:"🛰 Promise 的几个关键问题",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/dbb94a/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/08.%20%F0%9F%9B%B0%20Promise%20%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/08. 🛰 Promise 的几个关键问题.md",key:"v-72feb9e2",path:"/pages/dbb94a/",headersStr:null,content:"1⃣️ 改变 Promise 的状态的三个方法：\n\n * resolve(value) ：如果当前是 pending 就会变为 resolved；\n\n * reject(reason) ：如果当前是 pending 就会变为 rejected；\n\n * 抛出异常： 如果当前是 pending 就会变为 rejected；\n\n🌰 例子：\n\nlet p = new Promise((resolve, reject) => {\n    resolve('ok');\n});\n//执行 then 方法的结果\nlet result = p.then(value => {\n    // console.log(value);\n    //1. 抛出错误\n    // throw '出了问题';\n    //2. 返回结果是非 Promise 类型的对象\n    // return 521;\n    //3. 返回结果是 Promise 对象\n    return new Promise((resolve, reject) => {\n        // resolve('success');\n        reject('error');\n    });\n}, reason => {\n    console.warn(reason);\n});\n\nconsole.log(result);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n2⃣️ 指定多个成功 / 失败回调函数，都会调用吗？\n\n * 当 Promise 改变为对应的状态时都会调用。\n\n🌰 例子：\n\nlet p = new Promise((resolve, reject) => {\n    // resolve('OK'); // 先改变状态后运行回调\n    setTimeout(()=>{\n        resolve('OK')\n    },1000)\n});\n\n///指定回调 - 1\np.then(value => {\n    console.log(value);\n});\n\n//指定回调 - 2\n/*p.then(value => {\n    alert(value);\n});*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3⃣️ 改变 Promise 状态和指定回调函数的先后顺序：\n\n * 都有可能。正常情况下是先指定回调函数再改变 Promise 的状态，但也可以先改状态再指定回调函数。\n * 先改状态再指定回调的情况：\n   * 在执行其中直接调用 resolve() / reject()\n   * 延迟更长时间才调用 then()\n * 什么时候才能得到数据：\n   * 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据；\n   * 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据；\n\n（主要关注 Promise 构造时里面是同步或异步任务）\n\n🌰 例子\n\nlet p = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('OK');\n    }, 1000);\n});\n\np.then(value => {\n    console.log(value);\n},reason=>{\n \t\tconsole.warn(reason)   \n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n4⃣️ promise.then() 返回的新 Promise 的结果状态由什么决定？\n\n * 简单表达：由 then() 指定的回调函数执行的结果决定。\n\n * 详细表达：\n   \n   * 如果抛出异常，新 Promise 变为 rejected ， reason 为抛出的异常。\n   * 如果返回的是非 Promise 的任意值，新 Promise 变为 resolved ， value 为返回的值\n   * 如果返回的是另一个新 Promise，此 Promise 的结果就会成为新 Promise 的结果。\n\n🌰 例子：\n\nlet p = new Promise((resolve, reject) => {\n    resolve('ok');\n});\n//执行 then 方法的结果\nlet result = p.then(value => {\n    // console.log(value);\n    //1. 抛出错误\n    // throw '出了问题';\n    //2. 返回结果是非 Promise 类型的对象\n    // return 521;\n    //3. 返回结果是 Promise 对象\n    return new Promise((resolve, reject) => {\n        // resolve('success');\n        reject('error');\n    });\n}, reason => {\n    console.warn(reason);\n});\n\nconsole.log(result);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n5⃣️ Promise 如何串连多个操作任务？\n\n * Promise 的 then() 返回一个新的 Promise，可以开成 then() 的链式调用。\n * 通过 then 的链式调用串连多个同步 / 异步任务。\n\n🌰 例子：\n\nlet p = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('OK');\n    }, 1000);\n});\n\np.then(value => {\n    return new Promise((resolve, reject) => {\n        resolve(\"success\");\n    });\n}).then(value => {\n    console.log(value);\n}).then(value => {\n    console.log(value); // undefined 上一个 Promise无返回值\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n6⃣️ Promise 异常传透：\n\n * 当使用 Promise 的 then 链式调用时，可以在最后指定失败的回调。\n * 前面任何操作出了异常，都会传到最后失败的回调中处理。\n\n🌰 例子：\n\nlet p = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('OK');\n        // reject('Err');\n    }, 1000);\n});\n\np.then(value => {\n    // console.log(111);\n    throw '失败啦!';\n}).then(value => {\n    console.log(222);\n}).then(value => {\n    console.log(333);\n}).catch(reason => {\n    console.warn(reason);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n7⃣️ 中断 Promise 链：\n\n * 当使用 Promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数。\n\n * 办法：在回调函数中返回一个 pendding 状态的 Promise 对象。（有且只有一种方式）\n\n🌰 例子：\n\nlet p = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('OK');\n    }, 1000);\n});\n\np.then(value => {\n    console.log(111);\n    //有且只有一个方式\n    return new Promise(() => {});\n}).then(value => {\n    console.log(222);\n}).then(value => {\n    console.log(333);\n}).catch(reason => {\n    console.warn(reason);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"1⃣️ 改变 promise 的状态的三个方法：\n\n * resolve(value) ：如果当前是 pending 就会变为 resolved；\n\n * reject(reason) ：如果当前是 pending 就会变为 rejected；\n\n * 抛出异常： 如果当前是 pending 就会变为 rejected；\n\n🌰 例子：\n\nlet p = new promise((resolve, reject) => {\n    resolve('ok');\n});\n//执行 then 方法的结果\nlet result = p.then(value => {\n    // console.log(value);\n    //1. 抛出错误\n    // throw '出了问题';\n    //2. 返回结果是非 promise 类型的对象\n    // return 521;\n    //3. 返回结果是 promise 对象\n    return new promise((resolve, reject) => {\n        // resolve('success');\n        reject('error');\n    });\n}, reason => {\n    console.warn(reason);\n});\n\nconsole.log(result);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n2⃣️ 指定多个成功 / 失败回调函数，都会调用吗？\n\n * 当 promise 改变为对应的状态时都会调用。\n\n🌰 例子：\n\nlet p = new promise((resolve, reject) => {\n    // resolve('ok'); // 先改变状态后运行回调\n    settimeout(()=>{\n        resolve('ok')\n    },1000)\n});\n\n///指定回调 - 1\np.then(value => {\n    console.log(value);\n});\n\n//指定回调 - 2\n/*p.then(value => {\n    alert(value);\n});*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3⃣️ 改变 promise 状态和指定回调函数的先后顺序：\n\n * 都有可能。正常情况下是先指定回调函数再改变 promise 的状态，但也可以先改状态再指定回调函数。\n * 先改状态再指定回调的情况：\n   * 在执行其中直接调用 resolve() / reject()\n   * 延迟更长时间才调用 then()\n * 什么时候才能得到数据：\n   * 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据；\n   * 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据；\n\n（主要关注 promise 构造时里面是同步或异步任务）\n\n🌰 例子\n\nlet p = new promise((resolve, reject) => {\n    settimeout(() => {\n        resolve('ok');\n    }, 1000);\n});\n\np.then(value => {\n    console.log(value);\n},reason=>{\n \t\tconsole.warn(reason)   \n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n4⃣️ promise.then() 返回的新 promise 的结果状态由什么决定？\n\n * 简单表达：由 then() 指定的回调函数执行的结果决定。\n\n * 详细表达：\n   \n   * 如果抛出异常，新 promise 变为 rejected ， reason 为抛出的异常。\n   * 如果返回的是非 promise 的任意值，新 promise 变为 resolved ， value 为返回的值\n   * 如果返回的是另一个新 promise，此 promise 的结果就会成为新 promise 的结果。\n\n🌰 例子：\n\nlet p = new promise((resolve, reject) => {\n    resolve('ok');\n});\n//执行 then 方法的结果\nlet result = p.then(value => {\n    // console.log(value);\n    //1. 抛出错误\n    // throw '出了问题';\n    //2. 返回结果是非 promise 类型的对象\n    // return 521;\n    //3. 返回结果是 promise 对象\n    return new promise((resolve, reject) => {\n        // resolve('success');\n        reject('error');\n    });\n}, reason => {\n    console.warn(reason);\n});\n\nconsole.log(result);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n5⃣️ promise 如何串连多个操作任务？\n\n * promise 的 then() 返回一个新的 promise，可以开成 then() 的链式调用。\n * 通过 then 的链式调用串连多个同步 / 异步任务。\n\n🌰 例子：\n\nlet p = new promise((resolve, reject) => {\n    settimeout(() => {\n        resolve('ok');\n    }, 1000);\n});\n\np.then(value => {\n    return new promise((resolve, reject) => {\n        resolve(\"success\");\n    });\n}).then(value => {\n    console.log(value);\n}).then(value => {\n    console.log(value); // undefined 上一个 promise无返回值\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n6⃣️ promise 异常传透：\n\n * 当使用 promise 的 then 链式调用时，可以在最后指定失败的回调。\n * 前面任何操作出了异常，都会传到最后失败的回调中处理。\n\n🌰 例子：\n\nlet p = new promise((resolve, reject) => {\n    settimeout(() => {\n        resolve('ok');\n        // reject('err');\n    }, 1000);\n});\n\np.then(value => {\n    // console.log(111);\n    throw '失败啦!';\n}).then(value => {\n    console.log(222);\n}).then(value => {\n    console.log(333);\n}).catch(reason => {\n    console.warn(reason);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n7⃣️ 中断 promise 链：\n\n * 当使用 promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数。\n\n * 办法：在回调函数中返回一个 pendding 状态的 promise 对象。（有且只有一种方式）\n\n🌰 例子：\n\nlet p = new promise((resolve, reject) => {\n    settimeout(() => {\n        resolve('ok');\n    }, 1000);\n});\n\np.then(value => {\n    console.log(111);\n    //有且只有一个方式\n    return new promise(() => {});\n}).then(value => {\n    console.log(222);\n}).then(value => {\n    console.log(333);\n}).catch(reason => {\n    console.warn(reason);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛫 Promise 的自定义封装",frontmatter:{title:"🛫 Promise 的自定义封装",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/02f98e/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/09.%20%F0%9F%9B%AB%20Promise%20%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B0%81%E8%A3%85.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/09. 🛫 Promise 的自定义封装.md",key:"v-e3dedec8",path:"/pages/02f98e/",headersStr:null,content:"class Promise {\n    // 构造方法\n    constructor(executor) {\n        // 添加属性\n        this.PromiseState = 'pending'\n        this.PromiseResult = null\n        this.callbacks = []\n\n        // 保存实例对象的this的值\n        const self = this\n\n        // resolve 函数\n        function resolve(data) {\n            // 判断状态\n            if (self.PromiseState !== 'pending') return\n\n            // 此时this为window\n            // 改变对象状态(PromiseState)\n            self.PromiseState = 'fulfilled'\n            // 设置对象结果值(PromiseResult)\n            self.PromiseResult = data\n\n            // 调用成功的回调函数\n            /*if (self.callback.onResolved) {\n                self.callback.onResolved(data);\n            }*/\n            setTimeout(() => {\n                self.callbacks.forEach(item => {\n                    item.onResolved(data)\n                })\n            })\n        }\n\n        // reject 函数\n        function reject(data) {\n            // 判断状态\n            if (self.PromiseState !== 'pending') return\n\n            // 改变对象状态(PromiseState)\n            self.PromiseState = 'rejected'\n            // 设置对象结果值(PromiseResult)\n            self.PromiseResult = data\n\n            // 调用失败的回调函数\n            /*if (self.callback.onRejected) {\n                self.callback.onRejected(data);\n            }*/\n\n            setTimeout(() => {\n                self.callbacks.forEach(item => {\n                    item.onRejected(data)\n                })\n            })\n        }\n\n        try {\n            // 同步调用执行器函数\n            executor(resolve, reject)\n        } catch (e) {\n            // 修改对象状态为失败\n            reject(e)\n        }\n    }\n\n    then(onResolved, onRejected) {\n\n        const self = this\n        // 判断回调函数参数\n        if (typeof onRejected !== 'function') {\n            onRejected = reason => {\n                throw reason;\n            }\n        }\n        if (typeof onResolved !== 'function') {\n            onResolved = value => value;\n        }\n        return new Promise((resolve, reject) => {\n            // 封装函数\n            function callback(type) {\n                try {\n                    // 获取回调函数的执行结果\n                    let result = type(self.PromiseResult);\n                    // 判断\n                    if (result instanceof Promise) {\n                        // 如果是 promise 类型的对象\n                        result.then(v => {\n                            resolve(v)\n                        }, r => {\n                            reject(r)\n                        })\n                    } else {\n                        // 结果的对象状态为「成功」\n                        resolve(result)\n                    }\n                } catch (e) {\n                    reject(e)\n                }\n            }\n\n            // 调用回调函数\n            if (this.PromiseState === 'fulfilled') {\n                setTimeout(() => {\n                    callback(onResolved)\n                })\n            }\n\n            if (this.PromiseState === 'rejected') {\n                setTimeout(() => {\n                    callback(onRejected)\n                })\n            }\n\n            // pending的状态\n            if (this.PromiseState === 'pending') {\n                this.callbacks.push({\n                    onResolved: function () {\n                        callback(onResolved)\n                    },\n                    onRejected: function () {\n                        callback(onRejected)\n                    }\n                })\n            }\n\n\n        })\n    }\n\n    catch(onRejected) {\n        return this.then(undefined, onRejected)\n    }\n\n    static resolve(value) {\n        return new Promise((resolve, reject) => {\n            if (value instanceof Promise) {\n                value.then(v => {\n                    resolve(v)\n                }, r => {\n                    reject(r)\n                })\n            } else {\n                resolve(value)\n            }\n        })\n    }\n\n    static reject(reason) {\n        return new Promise((resolve, reject) => {\n            reject(reason)\n        })\n    }\n\n    static all(promises) {\n        return new Promise((resolve, reject) => {\n            // 声明变量\n            let count = 0 // 计数\n            let arr = [] // 接收成功结果\n            // 遍历\n            for (let i = 0; i < promises.length; i++) {\n                promises[i].then(v => {\n                    // 当n个promise对象都成功才 resolve\n                    count++;\n                    // 将当前promise对象成功的结果存入数组中\n                    arr[i] = v\n                    // 判断\n                    if (count === promises.length) {\n                        // 在count等于数组个数才改变状态\n                        resolve(arr) // 修改状态\n                    }\n                }, r => {\n                    reject(r) // 只要有一个失败就改为失败\n                })\n            }\n        })\n    }\n\n    static race(promises) {\n        return new Promise((resolve, reject) => {\n            for (let i = 0; i < promises.length; i++) {\n                promises[i].then(v => {\n                    // 修改返回对象的状态为「成功」 谁先运行谁决定状态\n                    resolve(v)\n                }, r => {\n                    reject(r)\n                })\n            }\n        })\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n",normalizedContent:"class promise {\n    // 构造方法\n    constructor(executor) {\n        // 添加属性\n        this.promisestate = 'pending'\n        this.promiseresult = null\n        this.callbacks = []\n\n        // 保存实例对象的this的值\n        const self = this\n\n        // resolve 函数\n        function resolve(data) {\n            // 判断状态\n            if (self.promisestate !== 'pending') return\n\n            // 此时this为window\n            // 改变对象状态(promisestate)\n            self.promisestate = 'fulfilled'\n            // 设置对象结果值(promiseresult)\n            self.promiseresult = data\n\n            // 调用成功的回调函数\n            /*if (self.callback.onresolved) {\n                self.callback.onresolved(data);\n            }*/\n            settimeout(() => {\n                self.callbacks.foreach(item => {\n                    item.onresolved(data)\n                })\n            })\n        }\n\n        // reject 函数\n        function reject(data) {\n            // 判断状态\n            if (self.promisestate !== 'pending') return\n\n            // 改变对象状态(promisestate)\n            self.promisestate = 'rejected'\n            // 设置对象结果值(promiseresult)\n            self.promiseresult = data\n\n            // 调用失败的回调函数\n            /*if (self.callback.onrejected) {\n                self.callback.onrejected(data);\n            }*/\n\n            settimeout(() => {\n                self.callbacks.foreach(item => {\n                    item.onrejected(data)\n                })\n            })\n        }\n\n        try {\n            // 同步调用执行器函数\n            executor(resolve, reject)\n        } catch (e) {\n            // 修改对象状态为失败\n            reject(e)\n        }\n    }\n\n    then(onresolved, onrejected) {\n\n        const self = this\n        // 判断回调函数参数\n        if (typeof onrejected !== 'function') {\n            onrejected = reason => {\n                throw reason;\n            }\n        }\n        if (typeof onresolved !== 'function') {\n            onresolved = value => value;\n        }\n        return new promise((resolve, reject) => {\n            // 封装函数\n            function callback(type) {\n                try {\n                    // 获取回调函数的执行结果\n                    let result = type(self.promiseresult);\n                    // 判断\n                    if (result instanceof promise) {\n                        // 如果是 promise 类型的对象\n                        result.then(v => {\n                            resolve(v)\n                        }, r => {\n                            reject(r)\n                        })\n                    } else {\n                        // 结果的对象状态为「成功」\n                        resolve(result)\n                    }\n                } catch (e) {\n                    reject(e)\n                }\n            }\n\n            // 调用回调函数\n            if (this.promisestate === 'fulfilled') {\n                settimeout(() => {\n                    callback(onresolved)\n                })\n            }\n\n            if (this.promisestate === 'rejected') {\n                settimeout(() => {\n                    callback(onrejected)\n                })\n            }\n\n            // pending的状态\n            if (this.promisestate === 'pending') {\n                this.callbacks.push({\n                    onresolved: function () {\n                        callback(onresolved)\n                    },\n                    onrejected: function () {\n                        callback(onrejected)\n                    }\n                })\n            }\n\n\n        })\n    }\n\n    catch(onrejected) {\n        return this.then(undefined, onrejected)\n    }\n\n    static resolve(value) {\n        return new promise((resolve, reject) => {\n            if (value instanceof promise) {\n                value.then(v => {\n                    resolve(v)\n                }, r => {\n                    reject(r)\n                })\n            } else {\n                resolve(value)\n            }\n        })\n    }\n\n    static reject(reason) {\n        return new promise((resolve, reject) => {\n            reject(reason)\n        })\n    }\n\n    static all(promises) {\n        return new promise((resolve, reject) => {\n            // 声明变量\n            let count = 0 // 计数\n            let arr = [] // 接收成功结果\n            // 遍历\n            for (let i = 0; i < promises.length; i++) {\n                promises[i].then(v => {\n                    // 当n个promise对象都成功才 resolve\n                    count++;\n                    // 将当前promise对象成功的结果存入数组中\n                    arr[i] = v\n                    // 判断\n                    if (count === promises.length) {\n                        // 在count等于数组个数才改变状态\n                        resolve(arr) // 修改状态\n                    }\n                }, r => {\n                    reject(r) // 只要有一个失败就改为失败\n                })\n            }\n        })\n    }\n\n    static race(promises) {\n        return new promise((resolve, reject) => {\n            for (let i = 0; i < promises.length; i++) {\n                promises[i].then(v => {\n                    // 修改返回对象的状态为「成功」 谁先运行谁决定状态\n                    resolve(v)\n                }, r => {\n                    reject(r)\n                })\n            }\n        })\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛩 Promise 的 async 和 await",frontmatter:{title:"🛩 Promise 的 async 和 await",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/0eb0a7/",categories:["🚶🏻 前端巩固基础","🚇 JavaScript Promise"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/39.%20%F0%9F%9A%87%20JavaScript%20Promise/10.%20%F0%9F%9B%A9%20Promise%20%E7%9A%84%20async%20%E5%92%8C%20await.html",relativePath:"101. 🚶🏻 前端巩固基础/39. 🚇 JavaScript Promise/10. 🛩 Promise 的 async 和 await.md",key:"v-bb055ad2",path:"/pages/0eb0a7/",headers:[{level:3,title:"async 函数",slug:"async-函数",normalizedTitle:"async 函数",charIndex:14},{level:3,title:"await 表达式",slug:"await-表达式",normalizedTitle:"await 表达式",charIndex:595},{level:3,title:"async 与 await 结合",slug:"async-与-await-结合",normalizedTitle:"async 与 await 结合",charIndex:1843},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3379}],headersStr:"async 函数 await 表达式 async 与 await 结合 总结",content:"🔗 相关链接 ：\n\n * async 函数 - JavaScript | MDN (mozilla.org)\n * await - JavaScript | MDN (mozilla.org)\n\n简而言之， async / await 的使用是 更加舒适使用 Promise 的方式。\n\n\n# async 函数\n\n * 返回值为 Promise 对象\n * Promise 对象的结果由 async 函数执行的返回值决定。\n\n（注：与 .then 相似）\n\n使用 async 「修饰」的函数表示：这个函数总是返回一个 Promise ，其他值将自动被包装在一个 resolved 的 promise 中。\n\n🌰 例子：\n\nasync function main(){\n    // 返回值为非promise\n    // return 123 // 成功的promise\n    // 返回的是promise对象\n    /*return new Promise((resolve, reject)=>{\n        resolve('ok') // 结果由这个结果决定\n    })*/\n    throw \"error\" \n}\n\nlet result = main()\nconsole.log(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# await 表达式\n\nasync function func() {\n  let value = await promise;\n}\n\n\n1\n2\n3\n\n * await 右侧的表达式一般为 Promise 对象，但也可以是其它的值。\n * 如果表达式为 Promise 对象，await 返回的是 Promise 成功的值。\n * 如果表达式是其他值，直接将此值作为 await 的返回值。\n\n关键字 await 让 JavaScript 引擎等待直到 promise 完成并返回结果。\n\n注意：\n\n * await 必须写在 async 函数中，但 async 函数中可以没有 await 。（ await 写在普通函数中会报错）\n * 如果 await 的 Promise 失败了，就会抛出异常，需要通过 try … catch … 捕获处理。\n\n提示\n\nawait 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\n\n相比于 promise.then ，它只是获取 promise 的结果的一个更优雅的语法。并且也更易于读写。\n\n🌰 例子：\n\nasync function main(){\n  let p = new Promise((resolve, reject)=>{\n    // resolve('ok')\n    reject('error')\n  })\n\n  // let result = await p; // 右侧为promise的情况\n  // console.log(result);\n  // let result2 = await 123; // 右侧为其他类型\n  // console.log(result2);\n\n  try {\n    let result3 = await p; // 右侧为promise失败\n  } catch (e) {\n    console.warn(e) // 获取到失败的结果\n  }\n}\n\nmain()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n提示\n\nasync / await 可以与 Promis.all 结合使用：当需要同时等待多个 promise 时，可以使用 Promise 包装起来，然后使用 await ：\n\nlet results = await Promise.all([\n  fetch(url1),\n  fetch(url2),\n  ...\n]);\n\n\n1\n2\n3\n4\n5\n\n\n> 如果出现 error，也会正常传递，从失败了的 promise 传到 Promise.all ，然后变成能通过使用 try..catch 在调用周围捕获到的异常。\n\n\n# async 与 await 结合\n\n🌰 例子（读取文件）：\n\nconst fs = require('fs')\nconst util = require('util')\nconst mineReadFile = util.promisify(fs.readFile)\n\n// 使用async与await\nasync function main() {\n    try {\n        let data1 = await mineReadFile('./resource/1.html')\n        let data2 = await mineReadFile('./resource/2.html')\n        let data3 = await mineReadFile('./resource/3.html')\n        console.log(data1 + data2 + data3)\n    } catch (err) {\n        console.warn(err)\n    }\n\n}\n\nmain()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 相比于使用回调函数实现，减少写抛出异常 try-catch 结构。\n * 在 async 与 await 结合后，少用回调函数。\n\n🌰 例子（发送 AJAX 请求）：\n\n<button id=\"btn\">获取</button>\n\n<script>\n    function sendAJAX(url) {\n        return new Promise((resolve, reject)=>{\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', url)\n            xhr.send();\n            xhr.onreadystatechange = function () {\n                if(xhr.readyState === 4) {\n                    if(xhr.status >= 200 && xhr.status < 300) {\n                        // 成功请求\n                        resolve(xhr.response)\n                    } else {\n                        // 失败请求\n                        reject(xhr.status)\n                    }\n                }\n            }\n        })\n    }\n\n    let btn = document.querySelector(\"#btn\")\n    btn.addEventListener('click', async function(){\n        let text = await sendAJAX('https://api.apiopen.top/getJoke')\n        console.log(text)\n    })\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 总结\n\n * async 关键字对函数的作用：\n   \n   * 让这个函数总是返回一个 promise。\n   * 允许在该函数内使用 await 。\n\n * Promise 前的关键字 await 使 JavaScript 引擎等待该 promise 确定状态，然后：\n   \n   1. 如果有 error，就会抛出异常 ，就像那里调用了 throw error 一样。\n   2. 否则，就返回结果。",normalizedContent:"🔗 相关链接 ：\n\n * async 函数 - javascript | mdn (mozilla.org)\n * await - javascript | mdn (mozilla.org)\n\n简而言之， async / await 的使用是 更加舒适使用 promise 的方式。\n\n\n# async 函数\n\n * 返回值为 promise 对象\n * promise 对象的结果由 async 函数执行的返回值决定。\n\n（注：与 .then 相似）\n\n使用 async 「修饰」的函数表示：这个函数总是返回一个 promise ，其他值将自动被包装在一个 resolved 的 promise 中。\n\n🌰 例子：\n\nasync function main(){\n    // 返回值为非promise\n    // return 123 // 成功的promise\n    // 返回的是promise对象\n    /*return new promise((resolve, reject)=>{\n        resolve('ok') // 结果由这个结果决定\n    })*/\n    throw \"error\" \n}\n\nlet result = main()\nconsole.log(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# await 表达式\n\nasync function func() {\n  let value = await promise;\n}\n\n\n1\n2\n3\n\n * await 右侧的表达式一般为 promise 对象，但也可以是其它的值。\n * 如果表达式为 promise 对象，await 返回的是 promise 成功的值。\n * 如果表达式是其他值，直接将此值作为 await 的返回值。\n\n关键字 await 让 javascript 引擎等待直到 promise 完成并返回结果。\n\n注意：\n\n * await 必须写在 async 函数中，但 async 函数中可以没有 await 。（ await 写在普通函数中会报错）\n * 如果 await 的 promise 失败了，就会抛出异常，需要通过 try … catch … 捕获处理。\n\n提示\n\nawait 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 cpu 资源，因为 javascript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\n\n相比于 promise.then ，它只是获取 promise 的结果的一个更优雅的语法。并且也更易于读写。\n\n🌰 例子：\n\nasync function main(){\n  let p = new promise((resolve, reject)=>{\n    // resolve('ok')\n    reject('error')\n  })\n\n  // let result = await p; // 右侧为promise的情况\n  // console.log(result);\n  // let result2 = await 123; // 右侧为其他类型\n  // console.log(result2);\n\n  try {\n    let result3 = await p; // 右侧为promise失败\n  } catch (e) {\n    console.warn(e) // 获取到失败的结果\n  }\n}\n\nmain()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n提示\n\nasync / await 可以与 promis.all 结合使用：当需要同时等待多个 promise 时，可以使用 promise 包装起来，然后使用 await ：\n\nlet results = await promise.all([\n  fetch(url1),\n  fetch(url2),\n  ...\n]);\n\n\n1\n2\n3\n4\n5\n\n\n> 如果出现 error，也会正常传递，从失败了的 promise 传到 promise.all ，然后变成能通过使用 try..catch 在调用周围捕获到的异常。\n\n\n# async 与 await 结合\n\n🌰 例子（读取文件）：\n\nconst fs = require('fs')\nconst util = require('util')\nconst minereadfile = util.promisify(fs.readfile)\n\n// 使用async与await\nasync function main() {\n    try {\n        let data1 = await minereadfile('./resource/1.html')\n        let data2 = await minereadfile('./resource/2.html')\n        let data3 = await minereadfile('./resource/3.html')\n        console.log(data1 + data2 + data3)\n    } catch (err) {\n        console.warn(err)\n    }\n\n}\n\nmain()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 相比于使用回调函数实现，减少写抛出异常 try-catch 结构。\n * 在 async 与 await 结合后，少用回调函数。\n\n🌰 例子（发送 ajax 请求）：\n\n<button id=\"btn\">获取</button>\n\n<script>\n    function sendajax(url) {\n        return new promise((resolve, reject)=>{\n            const xhr = new xmlhttprequest();\n            xhr.open('get', url)\n            xhr.send();\n            xhr.onreadystatechange = function () {\n                if(xhr.readystate === 4) {\n                    if(xhr.status >= 200 && xhr.status < 300) {\n                        // 成功请求\n                        resolve(xhr.response)\n                    } else {\n                        // 失败请求\n                        reject(xhr.status)\n                    }\n                }\n            }\n        })\n    }\n\n    let btn = document.queryselector(\"#btn\")\n    btn.addeventlistener('click', async function(){\n        let text = await sendajax('https://api.apiopen.top/getjoke')\n        console.log(text)\n    })\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 总结\n\n * async 关键字对函数的作用：\n   \n   * 让这个函数总是返回一个 promise。\n   * 允许在该函数内使用 await 。\n\n * promise 前的关键字 await 使 javascript 引擎等待该 promise 确定状态，然后：\n   \n   1. 如果有 error，就会抛出异常 ，就像那里调用了 throw error 一样。\n   2. 否则，就返回结果。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧨 JavaScript 防抖与节流",frontmatter:{title:"🧨 JavaScript 防抖与节流",date:"2022-04-22T16:42:30.000Z",permalink:"/pages/921863/",categories:["📔 JavaScript 其他内容"],tags:["JavaScript深入部分"]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/40.%20%F0%9F%93%94%20JavaScript%20%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%20%F0%9F%A7%A8%20JavaScript%20%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.html",relativePath:"101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/01. 🧨 JavaScript 防抖与节流.md",key:"v-50cc48b9",path:"/pages/921863/",headersStr:null,content:" * 节流：在规定的问隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。\n * 防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发只会执行一次\n\n引入 Lodash 插件：里面封装函数的防抖与节流的业务（闭包、延时器）：可以通过 npm 或者引入 js 依赖。\n\n🌰 防抖例子：搜索引擎搜索时，输入关键字的两种情况：\n\n * 只要有输入文本发生变化，就向服务器发送搜索请求；\n * 等到最后的输入不再变化（输入完毕），才向服务器发送搜索请求（这才是搜索更合理的情况）；\n\n🌰 搜索防抖例子（在规定的时间后才执行）：\n\nlet input = document.querySelector('input')\ninput.oninput = _.debounce(function (){\n    console.log('ajax发送请求了')\n}, 1000)\n\n\n1\n2\n3\n4\n\n\n🌰 节流例子（计数器按钮数字加一）：\n\n// 计数器在一秒以内只执行一次\nbutton.onclick = _.throttle( function () {\n    count++;\n    span.innerHTML = count;\n    console.log('执行')\n}, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 如果有较多的业务代码加入到节流中，可以给浏览器很充裕的时间去解析。\n\n总结：\n\n * 防抖：用户操作频繁，但是只执行一次；\n * 节流：用户操作频繁，把频繁的操作变为少量操作（最终还是会执行多次），给浏览器充裕的时间解析代码。",normalizedContent:" * 节流：在规定的问隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。\n * 防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发只会执行一次\n\n引入 lodash 插件：里面封装函数的防抖与节流的业务（闭包、延时器）：可以通过 npm 或者引入 js 依赖。\n\n🌰 防抖例子：搜索引擎搜索时，输入关键字的两种情况：\n\n * 只要有输入文本发生变化，就向服务器发送搜索请求；\n * 等到最后的输入不再变化（输入完毕），才向服务器发送搜索请求（这才是搜索更合理的情况）；\n\n🌰 搜索防抖例子（在规定的时间后才执行）：\n\nlet input = document.queryselector('input')\ninput.oninput = _.debounce(function (){\n    console.log('ajax发送请求了')\n}, 1000)\n\n\n1\n2\n3\n4\n\n\n🌰 节流例子（计数器按钮数字加一）：\n\n// 计数器在一秒以内只执行一次\nbutton.onclick = _.throttle( function () {\n    count++;\n    span.innerhtml = count;\n    console.log('执行')\n}, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 如果有较多的业务代码加入到节流中，可以给浏览器很充裕的时间去解析。\n\n总结：\n\n * 防抖：用户操作频繁，但是只执行一次；\n * 节流：用户操作频繁，把频繁的操作变为少量操作（最终还是会执行多次），给浏览器充裕的时间解析代码。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🗑 JavaScript 关于使用 var 声明变量",frontmatter:{title:"🗑 JavaScript 关于使用 var 声明变量",date:"2022-05-09T17:23:42.000Z",permalink:"/pages/ce4056/",categories:["📔 JavaScript 其他内容"],tags:["JavaScript深入部分"]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/40.%20%F0%9F%93%94%20JavaScript%20%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/02.%20%F0%9F%97%91%20JavaScript%20%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%20var%20%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F.html",relativePath:"101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/02. 🗑 JavaScript 关于使用 var 声明变量.md",key:"v-8942e32e",path:"/pages/ce4056/",headers:[{level:2,title:"var 中没有「块级作用域」",slug:"var-中没有「块级作用域」",normalizedTitle:"var 中没有「块级作用域」",charIndex:65},{level:2,title:"var 允许重新变量的重新声明",slug:"var-允许重新变量的重新声明",normalizedTitle:"var 允许重新变量的重新声明",charIndex:742},{level:2,title:"var 可以在声明前被使用 / 变量提升",slug:"var-可以在声明前被使用-变量提升",normalizedTitle:"var 可以在声明前被使用 / 变量提升",charIndex:998},{level:2,title:"「IIFE」",slug:"「iife」",normalizedTitle:"「iife」",charIndex:2131}],headersStr:"var 中没有「块级作用域」 var 允许重新变量的重新声明 var 可以在声明前被使用 / 变量提升 「IIFE」",content:'在 JavaScript 还没有使用 let 声明变量之前，一般使用 var 声明变量。但是 var 声明变量有许多知名\n\n\n# var 中没有「块级作用域」\n\n用 var 声明的变量，不是 函数作用域 就是 全局作用域，它们在代码块外也是可见的，所以不存在 块级作用域的说法。\n\n🌰 例子 / 对于 if 代码块：\n\nif(true) {\n  var test = true\n}\n\nconsole.log(test) // true \n\n\n1\n2\n3\n4\n5\n\n\n> 由于 var 会忽略代码块，所以声明了 全局变量 test 。如果使用 let 则仅 if 代码块内部中可见。\n\n🌰 例子 / 对于 for 代码块：\n\nfor(var i = 0; i < 10; i++) {\n  var one = 1\n}\n\nconsole.log(i)\nconsole.log(one)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 for 代码块中，使用 var 声明的变量同样相当于是 全局变量 。\n\n如果一个代码块位于函数内部，那么 var 声明的变量的作用域将为函数作用域。\n\n🌰 例子 / 函数作用域：\n\nfunction sayHi() {\n  if(true) {\n    var phrase = \'hello\'\n  }\n  \n  console.log(phrase)\n}\n\nsayHi()\nconsole.log(phrase) // 函数内部的变量对外不可见\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> var 穿透了 if ， for 和其它代码块。这是因为在早期的 JavaScript 中，块没有词法环境，而 var 就是这个时期的代表之一。\n\n\n# var 允许重新变量的重新声明\n\n> 在 let 声明变量时，在同一作用域下将同一个变量声明两次，则会出现错误。\n\n使用 var ，可以重复声明一个变量，不管多少次都行。如果对一个已经声明的变量使用 var ，这条新的声明语句会被忽略 var ，即覆盖上一次声明的内容：\n\nvar user = "Pete";\n\nvar user = "John"; // 这个 "var" 无效（因为变量已经声明过了）\n// ……不会触发错误\n\nalert(user); // John\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# var 可以在声明前被使用 / 变量提升\n\n当函数开始的时候，就会处理 var 声明（脚本启动对应全局变量）。 var 声明的变量会在函数开头被定义，与它在代码中定义的位置无关（这里不考虑定义在嵌套函数中的情况）。\n\n🌰 例子：\n\nfunction sayHi() {\n  phrase = "Hello";\n  console.log(phrase);\n  var phrase;\n}\nsayHi();\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 由于 var 会被在函数的开头定义，所以相当于：\n> \n> function sayHi() {\n>   var phrase;\n>   phrase = "Hello";\n>   console.log(phrase);\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n🌰 例子 / 在 if 中：\n\nfunction sayHi() {\n  phrase = "Hello"; // (*)\n  if (false) {\n    var phrase;\n  }\n  alert(phrase);\n}\nsayHi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这个例子中， if (false) 分支永远都不会执行，但没关系，它里面的 var 在函数刚开始时就被处理了，所以在执行 (*) 那行代码时，变量是存在的。\n\n变量提升（hoisting /rasing） ，所有的 var 都被「提升」到了函数的顶部。声明会被提升，但是赋值不会。\n\n🌰 例子 ：\n\nfunction sayHi(){\n  console.log(phrase)\n  var phrase = \'hello\'\n}\nsayHi() // undefined\n\n\n1\n2\n3\n4\n5\n\n\n> var phrase = "Hello" 这行代码包含两个行为：\n> \n>  1. 使用 var 声明变量。\n>  2. 使用 = 给变量赋值。\n> \n> 但是提升只有声明会被提升，而赋值不会，赋值操作始终是在赋值出现的地方才起作用，所以相当于：\n> \n> function sayHi() {\n>   var phrase; // 在函数刚开始时进行变量声明\n>   alert(phrase); // undefined\n>   phrase = "Hello"; // ……赋值 — 当程序执行到这一行时。\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> var 声明可以在函数开头处理，所以可以在任何地方引用。但是，不赋值之前都是为 undefined ，所以使用变量之前最好要先被赋值。\n\n\n# 「IIFE」\n\n因为 var 声明的变量没有 块级作用域，为了实现类似 块级作用域的效果，程序员们就发明 「立即调用函数表达式（immediately-invoked function expressions，IIFE）」利用了函数作用域的特性。\n\n现在的脚本中基本不会使用 IFFE 了。\n\n🌰 例子：\n\n(function() {\n  var message = "Hello";\n  alert(message); // Hello\n})();\n\n\n1\n2\n3\n4\n\n\n> 这里，创建了一个函数表达式并立即调用。因此，代码立即执行并拥有了自己的私有变量。',normalizedContent:'在 javascript 还没有使用 let 声明变量之前，一般使用 var 声明变量。但是 var 声明变量有许多知名\n\n\n# var 中没有「块级作用域」\n\n用 var 声明的变量，不是 函数作用域 就是 全局作用域，它们在代码块外也是可见的，所以不存在 块级作用域的说法。\n\n🌰 例子 / 对于 if 代码块：\n\nif(true) {\n  var test = true\n}\n\nconsole.log(test) // true \n\n\n1\n2\n3\n4\n5\n\n\n> 由于 var 会忽略代码块，所以声明了 全局变量 test 。如果使用 let 则仅 if 代码块内部中可见。\n\n🌰 例子 / 对于 for 代码块：\n\nfor(var i = 0; i < 10; i++) {\n  var one = 1\n}\n\nconsole.log(i)\nconsole.log(one)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 for 代码块中，使用 var 声明的变量同样相当于是 全局变量 。\n\n如果一个代码块位于函数内部，那么 var 声明的变量的作用域将为函数作用域。\n\n🌰 例子 / 函数作用域：\n\nfunction sayhi() {\n  if(true) {\n    var phrase = \'hello\'\n  }\n  \n  console.log(phrase)\n}\n\nsayhi()\nconsole.log(phrase) // 函数内部的变量对外不可见\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> var 穿透了 if ， for 和其它代码块。这是因为在早期的 javascript 中，块没有词法环境，而 var 就是这个时期的代表之一。\n\n\n# var 允许重新变量的重新声明\n\n> 在 let 声明变量时，在同一作用域下将同一个变量声明两次，则会出现错误。\n\n使用 var ，可以重复声明一个变量，不管多少次都行。如果对一个已经声明的变量使用 var ，这条新的声明语句会被忽略 var ，即覆盖上一次声明的内容：\n\nvar user = "pete";\n\nvar user = "john"; // 这个 "var" 无效（因为变量已经声明过了）\n// ……不会触发错误\n\nalert(user); // john\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# var 可以在声明前被使用 / 变量提升\n\n当函数开始的时候，就会处理 var 声明（脚本启动对应全局变量）。 var 声明的变量会在函数开头被定义，与它在代码中定义的位置无关（这里不考虑定义在嵌套函数中的情况）。\n\n🌰 例子：\n\nfunction sayhi() {\n  phrase = "hello";\n  console.log(phrase);\n  var phrase;\n}\nsayhi();\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 由于 var 会被在函数的开头定义，所以相当于：\n> \n> function sayhi() {\n>   var phrase;\n>   phrase = "hello";\n>   console.log(phrase);\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n🌰 例子 / 在 if 中：\n\nfunction sayhi() {\n  phrase = "hello"; // (*)\n  if (false) {\n    var phrase;\n  }\n  alert(phrase);\n}\nsayhi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这个例子中， if (false) 分支永远都不会执行，但没关系，它里面的 var 在函数刚开始时就被处理了，所以在执行 (*) 那行代码时，变量是存在的。\n\n变量提升（hoisting /rasing） ，所有的 var 都被「提升」到了函数的顶部。声明会被提升，但是赋值不会。\n\n🌰 例子 ：\n\nfunction sayhi(){\n  console.log(phrase)\n  var phrase = \'hello\'\n}\nsayhi() // undefined\n\n\n1\n2\n3\n4\n5\n\n\n> var phrase = "hello" 这行代码包含两个行为：\n> \n>  1. 使用 var 声明变量。\n>  2. 使用 = 给变量赋值。\n> \n> 但是提升只有声明会被提升，而赋值不会，赋值操作始终是在赋值出现的地方才起作用，所以相当于：\n> \n> function sayhi() {\n>   var phrase; // 在函数刚开始时进行变量声明\n>   alert(phrase); // undefined\n>   phrase = "hello"; // ……赋值 — 当程序执行到这一行时。\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> var 声明可以在函数开头处理，所以可以在任何地方引用。但是，不赋值之前都是为 undefined ，所以使用变量之前最好要先被赋值。\n\n\n# 「iife」\n\n因为 var 声明的变量没有 块级作用域，为了实现类似 块级作用域的效果，程序员们就发明 「立即调用函数表达式（immediately-invoked function expressions，iife）」利用了函数作用域的特性。\n\n现在的脚本中基本不会使用 iffe 了。\n\n🌰 例子：\n\n(function() {\n  var message = "hello";\n  alert(message); // hello\n})();\n\n\n1\n2\n3\n4\n\n\n> 这里，创建了一个函数表达式并立即调用。因此，代码立即执行并拥有了自己的私有变量。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🪤JavaScript 的模块管理",frontmatter:{title:"🪤JavaScript 的模块管理",date:"2022-05-15T22:15:44.000Z",permalink:"/pages/6edabb/",categories:["📔 JavaScript 其他内容"],tags:["JavaScript深入部分"]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/40.%20%F0%9F%93%94%20JavaScript%20%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/10.%20%F0%9F%AA%A4JavaScript%20%E7%9A%84%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86.html",relativePath:"101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/10. 🪤JavaScript 的模块管理.md",key:"v-0558a126",path:"/pages/6edabb/",headers:[{level:2,title:"关于 JavaScript 模块",slug:"关于-javascript-模块",normalizedTitle:"关于 javascript 模块",charIndex:2},{level:3,title:"不同的模块系统",slug:"不同的模块系统",normalizedTitle:"不同的模块系统",charIndex:101},{level:3,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:16},{level:3,title:"模块中的核心语法 / 功能",slug:"模块中的核心语法-功能",normalizedTitle:"模块中的核心语法 / 功能",charIndex:990},{level:2,title:"模块的 导出 / 导入",slug:"模块的-导出-导入",normalizedTitle:"模块的 导出 / 导入",charIndex:3414},{level:3,title:"在声明之前导出",slug:"在声明之前导出",normalizedTitle:"在声明之前导出",charIndex:3430},{level:3,title:"声明之后导出",slug:"声明之后导出",normalizedTitle:"声明之后导出",charIndex:3853},{level:3,title:"导入",slug:"导入",normalizedTitle:"导入",charIndex:376},{level:3,title:"别名",slug:"别名",normalizedTitle:"别名",charIndex:4679},{level:3,title:"export default",slug:"export-default",normalizedTitle:"export default",charIndex:4993},{level:3,title:"default",slug:"default",normalizedTitle:"default",charIndex:5e3},{level:3,title:"重新导出",slug:"重新导出",normalizedTitle:"重新导出",charIndex:6723},{level:3,title:"动态导入",slug:"动态导入",normalizedTitle:"动态导入",charIndex:8468},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:9412}],headersStr:"关于 JavaScript 模块 不同的模块系统 模块 模块中的核心语法 / 功能 模块的 导出 / 导入 在声明之前导出 声明之后导出 导入 别名 export default default 重新导出 动态导入 总结",content:"# 关于 JavaScript 模块\n\n随着 JavaScript 中的脚本应用代码越来越多，可以将它 拆分成多个文件（模块 Module）。一个模块可以包含用来 特定目的的类 或者 函数库。\n\n\n# 不同的模块系统\n\n * AMD ： 基于 require.js 库实现的模块系统。\n\n * CommonJS： 为 Node.js 服务器创建的模块系统。\n\n * UMD： 建议作为通用的模块系统，兼容 AMD 和 CommonJS。\n\n\n# 模块\n\n一个模块 （Module）就是一个文件。（一个脚本）模块之间可以互相加载，使用特殊的指令 export 和 import 交换功能，从一个模块调用另一个模块的 函数。\n\n * export （导出）：用来标记 从当前模块 外部可以访问的变量和函数。\n * import （引入）：允许 从其他模块 导入变量和函数。\n\n🌰 例子：\n\n * 在 sayHi.js 文件中 导出 一个函数：\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n\n1\n2\n3\n\n * 在另一个文件（例如 main.js ）导入并且使用这个函数：\n\nimport { sayHi } from './sayHi.js'\n\nconsole.log(sayHi) // function sayHi ... \nsayHi('John')\n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 在浏览器中导入模块\n\n由于模块支持特殊的关键字和功能，因此必须要通过使用 <script type=\"module\"> 特性来告诉浏览器，此脚本应该被当作模块来对待。\n\n（ sayHi.js 同上）\n\n * 在 HTML 页面文件中：\n\n<!DOCTYPE html>\n<script type=\"module\">\n  import {sayHi} from './say.js';\n\n  document.body.innerHTML = sayHi('John');\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 浏览器会自动获取并解析导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。\n> \n> 注意在浏览器打开 file 协议的 HTML 文件读取模块不起作用。\n\n\n# 模块中的核心语法 / 功能\n\n在模块中：\n\n * 给未声明的变量赋值不能使用，将产生错误。\n\n * 每个模块都有自己的 顶级作用域。即 一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。\n   \n   > 但是，可以通过将变量显式地分配给 window 的一个属性，使其成为窗口级别的全局变量。例如 window.user = \"John\" 。这样所有的脚本都会看到它，无论脚本是否带有 type=\"module\" 。避免全局变量的使用！\n\n * 模块代码仅在第一次导入时被解析。如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时。将其导出的内容提供给进一步的导入。\n   \n   🌰 例子：\n   \n   * 在一个模块 alert.js 中，导出一个 JavaScript 语句：\n   \n   console.log(\"Module is evaluated!\")\n   \n   \n   1\n   \n   * 在不同的文件中导入相同的模块：\n   \n   // 📁 1.js\n   import `./alert.js`; // Module is evaluated!\n   \n   // 📁 2.js\n   import `./alert.js`; // (什么都不显示)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 所以，一般 顶层模块代码应该用于初始化，创建模块特定的内部数据结构。如果需要多次调用某些东西，应该将其以函数的形式导出。\n   \n   🌰 例子 / 模块导出对象：\n   \n   // 📁 admin.js\n   export let admin = {\n     name: \"John\"\n   };\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   如果这个模块被导入到多个文件中，模块仅在 第一次被导入时被解析，并创建 admin 对象，然后将其传入到所有的导入。\n   \n   即，所有的导入获得的都是同一个唯一的 admin 对象：\n   \n   // 📁 1.js\n   import { admin } from './admin.js';\n   admin.name = \"Pete\";\n   \n   // 📁 2.js\n   import { admin } from './admin.js';\n   alert(admin.name); // Pete\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   > 当在一个脚本中导入一个模块对象，并修改它；在另一个脚本中可以看到该修改，因为共享的是同一个 模块对象。\n   \n   🌰 例子：\n   \n   > 模块可以提供需要配置的通用功能，可以导出一个配置对象，期望外部代码可以对其进行赋值。\n   > \n   > 这是经典的模块使用方式：\n   > \n   >  * 模块导出一些配置方法，例如一个配置对象。\n   >  * 在第一次导入时，对其进行初始化，写入其属性。可以在应用顶级脚本中进行此操作。\n   >  * 进一步地导入使用模块。\n   \n   * admin.js 模块可能提供了某些功能（例如身份验证），但希望凭证可以从模块之外赋值到 config 对象：\n   \n   // 📁 admin.js\n   export let config = { };\n   \n   export function sayHi() {\n     alert(`Ready to serve, ${config.user}!`);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   * 在 init.js 中，导入了 config 并设置了 设置了 config.user ：\n   \n   import { config } from './admin.js';\n   config.user = \"Pete\";\n   \n   \n   1\n   2\n   \n   * 在另一个脚本中导入 config ：\n   \n   // 📁 another.js\n   import { sayHi } from './admin.js';\n   \n   sayHi(); // Ready to serve, Pete!\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 这时可以正确显示被配置的内容。\n\n * import.meta ：该对象包含关于当前模块的信息。\n   \n   它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。\n   \n   🌰 例子 / 获取当前 HTML 的 URL：\n   \n   <script type=\"module\">\n     alert(import.meta.url);\n   <\/script>\n   \n   \n   1\n   2\n   3\n   \n\n * 在一个模块中 顶级 this 的值为 undefined （对比来看，非模块的 this 是 全局对象）\n   \n   🌰 例子：\n   \n   <script>\n     alert(this); // window\n   <\/script>\n   \n   <script type=\"module\">\n     alert(this); // undefined\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# 模块的 导出 / 导入\n\n\n# 在声明之前导出\n\n可以通过在声明之前放置 export 来标记 任意声明 为导出，无论声明的是变量，函数还是类都可以。\n\n🌰 例子：\n\n// 导出数组\nexport let months = ['Jan', ... ]\n\n// 导出常量 \nexport const STANDARD_YEAR = 2048;\n            \n// 导出类\nexport class User {\n\tconstructor(name) {\n    this.name = name\n  }                      \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n提示\n\n** 导出 class / function 后没有分号。** 在类或者函数前的 export 不会让它们变成 函数表达式。尽管被导出了，但它仍然是一个函数声明。大部分 JavaScript 样式指南都不建议在函数和类声明后使用分号。\n\n\n# 声明之后导出\n\n🌰 例子 / 先声明函数再导出：\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nfunction sayBye(user) {\n  alert(`Bye, ${user}!`);\n}\n\nexport {sayHi, sayBye};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 一般最后的导出放在代码末尾，防止遗漏。\n\n\n# 导入\n\n * 通常导入：把要导入的东西列在花括号 import {...} 中。\n   \n   🌰 例子：\n   \n   // 📁 main.js\n   import {sayHi, sayBye} from './say.js';\n   \n   sayHi('John');\n   sayBye('John');\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 将导入的内容为一个 对象。\n   \n   🌰 例子：\n   \n   import * as say from './say.js';\n   \n   say.sayHi('John');\n   say.sayBye('John');\n   \n   \n   1\n   2\n   3\n   4\n   \n\n提示\n\n最好明确列出 要导入的内容。\n\n * 现代的构建工具（webpack 和其他工具）将模块打包到一起并对其进行优化，以加快加载速度并删除未使用的代码。\n   \n   优化器（optimizer）就会检测到导入，并从打包好的代码中删除那些未被使用的函数，从而使构建更小。这就是所谓的「摇树（tree-shaking）」。\n\n * 明确列出要导入的内容会使得名称较短： sayHi() 而不是 say.sayHi() 。\n\n * 导入的显式列表可以更好地概述代码结构：使用的内容和位置。它使得代码支持重构，并且重构起来更容易。\n\n\n# 别名\n\n使用 as 让导入和导出具有不同的名字。\n\n * import as * ：\n   \n   🌰 例子：\n   \n   import {sayHi as hi, sayBye as bye} from './say.js';\n   \n   hi('John'); // Hello, John!\n   bye('John');\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * export as * ：\n   \n   🌰 例子：\n   \n   export {sayHi as hi, sayBye as bye};\n   \n   \n   1\n   \n   \n   在导入时使用别名。\n\n\n# export default\n\n> 实际情况中有两种模块：\n> \n>  * 包含库或函数包的模块。\n>  * 声明 单个实体 的模块。\n> \n> 大部分情况下，开发者倾向于使用第二种方式，以便每个「东西」都存在于它自己的模块中。\n> \n> 文件具有良好的命名，并且文件夹结构得当，那么代码导航会变得更容易。\n\n模块的 默认导出语法： export default 放在要导出的实体前。\n\n🌰 例子：\n\n * 默认导出一个类 User ：\n\n// 📁 user.js\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 每个文件可能只有一个 export default ，所以导入不用 {} ：\n\n// 📁 main.js\nimport User from './user.js'; // 不需要花括号 {User}，只需要写成 User 即可\n\nnew User('John');\n\n\n1\n2\n3\n4\n\n\n由于每个文件最多只能有一个默认的导出，因此导出的实体可能没有名称。\n\n🌰 例子：\n\n// 导出类\nexport default class { \n  constructor() { ... }\n}\n  \n// 导出函数\nexport default function(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// 数组\nexport default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 对于不加 default ，又不给命名，这样的导出是错误的。\n\n\n# default\n\n在某些情况下， default 关键词被用于 引用 默认的导出。\n\n🌰 例子：\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nexport {sayHi as default};\n\n\n1\n2\n3\n4\n5\n\n\n> 与 export default 的效果相同。\n\n🌰 例子 / 当模块中又有 默认导出 又有别的一些导出时：\n\n// 📁 user.js\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n导入时：\n\n// 📁 main.js\nimport {default as User, sayHi} from './user.js';\n\nnew User('John');\n\n\n1\n2\n3\n4\n\n\n另一种方法， 将所有东西 * 作为对象导入：\n\n// 📁 main.js\nimport * as user from './user.js';\n\nlet User = user.default; // 默认的导出\nnew User('John');\n\n\n1\n2\n3\n4\n5\n\n\n提示\n\n * 对于命名的导出，在导入时一般使用正确相同的名称。\n\n * 对于默认的导出，一般使用文件名相同的名称形式导入（别的命名也可以，但一般为了变量命名规范，要与文件名对应）。\n   \n   🌰 例子：\n   \n   import User from './user.js';\n   import LoginForm from './loginForm.js';\n   import func from '/path/to/func.js';\n   ...\n   \n   \n   1\n   2\n   3\n   4\n   \n\n所以即便是模块中只有一个实体导出，也一般使用命名导出，这也方便了 重新导出。\n\n\n# 重新导出\n\n重新导出 export ... from 允许导入内容，并立即将其导出（可能是用的是其他的名字）。\n\n🌰 例子：\n\nexport {sayHi} from './say.js'; // 重新导出 sayHi\n\nexport {default as User} from './user.js'; // 重新导出 default\n\n\n1\n2\n3\n\n\n🌰 例子 / 实际应用例子：\n\n> 当开发一个 package （一个包含大量模块的文件夹），其中一些功能是导出到外部的，并且其中一些模块仅仅是供其他 package 中的模块内部使用的 「辅助模块」。\n> \n> > 文件结构：\n> > \n> > auth/\n> >     index.js\n> >     user.js\n> >     helpers.js\n> >     tests/\n> >         login.js\n> >     providers/\n> >         github.js\n> >         facebook.js\n> >         ...\n> > \n> > \n> > 1\n> > 2\n> > 3\n> > 4\n> > 5\n> > 6\n> > 7\n> > 8\n> > 9\n> > 10\n\n当想要使用其中的功能，应该只从 index.js 导入：\n\nimport {login, logout} from 'auth/index.js'\n\n\n1\n\n\n所以 index.js 出口文件 应该要导出希望包中提供的所有功能：\n\n> 这样做的目的，其他使用包的开发者不应该干预其内部结构，不应该搜索包的文件夹中的文件。所以只在 auth/index.js 中导出必要的部分，并保持其他内容「不可见」。\n\n// 📁 auth/index.js\n\n// 导入 login/logout 然后立即导出它们\nimport {login, logout} from './helpers.js';\nexport {login, logout};\n\n// 将默认导出导入为 User，然后导出它\nimport User from './user.js';\nexport {User};\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用 export ... from ... 可以简写这个过程：\n\n// 📁 auth/index.js\nexport {login, logout} from './helpers.js'\n\nexport {default as User} from './user.js'\n\n\n1\n2\n3\n4\n\n\nexport ... from 与 import/export 相比的显着区别是 重新导出的模块在当前文件中不可用。所以在上面的 auth/index.js 中，不能使用重新导出的 login/logout 函数。\n\n🌰 例子 / 重新导出 默认导出：\n\n * 如果 有一个 user.js 脚本，其中写了 export default class User ，并且想重新导出类 User ：\n\n// 📁 user.js\nexport default class User {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n> 这时可能会遇到两个问题：\n> \n>  * export User from './user.js' 无效。\n>    \n>    要重新导出默认导出，必须明确写出 export {default as User} ，就像上面的例子中那样。\n> \n>  * export * from './user.js' 重新导出只导出了 命名的导出，但是忽略了默认的导出。\n\n如果想要将 命名的导出和默认的导出都重新导出，那么需要两条语句：\n\nexport * from './user.js' // 重新导出命名的导出\nexport {default} from './user.js' // 重新导出默认的导出\n\n\n1\n2\n\n\n> 所以 默认导出 给重新导出带来了不便。要重新导出最好命名。\n\n\n# 动态导入\n\nimport(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。可以在代码中的任意位置调用这个表达式。\n\n🌰 例子 / 使用例子：\n\nlet modulePath = prompt(\"Which module to load?\");\n\nimport(modulePath)\n  .then(obj => <module object>)\n  .catch(err => <loading error, e.g. if no such module>)\n\n\n1\n2\n3\n4\n5\n\n\n或者在 异步函数中使用 await ：\n\nlet module = await import(modulePath)\n\n\n1\n\n\n🌰 例子 / 完整例子：\n\n * 若有模块 say.js ：\n\n// 📁 say.js\nexport function hi() {\n  alert(`Hello`);\n}\n\nexport function bye() {\n  alert(`Bye`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 那么可以这样动态导入：\n\nlet {hi, bye} = await import('./say.js');\n\nhi();\nbye();\n\n\n1\n2\n3\n4\n\n * 如果模块 say.js 有默认导出：\n\n// 📁 say.js\nexport default function() {\n  alert(\"Module loaded (export default)!\");\n}\n\n\n1\n2\n3\n4\n\n * 动态导入需要在导入后使用 default 属性：\n\nlet obj = await import('./say.js');\nlet say = obj.default;\nsay();\n\n\n1\n2\n3\n\n\n或者：\n\nlet {default: say} = await import('./say.js');\n\n\n1\n\n\n提示\n\nimport() 只是一种特殊语法，不能将 import 复制到一个变量中，或者对其使用 call/apply 。因为它不是一个函数。\n\n\n# 总结\n\n * 一个模块就是一个文件。\n * 模块具有自己的本地顶级作用域，并可以通过 import/export 交换功能。\n * 模块代码只执行一次。导出仅创建一次，然后会在导入之间共享。\n\n模块的导出：\n\n * 在声明一个 class/function/… 之前：\n   * export [default] class/function/variable ...\n * 独立的导出：\n   * export {x [as y], ...} .\n * 重新导出：\n   * export {x [as y], ...} from \"module\"\n   * export * from \"module\" （不会重新导出默认的导出）。\n   * export {default [as y]} from \"module\" （重新导出默认的导出）。\n\n模块的导入：\n\n * 导入命名的导出：\n   * import {x [as y], ...} from \"module\"\n * 导入默认的导出：\n   * import x from \"module\"\n   * import {default as x} from \"module\"\n * 导入所有：\n   * import * as obj from \"module\"\n * 导入模块（其代码，并运行），但不要将其任何导出赋值给变量：\n   * import \"module\"",normalizedContent:"# 关于 javascript 模块\n\n随着 javascript 中的脚本应用代码越来越多，可以将它 拆分成多个文件（模块 module）。一个模块可以包含用来 特定目的的类 或者 函数库。\n\n\n# 不同的模块系统\n\n * amd ： 基于 require.js 库实现的模块系统。\n\n * commonjs： 为 node.js 服务器创建的模块系统。\n\n * umd： 建议作为通用的模块系统，兼容 amd 和 commonjs。\n\n\n# 模块\n\n一个模块 （module）就是一个文件。（一个脚本）模块之间可以互相加载，使用特殊的指令 export 和 import 交换功能，从一个模块调用另一个模块的 函数。\n\n * export （导出）：用来标记 从当前模块 外部可以访问的变量和函数。\n * import （引入）：允许 从其他模块 导入变量和函数。\n\n🌰 例子：\n\n * 在 sayhi.js 文件中 导出 一个函数：\n\nexport function sayhi(user) {\n  alert(`hello, ${user}!`);\n}\n\n\n1\n2\n3\n\n * 在另一个文件（例如 main.js ）导入并且使用这个函数：\n\nimport { sayhi } from './sayhi.js'\n\nconsole.log(sayhi) // function sayhi ... \nsayhi('john')\n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 在浏览器中导入模块\n\n由于模块支持特殊的关键字和功能，因此必须要通过使用 <script type=\"module\"> 特性来告诉浏览器，此脚本应该被当作模块来对待。\n\n（ sayhi.js 同上）\n\n * 在 html 页面文件中：\n\n<!doctype html>\n<script type=\"module\">\n  import {sayhi} from './say.js';\n\n  document.body.innerhtml = sayhi('john');\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 浏览器会自动获取并解析导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。\n> \n> 注意在浏览器打开 file 协议的 html 文件读取模块不起作用。\n\n\n# 模块中的核心语法 / 功能\n\n在模块中：\n\n * 给未声明的变量赋值不能使用，将产生错误。\n\n * 每个模块都有自己的 顶级作用域。即 一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。\n   \n   > 但是，可以通过将变量显式地分配给 window 的一个属性，使其成为窗口级别的全局变量。例如 window.user = \"john\" 。这样所有的脚本都会看到它，无论脚本是否带有 type=\"module\" 。避免全局变量的使用！\n\n * 模块代码仅在第一次导入时被解析。如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时。将其导出的内容提供给进一步的导入。\n   \n   🌰 例子：\n   \n   * 在一个模块 alert.js 中，导出一个 javascript 语句：\n   \n   console.log(\"module is evaluated!\")\n   \n   \n   1\n   \n   * 在不同的文件中导入相同的模块：\n   \n   // 📁 1.js\n   import `./alert.js`; // module is evaluated!\n   \n   // 📁 2.js\n   import `./alert.js`; // (什么都不显示)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 所以，一般 顶层模块代码应该用于初始化，创建模块特定的内部数据结构。如果需要多次调用某些东西，应该将其以函数的形式导出。\n   \n   🌰 例子 / 模块导出对象：\n   \n   // 📁 admin.js\n   export let admin = {\n     name: \"john\"\n   };\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   如果这个模块被导入到多个文件中，模块仅在 第一次被导入时被解析，并创建 admin 对象，然后将其传入到所有的导入。\n   \n   即，所有的导入获得的都是同一个唯一的 admin 对象：\n   \n   // 📁 1.js\n   import { admin } from './admin.js';\n   admin.name = \"pete\";\n   \n   // 📁 2.js\n   import { admin } from './admin.js';\n   alert(admin.name); // pete\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   > 当在一个脚本中导入一个模块对象，并修改它；在另一个脚本中可以看到该修改，因为共享的是同一个 模块对象。\n   \n   🌰 例子：\n   \n   > 模块可以提供需要配置的通用功能，可以导出一个配置对象，期望外部代码可以对其进行赋值。\n   > \n   > 这是经典的模块使用方式：\n   > \n   >  * 模块导出一些配置方法，例如一个配置对象。\n   >  * 在第一次导入时，对其进行初始化，写入其属性。可以在应用顶级脚本中进行此操作。\n   >  * 进一步地导入使用模块。\n   \n   * admin.js 模块可能提供了某些功能（例如身份验证），但希望凭证可以从模块之外赋值到 config 对象：\n   \n   // 📁 admin.js\n   export let config = { };\n   \n   export function sayhi() {\n     alert(`ready to serve, ${config.user}!`);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   * 在 init.js 中，导入了 config 并设置了 设置了 config.user ：\n   \n   import { config } from './admin.js';\n   config.user = \"pete\";\n   \n   \n   1\n   2\n   \n   * 在另一个脚本中导入 config ：\n   \n   // 📁 another.js\n   import { sayhi } from './admin.js';\n   \n   sayhi(); // ready to serve, pete!\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 这时可以正确显示被配置的内容。\n\n * import.meta ：该对象包含关于当前模块的信息。\n   \n   它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 url，或者如果它是在 html 中的话，则包含当前页面的 url。\n   \n   🌰 例子 / 获取当前 html 的 url：\n   \n   <script type=\"module\">\n     alert(import.meta.url);\n   <\/script>\n   \n   \n   1\n   2\n   3\n   \n\n * 在一个模块中 顶级 this 的值为 undefined （对比来看，非模块的 this 是 全局对象）\n   \n   🌰 例子：\n   \n   <script>\n     alert(this); // window\n   <\/script>\n   \n   <script type=\"module\">\n     alert(this); // undefined\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# 模块的 导出 / 导入\n\n\n# 在声明之前导出\n\n可以通过在声明之前放置 export 来标记 任意声明 为导出，无论声明的是变量，函数还是类都可以。\n\n🌰 例子：\n\n// 导出数组\nexport let months = ['jan', ... ]\n\n// 导出常量 \nexport const standard_year = 2048;\n            \n// 导出类\nexport class user {\n\tconstructor(name) {\n    this.name = name\n  }                      \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n提示\n\n** 导出 class / function 后没有分号。** 在类或者函数前的 export 不会让它们变成 函数表达式。尽管被导出了，但它仍然是一个函数声明。大部分 javascript 样式指南都不建议在函数和类声明后使用分号。\n\n\n# 声明之后导出\n\n🌰 例子 / 先声明函数再导出：\n\nfunction sayhi(user) {\n  alert(`hello, ${user}!`);\n}\n\nfunction saybye(user) {\n  alert(`bye, ${user}!`);\n}\n\nexport {sayhi, saybye};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 一般最后的导出放在代码末尾，防止遗漏。\n\n\n# 导入\n\n * 通常导入：把要导入的东西列在花括号 import {...} 中。\n   \n   🌰 例子：\n   \n   // 📁 main.js\n   import {sayhi, saybye} from './say.js';\n   \n   sayhi('john');\n   saybye('john');\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 将导入的内容为一个 对象。\n   \n   🌰 例子：\n   \n   import * as say from './say.js';\n   \n   say.sayhi('john');\n   say.saybye('john');\n   \n   \n   1\n   2\n   3\n   4\n   \n\n提示\n\n最好明确列出 要导入的内容。\n\n * 现代的构建工具（webpack 和其他工具）将模块打包到一起并对其进行优化，以加快加载速度并删除未使用的代码。\n   \n   优化器（optimizer）就会检测到导入，并从打包好的代码中删除那些未被使用的函数，从而使构建更小。这就是所谓的「摇树（tree-shaking）」。\n\n * 明确列出要导入的内容会使得名称较短： sayhi() 而不是 say.sayhi() 。\n\n * 导入的显式列表可以更好地概述代码结构：使用的内容和位置。它使得代码支持重构，并且重构起来更容易。\n\n\n# 别名\n\n使用 as 让导入和导出具有不同的名字。\n\n * import as * ：\n   \n   🌰 例子：\n   \n   import {sayhi as hi, saybye as bye} from './say.js';\n   \n   hi('john'); // hello, john!\n   bye('john');\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * export as * ：\n   \n   🌰 例子：\n   \n   export {sayhi as hi, saybye as bye};\n   \n   \n   1\n   \n   \n   在导入时使用别名。\n\n\n# export default\n\n> 实际情况中有两种模块：\n> \n>  * 包含库或函数包的模块。\n>  * 声明 单个实体 的模块。\n> \n> 大部分情况下，开发者倾向于使用第二种方式，以便每个「东西」都存在于它自己的模块中。\n> \n> 文件具有良好的命名，并且文件夹结构得当，那么代码导航会变得更容易。\n\n模块的 默认导出语法： export default 放在要导出的实体前。\n\n🌰 例子：\n\n * 默认导出一个类 user ：\n\n// 📁 user.js\nexport default class user {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 每个文件可能只有一个 export default ，所以导入不用 {} ：\n\n// 📁 main.js\nimport user from './user.js'; // 不需要花括号 {user}，只需要写成 user 即可\n\nnew user('john');\n\n\n1\n2\n3\n4\n\n\n由于每个文件最多只能有一个默认的导出，因此导出的实体可能没有名称。\n\n🌰 例子：\n\n// 导出类\nexport default class { \n  constructor() { ... }\n}\n  \n// 导出函数\nexport default function(user) {\n  alert(`hello, ${user}!`);\n}\n\n// 数组\nexport default ['jan', 'feb', 'mar','apr', 'aug', 'sep', 'oct', 'nov', 'dec'];\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 对于不加 default ，又不给命名，这样的导出是错误的。\n\n\n# default\n\n在某些情况下， default 关键词被用于 引用 默认的导出。\n\n🌰 例子：\n\nfunction sayhi(user) {\n  alert(`hello, ${user}!`);\n}\n\nexport {sayhi as default};\n\n\n1\n2\n3\n4\n5\n\n\n> 与 export default 的效果相同。\n\n🌰 例子 / 当模块中又有 默认导出 又有别的一些导出时：\n\n// 📁 user.js\nexport default class user {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport function sayhi(user) {\n  alert(`hello, ${user}!`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n导入时：\n\n// 📁 main.js\nimport {default as user, sayhi} from './user.js';\n\nnew user('john');\n\n\n1\n2\n3\n4\n\n\n另一种方法， 将所有东西 * 作为对象导入：\n\n// 📁 main.js\nimport * as user from './user.js';\n\nlet user = user.default; // 默认的导出\nnew user('john');\n\n\n1\n2\n3\n4\n5\n\n\n提示\n\n * 对于命名的导出，在导入时一般使用正确相同的名称。\n\n * 对于默认的导出，一般使用文件名相同的名称形式导入（别的命名也可以，但一般为了变量命名规范，要与文件名对应）。\n   \n   🌰 例子：\n   \n   import user from './user.js';\n   import loginform from './loginform.js';\n   import func from '/path/to/func.js';\n   ...\n   \n   \n   1\n   2\n   3\n   4\n   \n\n所以即便是模块中只有一个实体导出，也一般使用命名导出，这也方便了 重新导出。\n\n\n# 重新导出\n\n重新导出 export ... from 允许导入内容，并立即将其导出（可能是用的是其他的名字）。\n\n🌰 例子：\n\nexport {sayhi} from './say.js'; // 重新导出 sayhi\n\nexport {default as user} from './user.js'; // 重新导出 default\n\n\n1\n2\n3\n\n\n🌰 例子 / 实际应用例子：\n\n> 当开发一个 package （一个包含大量模块的文件夹），其中一些功能是导出到外部的，并且其中一些模块仅仅是供其他 package 中的模块内部使用的 「辅助模块」。\n> \n> > 文件结构：\n> > \n> > auth/\n> >     index.js\n> >     user.js\n> >     helpers.js\n> >     tests/\n> >         login.js\n> >     providers/\n> >         github.js\n> >         facebook.js\n> >         ...\n> > \n> > \n> > 1\n> > 2\n> > 3\n> > 4\n> > 5\n> > 6\n> > 7\n> > 8\n> > 9\n> > 10\n\n当想要使用其中的功能，应该只从 index.js 导入：\n\nimport {login, logout} from 'auth/index.js'\n\n\n1\n\n\n所以 index.js 出口文件 应该要导出希望包中提供的所有功能：\n\n> 这样做的目的，其他使用包的开发者不应该干预其内部结构，不应该搜索包的文件夹中的文件。所以只在 auth/index.js 中导出必要的部分，并保持其他内容「不可见」。\n\n// 📁 auth/index.js\n\n// 导入 login/logout 然后立即导出它们\nimport {login, logout} from './helpers.js';\nexport {login, logout};\n\n// 将默认导出导入为 user，然后导出它\nimport user from './user.js';\nexport {user};\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用 export ... from ... 可以简写这个过程：\n\n// 📁 auth/index.js\nexport {login, logout} from './helpers.js'\n\nexport {default as user} from './user.js'\n\n\n1\n2\n3\n4\n\n\nexport ... from 与 import/export 相比的显着区别是 重新导出的模块在当前文件中不可用。所以在上面的 auth/index.js 中，不能使用重新导出的 login/logout 函数。\n\n🌰 例子 / 重新导出 默认导出：\n\n * 如果 有一个 user.js 脚本，其中写了 export default class user ，并且想重新导出类 user ：\n\n// 📁 user.js\nexport default class user {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n> 这时可能会遇到两个问题：\n> \n>  * export user from './user.js' 无效。\n>    \n>    要重新导出默认导出，必须明确写出 export {default as user} ，就像上面的例子中那样。\n> \n>  * export * from './user.js' 重新导出只导出了 命名的导出，但是忽略了默认的导出。\n\n如果想要将 命名的导出和默认的导出都重新导出，那么需要两条语句：\n\nexport * from './user.js' // 重新导出命名的导出\nexport {default} from './user.js' // 重新导出默认的导出\n\n\n1\n2\n\n\n> 所以 默认导出 给重新导出带来了不便。要重新导出最好命名。\n\n\n# 动态导入\n\nimport(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。可以在代码中的任意位置调用这个表达式。\n\n🌰 例子 / 使用例子：\n\nlet modulepath = prompt(\"which module to load?\");\n\nimport(modulepath)\n  .then(obj => <module object>)\n  .catch(err => <loading error, e.g. if no such module>)\n\n\n1\n2\n3\n4\n5\n\n\n或者在 异步函数中使用 await ：\n\nlet module = await import(modulepath)\n\n\n1\n\n\n🌰 例子 / 完整例子：\n\n * 若有模块 say.js ：\n\n// 📁 say.js\nexport function hi() {\n  alert(`hello`);\n}\n\nexport function bye() {\n  alert(`bye`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 那么可以这样动态导入：\n\nlet {hi, bye} = await import('./say.js');\n\nhi();\nbye();\n\n\n1\n2\n3\n4\n\n * 如果模块 say.js 有默认导出：\n\n// 📁 say.js\nexport default function() {\n  alert(\"module loaded (export default)!\");\n}\n\n\n1\n2\n3\n4\n\n * 动态导入需要在导入后使用 default 属性：\n\nlet obj = await import('./say.js');\nlet say = obj.default;\nsay();\n\n\n1\n2\n3\n\n\n或者：\n\nlet {default: say} = await import('./say.js');\n\n\n1\n\n\n提示\n\nimport() 只是一种特殊语法，不能将 import 复制到一个变量中，或者对其使用 call/apply 。因为它不是一个函数。\n\n\n# 总结\n\n * 一个模块就是一个文件。\n * 模块具有自己的本地顶级作用域，并可以通过 import/export 交换功能。\n * 模块代码只执行一次。导出仅创建一次，然后会在导入之间共享。\n\n模块的导出：\n\n * 在声明一个 class/function/… 之前：\n   * export [default] class/function/variable ...\n * 独立的导出：\n   * export {x [as y], ...} .\n * 重新导出：\n   * export {x [as y], ...} from \"module\"\n   * export * from \"module\" （不会重新导出默认的导出）。\n   * export {default [as y]} from \"module\" （重新导出默认的导出）。\n\n模块的导入：\n\n * 导入命名的导出：\n   * import {x [as y], ...} from \"module\"\n * 导入默认的导出：\n   * import x from \"module\"\n   * import {default as x} from \"module\"\n * 导入所有：\n   * import * as obj from \"module\"\n * 导入模块（其代码，并运行），但不要将其任何导出赋值给变量：\n   * import \"module\"",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🔦 JavaScript 的错误处理",frontmatter:{title:"🔦 JavaScript 的错误处理",date:"2022-05-26T17:38:30.000Z",permalink:"/pages/7c3484/",categories:["📔 JavaScript 其他内容"],tags:["JavaScript深入部分"]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/40.%20%F0%9F%93%94%20JavaScript%20%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/20.%20%F0%9F%94%A6%20JavaScript%20%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",relativePath:"101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/20. 🔦 JavaScript 的错误处理.md",key:"v-61eaf91f",path:"/pages/7c3484/",headers:[{level:2,title:"try...catch 结构",slug:"try-catch-结构",normalizedTitle:"try...catch 结构",charIndex:2},{level:3,title:"Error 对象",slug:"error-对象",normalizedTitle:"error 对象",charIndex:768},{level:3,title:"抛出 Error 对象",slug:"抛出-error-对象",normalizedTitle:"抛出 error 对象",charIndex:1381},{level:3,title:"finally",slug:"finally",normalizedTitle:"finally",charIndex:2308},{level:2,title:"全局 catch",slug:"全局-catch",normalizedTitle:"全局 catch",charIndex:3132}],headersStr:"try...catch 结构 Error 对象 抛出 Error 对象 finally 全局 catch",content:"# try...catch 结构\n\ntry {\n\n  // 代码...\n\n} catch (err) {\n\n  // 错误捕获\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n其中 err 将包含一个 error 对象，该对象包含了所发生事件的详细信息。\n\n🌰 例子：\n\ntry {\n  console.log('Start of try runs');  // (1) <--\n  lalala; // Error，变量未定义！\n  console.log('End of try (never reached)');  // (2)\n} catch (err) {\n  console.log(err); // (3) <--\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\ntry...catch 仅对运行时的 error 有效。\n\n要使得 try...catch 能工作，代码必须是可执行的。换句话说，它必须是有效的 JavaScript 代码。如果代码包含语法错误，那么 try..catch 将无法正常工作（编译错误）。\n\ntry...catch 只能处理有效代码中出现的错误（运行错误），或者为 异常。\n\n提示\n\n在使用如 setTimeout 定时器 计划的代码时，应该：\n\nsetTimeout(function() {\n  try {\n    noSuchVariable; // try...catch 处理 error 了！\n  } catch {\n    alert( \"error is caught here!\" );\n  }\n}, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果在 setTimeout 外部使用则捕获不了错误，因为引擎已经离开了 try ... catch 结构。\n\n\n# Error 对象\n\n发生错误时，JavaScript 生成包含错误有关其详细信息的对象，作为参数传送给 catch 。\n\n内建的 Error 对象中包含：\n\n * name ：``Error` 名称。\n * message ：关于错误的详细文字描述。\n * stack ：当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。\n\n🌰 例子：\n\ntry {\n  lalala; // error, variable is not defined!\n} catch (err) {\n  alert(err.name); // ReferenceError\n  alert(err.message); // lalala is not defined\n  alert(err.stack); // ReferenceError: lalala is not defined at (...call stack)\n\n  // 整体错误对象输出\n  alert(err); // ReferenceError: lalala is not defined\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n提示\n\n新增的 JavaScript 特性中，可以不使用 Error 对象：\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 抛出 Error 对象\n\n使用 throw 操作符会生成一个 error 对象。\n\n🌰 例子：\n\nlet json = '{ \"age\": 30 }'; // 不完整的数据\n\ntry {\n\n  let user = JSON.parse(json); \n\n  if (!user.name) {\n    throw new SyntaxError(\"Incomplete data: no name\");\n  }\n\n  alert( user.name );\n\n} catch(err) {\n  alert( \"JSON Error: \" + err.message ); // JSON Error: Incomplete data: no name\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次抛出错误 Error 对象： catch 应该只处理它知道的 error，并在此抛出所有其他 error。\n\n🌰 例子：\n\nlet json = '{ \"age\": 30 }'; // 不完整的数据\ntry {\n\n  let user = JSON.parse(json);\n\n  if (!user.name) {\n    throw new SyntaxError(\"Incomplete data: no name\");\n  }\n\n  blabla(); // 预料之外的 error\n\n  alert( user.name );\n\n} catch (err) {\n\n  if (err instanceof SyntaxError) {\n    alert( \"JSON Error: \" + err.message );\n  } else {\n    throw err; // 再次抛出 (*)\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> catch 中只处理了 SyntaxError ，对于其他错误，再次抛出，交由外部的 try…catch 结构处理，如果没有被处理则 脚本就会被杀死。\n\n\n# finally\n\nfinally 子句通常用在：当开始做某事的时候，希望无论出现什么情况都要完成完成某个任务。\n\n> 无论是 有无出现错误，都会执行 finally 中的工作。\n\n🌰 例子：\n\ntry {\n  confirm( 'try' );\n  if (confirm('Make an error?')) BAD_CODE();\n} catch (err) {\n  console.log( 'catch' );\n} finally {\n  console.log( 'finally' );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n注意 try 中的局部变量。如果在 try 中声明变量（使用 let ），那么该变量只能在 try 中使用可见。 finally 中不可见。\n\n * 在 try 中的 return ：\n   \n   try {\n     return 1;\n   } catch (err) {\n     /* ... */\n   } finally {\n     console.log( 'finally' );\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   此时，先执行 finally 中的代码，再执行 return 。\n\n * 只用 try...finally ：\n   \n   当不想再 try 结构中处理错误，但是要确保 finally 中的代码要执行：\n   \n   try{\n     // ...\n   } finally {\n     // ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 由于没有 catch ，所以 try 中的 error 总是会使代码执行跳转至函数 func() 外。但是，在跳出之前需要执行 finally 中的代码。\n\n\n# 全局 catch\n\n即使没有 try...catch ，大多数执行环境也允许设置全局错误处理程序来捕获 出错对象。在浏览器中，就是 window.onerror 。",normalizedContent:"# try...catch 结构\n\ntry {\n\n  // 代码...\n\n} catch (err) {\n\n  // 错误捕获\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n其中 err 将包含一个 error 对象，该对象包含了所发生事件的详细信息。\n\n🌰 例子：\n\ntry {\n  console.log('start of try runs');  // (1) <--\n  lalala; // error，变量未定义！\n  console.log('end of try (never reached)');  // (2)\n} catch (err) {\n  console.log(err); // (3) <--\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\ntry...catch 仅对运行时的 error 有效。\n\n要使得 try...catch 能工作，代码必须是可执行的。换句话说，它必须是有效的 javascript 代码。如果代码包含语法错误，那么 try..catch 将无法正常工作（编译错误）。\n\ntry...catch 只能处理有效代码中出现的错误（运行错误），或者为 异常。\n\n提示\n\n在使用如 settimeout 定时器 计划的代码时，应该：\n\nsettimeout(function() {\n  try {\n    nosuchvariable; // try...catch 处理 error 了！\n  } catch {\n    alert( \"error is caught here!\" );\n  }\n}, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果在 settimeout 外部使用则捕获不了错误，因为引擎已经离开了 try ... catch 结构。\n\n\n# error 对象\n\n发生错误时，javascript 生成包含错误有关其详细信息的对象，作为参数传送给 catch 。\n\n内建的 error 对象中包含：\n\n * name ：``error` 名称。\n * message ：关于错误的详细文字描述。\n * stack ：当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。\n\n🌰 例子：\n\ntry {\n  lalala; // error, variable is not defined!\n} catch (err) {\n  alert(err.name); // referenceerror\n  alert(err.message); // lalala is not defined\n  alert(err.stack); // referenceerror: lalala is not defined at (...call stack)\n\n  // 整体错误对象输出\n  alert(err); // referenceerror: lalala is not defined\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n提示\n\n新增的 javascript 特性中，可以不使用 error 对象：\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 抛出 error 对象\n\n使用 throw 操作符会生成一个 error 对象。\n\n🌰 例子：\n\nlet json = '{ \"age\": 30 }'; // 不完整的数据\n\ntry {\n\n  let user = json.parse(json); \n\n  if (!user.name) {\n    throw new syntaxerror(\"incomplete data: no name\");\n  }\n\n  alert( user.name );\n\n} catch(err) {\n  alert( \"json error: \" + err.message ); // json error: incomplete data: no name\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次抛出错误 error 对象： catch 应该只处理它知道的 error，并在此抛出所有其他 error。\n\n🌰 例子：\n\nlet json = '{ \"age\": 30 }'; // 不完整的数据\ntry {\n\n  let user = json.parse(json);\n\n  if (!user.name) {\n    throw new syntaxerror(\"incomplete data: no name\");\n  }\n\n  blabla(); // 预料之外的 error\n\n  alert( user.name );\n\n} catch (err) {\n\n  if (err instanceof syntaxerror) {\n    alert( \"json error: \" + err.message );\n  } else {\n    throw err; // 再次抛出 (*)\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> catch 中只处理了 syntaxerror ，对于其他错误，再次抛出，交由外部的 try…catch 结构处理，如果没有被处理则 脚本就会被杀死。\n\n\n# finally\n\nfinally 子句通常用在：当开始做某事的时候，希望无论出现什么情况都要完成完成某个任务。\n\n> 无论是 有无出现错误，都会执行 finally 中的工作。\n\n🌰 例子：\n\ntry {\n  confirm( 'try' );\n  if (confirm('make an error?')) bad_code();\n} catch (err) {\n  console.log( 'catch' );\n} finally {\n  console.log( 'finally' );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n注意 try 中的局部变量。如果在 try 中声明变量（使用 let ），那么该变量只能在 try 中使用可见。 finally 中不可见。\n\n * 在 try 中的 return ：\n   \n   try {\n     return 1;\n   } catch (err) {\n     /* ... */\n   } finally {\n     console.log( 'finally' );\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   此时，先执行 finally 中的代码，再执行 return 。\n\n * 只用 try...finally ：\n   \n   当不想再 try 结构中处理错误，但是要确保 finally 中的代码要执行：\n   \n   try{\n     // ...\n   } finally {\n     // ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 由于没有 catch ，所以 try 中的 error 总是会使代码执行跳转至函数 func() 外。但是，在跳出之前需要执行 finally 中的代码。\n\n\n# 全局 catch\n\n即使没有 try...catch ，大多数执行环境也允许设置全局错误处理程序来捕获 出错对象。在浏览器中，就是 window.onerror 。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🎪 JavaScript Proxy 和 Reflect",frontmatter:{title:"🎪 JavaScript Proxy 和 Reflect",date:"2022-05-26T20:04:21.000Z",permalink:"/pages/15a7cb/",categories:["📔 JavaScript 其他内容"],tags:["JavaScript深入部分"]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/40.%20%F0%9F%93%94%20JavaScript%20%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/30.%20%F0%9F%8E%AA%20JavaScript%20Proxy%20%E5%92%8C%20Reflect.html",relativePath:"101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/30. 🎪 JavaScript Proxy 和 Reflect.md",key:"v-0c4acd47",path:"/pages/15a7cb/",headers:[{level:2,title:"Proxy",slug:"proxy",normalizedTitle:"proxy",charIndex:36},{level:3,title:"读取和写入操作",slug:"读取和写入操作",normalizedTitle:"读取和写入操作",charIndex:2228},{level:3,title:"迭代操作",slug:"迭代操作",normalizedTitle:"迭代操作",charIndex:3537},{level:3,title:"对内部受保护属性操作",slug:"对内部受保护属性操作",normalizedTitle:"对内部受保护属性操作",charIndex:4848},{level:3,title:"使用 has 拦截 in",slug:"使用-has-拦截-in",normalizedTitle:"使用 has 拦截 in",charIndex:6728},{level:3,title:"包装函数",slug:"包装函数",normalizedTitle:"包装函数",charIndex:7123},{level:2,title:"Reflect",slug:"reflect",normalizedTitle:"reflect",charIndex:8001},{level:3,title:"代理 getter 访问器",slug:"代理-getter-访问器",normalizedTitle:"代理 getter 访问器",charIndex:9182},{level:2,title:"Proxy 的局限",slug:"proxy-的局限",normalizedTitle:"proxy 的局限",charIndex:10283},{level:3,title:"内建对象的内部插槽",slug:"内建对象的内部插槽",normalizedTitle:"内建对象的内部插槽",charIndex:10297},{level:3,title:"私有字段",slug:"私有字段",normalizedTitle:"私有字段",charIndex:10995},{level:3,title:"代理对象之后…",slug:"代理对象之后",normalizedTitle:"代理对象之后…",charIndex:11480},{level:3,title:"可撤销的代理",slug:"可撤销的代理",normalizedTitle:"可撤销的代理",charIndex:11923},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:12784}],headersStr:"Proxy 读取和写入操作 迭代操作 对内部受保护属性操作 使用 has 拦截 in 包装函数 Reflect 代理 getter 访问器 Proxy 的局限 内建对象的内部插槽 私有字段 代理对象之后… 可撤销的代理 总结",content:'> Vue 的新版中 响应式 数据实现原理。\n> \n> ECMA 关于 Proxy 的规范： ECMAScript® 2023 Language Specification (tc39.es)\n> \n> MDN 参考：Proxy - JavaScript | MDN (mozilla.org)\n\n\n# Proxy\n\n使用 Proxy 对象可以 包装另一个对象 并且 拦截读写操作，然后在 自行处理 读写操作、或者允许该对象处理读写操作。\n\n使用语法：\n\nlet proxy = new Proxy(target, handler)\n\n\n1\n\n * target ： 要包装的对象，可以是任意对象（包括函数）。\n * handler ：代理的配置。（带有 拦截操作的方法 的对象）， get 拦截读操作， set 拦截写操作。\n\n对 proxy 进行操作，如果在 handler 中存在相应的 拦截方法，则运行该拦截方法，并且 Proxy 有机会对它进行处理。如果没有则对 target 直接处理。\n\n🌰 例子：\n\nlet target = {}\nlet proxy = new Proxy(target, {})\n\nproxy.test = 5\nconsole.log(target.test)\nconsole.log(proxy.test)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 上面的例子， handler 为空，则对 target 直接进行读写操作，对于 proxy 的操作直接转发给了 target 。\n\n提示\n\nProxy 是一个特殊的对象，没有自己的属性，如果 handler 为空，则透明地将操作转发给 target 。\n\n能给 Proxy 添加的 handler 捕捉器：\n\n> handler 能拦截 JavaScript 中的内部工作方法，例如 [[get]] 读取属性的内部方法、 [[set]] 写入属性的内部方法。因为这些方法名称仅在规范中使用，不能通过直接调用使用。\n> \n> 所以要通过 Proxy 的 handler 捕捉器拦截这些方法的调用。\n\n常用：\n\n内部方法              HANDLER 方法       何时触发\n[[Get]]           get              读取属性\n[[Set]]           set              写入属性\n[[HasProperty]]   has              in 操作符\n[[Delete]]        deleteProperty   delete 操作符\n[[Call]]          apply            函数调用\n[[Construct]]     construct        new 操作符\n\n点击查看\n\n[[GETPROTOTYPEOF]]      GETPROTOTYPEOF             OBJECT.GETPROTOTYPEOF\n[[SetPrototypeOf]]      setPrototypeOf             Object.setPrototypeOf\n[[IsExtensible]]        isExtensible               Object.isExtensible\n[[PreventExtensions]]   preventExtensions          Object.preventExtensions\n[[DefineOwnProperty]]   defineProperty             Object.defineProperty, Object.defineProperties\n[[GetOwnProperty]]      getOwnPropertyDescriptor   Object.getOwnPropertyDescriptor, for..in ,\n                                                   Object.keys/values/entries\n[[OwnPropertyKeys]]     ownKeys                    Object.getOwnPropertyNames, Object.getOwnPropertySymbols,\n                                                   for..in , Object.keys/values/entries s\n\n> JavaScript 将强制执行 内部方法和捕捉器必须遵循的条件 （不变量）。例如：\n> \n>  * [[Set]] 如果值已成功写入，则必须返回 true ，否则返回 false 。\n> \n>  * [[Delete]] 如果已成功删除该值，则必须返回 true ，否则返回 false 。\n> \n>  * [[GetPrototypeOf]] ，必须返回与应用于被代理对象的 [[GetPrototypeOf]] 相同的值。读取代理对象的原型必须始终返回被代理对象的原型。\n> \n> 不变量确保了语言功能的正确和一致的行为。\n\n\n# 读取和写入操作\n\n使用捕捉器拦截读取操作， handler 应该有 get(target, property, receiver) 方法，在读取属性时触发该方法。\n\n * target ：目标对象，该对象被作为第一个参数传递给 new Proxy 。\n * property ：目标属性名。\n * receiver ：如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象。一般是 proxy 对象的本身。\n\n🌰 例子 / 使用 handler 实现对象的默认值：\n\nlet numbers = [1,2,3]\n\nnumbers = new Proxy(numbers, {\n  get(target, property) {\n    if(property in target) {\n      return target[prop]\n    } else {\n      return 0 // 默认值\n    }\n  }\n})\n\nconsole.log(numbers[0]) // 1\nconsole.log(numbers[3]) // 0 因为没有这个数组项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 利用 捕捉器 拦截读取操作，可以避免 要读取的目标属性中没有 目标值 时，赋予默认值可以替代 undefined 的情况。\n\n> numbers = new Proxy(numbers, ...) 完全替代了原来的目标对象。代理该目标对象后，不应该在引用目标对象。\n\n使用捕捉器拦截写入操作， set 捕捉器被触发 set(target, property, value, receiver) ：\n\n * target ：是目标对象。（要写入的对象）\n * property ：目标属性名称。\n * value ：目标属性的值。（要写入的值）\n * receiver ：与 get 捕捉器类似，仅与 setter 访问器属性相关。\n\n🌰 例子：\n\nlet numbers = []\n\nnumbers = new Proxy(numbers, {\n  set(target, property, value) {\n    if(typef value === \'number\') {\n      target[property] = value\n      return true\n    } else {\n      return false\n    }\n  }\n})\n\nnumbers.push(1)\nnumbers.push("test") // TypeError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 使用 set 拦截了 写入的操作，简单实现了规定（限制）了要写入的值的类型。因此不需要重写添加元素数组方法就可以检查写入数组的值的类型。\n> \n> 并且 set 必须要在写入成功时返回 true 。如果没有返回，或者返回 false ，都会报错。\n\n\n# 迭代操作\n\nObject.keys ， for..in 循环和大多数其他遍历对象属性的方法都使用内部方法 [[OwnPropertyKeys]] （由 ownKeys 捕捉器拦截) 来获取属性列表。\n\n可以使用 ownkeys 拦截遍历操作。\n\n🌰 例子 / 使用 ownkeys 拦截，遍历时跳过带有 _ 开头的属性：\n\nlet user = {\n  name: "John",\n  age: 30,\n  _password: "***"\n};\n\nuser = new Proxy(user, {\n  ownKeys(target) {\n    return Object.keys(target).filter(key => !key.startWith(\'_\'))\n  }\n})\n\nfor(let key in user) console.log(key)\n\n// 对下列方法同样有效\nconsole.log(Object.keys(user))\nconsole.log(Object.values(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n但是当 返回对象中不存在的键 时， ownKeys 失效：\n\nlet user = { };\n\nuser = new Proxy(user, {\n  ownKeys(target) {\n    return [\'a\', \'b\', \'c\'];\n  }\n});\n\nconsole.log(Object.keys(user)) // <empty>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 因为 Object.keys 仅返回带有 enumerable 标志的属性。该方法会对每个属性调用内部方法 [[GetOwnProperty]] 来获取 描述符。而 新返回的键， 没有属性、描述符为空，自然会被忽略。\n> \n> 如果要使得 新返回的键 能带有 enumerable 描述符，可以 拦截 [[GetOwnProperty]] 的调用，返回带有 enumberable: true 的描述符。\n> \n> let user = { };\n> \n> user = new Proxy(user, {\n>   // 一旦获取属性列表就会调用\n>   ownKeys(target) { \n>     return [\'a\', \'b\', \'c\'];\n>   },\n> \n>   // 一旦获取属性就会调用\n>   getOwnPropertyDescriptor(target, prop) { \n>     return {\n>       enumerable: true,\n>       configurable: true\n>       // ... \n>     };\n>   }\n> \n> });\n> \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n\n\n# 对内部受保护属性操作\n\n受保护的属性一般使用 开头 _ 标识属性名称。但技术上，还是能够从外部获取。所以可以通过使用捕捉器，例如拦截 [[get]] 读取操作实现保护 _ 开头的 受保护属性。\n\n只需要实现：\n\n * get 读取属性时抛出错误；\n * set 写入属性时抛出错误；\n * deleteProperty 删除属性时抛出错误；\n * 遍历时（ for...in 、 Object.keys ） 排除掉这些属性。\n\n🌰 例子：\n\nlet user = {\n  name: "simon",\n  _password: "****"\n}\n\nuser = new Proxy(user, {\n  get(target, property) {\n    if(property.startsWith("_")) {\n      throw new Error("Accress Denied")\n    }\n  },\n  set(target, property, value) {\n    if(property.startsWith("_")) {\n      throw new Error("Accress Denied")\n    } else {\n      target[property] = value\n      return true\n    }\n  },\n  deleteProperty(target, property) {\n    if(property.startsWith("_")) {\n      throw new Error("Accress Denied")\n    } else {\n      delete target[property]\n      return true\n    }\n  },\n  ownKeys(target) {\n    return Object.keys(target).filter(key => !key.startsWith("_"))\n  }\n})\n\ntry {\n  console.log(user._password)\n} catch (error) { console.log(error)}\n\ntry {\n\tuser._password = "test"\n} catch (error) { console.log(error)}\n\ntry {\n  delete user._password\n} catch (error) { console.log(error)}\n\nfor(key in user) {\n  console.log(user) // name\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n在要利用一个 访问器 访问该保护属性时，要在拦截方法 get 中检测 属性的类型：\n\n🌰 例子：\n\n当要调用 访问器时：\n\nuser = {\n  // ... \n  checkPassword(value) {\n    return value === this._password\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 检测输入的密码是否与 保护的属性 密码值相同。\n\nget(target, property) {\n  let value = target[property]\n  return (typeof value === \'function\') ? value.bind(target) : value\n}\n\n\n1\n2\n3\n4\n\n\n> 在拦截之后，调用该 target[property] 可能会丢失原来的上下文对象，所以要使用 bind 绑定原来的 target ，使得它将来的调用都会使用 target 为 this 。\n\n> 上述的 保护内部属性 的代理方式，虽然可行，但是存在未知性的错误。如果一个方法可能会降未被代理的对象传递到其他地方，然后 此时原始对象和被代理对象都可能丢失。并且一个对象也可能会被代理多次，如果将未被包装的对象传递给方法，就会产生未知的错误。\n> \n> 所以不应该这样使用代理对象。在 新的 JavaScript 特性中，已经使用 # 标识私有属性。\n\n\n# 使用 has 拦截 in\n\n当使用 in 操作符来检查一个数字是否在 range 范围内。\n\nhas 捕捉器可以拦截 in 的调用， has(target, property) ：\n\n * target ：目标对象；\n * property ：属性名称；\n\n🌰 例子：\n\nlet range = {\n  start: 1,\n  end: 10\n}\n\nrange = new Proxy(range, {\n  has(target, property) {\n    return prop >= target.start && prop <= target.end\n  }\n})\n\nconsole.log(5 in range)  // true\nconsole.log(50 in range) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 包装函数\n\n将 代理 包装在函数的周围，使用 apply(target, thisArg, args) 捕捉器代理 以函数的方式被调用：\n\n * target ：目标对象（函数）；\n * thisArg ： this 的值；\n * args ：参数列表；\n\n🌰 例子 / 延迟函数的调用装饰器 delay(f, ms) ：\n\n * 在 基于函数 方式实现：\n\n点击查看\n\nfunction delay(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms)\n  }\n}\n\nfunction sayHi(user) {\n  console.log(`Hi, ${user}`)\n}\n\nconsole.log(sayHi.length) // 1（参数个数）\n\nsayHi = delay(sayHi, 3000)\n\nconsole.log(sayHi.length) // 0 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 基于函数实现的包装函数，不会转发 属性 读取和写入操作，进行包装后就会失去对原始函数属性的访问，例如 name 、 length 。\n\n * 使用 apply 捕捉器拦截：\n\nfunction delay(f, ms) {\n  return new Proxy(f, {\n    apply(target, thisArg, args) {\n      setTimeout(() => target.apply(thisArgs, args), ms)\n    }\n  })\n} \n\nsayHi = delay(sayHi, 3000)\nconsole.log(sayHi.length) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 使用 Proxy 的功能要强大得多，因为它可以将所有东西转发到目标对象。\n> \n> 这时得到一个 更加丰富 的包装器。\n\n\n# Reflect\n\n是 JavaScript 的内建对象，简化 Proxy 的创建。\n\n在 Proxy 中不可以直接调用 [[Get]] 、 [[Set]] 等规范性内部方法，在 Reflect 对象中可以调用这些方法的最小包装。\n\n并且， Reflect 运行将 操作符 （ new 、 delete 等）作为函数执行调用（对应方法 construct 、 deleteProperty ）。\n\n点击查看\n\n操作                  REFLECT 调用                          内部方法\nobj[prop]           Reflect.get(obj, prop)              [[Get]]\nobj[prop] = value   Reflect.set(obj, prop, value)       [[Set]]\ndelete obj[prop]    Reflect.deleteProperty(obj, prop)   [[Delete]]\nnew F(value)        Reflect.construct(F, value)         [[Construct]]\n\n🌰 例子：\n\nlet user = {}\nReflect.set(user, \'name\', \'John\')\nconsole.log(user.name) // John\n\n\n1\n2\n3\n\n\n对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同。 所以，可以使用 Reflect 来将操作转发给原始对象。\n\n🌰 例子 / 结合 Proxy 和 Reflect 的使用：\n\nlet user = {}\n\nuser = new Proxy(user, {\n  get(target, property, receiver) {\n    console.log(`GET ${property}`)\n    return Reflect.get(target, property, receiver)\n  },\n  set(target, property, value, receiver) {\n    console.log(`SET ${property} = ${value}`)\n    return Reflect.set(target, property, value, receiver)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 如果一个捕捉器想要将调用转发给对象，则只需使用相同的参数调用 Reflect.<method> 就足够了。 简化了 Proxy 的工作。\n\n\n# 代理 getter 访问器\n\n🌰 例子：\n\nlet user = {\n  _name: "Guest",\n  get name() {\n    return this._name\n  }\n}\n\nlet userProxy = new Proxy(user, {\n  get(target, property, receiver) {\n    return target[prop]\n  }\n})\nconsole.log(userProperty.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 此处，一切还正常。\n\n创建一个以 userProxy 为原型的 admin 对象：\n\nlet admin = {\n  __proto__: userProxy,\n  _name: "Admin"\n}\n\nconsole.log(admin.name) // "Guest"\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以看出，如果直接读取 admin.name ，没有找到 amdin 中的 name 属性，转而向 admin 的原型对象 userProxy 找，此时 userProxy.name 会代理 读取属性 的方法，找到的是上下文是 user 的上下文，所以输出的是 guest 。\n\n要解决这种情况，需要使用捕捉器 get 的第三个参数 receiver 将正确的 this 转发给 getter 。但是按照规范 Proxy 中的 get 不能被调用，所以可以利用 Reflect.get ：\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return Reflect.get(target, prop, receiver)\n  }\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 此时通过 receiver 保留了对正确 this 的引用（即 admin ）。\n\n简化 Reflect 的使用：\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return Reflect.get(...arguments)\n  }\n})\n\n\n1\n2\n3\n4\n5\n\n\nReflect 调用的命名与捕捉器的命名完全相同，并且接受相同的参数。它们是以这种方式专门设计的。\n\n因此， return Reflect... 提供了一个安全的方式，可以轻松地转发操作，并确保不会忘记与此相关的任何内容。\n\n\n# Proxy 的局限\n\n\n# 内建对象的内部插槽\n\n许多内建对象，例如 Map ， Set ， Date ， Promise 等，都使用「内部插槽」。它们类似于属性，但仅限于内部使用，仅用于规范目的。\n\n例如， Map 将项目（item）存储在 [[MapData]] 中。内建方法可以直接访问它们，而不通过 [[Get]]/[[Set]] 内部方法。\n\n所以，当使用 Proxy 代理这些内建对象，这些内部插槽并不能被拦截。\n\n🌰 例子：\n\nlet map = new Map()\nlet proxy = new Proxy(map, {})\nproxy.set(\'test\', 1) // Error\n\n\n1\n2\n3\n\n\n> 由于 this =。proxy ，在 proxy 中无法找到 this.[[MapData] ，所以报错。\n\n解决方法：\n\nlet proxy = new Proxy(map, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n    return typeof value == \'function\' ? value.bind(target) : value;\n  }\n});\n\nproxy.set(\'test\', 1);\nconsole.log(proxy.get(\'test\'));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 这时， proxy.set 的内部 this 不是 proxy 而是原始的 map ，所以找得到 this.[[MapData]] 内部插槽。\n\n\n# 私有字段\n\n私有字段也是通过 内部插槽 实现的，所以直接代理并不能正常 [[GET]]/[[SET]] 。同样要使用 Reflect 带 bind 方法解决：\n\nclass User {\n  #name = "Guest";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n    return typeof value == \'function\' ? value.bind(target) : value;\n  }\n});\n\nconsole.log(user.getName()); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 但是这种方法也有缺点，将原始对象暴露给该方法，可能会进一步传递破坏其他代理功能。\n\n\n# 代理对象之后…\n\n🌰 例子：\n\nlet allUsers = new Set();\n\nclass User {\n  constructor(name) {\n    this.name = name;\n    allUsers.add(this);\n  }\n}\n\nlet user = new User("John");\nconsole.log(allUsers.has(user)) // true\n\nuser = new Proxy(user, {})\nconsole.log(allUsers.has(user)) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> user 被代理后，不能再 allusers 中找到。因为代理是一个不同的对象。\n\n注意\n\nProxy 无法拦截严格相等性检查 === ：一个对象只严格等于其自身，没有其他值。因此，比较对象是否相等的所有操作和内建类都会区分对象和代理。这里没有透明的替代品。\n\n\n# 可撤销的代理\n\n一个 可撤销 的代理是可以被禁用的代理。\n\n假设有一个资源，并且想随时关闭对该资源的访问。\n\n可以做的是将它包装成可一个撤销的代理，没有任何捕捉器。这样的代理会将操作转发给对象，并且可以随时将其禁用。\n\nlet {proxy, revoke} = Proxy.revocable(target, handler)\n\n\n1\n\n\n这个 Proxy 调用返回一个带有 proxy 和 revoke 函数的对象以将其禁用。\n\n🌰 例子：\n\nlet object = {\n  data: "Valuable data"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\nconosole.log(proxy.data) \nrevoke()\nconsole.log(proxy.data) // Error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> revoke() 的调用会从代理中删除对目标对象的所有内部引用，因此它们之间再无连接。\n\n🌰 例子 / 利用 WeakMap 的不阻止「垃圾回收」 的机制绑定 proxy 和 revoke ：\n\nlet revokes = new WeakMap()\n\nlet object = {\n  data: "Valuable data"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\nrevokes.set(proxy, revoke);\n\n// ... then\nrevoke = revokes.get(proxy)\nrevoke()\nconsole.log(proxy.data) // Error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 如果一个代理对象变得「不可访问」（例如，没有变量再引用它），则 WeakMap 允许将其与它的 revoke 一起从内存中清除，因为我们不再需要它了。\n\n\n# 总结\n\n * Proxy 是对象的包装器，将代理上的操作转发到对象，并可以选择捕获其中一些操作。它可以包装任何类型的对象，包括类和函数。',normalizedContent:'> vue 的新版中 响应式 数据实现原理。\n> \n> ecma 关于 proxy 的规范： ecmascript® 2023 language specification (tc39.es)\n> \n> mdn 参考：proxy - javascript | mdn (mozilla.org)\n\n\n# proxy\n\n使用 proxy 对象可以 包装另一个对象 并且 拦截读写操作，然后在 自行处理 读写操作、或者允许该对象处理读写操作。\n\n使用语法：\n\nlet proxy = new proxy(target, handler)\n\n\n1\n\n * target ： 要包装的对象，可以是任意对象（包括函数）。\n * handler ：代理的配置。（带有 拦截操作的方法 的对象）， get 拦截读操作， set 拦截写操作。\n\n对 proxy 进行操作，如果在 handler 中存在相应的 拦截方法，则运行该拦截方法，并且 proxy 有机会对它进行处理。如果没有则对 target 直接处理。\n\n🌰 例子：\n\nlet target = {}\nlet proxy = new proxy(target, {})\n\nproxy.test = 5\nconsole.log(target.test)\nconsole.log(proxy.test)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 上面的例子， handler 为空，则对 target 直接进行读写操作，对于 proxy 的操作直接转发给了 target 。\n\n提示\n\nproxy 是一个特殊的对象，没有自己的属性，如果 handler 为空，则透明地将操作转发给 target 。\n\n能给 proxy 添加的 handler 捕捉器：\n\n> handler 能拦截 javascript 中的内部工作方法，例如 [[get]] 读取属性的内部方法、 [[set]] 写入属性的内部方法。因为这些方法名称仅在规范中使用，不能通过直接调用使用。\n> \n> 所以要通过 proxy 的 handler 捕捉器拦截这些方法的调用。\n\n常用：\n\n内部方法              handler 方法       何时触发\n[[get]]           get              读取属性\n[[set]]           set              写入属性\n[[hasproperty]]   has              in 操作符\n[[delete]]        deleteproperty   delete 操作符\n[[call]]          apply            函数调用\n[[construct]]     construct        new 操作符\n\n点击查看\n\n[[getprototypeof]]      getprototypeof             object.getprototypeof\n[[setprototypeof]]      setprototypeof             object.setprototypeof\n[[isextensible]]        isextensible               object.isextensible\n[[preventextensions]]   preventextensions          object.preventextensions\n[[defineownproperty]]   defineproperty             object.defineproperty, object.defineproperties\n[[getownproperty]]      getownpropertydescriptor   object.getownpropertydescriptor, for..in ,\n                                                   object.keys/values/entries\n[[ownpropertykeys]]     ownkeys                    object.getownpropertynames, object.getownpropertysymbols,\n                                                   for..in , object.keys/values/entries s\n\n> javascript 将强制执行 内部方法和捕捉器必须遵循的条件 （不变量）。例如：\n> \n>  * [[set]] 如果值已成功写入，则必须返回 true ，否则返回 false 。\n> \n>  * [[delete]] 如果已成功删除该值，则必须返回 true ，否则返回 false 。\n> \n>  * [[getprototypeof]] ，必须返回与应用于被代理对象的 [[getprototypeof]] 相同的值。读取代理对象的原型必须始终返回被代理对象的原型。\n> \n> 不变量确保了语言功能的正确和一致的行为。\n\n\n# 读取和写入操作\n\n使用捕捉器拦截读取操作， handler 应该有 get(target, property, receiver) 方法，在读取属性时触发该方法。\n\n * target ：目标对象，该对象被作为第一个参数传递给 new proxy 。\n * property ：目标属性名。\n * receiver ：如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象。一般是 proxy 对象的本身。\n\n🌰 例子 / 使用 handler 实现对象的默认值：\n\nlet numbers = [1,2,3]\n\nnumbers = new proxy(numbers, {\n  get(target, property) {\n    if(property in target) {\n      return target[prop]\n    } else {\n      return 0 // 默认值\n    }\n  }\n})\n\nconsole.log(numbers[0]) // 1\nconsole.log(numbers[3]) // 0 因为没有这个数组项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 利用 捕捉器 拦截读取操作，可以避免 要读取的目标属性中没有 目标值 时，赋予默认值可以替代 undefined 的情况。\n\n> numbers = new proxy(numbers, ...) 完全替代了原来的目标对象。代理该目标对象后，不应该在引用目标对象。\n\n使用捕捉器拦截写入操作， set 捕捉器被触发 set(target, property, value, receiver) ：\n\n * target ：是目标对象。（要写入的对象）\n * property ：目标属性名称。\n * value ：目标属性的值。（要写入的值）\n * receiver ：与 get 捕捉器类似，仅与 setter 访问器属性相关。\n\n🌰 例子：\n\nlet numbers = []\n\nnumbers = new proxy(numbers, {\n  set(target, property, value) {\n    if(typef value === \'number\') {\n      target[property] = value\n      return true\n    } else {\n      return false\n    }\n  }\n})\n\nnumbers.push(1)\nnumbers.push("test") // typeerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 使用 set 拦截了 写入的操作，简单实现了规定（限制）了要写入的值的类型。因此不需要重写添加元素数组方法就可以检查写入数组的值的类型。\n> \n> 并且 set 必须要在写入成功时返回 true 。如果没有返回，或者返回 false ，都会报错。\n\n\n# 迭代操作\n\nobject.keys ， for..in 循环和大多数其他遍历对象属性的方法都使用内部方法 [[ownpropertykeys]] （由 ownkeys 捕捉器拦截) 来获取属性列表。\n\n可以使用 ownkeys 拦截遍历操作。\n\n🌰 例子 / 使用 ownkeys 拦截，遍历时跳过带有 _ 开头的属性：\n\nlet user = {\n  name: "john",\n  age: 30,\n  _password: "***"\n};\n\nuser = new proxy(user, {\n  ownkeys(target) {\n    return object.keys(target).filter(key => !key.startwith(\'_\'))\n  }\n})\n\nfor(let key in user) console.log(key)\n\n// 对下列方法同样有效\nconsole.log(object.keys(user))\nconsole.log(object.values(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n但是当 返回对象中不存在的键 时， ownkeys 失效：\n\nlet user = { };\n\nuser = new proxy(user, {\n  ownkeys(target) {\n    return [\'a\', \'b\', \'c\'];\n  }\n});\n\nconsole.log(object.keys(user)) // <empty>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 因为 object.keys 仅返回带有 enumerable 标志的属性。该方法会对每个属性调用内部方法 [[getownproperty]] 来获取 描述符。而 新返回的键， 没有属性、描述符为空，自然会被忽略。\n> \n> 如果要使得 新返回的键 能带有 enumerable 描述符，可以 拦截 [[getownproperty]] 的调用，返回带有 enumberable: true 的描述符。\n> \n> let user = { };\n> \n> user = new proxy(user, {\n>   // 一旦获取属性列表就会调用\n>   ownkeys(target) { \n>     return [\'a\', \'b\', \'c\'];\n>   },\n> \n>   // 一旦获取属性就会调用\n>   getownpropertydescriptor(target, prop) { \n>     return {\n>       enumerable: true,\n>       configurable: true\n>       // ... \n>     };\n>   }\n> \n> });\n> \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n\n\n# 对内部受保护属性操作\n\n受保护的属性一般使用 开头 _ 标识属性名称。但技术上，还是能够从外部获取。所以可以通过使用捕捉器，例如拦截 [[get]] 读取操作实现保护 _ 开头的 受保护属性。\n\n只需要实现：\n\n * get 读取属性时抛出错误；\n * set 写入属性时抛出错误；\n * deleteproperty 删除属性时抛出错误；\n * 遍历时（ for...in 、 object.keys ） 排除掉这些属性。\n\n🌰 例子：\n\nlet user = {\n  name: "simon",\n  _password: "****"\n}\n\nuser = new proxy(user, {\n  get(target, property) {\n    if(property.startswith("_")) {\n      throw new error("accress denied")\n    }\n  },\n  set(target, property, value) {\n    if(property.startswith("_")) {\n      throw new error("accress denied")\n    } else {\n      target[property] = value\n      return true\n    }\n  },\n  deleteproperty(target, property) {\n    if(property.startswith("_")) {\n      throw new error("accress denied")\n    } else {\n      delete target[property]\n      return true\n    }\n  },\n  ownkeys(target) {\n    return object.keys(target).filter(key => !key.startswith("_"))\n  }\n})\n\ntry {\n  console.log(user._password)\n} catch (error) { console.log(error)}\n\ntry {\n\tuser._password = "test"\n} catch (error) { console.log(error)}\n\ntry {\n  delete user._password\n} catch (error) { console.log(error)}\n\nfor(key in user) {\n  console.log(user) // name\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n在要利用一个 访问器 访问该保护属性时，要在拦截方法 get 中检测 属性的类型：\n\n🌰 例子：\n\n当要调用 访问器时：\n\nuser = {\n  // ... \n  checkpassword(value) {\n    return value === this._password\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 检测输入的密码是否与 保护的属性 密码值相同。\n\nget(target, property) {\n  let value = target[property]\n  return (typeof value === \'function\') ? value.bind(target) : value\n}\n\n\n1\n2\n3\n4\n\n\n> 在拦截之后，调用该 target[property] 可能会丢失原来的上下文对象，所以要使用 bind 绑定原来的 target ，使得它将来的调用都会使用 target 为 this 。\n\n> 上述的 保护内部属性 的代理方式，虽然可行，但是存在未知性的错误。如果一个方法可能会降未被代理的对象传递到其他地方，然后 此时原始对象和被代理对象都可能丢失。并且一个对象也可能会被代理多次，如果将未被包装的对象传递给方法，就会产生未知的错误。\n> \n> 所以不应该这样使用代理对象。在 新的 javascript 特性中，已经使用 # 标识私有属性。\n\n\n# 使用 has 拦截 in\n\n当使用 in 操作符来检查一个数字是否在 range 范围内。\n\nhas 捕捉器可以拦截 in 的调用， has(target, property) ：\n\n * target ：目标对象；\n * property ：属性名称；\n\n🌰 例子：\n\nlet range = {\n  start: 1,\n  end: 10\n}\n\nrange = new proxy(range, {\n  has(target, property) {\n    return prop >= target.start && prop <= target.end\n  }\n})\n\nconsole.log(5 in range)  // true\nconsole.log(50 in range) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 包装函数\n\n将 代理 包装在函数的周围，使用 apply(target, thisarg, args) 捕捉器代理 以函数的方式被调用：\n\n * target ：目标对象（函数）；\n * thisarg ： this 的值；\n * args ：参数列表；\n\n🌰 例子 / 延迟函数的调用装饰器 delay(f, ms) ：\n\n * 在 基于函数 方式实现：\n\n点击查看\n\nfunction delay(f, ms) {\n  return function() {\n    settimeout(() => f.apply(this, arguments), ms)\n  }\n}\n\nfunction sayhi(user) {\n  console.log(`hi, ${user}`)\n}\n\nconsole.log(sayhi.length) // 1（参数个数）\n\nsayhi = delay(sayhi, 3000)\n\nconsole.log(sayhi.length) // 0 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 基于函数实现的包装函数，不会转发 属性 读取和写入操作，进行包装后就会失去对原始函数属性的访问，例如 name 、 length 。\n\n * 使用 apply 捕捉器拦截：\n\nfunction delay(f, ms) {\n  return new proxy(f, {\n    apply(target, thisarg, args) {\n      settimeout(() => target.apply(thisargs, args), ms)\n    }\n  })\n} \n\nsayhi = delay(sayhi, 3000)\nconsole.log(sayhi.length) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 使用 proxy 的功能要强大得多，因为它可以将所有东西转发到目标对象。\n> \n> 这时得到一个 更加丰富 的包装器。\n\n\n# reflect\n\n是 javascript 的内建对象，简化 proxy 的创建。\n\n在 proxy 中不可以直接调用 [[get]] 、 [[set]] 等规范性内部方法，在 reflect 对象中可以调用这些方法的最小包装。\n\n并且， reflect 运行将 操作符 （ new 、 delete 等）作为函数执行调用（对应方法 construct 、 deleteproperty ）。\n\n点击查看\n\n操作                  reflect 调用                          内部方法\nobj[prop]           reflect.get(obj, prop)              [[get]]\nobj[prop] = value   reflect.set(obj, prop, value)       [[set]]\ndelete obj[prop]    reflect.deleteproperty(obj, prop)   [[delete]]\nnew f(value)        reflect.construct(f, value)         [[construct]]\n\n🌰 例子：\n\nlet user = {}\nreflect.set(user, \'name\', \'john\')\nconsole.log(user.name) // john\n\n\n1\n2\n3\n\n\n对于每个可被 proxy 捕获的内部方法，在 reflect 中都有一个对应的方法，其名称和参数与 proxy 捕捉器相同。 所以，可以使用 reflect 来将操作转发给原始对象。\n\n🌰 例子 / 结合 proxy 和 reflect 的使用：\n\nlet user = {}\n\nuser = new proxy(user, {\n  get(target, property, receiver) {\n    console.log(`get ${property}`)\n    return reflect.get(target, property, receiver)\n  },\n  set(target, property, value, receiver) {\n    console.log(`set ${property} = ${value}`)\n    return reflect.set(target, property, value, receiver)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 如果一个捕捉器想要将调用转发给对象，则只需使用相同的参数调用 reflect.<method> 就足够了。 简化了 proxy 的工作。\n\n\n# 代理 getter 访问器\n\n🌰 例子：\n\nlet user = {\n  _name: "guest",\n  get name() {\n    return this._name\n  }\n}\n\nlet userproxy = new proxy(user, {\n  get(target, property, receiver) {\n    return target[prop]\n  }\n})\nconsole.log(userproperty.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 此处，一切还正常。\n\n创建一个以 userproxy 为原型的 admin 对象：\n\nlet admin = {\n  __proto__: userproxy,\n  _name: "admin"\n}\n\nconsole.log(admin.name) // "guest"\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以看出，如果直接读取 admin.name ，没有找到 amdin 中的 name 属性，转而向 admin 的原型对象 userproxy 找，此时 userproxy.name 会代理 读取属性 的方法，找到的是上下文是 user 的上下文，所以输出的是 guest 。\n\n要解决这种情况，需要使用捕捉器 get 的第三个参数 receiver 将正确的 this 转发给 getter 。但是按照规范 proxy 中的 get 不能被调用，所以可以利用 reflect.get ：\n\nlet userproxy = new proxy(user, {\n  get(target, prop, receiver) {\n    return reflect.get(target, prop, receiver)\n  }\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 此时通过 receiver 保留了对正确 this 的引用（即 admin ）。\n\n简化 reflect 的使用：\n\nlet userproxy = new proxy(user, {\n  get(target, prop, receiver) {\n    return reflect.get(...arguments)\n  }\n})\n\n\n1\n2\n3\n4\n5\n\n\nreflect 调用的命名与捕捉器的命名完全相同，并且接受相同的参数。它们是以这种方式专门设计的。\n\n因此， return reflect... 提供了一个安全的方式，可以轻松地转发操作，并确保不会忘记与此相关的任何内容。\n\n\n# proxy 的局限\n\n\n# 内建对象的内部插槽\n\n许多内建对象，例如 map ， set ， date ， promise 等，都使用「内部插槽」。它们类似于属性，但仅限于内部使用，仅用于规范目的。\n\n例如， map 将项目（item）存储在 [[mapdata]] 中。内建方法可以直接访问它们，而不通过 [[get]]/[[set]] 内部方法。\n\n所以，当使用 proxy 代理这些内建对象，这些内部插槽并不能被拦截。\n\n🌰 例子：\n\nlet map = new map()\nlet proxy = new proxy(map, {})\nproxy.set(\'test\', 1) // error\n\n\n1\n2\n3\n\n\n> 由于 this =。proxy ，在 proxy 中无法找到 this.[[mapdata] ，所以报错。\n\n解决方法：\n\nlet proxy = new proxy(map, {\n  get(target, prop, receiver) {\n    let value = reflect.get(...arguments);\n    return typeof value == \'function\' ? value.bind(target) : value;\n  }\n});\n\nproxy.set(\'test\', 1);\nconsole.log(proxy.get(\'test\'));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 这时， proxy.set 的内部 this 不是 proxy 而是原始的 map ，所以找得到 this.[[mapdata]] 内部插槽。\n\n\n# 私有字段\n\n私有字段也是通过 内部插槽 实现的，所以直接代理并不能正常 [[get]]/[[set]] 。同样要使用 reflect 带 bind 方法解决：\n\nclass user {\n  #name = "guest";\n\n  getname() {\n    return this.#name;\n  }\n}\n\nlet user = new user();\n\nuser = new proxy(user, {\n  get(target, prop, receiver) {\n    let value = reflect.get(...arguments);\n    return typeof value == \'function\' ? value.bind(target) : value;\n  }\n});\n\nconsole.log(user.getname()); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 但是这种方法也有缺点，将原始对象暴露给该方法，可能会进一步传递破坏其他代理功能。\n\n\n# 代理对象之后…\n\n🌰 例子：\n\nlet allusers = new set();\n\nclass user {\n  constructor(name) {\n    this.name = name;\n    allusers.add(this);\n  }\n}\n\nlet user = new user("john");\nconsole.log(allusers.has(user)) // true\n\nuser = new proxy(user, {})\nconsole.log(allusers.has(user)) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> user 被代理后，不能再 allusers 中找到。因为代理是一个不同的对象。\n\n注意\n\nproxy 无法拦截严格相等性检查 === ：一个对象只严格等于其自身，没有其他值。因此，比较对象是否相等的所有操作和内建类都会区分对象和代理。这里没有透明的替代品。\n\n\n# 可撤销的代理\n\n一个 可撤销 的代理是可以被禁用的代理。\n\n假设有一个资源，并且想随时关闭对该资源的访问。\n\n可以做的是将它包装成可一个撤销的代理，没有任何捕捉器。这样的代理会将操作转发给对象，并且可以随时将其禁用。\n\nlet {proxy, revoke} = proxy.revocable(target, handler)\n\n\n1\n\n\n这个 proxy 调用返回一个带有 proxy 和 revoke 函数的对象以将其禁用。\n\n🌰 例子：\n\nlet object = {\n  data: "valuable data"\n};\n\nlet {proxy, revoke} = proxy.revocable(object, {});\n\nconosole.log(proxy.data) \nrevoke()\nconsole.log(proxy.data) // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> revoke() 的调用会从代理中删除对目标对象的所有内部引用，因此它们之间再无连接。\n\n🌰 例子 / 利用 weakmap 的不阻止「垃圾回收」 的机制绑定 proxy 和 revoke ：\n\nlet revokes = new weakmap()\n\nlet object = {\n  data: "valuable data"\n};\n\nlet {proxy, revoke} = proxy.revocable(object, {});\nrevokes.set(proxy, revoke);\n\n// ... then\nrevoke = revokes.get(proxy)\nrevoke()\nconsole.log(proxy.data) // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 如果一个代理对象变得「不可访问」（例如，没有变量再引用它），则 weakmap 允许将其与它的 revoke 一起从内存中清除，因为我们不再需要它了。\n\n\n# 总结\n\n * proxy 是对象的包装器，将代理上的操作转发到对象，并可以选择捕获其中一些操作。它可以包装任何类型的对象，包括类和函数。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🎣 JavaScript 正则表达式",frontmatter:{title:"🎣 JavaScript 正则表达式",date:"2022-03-10T11:12:21.000Z",permalink:"/pages/f38565/",categories:["📔 JavaScript 其他内容"],tags:["JavaScript深入部分"]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/40.%20%F0%9F%93%94%20JavaScript%20%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/60.%20%F0%9F%8E%A3%20JavaScript%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/60. 🎣 JavaScript 正则表达式.md",key:"v-3c9c95c2",path:"/pages/f38565/",headers:[{level:2,title:"创建正则表达式",slug:"创建正则表达式",normalizedTitle:"创建正则表达式",charIndex:63},{level:2,title:"检验方法",slug:"检验方法",normalizedTitle:"检验方法",charIndex:271},{level:3,title:"字符串方法",slug:"字符串方法",normalizedTitle:"字符串方法",charIndex:280},{level:3,title:"test() 方法",slug:"test-方法",normalizedTitle:"test () 方法",charIndex:null},{level:3,title:"exec() 方法",slug:"exec-方法",normalizedTitle:"exec () 方法",charIndex:null},{level:2,title:"匹配模式",slug:"匹配模式",normalizedTitle:"匹配模式",charIndex:100}],headersStr:"创建正则表达式 检验方法 字符串方法 test() 方法 exec() 方法 匹配模式",content:'定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。\n\n\n# 创建正则表达式\n\nvar reg = new RegExp("正则", "匹配模式");\n// 参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替\n\nvar reg = /正则表达式/匹配模式 \n//（匹配模式可选可以多个一起写：/gi）\n\n\n1\n2\n3\n4\n5\n\n\n定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。\n\n\n# 检验方法\n\n\n# 字符串方法\n\nsearch() 检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。\n\nvar str = "Visit Our Website!"; \nvar n = str.search(/Website/i); // 不分大小写\n\nvar n = str.search("website"); // 分大小写\nconsole.log(n);\n\n\n1\n2\n3\n4\n5\n\n\nreplace() 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n\nvar txt = str.replace(/microsoft/i,"Runoob");\n\n\n1\n\n\n\n# test() 方法\n\n检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true ，否则返回 false 。\n\nvar patt = /e/;\npatt.test("The best things in life are  free");\n\n\n1\n2\n\n\n\n# exec() 方法\n\n用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。\n\n/e/.exec("The best things in life are free!");\n// 输出为 e\n\n\n1\n2\n\n\n\n# 匹配模式\n\n修饰符   描述\ni     执行对大小写不敏感的匹配。\ng     执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\nm     执行多行匹配。',normalizedContent:'定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。\n\n\n# 创建正则表达式\n\nvar reg = new regexp("正则", "匹配模式");\n// 参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替\n\nvar reg = /正则表达式/匹配模式 \n//（匹配模式可选可以多个一起写：/gi）\n\n\n1\n2\n3\n4\n5\n\n\n定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。\n\n\n# 检验方法\n\n\n# 字符串方法\n\nsearch() 检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。\n\nvar str = "visit our website!"; \nvar n = str.search(/website/i); // 不分大小写\n\nvar n = str.search("website"); // 分大小写\nconsole.log(n);\n\n\n1\n2\n3\n4\n5\n\n\nreplace() 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n\nvar txt = str.replace(/microsoft/i,"runoob");\n\n\n1\n\n\n\n# test() 方法\n\n检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true ，否则返回 false 。\n\nvar patt = /e/;\npatt.test("the best things in life are  free");\n\n\n1\n2\n\n\n\n# exec() 方法\n\n用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。\n\n/e/.exec("the best things in life are free!");\n// 输出为 e\n\n\n1\n2\n\n\n\n# 匹配模式\n\n修饰符   描述\ni     执行对大小写不敏感的匹配。\ng     执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\nm     执行多行匹配。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📦 JavaScript 浏览器存储",frontmatter:{title:"📦 JavaScript 浏览器存储",date:"2022-06-04T21:31:11.000Z",permalink:"/pages/40ee0e/",categories:["📔 JavaScript 其他内容"],tags:["JavaScript深入部分"]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/40.%20%F0%9F%93%94%20JavaScript%20%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/50.%20%F0%9F%93%A6%20JavaScript%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8.html",relativePath:"101. 🚶🏻 前端巩固基础/40. 📔 JavaScript 其他内容/50. 📦 JavaScript 浏览器存储.md",key:"v-03ab99a8",path:"/pages/40ee0e/",headers:[{level:2,title:"Cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:2},{level:3,title:"读取 cookie",slug:"读取-cookie",normalizedTitle:"读取 cookie",charIndex:329},{level:3,title:"写入 cookie",slug:"写入-cookie",normalizedTitle:"写入 cookie",charIndex:444},{level:3,title:"cookie 操作函数",slug:"cookie-操作函数",normalizedTitle:"cookie 操作函数",charIndex:4766},{level:3,title:"第三方 cookie",slug:"第三方-cookie",normalizedTitle:"第三方 cookie",charIndex:6425},{level:2,title:"LocalStorage / SessionStorage",slug:"localstorage-sessionstorage",normalizedTitle:"localstorage / sessionstorage",charIndex:7103},{level:3,title:"localStorage 的使用",slug:"localstorage-的使用",normalizedTitle:"localstorage 的使用",charIndex:7740},{level:3,title:"sessionStorage 的使用",slug:"sessionstorage-的使用",normalizedTitle:"sessionstorage 的使用",charIndex:9727},{level:3,title:"storage 事件",slug:"storage-事件",normalizedTitle:"storage 事件",charIndex:8441},{level:2,title:"IndexedDB",slug:"indexeddb",normalizedTitle:"indexeddb",charIndex:10891}],headersStr:"Cookie 读取 cookie 写入 cookie cookie 操作函数 第三方 cookie LocalStorage / SessionStorage localStorage 的使用 sessionStorage 的使用 storage 事件 IndexedDB",content:'# Cookie\n\nCookie 是一串 直接存储在浏览器的数据；是 HTTP 协议的一部分；\n\n * 通常由 Web 服务器使用响应 Set-Cookie HTTP header 设置。\n * 浏览器使用 Cookie HTTP header 自动添加到（几乎） 每个对相同域 的请求中。\n\n> 🌰 例子 / 登录身份验证：\n> \n>  * 登录成功后，服务器在响应中使用 Set-Cookie HTTP-header 来设置具有唯一的会话标识符的 cookie。\n>  * 下次当请求被发送到同一个域时，浏览器会使用 Cookie HTTP-header 通过网络发送 cookie。\n>  * 服务器通过这个 cookie 识别身份的请求。\n\n\n# 读取 cookie\n\n使用 document.cookie 读取网站存储的 cookie。\n\n * cument.cookie 的值由 name=value 对组成，以 ; 分隔。\n * 每一个都是独立的 cookie。\n\n\n# 写入 cookie\n\n> 使用 JavaScript 写入 cookie 使用 document.cookie （不是数据属性），这个访问器 （包含 getter / setter ），对其赋值操作会被特殊处理。\n\n对 document.cookie 的写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie。\n\n🌰 例子：\n\ndocument.cookie = "user=john"; // 只更新名称为 user 的 cookie\nconsole.log(document.cookie); // 展示所有的 cookie\n\n\n1\n2\n\n\ncookie 的名称和值 可以是任何字符。为了保持有效的格式，它们应该使用内建的 encodeURIComponent 函数对其进行转义（与 URL 对象添加参数同理）：\n\n// 特殊字符（空格），需要编码\nlet name = "my name";\nlet value = "John Smith"\n\n// 将 cookie 编码为 my%20name=John%20Smith\ndocument.cookie = encodeURIComponent(name) + \'=\' + encodeURIComponent(value);\n\nconsole.log(document.cookie);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> cookie 存储限制：\n> \n>  * encodeURIComponent 编码后的 name=value 对，大小不能超过 4KB。\n>  * 每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。\n\nCookie 中的要设置的选项参数：\n\n> document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"\n> \n> \n> 1\n\n * path ： url 路径前缀。必须是绝对路径，使得该路径下的页面运行访问该 cookie。默认为当前路径。通常设置为 path=/ ，即使 cookie 对该网站的所有页面可见。\n   \n   例子，一个 cookie 带有 path=/admin 设置，那么该 cookie 在 /admin 和 /admin/something 下都是可见的，但是在 /home 或 /adminpage 下不可见。\n\n * domain ：控制可以访问 cookie 的域。在实际中，有一些安全限制无法设置的域，例如，无法从另一个二级域访问 cookie（ other.com 永远不会收到在 site.com 设置的 cookie），这使得 cookie 的敏感数据只能存储在一个站点上可用的 cookie 中。\n   \n   ** 默认情况下，cookie 只有在设置的域下才能被访问到。 ** 注意，默认情况下，cookie 不会共享给 子域（例如， forum.site.com 是 site.com 的子域）。\n   \n   可以通过设置 domain 允许子域设置 cookie：当在 site.com 设置 cookie 时，应该明确地将 domain 选项设置为根域： domain=site.com 。那么，所有子域都可以访问到这样的 cookie。\n   \n   🌰 例子：\n   \n   document.cookie = "user=John; domain=site.com"\n   \n   \n   1\n   \n   \n   在子域 forum.site.com 中，可以访问该 cookie：\n   \n   alert(document.cookie); // 有 cookie user=John\n   \n   \n   1\n   \n\n * expires / max-age ：控制 cookie 的过期事件。默认情况下， 不设置这两个参数的 cookie 在关闭浏览器后消失，即为 session cookie。可以通过设置这两个参数保持 cookie 在浏览器关闭后仍然存在。\n   \n   expire ：设置浏览器会清除掉该 cookie 的时间日期。\n   \n   🌰 例子：\n   \n   expires=Tue, 19 Jan 2038 03:14:07 GMT\n   \n   \n   1\n   \n   \n   > 日期格式必须为 GMT 时区格式。可以通过 date.toUTCString（） 方法转换。\n   > \n   > 🌰 例子 / 将 cookie 设置为 一天后到期：\n   > \n   > let date = new Date(Date.now() + 86400e3);\n   > date = date.toUTCString();\n   > document.cookie = "user=john; expires=" + date;\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 如果将 expires 设置为过去的日期，那么 cookie 会被直接删除。\n   \n   max-age ：是 expires 的替代选项，指明 cookie 的过期时间距离当前时间的秒数。（设置在设定的秒数之后过期）。\n   \n   🌰 例子 / 将 cookie 设置为 1 个小时后失效：\n   \n   document.cookie = "user=John; max-age=3600";\n   \n   \n   1\n   \n   \n   🌰 例子 / 设置为 0 或者负数，cookie 立即过期：\n   \n   document.cookie = "user=John; max-age=0";\n   \n   \n   1\n   \n\n * secure ：设置 cookie 的安全协议。\n   \n   > 默认情况下，如果在 http://site.com 上设置了 cookie，那么该 cookie 也会出现在 https://site.com 上，反之亦然。即此时的 cookie 不区分 HTTP 协议。\n   > \n   > 如果一个 cookie 是通过 https://site.com 设置的，那么它不会在相同域的 HTTP 环境下出现，例如 http://site.com 。所以，如果一个 cookie 包含绝不应该通过未加密的 HTTP 协议发送的敏感内容，那么就应该设置 secure 标识。\n   \n   🌰 例子 / 设置为只能在当前协议下可访问的 cookie（如当前在 HTTPS 环境下）：\n   \n   document.cookie = "user=John; secure";\n   \n   \n   1\n   \n\n * samesite ：cookie 的另一个安全特性，可以防止 XSRF （跨网站请求伪造） 攻击。\n   \n   > XSRF 攻击的例子：当用户登录了 bank.com ，有了当前网站的 cookie。浏览器会在每次请求时将其发送到 bank.com 的服务器，以便识别身份执行敏感的操作。\n   > \n   > 此时，在浏览器的另一个窗口访问另一个网站，该网站具有发送 bank.com/pay 请求的表单。当每次访问 bank.com 网站时，浏览器都会发送 cookie ，即使请求是从不同的网站发送的。\n   > \n   > 实际的网站不会允许这样的情况发生，所有由 bank.com 生成的表单都具有一个特殊的字段，（XSRF 保护 token）。恶意页面既不能生成，也不能从远程页面提取它。它可以在那里提交表单，但是无法获取数据。并且，网站 bank.com 会对收到的每个表单都进行这种 token 的检查。（一种防止 XSRF 的方式）\n   \n   上面的方法，需要检查每个表单请求的 token 字段。使用 cookie 的 samesite 选项：\n   \n   samesite=strict ：默认情况（没有值时）：除了来自同一个网站的请求，设置了 samesite=strict 的 cookie 在其他网站域永远不会被发送。\n   \n   > 设置为 strict 后， XSRF 攻击是没有机会成功的，因为来自 evil.com 的提交没有 cookie。因此， bank.com 将无法识别用户，也就不会继续进行付款。\n   > \n   > 但是 strict 有不方便的地方：当从其他地方访问 bank.com 连接时，同样也不能发送 samesite=strict 的 cookie。可以通过设置两种不同的 cookie 解决 ：一种用于「一般识别」；另一种用于进行敏感数据信息操作时的识别（设为 strict 的 cookie）。这样用户从别处访问网站时同样可以识别身份；并且进行敏感操作时必须从同一个网站启动才能进行。\n   \n   samesite=lax ：比 strict 轻松的 cookie 限制。 同样可以防止 XSRF 攻击，但是不会破坏用户的体验。\n   \n   与 strict 相似，从外部来到网站的，禁止浏览器发送 cookie，但是有例外的情况（符合以下两个条件）：\n   \n   * HTTP 方法为安全方法；（安全的 HTTP 方法一般用于读取数据，不会更改数据，例如 GET）\n   \n   * 该操作执行顶级导航（会更改浏览器地址栏中的 URL 的操作）\n     \n     > 通常成立。如果在 <iframe> 中执行就不是顶级；用于网络请求的 JavaScript 方法不会执行任何导航。\n   \n   samesite=lax 所做的是基本上允许最常见的前往 URL 操作携带 cookie。（例如，从笔记中打开网站），但是来自另一个网站的网络请求 / 表单提交都不会携带 cookie。\n\n * httpOnly：Web 服务器使用 Set-Cookie header 来设置 cookie。并且，它可以设置 httpOnly 选项。这个选项禁止任何 JavaScript 访问 cookie，即使用 document.cookie 看不到此类 cookie，也无法对此类 cookie 进行操作。\n\n\n# cookie 操作函数\n\n编写常见的 cookie 操作函数，相对于使用 document.cookie 更加方便（可以使用相似第三方库引入使用）：\n\n * getCookie(name) ：返回具有给定的 name 的 cookie。如果没有找到则返回 undefined 。\n   \n   function getCookie(name) {\n     let matches = document.cookie.match(new RegExp(\n       "(?:^|; )" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, \'\\\\$1\') + "=([^;]*)"\n     ));\n     return matches ? decodeURIComponent(matches[1]) : undefined;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * setCookie(name, value, options) ：将 cookie 的 name 设置为具有默认值 path=/ （可以修改以添加其他默认值）和给定值 value 。\n   \n   function setCookie(name, value, options = {}) {\n   \n     options = {\n       path: \'/\',\n       // 如果需要，可以在这里添加其他默认值\n       ...options\n     };\n   \n     if (options.expires instanceof Date) {\n       options.expires = options.expires.toUTCString();\n     }\n   \n     let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);\n   \n     for (let optionKey in options) {\n       updatedCookie += "; " + optionKey;\n       let optionValue = options[optionKey];\n       if (optionValue !== true) {\n         updatedCookie += "=" + optionValue;\n       }\n     }\n   \n     document.cookie = updatedCookie;\n   }\n   \n   // 使用范例：\n   setCookie(\'user\', \'John\', {secure: true, \'max-age\': 3600});\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n\n * deleteCookie(name) ：删除 cookie。\n   \n   通过设置过期时间 max-age 为 0 或者负数实现：\n   \n   function deleteCookie(name) {\n     setCookie(name, "", {\n       \'max-age\': -1\n     })\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n注意\n\n当进行更新或删除一个 cookie 操作时，应该使用和设置 cookie 时相同的路径和域选项。\n\n\n# 第三方 cookie\n\n常见的第三方 cookie 用与跟踪和广告服务。它们被绑定在原始域上，因此 ads.com 可以在不同网站之间跟踪同一用户，如果这些网站都可以访问 ads.com 的话。\n\n> 例如：\n> \n>  * site.com 网站的一个页面加载了另外一个网站的 banner： <img src="https://ads.com/banner.png"> 。\n>  * 与 banner 一起， ads.com 的远程服务器可能会设置带有 id=1234 这样的 cookie 的 Set-Cookie header。此类 cookie 源自 ads.com 域，并且仅在 ads.com 中可见。\n>  * 下次访问 ads.com 网站时，远程服务器获取 cookie id 并识别用户。\n>  * 用户从 site.com 网站跳转至另一个也带有 banner 的网站 other.com 时， ads.com 会获得该 cookie，因为它属于 ads.com ，从而识别用户并在他在网站之间切换时对其进行跟踪。\n\n> 现代浏览器可能会禁用此类的 cookie：\n> \n>  * Safari 浏览器完全不允许第三方 cookie。\n>  * Firefox 浏览器附带了一个第三方域的黑名单，它阻止了来自名单内的域的第三方 cookie。\n\n> 对于加载来自第三方域的脚本中使用 document.cookie 设置 cookie，无论脚本来自何处，设置的 cookie 都属于当前网页的域而不是第三方 cookie。\n\n\n# LocalStorage / SessionStorage\n\n通过 Web 存储对象 localStorage 和 sessionStorage 在浏览器中保存 键 / 值对数据。在页面刷新（ sessionStorage ） 或者浏览器重启之后（ localStorage ）数据仍然可以保留在浏览器中。\n\n> 相对于 cookie，Web 存储对象：\n> \n>  * Web 存储对象不会随每个请求被发送到服务器。所以可以存储更多的数据，并且浏览器允许保存至少 2 MB 的数据（或者更多），并且具有配置数据的设置；\n>  * 服务器无法通过 HTTP header 操作存储对象，一切通过 JavaScript 完成进行。\n>  * 存储绑定到源（域 / 协议 / 端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。\n\n * 键值 key / value 必须为字符串；\n * 存储大小限制为 5 MB+。取决于浏览器；\n * 没有过期时间（LocalStorage）\n\n两种存储对象提供相同的方法和属性：\n\n * setItem(key, value) ：存储键 / 值对。\n * getItem(key) ：按照键获取值。\n * removeItem(key) ：删除键及其对应的值。\n * clear() ：删除所有数据。\n * key(index) ： 获取该索引下的 键名。\n * length ：存储的内容的长度。\n\n\n# localStorage 的使用\n\n一般在所有同源的窗口之间， localStorage 数据可以共享。\n\n🌰 例子 / 使用 localStorage ：\n\n * 存储数据：\n   \n   localStorage.setItem(\'test\', 1)\n   \n   \n   1\n   \n\n * 读取数据：\n   \n   console.log(localStorage.getItem(\'test\')) // 1\n   \n   \n   1\n   \n\n> 在重新打开浏览器的同一个页面（不同窗口）也可以获取该数据；在同一个源（域 / 端口 / 协议），URL 路径可以不同，都可以共享该数据。\n\n🌰 例子 / 类对象形式的访问：\n\n与使用一个普通对象一样使用 LocalStorage：\n\n// 设置 key\nlocalStorage.test = 2;\n\n// 获取 key\nalert( localStorage.test ); // 2\n\n// 删除 key\ndelete localStorage.test;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但一般不建议这样使用：\n\n * 键值对由用户生成，可以为任何的内容。如果设置与内置对象属性相同的键（如 length / toString ），使用这种方式会出错，而使用 setItem / getItem 可以正常工作：\n   \n   let key = \'length\';\n   localStorage[key] = 5; // Error，无法对 length 进行赋值\n   \n   \n   1\n   2\n   \n\n * 存在 storage 事件，使用 类对象的形式修改数据不会触发； setItem 正常修改数据会触发。\n\n🌰 例子 / 遍历键：\n\n由于存储对象是不可迭代的。要获取所有的键（或者值）：\n\n * 使用遍历数组的方法：\n   \n   for (let i = 0; i < localStorage.length; i++) {\n     let key = localStorage.key(i)\n     console.log(`${key}: ${localStorage.getItem(key)}`)\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 使用 for... in 循环方法：\n   \n   > 注意这种方法会像处理常规对象一样；遍历所有的键，同时也会输出一些不需要的内建字段。\n   \n   for(let key in localStorage) {\n     alert(key); // 显示 getItem，setItem 和其他内建的东西\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   需要使用 hasOwnProperty 检查过滤掉原型中的字段：\n   \n   for(let key in localStorage) {\n     if (!localStorage.hasOwnProperty(key)) {\n       continue; // 跳过像 "setItem"，"getItem" 等这样的键\n     }\n     console.log(`${key}: ${localStorage.getItem(key)}`);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   或者使用 Object.keys 获取只属于自己的键，需要的遍历出来：\n   \n   let keys = Object.keys(localStorage)\n   for (let key of keys) {\n     console.log(`${key}: ${localStorage.getItem(key)}`)\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n注意，存储的对象的 键 / 值必须为 字符串。 如果为其他类型（数值、对象），会被自动转换为字符串。\n\n可以使用 JSON.stringfy() 存储对象：\n\nlocalStorage.user = JSON.stringify({name: "John"});\n\n\n1\n\n\n读取的数据使用 JSON.parse() 转换：\n\nlet user = JSON.parse(localStorage.user)\nconsole.log(user)\n\n\n1\n2\n\n\n或者对整个存储对象进行字符化处理：\n\nconsole.log(JSON.stringfy(localStorage, null, 2))\n\n\n1\n\n\n\n# sessionStorage 的使用\n\n与 localStorage 的使用基本类似，使用频率较低。使用 sessionStorage 有以下的限制：\n\n * 存储的数据只能保存在当前的会话（浏览器的标签页）：\n   * 意味着相同的页面不同的窗口会有不同的存储；\n   * 但是在同一个页面下的 iframe 下的存储是相同的。\n * 存储的数据在刷新后能保留，但是关闭或者重启浏览器不会保留。\n\n\n# storage 事件\n\n当 localStorage 或 sessionStorage 中的数据更新后， storage 事件就会被触发，它会有以下的属性：\n\n * key ：发生数据更改的键 key ；（如果调用的是 clear ， key 为 null ）\n * oldValue ：旧值；（新增数值为 null ）\n * newValue ：新值；（删除数值为 null ）\n * url ：发生数据更改的文档的 url ；\n * storageData ：发生数据更改的（ localStorage / sessionStorage ）对象；\n * storageArea ：包含存储对象（ sessionStorage 和 localStorage ）具有相同的事件，所以 event.storageArea 引用了被修改的对象。 允许同源的不同窗口交换信息。\n\n并且， storage 事件会在 所有可以访问到存储对象的 window 对象 上触发，导致当前数据发生改变的 window 对象除外。\n\n🌰 例子 / 当有两个窗口具有相同的页面， localStorage 在它们之间共享数据。如果两个窗口都监听 window.onstorage 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应。\n\n * 在其他文档对同一存储进行更新时会触发：\n   \n   window.onstorage = event => {\n     if (event.key != \'now\') return;\n     console.log(event.key + \':\' + event.newValue + " at " event.url)\n   }\n   \n   // 或者使用 window.addEventListener(\'storage\', event => {\n   // ...\n   // })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 会捕捉到关于 key 为 now 的数据的更新：\n   \n   localStorage.setItem(\'now\', Date.now())\n   \n   \n   1\n   \n\n\n# IndexedDB\n\n是一个浏览器内建的数据库，比 localStorage 强大得多。\n\n * 支持多种类型的键，可以存储几乎任何类型的值；\n * 支持事务可靠性；\n * 支持键值的范围查询、索引；\n * 相比于 localStorage 可以存储更大的数据；\n\n> IndexedDB 适用于 离线应用，可与 ServiceWorkers 和其他技术相结合使用。',normalizedContent:'# cookie\n\ncookie 是一串 直接存储在浏览器的数据；是 http 协议的一部分；\n\n * 通常由 web 服务器使用响应 set-cookie http header 设置。\n * 浏览器使用 cookie http header 自动添加到（几乎） 每个对相同域 的请求中。\n\n> 🌰 例子 / 登录身份验证：\n> \n>  * 登录成功后，服务器在响应中使用 set-cookie http-header 来设置具有唯一的会话标识符的 cookie。\n>  * 下次当请求被发送到同一个域时，浏览器会使用 cookie http-header 通过网络发送 cookie。\n>  * 服务器通过这个 cookie 识别身份的请求。\n\n\n# 读取 cookie\n\n使用 document.cookie 读取网站存储的 cookie。\n\n * cument.cookie 的值由 name=value 对组成，以 ; 分隔。\n * 每一个都是独立的 cookie。\n\n\n# 写入 cookie\n\n> 使用 javascript 写入 cookie 使用 document.cookie （不是数据属性），这个访问器 （包含 getter / setter ），对其赋值操作会被特殊处理。\n\n对 document.cookie 的写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie。\n\n🌰 例子：\n\ndocument.cookie = "user=john"; // 只更新名称为 user 的 cookie\nconsole.log(document.cookie); // 展示所有的 cookie\n\n\n1\n2\n\n\ncookie 的名称和值 可以是任何字符。为了保持有效的格式，它们应该使用内建的 encodeuricomponent 函数对其进行转义（与 url 对象添加参数同理）：\n\n// 特殊字符（空格），需要编码\nlet name = "my name";\nlet value = "john smith"\n\n// 将 cookie 编码为 my%20name=john%20smith\ndocument.cookie = encodeuricomponent(name) + \'=\' + encodeuricomponent(value);\n\nconsole.log(document.cookie);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> cookie 存储限制：\n> \n>  * encodeuricomponent 编码后的 name=value 对，大小不能超过 4kb。\n>  * 每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。\n\ncookie 中的要设置的选项参数：\n\n> document.cookie = "user=john; path=/; expires=tue, 19 jan 2038 03:14:07 gmt"\n> \n> \n> 1\n\n * path ： url 路径前缀。必须是绝对路径，使得该路径下的页面运行访问该 cookie。默认为当前路径。通常设置为 path=/ ，即使 cookie 对该网站的所有页面可见。\n   \n   例子，一个 cookie 带有 path=/admin 设置，那么该 cookie 在 /admin 和 /admin/something 下都是可见的，但是在 /home 或 /adminpage 下不可见。\n\n * domain ：控制可以访问 cookie 的域。在实际中，有一些安全限制无法设置的域，例如，无法从另一个二级域访问 cookie（ other.com 永远不会收到在 site.com 设置的 cookie），这使得 cookie 的敏感数据只能存储在一个站点上可用的 cookie 中。\n   \n   ** 默认情况下，cookie 只有在设置的域下才能被访问到。 ** 注意，默认情况下，cookie 不会共享给 子域（例如， forum.site.com 是 site.com 的子域）。\n   \n   可以通过设置 domain 允许子域设置 cookie：当在 site.com 设置 cookie 时，应该明确地将 domain 选项设置为根域： domain=site.com 。那么，所有子域都可以访问到这样的 cookie。\n   \n   🌰 例子：\n   \n   document.cookie = "user=john; domain=site.com"\n   \n   \n   1\n   \n   \n   在子域 forum.site.com 中，可以访问该 cookie：\n   \n   alert(document.cookie); // 有 cookie user=john\n   \n   \n   1\n   \n\n * expires / max-age ：控制 cookie 的过期事件。默认情况下， 不设置这两个参数的 cookie 在关闭浏览器后消失，即为 session cookie。可以通过设置这两个参数保持 cookie 在浏览器关闭后仍然存在。\n   \n   expire ：设置浏览器会清除掉该 cookie 的时间日期。\n   \n   🌰 例子：\n   \n   expires=tue, 19 jan 2038 03:14:07 gmt\n   \n   \n   1\n   \n   \n   > 日期格式必须为 gmt 时区格式。可以通过 date.toutcstring（） 方法转换。\n   > \n   > 🌰 例子 / 将 cookie 设置为 一天后到期：\n   > \n   > let date = new date(date.now() + 86400e3);\n   > date = date.toutcstring();\n   > document.cookie = "user=john; expires=" + date;\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 如果将 expires 设置为过去的日期，那么 cookie 会被直接删除。\n   \n   max-age ：是 expires 的替代选项，指明 cookie 的过期时间距离当前时间的秒数。（设置在设定的秒数之后过期）。\n   \n   🌰 例子 / 将 cookie 设置为 1 个小时后失效：\n   \n   document.cookie = "user=john; max-age=3600";\n   \n   \n   1\n   \n   \n   🌰 例子 / 设置为 0 或者负数，cookie 立即过期：\n   \n   document.cookie = "user=john; max-age=0";\n   \n   \n   1\n   \n\n * secure ：设置 cookie 的安全协议。\n   \n   > 默认情况下，如果在 http://site.com 上设置了 cookie，那么该 cookie 也会出现在 https://site.com 上，反之亦然。即此时的 cookie 不区分 http 协议。\n   > \n   > 如果一个 cookie 是通过 https://site.com 设置的，那么它不会在相同域的 http 环境下出现，例如 http://site.com 。所以，如果一个 cookie 包含绝不应该通过未加密的 http 协议发送的敏感内容，那么就应该设置 secure 标识。\n   \n   🌰 例子 / 设置为只能在当前协议下可访问的 cookie（如当前在 https 环境下）：\n   \n   document.cookie = "user=john; secure";\n   \n   \n   1\n   \n\n * samesite ：cookie 的另一个安全特性，可以防止 xsrf （跨网站请求伪造） 攻击。\n   \n   > xsrf 攻击的例子：当用户登录了 bank.com ，有了当前网站的 cookie。浏览器会在每次请求时将其发送到 bank.com 的服务器，以便识别身份执行敏感的操作。\n   > \n   > 此时，在浏览器的另一个窗口访问另一个网站，该网站具有发送 bank.com/pay 请求的表单。当每次访问 bank.com 网站时，浏览器都会发送 cookie ，即使请求是从不同的网站发送的。\n   > \n   > 实际的网站不会允许这样的情况发生，所有由 bank.com 生成的表单都具有一个特殊的字段，（xsrf 保护 token）。恶意页面既不能生成，也不能从远程页面提取它。它可以在那里提交表单，但是无法获取数据。并且，网站 bank.com 会对收到的每个表单都进行这种 token 的检查。（一种防止 xsrf 的方式）\n   \n   上面的方法，需要检查每个表单请求的 token 字段。使用 cookie 的 samesite 选项：\n   \n   samesite=strict ：默认情况（没有值时）：除了来自同一个网站的请求，设置了 samesite=strict 的 cookie 在其他网站域永远不会被发送。\n   \n   > 设置为 strict 后， xsrf 攻击是没有机会成功的，因为来自 evil.com 的提交没有 cookie。因此， bank.com 将无法识别用户，也就不会继续进行付款。\n   > \n   > 但是 strict 有不方便的地方：当从其他地方访问 bank.com 连接时，同样也不能发送 samesite=strict 的 cookie。可以通过设置两种不同的 cookie 解决 ：一种用于「一般识别」；另一种用于进行敏感数据信息操作时的识别（设为 strict 的 cookie）。这样用户从别处访问网站时同样可以识别身份；并且进行敏感操作时必须从同一个网站启动才能进行。\n   \n   samesite=lax ：比 strict 轻松的 cookie 限制。 同样可以防止 xsrf 攻击，但是不会破坏用户的体验。\n   \n   与 strict 相似，从外部来到网站的，禁止浏览器发送 cookie，但是有例外的情况（符合以下两个条件）：\n   \n   * http 方法为安全方法；（安全的 http 方法一般用于读取数据，不会更改数据，例如 get）\n   \n   * 该操作执行顶级导航（会更改浏览器地址栏中的 url 的操作）\n     \n     > 通常成立。如果在 <iframe> 中执行就不是顶级；用于网络请求的 javascript 方法不会执行任何导航。\n   \n   samesite=lax 所做的是基本上允许最常见的前往 url 操作携带 cookie。（例如，从笔记中打开网站），但是来自另一个网站的网络请求 / 表单提交都不会携带 cookie。\n\n * httponly：web 服务器使用 set-cookie header 来设置 cookie。并且，它可以设置 httponly 选项。这个选项禁止任何 javascript 访问 cookie，即使用 document.cookie 看不到此类 cookie，也无法对此类 cookie 进行操作。\n\n\n# cookie 操作函数\n\n编写常见的 cookie 操作函数，相对于使用 document.cookie 更加方便（可以使用相似第三方库引入使用）：\n\n * getcookie(name) ：返回具有给定的 name 的 cookie。如果没有找到则返回 undefined 。\n   \n   function getcookie(name) {\n     let matches = document.cookie.match(new regexp(\n       "(?:^|; )" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, \'\\\\$1\') + "=([^;]*)"\n     ));\n     return matches ? decodeuricomponent(matches[1]) : undefined;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * setcookie(name, value, options) ：将 cookie 的 name 设置为具有默认值 path=/ （可以修改以添加其他默认值）和给定值 value 。\n   \n   function setcookie(name, value, options = {}) {\n   \n     options = {\n       path: \'/\',\n       // 如果需要，可以在这里添加其他默认值\n       ...options\n     };\n   \n     if (options.expires instanceof date) {\n       options.expires = options.expires.toutcstring();\n     }\n   \n     let updatedcookie = encodeuricomponent(name) + "=" + encodeuricomponent(value);\n   \n     for (let optionkey in options) {\n       updatedcookie += "; " + optionkey;\n       let optionvalue = options[optionkey];\n       if (optionvalue !== true) {\n         updatedcookie += "=" + optionvalue;\n       }\n     }\n   \n     document.cookie = updatedcookie;\n   }\n   \n   // 使用范例：\n   setcookie(\'user\', \'john\', {secure: true, \'max-age\': 3600});\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n\n * deletecookie(name) ：删除 cookie。\n   \n   通过设置过期时间 max-age 为 0 或者负数实现：\n   \n   function deletecookie(name) {\n     setcookie(name, "", {\n       \'max-age\': -1\n     })\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n注意\n\n当进行更新或删除一个 cookie 操作时，应该使用和设置 cookie 时相同的路径和域选项。\n\n\n# 第三方 cookie\n\n常见的第三方 cookie 用与跟踪和广告服务。它们被绑定在原始域上，因此 ads.com 可以在不同网站之间跟踪同一用户，如果这些网站都可以访问 ads.com 的话。\n\n> 例如：\n> \n>  * site.com 网站的一个页面加载了另外一个网站的 banner： <img src="https://ads.com/banner.png"> 。\n>  * 与 banner 一起， ads.com 的远程服务器可能会设置带有 id=1234 这样的 cookie 的 set-cookie header。此类 cookie 源自 ads.com 域，并且仅在 ads.com 中可见。\n>  * 下次访问 ads.com 网站时，远程服务器获取 cookie id 并识别用户。\n>  * 用户从 site.com 网站跳转至另一个也带有 banner 的网站 other.com 时， ads.com 会获得该 cookie，因为它属于 ads.com ，从而识别用户并在他在网站之间切换时对其进行跟踪。\n\n> 现代浏览器可能会禁用此类的 cookie：\n> \n>  * safari 浏览器完全不允许第三方 cookie。\n>  * firefox 浏览器附带了一个第三方域的黑名单，它阻止了来自名单内的域的第三方 cookie。\n\n> 对于加载来自第三方域的脚本中使用 document.cookie 设置 cookie，无论脚本来自何处，设置的 cookie 都属于当前网页的域而不是第三方 cookie。\n\n\n# localstorage / sessionstorage\n\n通过 web 存储对象 localstorage 和 sessionstorage 在浏览器中保存 键 / 值对数据。在页面刷新（ sessionstorage ） 或者浏览器重启之后（ localstorage ）数据仍然可以保留在浏览器中。\n\n> 相对于 cookie，web 存储对象：\n> \n>  * web 存储对象不会随每个请求被发送到服务器。所以可以存储更多的数据，并且浏览器允许保存至少 2 mb 的数据（或者更多），并且具有配置数据的设置；\n>  * 服务器无法通过 http header 操作存储对象，一切通过 javascript 完成进行。\n>  * 存储绑定到源（域 / 协议 / 端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。\n\n * 键值 key / value 必须为字符串；\n * 存储大小限制为 5 mb+。取决于浏览器；\n * 没有过期时间（localstorage）\n\n两种存储对象提供相同的方法和属性：\n\n * setitem(key, value) ：存储键 / 值对。\n * getitem(key) ：按照键获取值。\n * removeitem(key) ：删除键及其对应的值。\n * clear() ：删除所有数据。\n * key(index) ： 获取该索引下的 键名。\n * length ：存储的内容的长度。\n\n\n# localstorage 的使用\n\n一般在所有同源的窗口之间， localstorage 数据可以共享。\n\n🌰 例子 / 使用 localstorage ：\n\n * 存储数据：\n   \n   localstorage.setitem(\'test\', 1)\n   \n   \n   1\n   \n\n * 读取数据：\n   \n   console.log(localstorage.getitem(\'test\')) // 1\n   \n   \n   1\n   \n\n> 在重新打开浏览器的同一个页面（不同窗口）也可以获取该数据；在同一个源（域 / 端口 / 协议），url 路径可以不同，都可以共享该数据。\n\n🌰 例子 / 类对象形式的访问：\n\n与使用一个普通对象一样使用 localstorage：\n\n// 设置 key\nlocalstorage.test = 2;\n\n// 获取 key\nalert( localstorage.test ); // 2\n\n// 删除 key\ndelete localstorage.test;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但一般不建议这样使用：\n\n * 键值对由用户生成，可以为任何的内容。如果设置与内置对象属性相同的键（如 length / tostring ），使用这种方式会出错，而使用 setitem / getitem 可以正常工作：\n   \n   let key = \'length\';\n   localstorage[key] = 5; // error，无法对 length 进行赋值\n   \n   \n   1\n   2\n   \n\n * 存在 storage 事件，使用 类对象的形式修改数据不会触发； setitem 正常修改数据会触发。\n\n🌰 例子 / 遍历键：\n\n由于存储对象是不可迭代的。要获取所有的键（或者值）：\n\n * 使用遍历数组的方法：\n   \n   for (let i = 0; i < localstorage.length; i++) {\n     let key = localstorage.key(i)\n     console.log(`${key}: ${localstorage.getitem(key)}`)\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 使用 for... in 循环方法：\n   \n   > 注意这种方法会像处理常规对象一样；遍历所有的键，同时也会输出一些不需要的内建字段。\n   \n   for(let key in localstorage) {\n     alert(key); // 显示 getitem，setitem 和其他内建的东西\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   需要使用 hasownproperty 检查过滤掉原型中的字段：\n   \n   for(let key in localstorage) {\n     if (!localstorage.hasownproperty(key)) {\n       continue; // 跳过像 "setitem"，"getitem" 等这样的键\n     }\n     console.log(`${key}: ${localstorage.getitem(key)}`);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   或者使用 object.keys 获取只属于自己的键，需要的遍历出来：\n   \n   let keys = object.keys(localstorage)\n   for (let key of keys) {\n     console.log(`${key}: ${localstorage.getitem(key)}`)\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n注意，存储的对象的 键 / 值必须为 字符串。 如果为其他类型（数值、对象），会被自动转换为字符串。\n\n可以使用 json.stringfy() 存储对象：\n\nlocalstorage.user = json.stringify({name: "john"});\n\n\n1\n\n\n读取的数据使用 json.parse() 转换：\n\nlet user = json.parse(localstorage.user)\nconsole.log(user)\n\n\n1\n2\n\n\n或者对整个存储对象进行字符化处理：\n\nconsole.log(json.stringfy(localstorage, null, 2))\n\n\n1\n\n\n\n# sessionstorage 的使用\n\n与 localstorage 的使用基本类似，使用频率较低。使用 sessionstorage 有以下的限制：\n\n * 存储的数据只能保存在当前的会话（浏览器的标签页）：\n   * 意味着相同的页面不同的窗口会有不同的存储；\n   * 但是在同一个页面下的 iframe 下的存储是相同的。\n * 存储的数据在刷新后能保留，但是关闭或者重启浏览器不会保留。\n\n\n# storage 事件\n\n当 localstorage 或 sessionstorage 中的数据更新后， storage 事件就会被触发，它会有以下的属性：\n\n * key ：发生数据更改的键 key ；（如果调用的是 clear ， key 为 null ）\n * oldvalue ：旧值；（新增数值为 null ）\n * newvalue ：新值；（删除数值为 null ）\n * url ：发生数据更改的文档的 url ；\n * storagedata ：发生数据更改的（ localstorage / sessionstorage ）对象；\n * storagearea ：包含存储对象（ sessionstorage 和 localstorage ）具有相同的事件，所以 event.storagearea 引用了被修改的对象。 允许同源的不同窗口交换信息。\n\n并且， storage 事件会在 所有可以访问到存储对象的 window 对象 上触发，导致当前数据发生改变的 window 对象除外。\n\n🌰 例子 / 当有两个窗口具有相同的页面， localstorage 在它们之间共享数据。如果两个窗口都监听 window.onstorage 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应。\n\n * 在其他文档对同一存储进行更新时会触发：\n   \n   window.onstorage = event => {\n     if (event.key != \'now\') return;\n     console.log(event.key + \':\' + event.newvalue + " at " event.url)\n   }\n   \n   // 或者使用 window.addeventlistener(\'storage\', event => {\n   // ...\n   // })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 会捕捉到关于 key 为 now 的数据的更新：\n   \n   localstorage.setitem(\'now\', date.now())\n   \n   \n   1\n   \n\n\n# indexeddb\n\n是一个浏览器内建的数据库，比 localstorage 强大得多。\n\n * 支持多种类型的键，可以存储几乎任何类型的值；\n * 支持事务可靠性；\n * 支持键值的范围查询、索引；\n * 相比于 localstorage 可以存储更大的数据；\n\n> indexeddb 适用于 离线应用，可与 serviceworkers 和其他技术相结合使用。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🎱 JavaScript 闭包",frontmatter:{title:"🎱 JavaScript 闭包",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/d7055d/",categories:["🚶🏻 前端巩固基础","🏃 JavaScript 进阶高级"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/50.%20%F0%9F%8F%83%20JavaScript%20%E8%BF%9B%E9%98%B6%E9%AB%98%E7%BA%A7/07.%20%F0%9F%8E%B1%20JavaScript%20%E9%97%AD%E5%8C%85.html",relativePath:"101. 🚶🏻 前端巩固基础/50. 🏃 JavaScript 进阶高级/07. 🎱 JavaScript 闭包.md",key:"v-e2d9dea8",path:"/pages/d7055d/",headers:[{level:3,title:"闭包的概念",slug:"闭包的概念",normalizedTitle:"闭包的概念",charIndex:883},{level:3,title:"闭包的作用",slug:"闭包的作用",normalizedTitle:"闭包的作用",charIndex:1597},{level:3,title:"闭包的生命周期",slug:"闭包的生命周期",normalizedTitle:"闭包的生命周期",charIndex:1932},{level:3,title:"闭包的应用",slug:"闭包的应用",normalizedTitle:"闭包的应用",charIndex:2283},{level:3,title:"闭包的缺点与解决",slug:"闭包的缺点与解决",normalizedTitle:"闭包的缺点与解决",charIndex:3939},{level:3,title:"面试题",slug:"面试题",normalizedTitle:"面试题",charIndex:4826}],headersStr:"闭包的概念 闭包的作用 闭包的生命周期 闭包的应用 闭包的缺点与解决 面试题",content:'🌰 例子引入：循环遍历加监听：\n\n初始：\n\n<html>\n  <button class="btns1">测试1</button>\n  <button class="btns1">测试2</button>\n  <button class="btns1">测试3</button>\n</html>\n<script>\nvar btns = document.getElementsByClassName("btns1");\n\nfor (var i = 0, length = btns.length; i < length; i++) {\n  var btn = btns[i];\n  btn.index = i;\n  btn.onclick = function () {\n    alert("第" + (this.index + 1) + "个");\n  };\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n使用闭包改进初始思路：\n\n<html>\n  <button class="btns2">测试1</button>\n  <button class="btns2">测试2</button>\n  <button class="btns2">测试3</button>\n</html>\n<script>\nvar btns = document.getElementsByClassName("btns2");\n\nfor (var i = 0, length = btns.length; i < length; i++) {\n  (function (i) {\n    var btn = btns[i];\n    btn.onclick = function () {\n      alert("第" + (i + 1) + "个");\n    };\n  })(i);\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n# 闭包的概念\n\n * 如何产生闭包：当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包。\n\n * 闭包的理解：（通过 devTools 查看 closure ）\n   \n   1. 闭包是嵌套的内部函数。（极大部分的人的理解）\n   2. 包含被引用变量（函数）的对象。（少数人理解）\n   \n   ⚠️ 注意：闭包存在于嵌套的内部函数中。\n\n * 产生闭包的条件：\n   \n   * 函数嵌套。\n   * 内部函数引用了外部函数的数据。（执行外部函数定义就会产生闭包，不必调用内部函数）\n\n🌰： 例子\n\nfunction fn1 (){\n  var a = 2 \n  function fn2 (){\n    console.log(a)\n  }\n}\nfn1()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常见的闭包：\n\n🌰 例子 1️⃣：将函数作为另一个函数的返回值：\n\nfunction fn1(){\n  var a = 2\n  function fn2() {\n  \ta++  \n    console.log(a)\n  }\n  return fn2\n}\nvar f = fn1()\nf() // 3\nf() // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 2️⃣：将函数作为实参传递给另一个函数调用：\n\nfunction showDelay(msg, time){\n  setTimeout(function (){\n  \talert(msg)\n\t}, time)\n}\n\nshowDelay(\'msg\', 2000)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 闭包的作用\n\n * 使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）。\n * 让函数外部可以操作（读 / 写）到函数内部的数据（变量或者函数）\n\n> ❓相关问题；\n> \n>  1. 函数执行完后，函数内部声明的局部变量是否还存在？\n>     \n>     一般不存在存在。当存在闭包时，可能还存在，因为该局部变量被包含在闭包内。由于外部声明了一个变量把内部的一个闭包一直关联着所以闭包会一直存在（例如上面第一个例子 var f = fn1() ）\n> \n>  2. 在函数外部能直接访问函数内部的局部变量吗？\n>     \n>     不能。但是通过闭包可以让外部操作它。（例如，通过 return xx() ，可被外部操作。）\n\n\n# 闭包的生命周期\n\n * 产生：在嵌套内部函数定义执行完就产生了（⚠️ 不是在调用时）。（例如上第一个例子 fn1() 被定义完，函数提升，内部函数对象已经创建了。）\n\n * 死亡：在嵌套的内部函数成为垃圾对象时（即包含闭包的函数对象称为垃圾对象）。（例如上第一个例子，在要抛弃闭包时，将 f = null 即可。）\n\n注意\n\n实在注意闭包的产生。对比下面的例子：\n\nfunction fn1(){\n  var a = 2\n  var f2 = fn2() { // 此时才产生闭包\n  \ta++  \n    console.log(a)\n  }\n  return fn2\n}\nvar f = fn1()\nf() // 3\nf() // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 闭包的应用\n\n可以使用闭包定义 JavaScript 模块。\n\n> JavaScript 模块：\n> \n>  * 具有特定功能的 .js 文件。\n>  * 将所有的数据和功能都封装在一个函数内部（私有的）。\n>  * 只向外暴露一个包含 n 个方法的对象或者函数（封装为对象）。\n>  * 模块的使用者只需要通过模块的对象调用方法来实现相应的功能。\n\n🌰 例子：\n\n:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"\n\n::: tab 第一种\n\n * 创建模块 MyModule.js 文件：\n\nfunction myModule1() {\n    // 似有数据\n    var msg = "test"\n\n    // 操作数据的函数\n    function doUpperCase() {\n        console.log("test")\n        console.log("doUpperCase: " + msg.toUpperCase());\n    }\n\n    function doLowerCase(){\n        console.log("doLowerCase: " + msg.toLowerCase());\n    }\n\n    // 向外暴露对象（给外部使用的方法）\n    return {\n        doUpperCase: doUpperCase,\n        doLowerCase: doLowerCase\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 在测试用 .html 文件中，引入并使用：\n\n<script type="text/javascript" src="myModule1.js"><\/script>\n<script type="text/javascript">\nvar module = myModule1()\nmodule.doUpperCase()\nmodule.doLowerCase()\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n:::\n\n::: tab ⭐️ 第二种\n\n * 创建模块 MyModule.js 文件：（修改为使用匿名函数）\n\n(function (window) {\n    // 私有数据\n    var msg = "test"\n\n    // 操作数据的函数\n    function doUpperCase() {\n        console.log("doUpperCase: " + msg.toUpperCase());\n    }\n\n    function doLowerCase() {\n        console.log("doLowerCase: " + msg.toLowerCase());\n    }\n\n    // 向外暴露对象（给外部使用的方法）\n    window.myModule2 = {\n        doUpperCase: doUpperCase,\n        doLowerCase: doLowerCase\n    }\n})(window)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 在测试用 .html 文件中，引入并使用：\n\n<script type="text/javascript" src="myModule2.js"><\/script>\n<script type="text/javascript">\nmyModule2.doLowerCase()\nmyModule2.doUpperCase()\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n:::\n\n::::\n\n\n# 闭包的缺点与解决\n\n * 闭包的缺点：\n   * 函数执行完后，函数内的局部变量没有释放，占用内存的时间会变长。\n   * 容易造成内存泄漏。\n * 解决闭包的缺点：\n   * 能不使用就不使用闭包。\n   * 及时释放使用过后的闭包。\n\n🌰 例子：\n\nfunction fn1() {\n\tvar arr = new Array[1000]\n  function fn2(){\n    console.log(arr.length)\n  }\n  return fn2\n}\n\nvar f = fn1()\nf()\nf = null // 让内部函数称为垃圾对象，♻️回收闭包。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n * 内存溢出：\n   * 一种程序运行出现的错误。\n   * 当程序运行需要的内存超过了剩余的内存时（导致崩溃内存不足），就会抛出内存溢出的错误。\n\n🌰 例子：\n\nvar obj = {}\nfor(var i = 0;i< 1000; i++){\n  obj[i] = new Array(100000) // 明显内存不足以支持处理如此庞大的数据\n}\n\n\n1\n2\n3\n4\n\n * 内存泄漏：\n   * 占用的内存没有及时释放。\n   * 内存泄漏积累多了就容易导致内存溢出。\n   * 常见的内存泄漏：\n     * 意外的全局变量。\n     * 没有及时清理的计时器或回调函数。\n     * 闭包。\n\n🌰 例子：\n\n// 意外的全局变量\nfunction fn() {\n  a = new Array(100000) // 定义后没有处理\n  console.log(a) \n}\n\n\n1\n2\n3\n4\n5\n\n\nvar intervalId = setInterval(function (){\n  console.log(\'-\')\n}, 1000)\n// clearInterval(intervalId) // 要及时清理循环定时器\n\n\n1\n2\n3\n4\n\n\n（闭包是使用后没有回收可参考之前提到的 🌰 例子）\n\n\n# 面试题\n\n⚠️ ：https://www.bilibili.com/video/BV14s411E7qf?p=36&spm_id_from=pageDriver\n\n1️⃣\n\nvar name = \'The Window\'\nvar object = {\n  name: \'My Object\',\n  getNameFunc: function() {\n    return this.name\n  }\n}\nalert(object.getNameFunc()())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n点击查看\n\n\'The Window\'\n\n\n1\n\n\n2️⃣\n\nvar name2 = \'The Window\'\nvar object2 = {\n  name2: \'My Object\',\n  getNameFunc: function() {\n    var that = this\n    return function(){\n      return that.name2\n    }\n  }\n}\nalert(object2.getNameFunc()())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n点击查看\n\n"My Object"\n\n\n1\n',normalizedContent:'🌰 例子引入：循环遍历加监听：\n\n初始：\n\n<html>\n  <button class="btns1">测试1</button>\n  <button class="btns1">测试2</button>\n  <button class="btns1">测试3</button>\n</html>\n<script>\nvar btns = document.getelementsbyclassname("btns1");\n\nfor (var i = 0, length = btns.length; i < length; i++) {\n  var btn = btns[i];\n  btn.index = i;\n  btn.onclick = function () {\n    alert("第" + (this.index + 1) + "个");\n  };\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n使用闭包改进初始思路：\n\n<html>\n  <button class="btns2">测试1</button>\n  <button class="btns2">测试2</button>\n  <button class="btns2">测试3</button>\n</html>\n<script>\nvar btns = document.getelementsbyclassname("btns2");\n\nfor (var i = 0, length = btns.length; i < length; i++) {\n  (function (i) {\n    var btn = btns[i];\n    btn.onclick = function () {\n      alert("第" + (i + 1) + "个");\n    };\n  })(i);\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n# 闭包的概念\n\n * 如何产生闭包：当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包。\n\n * 闭包的理解：（通过 devtools 查看 closure ）\n   \n   1. 闭包是嵌套的内部函数。（极大部分的人的理解）\n   2. 包含被引用变量（函数）的对象。（少数人理解）\n   \n   ⚠️ 注意：闭包存在于嵌套的内部函数中。\n\n * 产生闭包的条件：\n   \n   * 函数嵌套。\n   * 内部函数引用了外部函数的数据。（执行外部函数定义就会产生闭包，不必调用内部函数）\n\n🌰： 例子\n\nfunction fn1 (){\n  var a = 2 \n  function fn2 (){\n    console.log(a)\n  }\n}\nfn1()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常见的闭包：\n\n🌰 例子 1️⃣：将函数作为另一个函数的返回值：\n\nfunction fn1(){\n  var a = 2\n  function fn2() {\n  \ta++  \n    console.log(a)\n  }\n  return fn2\n}\nvar f = fn1()\nf() // 3\nf() // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 2️⃣：将函数作为实参传递给另一个函数调用：\n\nfunction showdelay(msg, time){\n  settimeout(function (){\n  \talert(msg)\n\t}, time)\n}\n\nshowdelay(\'msg\', 2000)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 闭包的作用\n\n * 使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）。\n * 让函数外部可以操作（读 / 写）到函数内部的数据（变量或者函数）\n\n> ❓相关问题；\n> \n>  1. 函数执行完后，函数内部声明的局部变量是否还存在？\n>     \n>     一般不存在存在。当存在闭包时，可能还存在，因为该局部变量被包含在闭包内。由于外部声明了一个变量把内部的一个闭包一直关联着所以闭包会一直存在（例如上面第一个例子 var f = fn1() ）\n> \n>  2. 在函数外部能直接访问函数内部的局部变量吗？\n>     \n>     不能。但是通过闭包可以让外部操作它。（例如，通过 return xx() ，可被外部操作。）\n\n\n# 闭包的生命周期\n\n * 产生：在嵌套内部函数定义执行完就产生了（⚠️ 不是在调用时）。（例如上第一个例子 fn1() 被定义完，函数提升，内部函数对象已经创建了。）\n\n * 死亡：在嵌套的内部函数成为垃圾对象时（即包含闭包的函数对象称为垃圾对象）。（例如上第一个例子，在要抛弃闭包时，将 f = null 即可。）\n\n注意\n\n实在注意闭包的产生。对比下面的例子：\n\nfunction fn1(){\n  var a = 2\n  var f2 = fn2() { // 此时才产生闭包\n  \ta++  \n    console.log(a)\n  }\n  return fn2\n}\nvar f = fn1()\nf() // 3\nf() // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 闭包的应用\n\n可以使用闭包定义 javascript 模块。\n\n> javascript 模块：\n> \n>  * 具有特定功能的 .js 文件。\n>  * 将所有的数据和功能都封装在一个函数内部（私有的）。\n>  * 只向外暴露一个包含 n 个方法的对象或者函数（封装为对象）。\n>  * 模块的使用者只需要通过模块的对象调用方法来实现相应的功能。\n\n🌰 例子：\n\n:::: tabs cache-lifetime="5" :options="{ useurlfragment: false }"\n\n::: tab 第一种\n\n * 创建模块 mymodule.js 文件：\n\nfunction mymodule1() {\n    // 似有数据\n    var msg = "test"\n\n    // 操作数据的函数\n    function douppercase() {\n        console.log("test")\n        console.log("douppercase: " + msg.touppercase());\n    }\n\n    function dolowercase(){\n        console.log("dolowercase: " + msg.tolowercase());\n    }\n\n    // 向外暴露对象（给外部使用的方法）\n    return {\n        douppercase: douppercase,\n        dolowercase: dolowercase\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 在测试用 .html 文件中，引入并使用：\n\n<script type="text/javascript" src="mymodule1.js"><\/script>\n<script type="text/javascript">\nvar module = mymodule1()\nmodule.douppercase()\nmodule.dolowercase()\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n:::\n\n::: tab ⭐️ 第二种\n\n * 创建模块 mymodule.js 文件：（修改为使用匿名函数）\n\n(function (window) {\n    // 私有数据\n    var msg = "test"\n\n    // 操作数据的函数\n    function douppercase() {\n        console.log("douppercase: " + msg.touppercase());\n    }\n\n    function dolowercase() {\n        console.log("dolowercase: " + msg.tolowercase());\n    }\n\n    // 向外暴露对象（给外部使用的方法）\n    window.mymodule2 = {\n        douppercase: douppercase,\n        dolowercase: dolowercase\n    }\n})(window)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 在测试用 .html 文件中，引入并使用：\n\n<script type="text/javascript" src="mymodule2.js"><\/script>\n<script type="text/javascript">\nmymodule2.dolowercase()\nmymodule2.douppercase()\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n:::\n\n::::\n\n\n# 闭包的缺点与解决\n\n * 闭包的缺点：\n   * 函数执行完后，函数内的局部变量没有释放，占用内存的时间会变长。\n   * 容易造成内存泄漏。\n * 解决闭包的缺点：\n   * 能不使用就不使用闭包。\n   * 及时释放使用过后的闭包。\n\n🌰 例子：\n\nfunction fn1() {\n\tvar arr = new array[1000]\n  function fn2(){\n    console.log(arr.length)\n  }\n  return fn2\n}\n\nvar f = fn1()\nf()\nf = null // 让内部函数称为垃圾对象，♻️回收闭包。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n * 内存溢出：\n   * 一种程序运行出现的错误。\n   * 当程序运行需要的内存超过了剩余的内存时（导致崩溃内存不足），就会抛出内存溢出的错误。\n\n🌰 例子：\n\nvar obj = {}\nfor(var i = 0;i< 1000; i++){\n  obj[i] = new array(100000) // 明显内存不足以支持处理如此庞大的数据\n}\n\n\n1\n2\n3\n4\n\n * 内存泄漏：\n   * 占用的内存没有及时释放。\n   * 内存泄漏积累多了就容易导致内存溢出。\n   * 常见的内存泄漏：\n     * 意外的全局变量。\n     * 没有及时清理的计时器或回调函数。\n     * 闭包。\n\n🌰 例子：\n\n// 意外的全局变量\nfunction fn() {\n  a = new array(100000) // 定义后没有处理\n  console.log(a) \n}\n\n\n1\n2\n3\n4\n5\n\n\nvar intervalid = setinterval(function (){\n  console.log(\'-\')\n}, 1000)\n// clearinterval(intervalid) // 要及时清理循环定时器\n\n\n1\n2\n3\n4\n\n\n（闭包是使用后没有回收可参考之前提到的 🌰 例子）\n\n\n# 面试题\n\n⚠️ ：https://www.bilibili.com/video/bv14s411e7qf?p=36&spm_id_from=pagedriver\n\n1️⃣\n\nvar name = \'the window\'\nvar object = {\n  name: \'my object\',\n  getnamefunc: function() {\n    return this.name\n  }\n}\nalert(object.getnamefunc()())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n点击查看\n\n\'the window\'\n\n\n1\n\n\n2️⃣\n\nvar name2 = \'the window\'\nvar object2 = {\n  name2: \'my object\',\n  getnamefunc: function() {\n    var that = this\n    return function(){\n      return that.name2\n    }\n  }\n}\nalert(object2.getnamefunc()())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n点击查看\n\n"my object"\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🕶 JavaScript 对象高级",frontmatter:{title:"🕶 JavaScript 对象高级",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/502815/",categories:["🚶🏻 前端巩固基础","🏃 JavaScript 进阶高级"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/50.%20%F0%9F%8F%83%20JavaScript%20%E8%BF%9B%E9%98%B6%E9%AB%98%E7%BA%A7/08.%20%F0%9F%95%B6%20JavaScript%20%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7.html",relativePath:"101. 🚶🏻 前端巩固基础/50. 🏃 JavaScript 进阶高级/08. 🕶 JavaScript 对象高级.md",key:"v-267b9391",path:"/pages/502815/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚛 TypeScript 前言",frontmatter:{title:"🚛 TypeScript 前言",date:"2022-04-28T11:06:46.000Z",permalink:"/pages/8d9f46/",categories:["🚶🏻 前端巩固基础","ʦ TypeScript"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/60.%20%CA%A6%20TypeScript/01.%20%F0%9F%9A%9B%20TypeScript%20%E5%89%8D%E8%A8%80.html",relativePath:"101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/01. 🚛 TypeScript 前言.md",key:"v-0ed16da6",path:"/pages/8d9f46/",headers:[{level:2,title:"JavaScript 中存在的问题",slug:"javascript-中存在的问题",normalizedTitle:"javascript 中存在的问题",charIndex:2},{level:3,title:"类型带来的问题",slug:"类型带来的问题",normalizedTitle:"类型带来的问题",charIndex:250},{level:3,title:"类型思维的缺失",slug:"类型思维的缺失",normalizedTitle:"类型思维的缺失",charIndex:674},{level:2,title:"TypeScript 的诞生",slug:"typescript-的诞生",normalizedTitle:"typescript 的诞生",charIndex:999},{level:2,title:"认识 TypeScript",slug:"认识-typescript",normalizedTitle:"认识 typescript",charIndex:1357},{level:2,title:"TypeScript 特点",slug:"typescript-特点",normalizedTitle:"typescript 特点",charIndex:1969},{level:2,title:"TypeScript 的安装与运行环境",slug:"typescript-的安装与运行环境",normalizedTitle:"typescript 的安装与运行环境",charIndex:2082}],headersStr:"JavaScript 中存在的问题 类型带来的问题 类型思维的缺失 TypeScript 的诞生 认识 TypeScript TypeScript 特点 TypeScript 的安装与运行环境",content:"# JavaScript 中存在的问题\n\n由于各种历史因素，JavaScript 语言本身存在很多的缺点：\n\n * 如 ES5 以及之前的使用的 var 关键字关于作用域的问题。\n * 如最初 JavaScript 设计的数组类型并不是连续的内存空间。\n * 直到今天 JavaScript 也没有加入类型检测。\n\n但是不可否认，JavaScript 在变得更好。ES6、7、8 等的推出，每次都会让这门语言更加现代、更加安全、更加方便。但是 JavaScript 在类型监测仍然没有进展。\n\n\n# 类型带来的问题\n\nJavaScript 不能在代码编译期间发现代码的错误。\n\n🌰 例子：\n\nfunction getLength(str){\n  return str.length;\n}\n\ngetLength('abc')\ngetLength(); // 错误调用，但是IDE不报错\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这个错误很大的原因就是因为 JavaScript 没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个错误；并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而深入崩溃。\n> \n> 当然可以通过以给 JavaScript 加上很多限制：要求 getLength 函数中 str 是一个必传的类型，没有调用者没有传编译期间就会报错。要求它的必须是一个 String 类型，传入其他类型就直接报错。那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改。\n\n\n# 类型思维的缺失\n\nJavaScript 因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于类型思维的缺失：\n\n * 不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验证。\n * 因为没有类型约束，而总是担心自己的代码不安全，不够健壮。\n\n在大型项目中使用 JavaScript 时，，这种宽松的类型约束会带来非常多 的安全隐患，多人员开发它们之间也没有良好的类型契约：\n\n * 实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证代码的健壮性；\n * 如果要调用外部函数，没有对函数进行任何的注释，只能去看里面的逻辑来理解这个函数需要传入什么参数，返回值是什么类型。\n\n\n# TypeScript 的诞生\n\n为了弥补 JavaScript 类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案： 2014 年，Facebook 推出了 flow 来对 JavaScript 进行类型检查； 同年，微软也推出了 TypeScript 1.0 版本； 他们都致力于为 JavaScript 提供类型检查。\n\n * Vue2.x 的时候采用的就是 flow 来做类型检查；\n * Vue3.x 已经全线转向 TypeScript，98.3% 使用 TypeScript 进行了重构；\n * Angular 在很早期就使用 TypeScript 进行了项目重构并且需要使用 TypeScript 来进行开发； 而甚至 Facebook 公司一些自己的产品也在使用 TypeScript；\n\n\n# 认识 TypeScript\n\n> TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\n> \n> TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.\n\nTypeScript 是拥有类型的 JavaScript 超集，它可以编译成普通、干净、完整的 JavaScript 代码。\n\n * TypeScript 是加强版的 JavaScript。\n * JavaScript 所拥有的特性，TypeScript 全部都是支持的，并且它紧随 ECMAScript 的标准，所以 ES6、ES7、ES8 等新语法标准，它都是支持的。\n * 并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等。\n * TypeScript 在实现新特性的同时，总是保持和 ES 标准的同步甚至是领先。\n * TypeScript 最终会被编译成 JavaScript 代码，所以并不需要担心它的兼容性问题，在编译时也不需要借助于 Babel 这样的工具；\n * TypeScript 不仅让 JavaScript 更加安全，而且给它带来了诸多好用的好用特性；。\n\n\n# TypeScript 特点\n\n官方描述：\n\n * 始于 JavaScript，归于 JavaScript\n * TypeScript 是一个强大的工具，用于构建大型项目\n * 拥有先进的 JavaScript 特性。\n\n\n# TypeScript 的安装与运行环境\n\n全局安装 TypeScript 开发环境：\n\n$ npm install typescript -g # 安装命令\n$ tsc --version # 查看版本\n\n\n1\n2\n\n\n常规查看 TypeScript 代码的运行效果的两个步骤：\n\n * 通过 tsc 编译 TypeScript 到 JavaScript 代码；\n\n * 在浏览器或者 Node 环境下运行 JavaScript 代码。\n\n简化 TypeScript 的运行：\n\n * 编写了 TypeScript 之后可以直接运行在浏览器上：通过 webpack，配置本地的 TypeScript 编译环境和开启一个本地服务，可以直接运行在浏览器上； codewhy TypeScript (二) 使用 Webpack 搭建环境 (qq.com)；\n * 编写了 TypeScript 之后，直接通过 node 的命令来执行：通过 ts-node 库，为 TypeScript 的运行提供执行环境。\n\n> 安装 ts-node：\n> \n> $  npm i ts-node -g\n> \n> \n> 1\n> \n> \n> 与 ts-node 需要依赖 tslib 和 @types/node 两个包：\n> \n> npm i tslib @types/node -g\n> \n> \n> 1",normalizedContent:"# javascript 中存在的问题\n\n由于各种历史因素，javascript 语言本身存在很多的缺点：\n\n * 如 es5 以及之前的使用的 var 关键字关于作用域的问题。\n * 如最初 javascript 设计的数组类型并不是连续的内存空间。\n * 直到今天 javascript 也没有加入类型检测。\n\n但是不可否认，javascript 在变得更好。es6、7、8 等的推出，每次都会让这门语言更加现代、更加安全、更加方便。但是 javascript 在类型监测仍然没有进展。\n\n\n# 类型带来的问题\n\njavascript 不能在代码编译期间发现代码的错误。\n\n🌰 例子：\n\nfunction getlength(str){\n  return str.length;\n}\n\ngetlength('abc')\ngetlength(); // 错误调用，但是ide不报错\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这个错误很大的原因就是因为 javascript 没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个错误；并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而深入崩溃。\n> \n> 当然可以通过以给 javascript 加上很多限制：要求 getlength 函数中 str 是一个必传的类型，没有调用者没有传编译期间就会报错。要求它的必须是一个 string 类型，传入其他类型就直接报错。那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改。\n\n\n# 类型思维的缺失\n\njavascript 因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于类型思维的缺失：\n\n * 不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验证。\n * 因为没有类型约束，而总是担心自己的代码不安全，不够健壮。\n\n在大型项目中使用 javascript 时，，这种宽松的类型约束会带来非常多 的安全隐患，多人员开发它们之间也没有良好的类型契约：\n\n * 实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证代码的健壮性；\n * 如果要调用外部函数，没有对函数进行任何的注释，只能去看里面的逻辑来理解这个函数需要传入什么参数，返回值是什么类型。\n\n\n# typescript 的诞生\n\n为了弥补 javascript 类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案： 2014 年，facebook 推出了 flow 来对 javascript 进行类型检查； 同年，微软也推出了 typescript 1.0 版本； 他们都致力于为 javascript 提供类型检查。\n\n * vue2.x 的时候采用的就是 flow 来做类型检查；\n * vue3.x 已经全线转向 typescript，98.3% 使用 typescript 进行了重构；\n * angular 在很早期就使用 typescript 进行了项目重构并且需要使用 typescript 来进行开发； 而甚至 facebook 公司一些自己的产品也在使用 typescript；\n\n\n# 认识 typescript\n\n> typescript is a superset of javascript that compiles to clean javascript output.\n> \n> typescript is a typed superset of javascript that compiles to plain javascript.\n\ntypescript 是拥有类型的 javascript 超集，它可以编译成普通、干净、完整的 javascript 代码。\n\n * typescript 是加强版的 javascript。\n * javascript 所拥有的特性，typescript 全部都是支持的，并且它紧随 ecmascript 的标准，所以 es6、es7、es8 等新语法标准，它都是支持的。\n * 并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（enum）、元组类型（tuple）等。\n * typescript 在实现新特性的同时，总是保持和 es 标准的同步甚至是领先。\n * typescript 最终会被编译成 javascript 代码，所以并不需要担心它的兼容性问题，在编译时也不需要借助于 babel 这样的工具；\n * typescript 不仅让 javascript 更加安全，而且给它带来了诸多好用的好用特性；。\n\n\n# typescript 特点\n\n官方描述：\n\n * 始于 javascript，归于 javascript\n * typescript 是一个强大的工具，用于构建大型项目\n * 拥有先进的 javascript 特性。\n\n\n# typescript 的安装与运行环境\n\n全局安装 typescript 开发环境：\n\n$ npm install typescript -g # 安装命令\n$ tsc --version # 查看版本\n\n\n1\n2\n\n\n常规查看 typescript 代码的运行效果的两个步骤：\n\n * 通过 tsc 编译 typescript 到 javascript 代码；\n\n * 在浏览器或者 node 环境下运行 javascript 代码。\n\n简化 typescript 的运行：\n\n * 编写了 typescript 之后可以直接运行在浏览器上：通过 webpack，配置本地的 typescript 编译环境和开启一个本地服务，可以直接运行在浏览器上； codewhy typescript (二) 使用 webpack 搭建环境 (qq.com)；\n * 编写了 typescript 之后，直接通过 node 的命令来执行：通过 ts-node 库，为 typescript 的运行提供执行环境。\n\n> 安装 ts-node：\n> \n> $  npm i ts-node -g\n> \n> \n> 1\n> \n> \n> 与 ts-node 需要依赖 tslib 和 @types/node 两个包：\n> \n> npm i tslib @types/node -g\n> \n> \n> 1",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🎲 JavaScript 线程机制与事件机制",frontmatter:{title:"🎲 JavaScript 线程机制与事件机制",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/fb7e0f/",categories:["🚶🏻 前端巩固基础","🏃 JavaScript 进阶高级"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/50.%20%F0%9F%8F%83%20JavaScript%20%E8%BF%9B%E9%98%B6%E9%AB%98%E7%BA%A7/09.%20%F0%9F%8E%B2%20JavaScript%20%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6.html",relativePath:"101. 🚶🏻 前端巩固基础/50. 🏃 JavaScript 进阶高级/09. 🎲 JavaScript 线程机制与事件机制.md",key:"v-ff8a52d4",path:"/pages/fb7e0f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚌 TypeScript 变量的声明与数据类型",frontmatter:{title:"🚌 TypeScript 变量的声明与数据类型",date:"2022-04-30T15:59:19.000Z",permalink:"/pages/3d1460/",categories:["🚶🏻 前端巩固基础","ʦ TypeScript"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/60.%20%CA%A6%20TypeScript/02.%20%F0%9F%9A%8C%20TypeScript%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/02. 🚌 TypeScript 变量的声明与数据类型.md",key:"v-4fd4978c",path:"/pages/3d1460/",headers:[{level:2,title:"变量的声明",slug:"变量的声明",normalizedTitle:"变量的声明",charIndex:2},{level:3,title:"声明变量的关键字",slug:"声明变量的关键字",normalizedTitle:"声明变量的关键字",charIndex:338},{level:3,title:"变量的类型推断",slug:"变量的类型推断",normalizedTitle:"变量的类型推断",charIndex:598},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:78},{level:3,title:"JavaScript 类型",slug:"javascript-类型",normalizedTitle:"javascript 类型",charIndex:830},{level:4,title:"number 数字类型",slug:"number-数字类型",normalizedTitle:"number 数字类型",charIndex:847},{level:4,title:"boolean 布尔类型",slug:"boolean-布尔类型",normalizedTitle:"boolean 布尔类型",charIndex:982},{level:4,title:"string 类型",slug:"string-类型",normalizedTitle:"string 类型",charIndex:1021},{level:4,title:"object 对象类型",slug:"object-对象类型",normalizedTitle:"object 对象类型",charIndex:1330},{level:4,title:"symbol 类型",slug:"symbol-类型",normalizedTitle:"symbol 类型",charIndex:1458},{level:4,title:"null/undefined 类型",slug:"null-undefined-类型",normalizedTitle:"null/undefined 类型",charIndex:1647},{level:3,title:"TypeScript 类型",slug:"typescript-类型",normalizedTitle:"typescript 类型",charIndex:1792},{level:4,title:"any 类型",slug:"any-类型",normalizedTitle:"any 类型",charIndex:1809},{level:4,title:"unknown 类型",slug:"unknown-类型",normalizedTitle:"unknown 类型",charIndex:2191},{level:4,title:"void 类型",slug:"void-类型",normalizedTitle:"void 类型",charIndex:2564},{level:4,title:"never 类型",slug:"never-类型",normalizedTitle:"never 类型",charIndex:2788},{level:4,title:"tuple 类型",slug:"tuple-类型",normalizedTitle:"tuple 类型",charIndex:3471},{level:3,title:"函数类型",slug:"函数类型",normalizedTitle:"函数类型",charIndex:4092},{level:4,title:"函数的参数类型",slug:"函数的参数类型",normalizedTitle:"函数的参数类型",charIndex:4100},{level:4,title:"函数的返回值类型",slug:"函数的返回值类型",normalizedTitle:"函数的返回值类型",charIndex:4356},{level:4,title:"匿名函数的参数",slug:"匿名函数的参数",normalizedTitle:"匿名函数的参数",charIndex:4567},{level:3,title:"对象类型",slug:"对象类型",normalizedTitle:"对象类型",charIndex:1337},{level:3,title:"可选属性类型",slug:"可选属性类型",normalizedTitle:"可选属性类型",charIndex:5329},{level:3,title:"联合类型",slug:"联合类型",normalizedTitle:"联合类型",charIndex:5659},{level:4,title:"函数中使用联合类型",slug:"函数中使用联合类型",normalizedTitle:"函数中使用联合类型",charIndex:5938},{level:4,title:"可选类型补充",slug:"可选类型补充",normalizedTitle:"可选类型补充",charIndex:6381},{level:3,title:"类型别名",slug:"类型别名",normalizedTitle:"类型别名",charIndex:6573},{level:3,title:"类型断言",slug:"类型断言",normalizedTitle:"类型断言",charIndex:7024},{level:3,title:"非空类型断言",slug:"非空类型断言",normalizedTitle:"非空类型断言",charIndex:7442},{level:3,title:"可选链的使用",slug:"可选链的使用",normalizedTitle:"可选链的使用",charIndex:7806},{level:3,title:"?? 和 !!  的使用",slug:"和-的使用",normalizedTitle:"?? 和！！的使用",charIndex:null},{level:3,title:"字面量类型",slug:"字面量类型",normalizedTitle:"字面量类型",charIndex:8770},{level:3,title:"字面量推理",slug:"字面量推理",normalizedTitle:"字面量推理",charIndex:9088},{level:3,title:"类型缩小",slug:"类型缩小",normalizedTitle:"类型缩小",charIndex:9400},{level:3,title:"typeof",slug:"typeof",normalizedTitle:"typeof",charIndex:2429},{level:3,title:"平等缩小",slug:"平等缩小",normalizedTitle:"平等缩小",charIndex:9604},{level:4,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:10352},{level:3,title:"in",slug:"in",normalizedTitle:"in",charIndex:185},{level:3,title:"枚举类型",slug:"枚举类型",normalizedTitle:"枚举类型",charIndex:10878}],headersStr:"变量的声明 声明变量的关键字 变量的类型推断 数据类型 JavaScript 类型 number 数字类型 boolean 布尔类型 string 类型 object 对象类型 symbol 类型 null/undefined 类型 TypeScript 类型 any 类型 unknown 类型 void 类型 never 类型 tuple 类型 函数类型 函数的参数类型 函数的返回值类型 匿名函数的参数 对象类型 可选属性类型 联合类型 函数中使用联合类型 可选类型补充 类型别名 类型断言 非空类型断言 可选链的使用 ?? 和 !!  的使用 字面量类型 字面量推理 类型缩小 typeof 平等缩小 instanceof in 枚举类型",content:"# 变量的声明\n\n在 TypeScript 中定义变量需要指定「标识符」的类型。\n\n所以完整的声明格式如下：\n\n * var/let/const 标识符: 数据类型 = 赋值;\n\n声明了类型后 TypeScript 就会进行类型检测，声明的类型可以称之为类型注解；\n\n🌰 声明一个字符串类型的 message 变量，完整的写法如下：\n\nlet message: string = 'hello typescript';\n\n\n1\n\n\n>  * 注意：小写 string （与 String 有区别）是 TypeScript 中定义的字符串类型，String 是 ECMAScript 中定义的一个。\n> \n>  * 这时给 message 赋其他类型的值，就会报错。\n\n\n# 声明变量的关键字\n\n在 TypeScript 定义变量（标识符）和 ES6 之后一致，可以使用 var 、 let 、 const 来定义。\n\nvar myname: string = 'why';\nlet myage: number = 20;\nconst myheight : number = 1.88;\n\n\n1\n2\n3\n\n\n> 注意：在 tslint 中并不推荐使用 var 来声明变量。主要原因和 ES6 升级后 let 和 var 的区别是一样的， var 是没有块级作用域的，可能会引起许多问题。\n\n\n# 变量的类型推断\n\n在开发中，有时候为了方便起见并不会在声明每一个变量时都写上对应的数据类型，更希望可以通过 TypeScript 本身的特性帮助我们推断出对应的变量类型。\n\n🌰 例子：\n\nlet message = 'hello typescript'\n// 此时下文再赋值数字类型就会报错\nmessage = 123\n\n\n1\n2\n3\n\n\nTypeScript 在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型。\n\n\n# 数据类型\n\n\n# JavaScript 类型\n\n# number 数字类型\n\nTypeScript 和 JavaScript 一样，不区分整数类型（int）和浮点型 （double），统一为 number 类型。\n\n * 进制数字类型：TypeScript 与 ES6 同样支持二进制、八进制、十 六进制的表示：。\n\n# boolean 布尔类型\n\n只有两个取值 true 和 false 。\n\n# string 类型\n\n字符串类型，可以使用单引号或者双引号表示；\n\n * 与 ES6 同样支持模版字符串拼接变量和字符串。\n\n * Array 数组类型：两种定义的方式：\n   \n   const names: string[] = [\"abc\", \"cba\", \"cba\"]\n   const names2: Array<string> = [\"abc\", \"cba\", \"nba\"]\n   \n   names.push(\"why\")\n   names2.push(\"why\")\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   数组中的数据类型只能为声明时的数据类型。\n\n# object 对象类型\n\n描述一个对象：\n\nconst myInfo: object = { \n  name: \"simon\",\n  age: 18,\n\theight: 1.88\n}\n\n\n1\n2\n3\n4\n5\n\n\n但是不能直接获取数据也不能设置数据。\n\n# symbol 类型\n\n通过 symbol 来定义相同的名称的变量，因为 Symbol 函数返回的是不同的值。\n\nconst s1: symbol = Symbol(\"title\")\nconst s2: symbol = Symbol(\"title\")\nconst person = {\n  [s1]:\"程序员\",\n  [s2]:\"老师\"\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# null/undefined 类型\n\n在 TypeScript 中，它们各自的类型也是 undefined 和 null ，也就意味着它们既是实际的值，也是自己的类型。\n\nlet n: null = null\nlet u: undefined = undefined\n\n\n1\n2\n\n\n\n# TypeScript 类型\n\n# any 类型\n\n当确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用 any 类型（类似于 Dart 语言中的 dynamic 类型）如果对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候可以使用 any （包括在 Vue 源码中，也会使用到 any 来进行某些类型的适配）。\n\n * any 类型有点像一种讨巧的 TypeScript 手段：\n * 可以对 any 类型的变量进行任何的操作，包括获取不存在的属性、方法；\n * 可以给一个 any 类型的变量赋值任何的值，比如数字、字符串的值；\n\nlet a: any = \"why\";\na = 123;\na = true;\nconst aArray: any[] = [\"why\", 18, 1.88];\n\n\n1\n2\n3\n4\n\n\n# unknown 类型\n\n是 TypeScript 中比较特殊的一种类型，它用于描述类型不确定的变量。\n\nfunction foo(): string {\n  return \"foo!\"\n}\n\nfunction bar(): number {\n  return 123;\n}\n\nconst flag = true\nlet result: unknown\n\nif(flag) { \n  result = foo()\n} else {\n  result = bar()\n}\n\nif(typeof result === \"string\"）{\n   console.log(result.length)\n}\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# void 类型\n\n通常用来指定一个函数是没有返回值的，那么它的返回值就是 void 类型。可以将 null 和 undefined 赋值给 void 类型，也就是函数可以返回 null 或者 undefined 。\n\nfunction sum(num1: number, num2: number): void{\n  console.log(num1 + num2)\n} // 没有写任何类型，默认的返回值类型就是void\n\n\n1\n2\n3\n\n\n# never 类型\n\n表示永远不会发生值的类型，比如一个函数。\n\n * 如果一个函数中是一个死循环或者抛出一个异常，该函数不会返回任何类型的值，所以写 void 类型或者其他类型都不合适，就可以使用 never 类型。\n   \n   function loopFun(): never { \n     while(true) {\n       console.log(\"123\")\n     }\n   }\n   \n   function LoopErr(): never {\n     throw new Error()\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   function handleMessage(message: number|string) {\n     switch (typeof message) {\n       case 'string':\n         console.log('foo')\n         break\n       case 'number':\n         console.log('bar'）\n         break\n       default:\n         const check: never = message\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n# tuple 类型\n\n是元组类型，很多语言中也有这种数据类型，比如 Python、Swift 等。\n\nconst tInfo: [string, number,number] = [\"why\", 18, 1.88];\nconst item1 = tInfo[0] // why,并且知道类型是string类型\nconst item2 = tInfo[1];// 18,并且知道类型是number类型\n\n\n1\n2\n3\n\n\n * tuple 类型与数组类型的区别：数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中。（不同类型的数据可以存放对象或元组）元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型\n\n * tuple 的应用场景：通常作为返回的值，使用的时候很方便：\n\nfunction useState<T>(state: T): [T, (newState: T) => void]{\n  let currentState = state\n  const changeState = (new State: T)=>{\n    currentState = newState\n  }\n  return [currentState, changeState]\n}\n\nconst [counter, setCounter] = useState(10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 函数类型\n\n# 函数的参数类型\n\n函数是 JavaScript 非常重要的组成部分，TypeScript 允许指定函数的参数和返回值的类型。\n\n在声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型：\n\nfunction greet (name: string) {\n  console. log(\"Hello\" + name.toUpperCase())\n}\n\ngreet(123) // 报错，参数类型有误\ngreet(\"abc\", \"cba\") // 报错，参数数量有误\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 函数的返回值类型\n\n添加返回值类型的注解，放在函数列表的后面：\n\nfunction sum (num1: number, num2: number): number { \n  return num1 + num2\n}\n\n\n1\n2\n3\n\n\n和变量的类型注解一样，通常情况下不需要返回类型注解，因为 TypeScript 会根据 return 返回值推断函数的返回类型。（某些第三方库处于方便理解，会明确指定返回类型）\n\n# 匿名函数的参数\n\n匿名函数与函数声明会有一些不同：\n\n * 当一个函数出现在 TypeScript 可以确定该函数会被如何调用的地方时；\n * 该函数的参数会自动指定类型；\n\n🌰 例子：\n\nconst names = ['abc', 'cba', 'nba']\nnames.forEach(item => {\n  console.log(item.toUpperCase())\n})\n\n\n1\n2\n3\n4\n\n\n> 并没有指定 item 的类型，但是 item 是一个 string 类型：\n> \n>  * 并没有指定 item 的类型，但是 item 是一个 string 类型；\n>  * 过程称之为上下文类型（contextual typing），因为函数执行的上下文可以帮助确定参数和返回值的类型。\n\n\n# 对象类型\n\n当希望限定一个函数接受的参数是一个对象：\n\n * 可以使用对象类型：\n   \n   function printCoordinate(point: {x: number, y: number}) {\n     console.log（\"x坐标:\", point.x)\n     console.log(\"y坐标:\", point.y)\n   }\n   \n   printCoordinate({x: 10,y: 30})\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 这里使用了一个对象来作为类型：\n   \n   * 在对象可以添加属性，并且告知 TypeScript 该属性需要是什么类型；\n   * 属性之间可以使用，或者 ; 来分割，最后一个分隔符是可选的；\n   * 每个属性的类型部分也是可选的，如果不指定，那么就是 any 类型；\n\n\n# 可选属性类型\n\n对象类型也可以指定哪些属性是可选的，可以在属性的后面添加一个 ? 。\n\nfunction printCoordinate(point: {x: number, y: number, z?: number}) {\n  console. 1og(\"x坐标:\",point.x)\n  console. log(\"y坐标:\",point.y)\n  if (point.z) {\n    console.log(\"z坐标:\",point.z)\n  }\n}\n\nprintCoordinate({x: 10, y: 30}）\nprintCoordinate({x: 20,y: 30, z: 40}）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 联合类型\n\nTypeScript 的类型系统允许使用多种运算符，从现有类型中构建新类型。使用第一种组合类型的方法：联合类型（Union Type）\n\n * 联合类型是由两个或者多个其他类型组成的类型；\n * 表示可以是这些类型中的任何一个值；\n * 联合类型中的每一个类型被称之为联合成员（union's members）;\n\nfunction printId(id: number | string) {\n  console.1og(\"你的id是:\",id)\n}\n\nprintId(10)\nprintId(\"abc\")\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 函数中使用联合类型\n\n传入给一个联合类型的值是非常简单的：\n\n * 只要保证是联合类型中的某一个类型的值即可\n * 但是拿到这个值之后，应该如何使用它呢？因为它可能是任何一种类型。\n * 比如我们拿到的值可能是 string 或者 number ，我们就不能对其调用 string 上的一些方法。\n\n解决方法：\n\n * 需要使用缩小（narrow）联合；\n * TypeScript 可以根据我们缩小的代码结构，推断出更加具体的类型；\n\nfunction printId(id: number | string) {\n  if(typeof id === 'string'）{ \n     //确定id是string类型\n     console.log(\"你的id是:\", id.toUpperCase())\n\t} else {\n    //确定id是number类型\n\t\tconsole.log(\"你的id是\", id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 可选类型补充\n\n可选类型可以看做是 类型 和 undefined 的联合类型：\n\nfunction print(message?: string) {\n  console.log(message)\n}\n\nprint()\nprint('xx')\nprint(undefined)\nprint(null) // 报错，不是两者其中之一的类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 类型别名\n\n此前通过在类型注解中编写 对象类型 和 联合类型，当想要要多次在其他地方使用时，就要编写多次。此时可以给对象类型起一个别名，使用 type 声明。\n\ntype ID = number | string\n\nfunction printId(id: ID) {\n  console.log(\"您的id:\",id)\n}\n\n\n1\n2\n3\n4\n5\n\n\ntype Point {\n\tx: number\n\ty: number\n}\n\nfunction printPoint(point: Point) {\n  console.log(point.x, point.y)\n}\n\nfunction sumPoint(point: Point) {\n  console.log(point.x + point.y)\n}\n\nprintPoint({x: 20, y: 20})\nsumPoint({x: 20, y: 20})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类型断言\n\n有时候 TypeScript 无法获取具体的类型信息，这时需要使用类型断言（Type Assertions）。\n\n例子：比如通过 document.getElementById ，TypeScript 只知道该函数会返回 HTMLElement ，但并不知道它具体的类型。可以使用 as 进行类型断言：\n\nconst myEl = document.getElementById(\"my-img\") as HTMLImageELement\nmyEl.src=\"图片地址\"\n\n\n1\n2\n\n\nTypeScript 只允许类型断言转换为 更具体 或者 不太具体 的类型版本，此规则可防止不可能的强制转换：\n\nconst name = 'string' as number; // 不能转换，因为已经确定为字符串类型\nconst name = ('string' as unknown) as number;\n\n\n1\n2\n\n\n\n# 非空类型断言\n\n当编写一下代码时，执行 ts 的编译阶段会报错：\n\nfunction printMessage(message?: string) {\n  console.log(message.toUpperCase()) // 此时传入的message有可能是undefined，所以不能执行方法\n}\n\nprintMessage('hello')\n\n\n1\n2\n3\n4\n5\n\n\n但是，我们确定传入的参数是有值的，此时可以使用非空类型断言。\n\nfunction printMessage(message?: string) {\n  console.log(message!.toUpperCase())\n}\n\n\n1\n2\n3\n\n\n非空断言使用的是 ! ，表示可以确定某个标识符是有值的，跳过 ts 在编译阶段对它的检测；\n\n\n# 可选链的使用\n\n可选链并不是 TypeScript 独有的特性，它是 ES11（ES2020）中增加的特性。\n\n * 可选链使用可选链操作符 ? ；\n * 作用：当对象的属性不存在时，会短路直接返回 undefined ；如果存在，那么才会继续执行。\n\ntype Person = {\n  name: string\n  friend?: {\n    name: string\n    age?: number,\n    girlFriend? :{\n      name: string\n    }\n  }\n}\n\nconst info: Person = {\n  name: 'why',\n  friend: {\n    name: 'kobe',\n    girlFriend: {\n    \tname: 'lily'\n    }\n  }\n}\n\nconsole.log(info.friend?.name)\nconsole.log(info.friend?.age)\nconsole.log(info.friend?.girlFriend?.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ?? 和 !! 的使用\n\n!! 操作符：\n\n * 将一个其他类型转换成 boolean 类型；\n * 类似于 Boolean(变量) 的方式；\n\nconst message = ''\nlet flag = Boolean(message)\nlet flag2 = !!messgae\nconsole.log(flag1, flag2) // false, false\n\n\n1\n2\n3\n4\n\n\n?? 操作符：\n\n * 是 ES11 增加的新特性；\n * 空值合并操作符（ ?? ）是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数；\n\nconst message = '321'\nconst result = message ?? '123' \nconsole.log(result) // message不为空所以返回message本身内容\n\n\n1\n2\n3\n\n\n\n# 字面量类型\n\n除了前面的类型以外，也可以使用字面量类型（literal types）定义。\n\nlet message: 'hello world' = 'hello world'\nmessage = 'hello typescript' // 只能声明为 'hello world'\n\n\n1\n2\n\n\n上面的例子看上去没有太大的意义，但是可以讲多个字面量类型联合在一起：\n\ntype Alignment = 'left' | 'right' | 'center'\nfunction changeAlign(align: Alignment) {\n  console.log('修改方向'， align)\n}\n\n\n1\n2\n3\n4\n\n\n\n# 字面量推理\n\nconst info = {\n  url: 'https://github.com/',\n  method: 'GET'\n}\n\nfunction request(url: string, method: 'GET'|'POST') {\n  console.log(url, method)\n}\n\nrequest(info.url, info.method) // 第二个参数报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为对象在进行字面量推理的时候， info 其实是一个 {url: string, method: string} ，所以不能把一个 string 赋值给一个字面量类型。\n\n\n# 类型缩小\n\n（Type Narrowing）\n\n * 通过类似于 typeof padding === ‘number’ 的判断语句，改变 TypeScript 的执行路径。\n * 在给定的执行路径，缩小比声明时更小的类型，这个过程称之为类型缩小。\n * typeof padding === ‘number’ 可以称为 类型保护（type guards）.\n\n常见类型保护有：\n\n * typeof\n * 平等缩小（ === 、 !== ）\n * intanceof\n * in\n * …\n\n\n# typeof\n\n在 TypeScript 中，检查返回的值 typeof 是一种类型保护：因为 TypeScript 对如何 typeof 操作不同的值进行编码。\n\ntype ID = number | string\nfunction printId(id: ID) {\n  if(typeof id === 'string'){\n    consosle.log(id.toUpperCase())\n  } else {\n    console.log(id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 平等缩小\n\n可以使用 switch 或者相等的一些运算符来表达相等性（ === 、 !== 、 != ）\n\ntype Direction = 'left'|'right'|'center'\nfunction turnDirection(direction: Direction){\n  switch(direction){\n    case 'left':\n      \tconsole.log('left')\n      \tbreak;\n    case 'right':\n        console.log('right')\n        break;\n    case 'center':\n        console.log('center')\n        break;\n    default:\n        console.log('default')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# instanceof\n\nJavaScript 中 instanceof 运算符来检查一个值是否是另一个值的「实例」。\n\nfunction printValue(date: Date|string){\n    if(date instanceof Date){\n        console.log(date.toLocaleString())\n    } else {\n        console.log(date)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# in\n\nJavaScript 运算符 in 用于确定对象是否具有带名称的属性：\n\n * 如果指定的属性在指定的对象或其原型链中，则 in 运算符返回 true 。\n\ntype Fish = {swim: () => void}\ntype Dog = {run: () => void}\n\nfunction move(animal: Fish | Dog) {\n  if('swim' in animal) {\n    animal.swim()\n  } else {\n    animal.run()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 枚举类型\n\n枚举类型是为数不多的 TypeScript 特性有的特性之一：\n\n * 枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型；\n\n * 枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型。\n   \n   * 枚举类型默认是有值的，默认值如下；\n     \n     enum Direction {\n       LEFT = 0,\n       RIGHT = 1,\n       TOP = 2,\n       BOTTOM = 3\n     }\n     \n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * 当然也可以给枚举其他值： 这个时候会从 100 进行递增；\n     \n     enum Direction {\n       LEFT = 100,\n       RIGHT,\n       TOP,\n       BOTTOM\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n   \n   * 也可以给他们赋值其他的类型：\n     \n     enum Direction {\n       LEFT,\n       RIGHT,\n       TOP = 'TOP',\n       BOTTOM = 'BOTTOM'\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\nenum Direction {\n  LEFT,\n  RIGHT,\n  TOP,\n  BOTTOM\n}\n\nfunction turnDirection (direction: Direction) {\n  switch (direction） {\n     \tcase Direction.LEFT:\n          console.log(\"转向左边~\"）\n          break;\n\t\t\tcase Direction.RIGHT:\n\t\t\t\t\tconsole.log(\"转向右边~\"）\n\t\t\t\t\tbreak;\n      case Direction.TOP:\n\t      console.log（\"转向上边~\"）\n  \t    break;\n\t\t\tcase Direction. BOTTOM:\n        console.log（\"转向下边~\"）\n        break;\n     \tdefault:\n        const myDirection: never = direction;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# 变量的声明\n\n在 typescript 中定义变量需要指定「标识符」的类型。\n\n所以完整的声明格式如下：\n\n * var/let/const 标识符: 数据类型 = 赋值;\n\n声明了类型后 typescript 就会进行类型检测，声明的类型可以称之为类型注解；\n\n🌰 声明一个字符串类型的 message 变量，完整的写法如下：\n\nlet message: string = 'hello typescript';\n\n\n1\n\n\n>  * 注意：小写 string （与 string 有区别）是 typescript 中定义的字符串类型，string 是 ecmascript 中定义的一个。\n> \n>  * 这时给 message 赋其他类型的值，就会报错。\n\n\n# 声明变量的关键字\n\n在 typescript 定义变量（标识符）和 es6 之后一致，可以使用 var 、 let 、 const 来定义。\n\nvar myname: string = 'why';\nlet myage: number = 20;\nconst myheight : number = 1.88;\n\n\n1\n2\n3\n\n\n> 注意：在 tslint 中并不推荐使用 var 来声明变量。主要原因和 es6 升级后 let 和 var 的区别是一样的， var 是没有块级作用域的，可能会引起许多问题。\n\n\n# 变量的类型推断\n\n在开发中，有时候为了方便起见并不会在声明每一个变量时都写上对应的数据类型，更希望可以通过 typescript 本身的特性帮助我们推断出对应的变量类型。\n\n🌰 例子：\n\nlet message = 'hello typescript'\n// 此时下文再赋值数字类型就会报错\nmessage = 123\n\n\n1\n2\n3\n\n\ntypescript 在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型。\n\n\n# 数据类型\n\n\n# javascript 类型\n\n# number 数字类型\n\ntypescript 和 javascript 一样，不区分整数类型（int）和浮点型 （double），统一为 number 类型。\n\n * 进制数字类型：typescript 与 es6 同样支持二进制、八进制、十 六进制的表示：。\n\n# boolean 布尔类型\n\n只有两个取值 true 和 false 。\n\n# string 类型\n\n字符串类型，可以使用单引号或者双引号表示；\n\n * 与 es6 同样支持模版字符串拼接变量和字符串。\n\n * array 数组类型：两种定义的方式：\n   \n   const names: string[] = [\"abc\", \"cba\", \"cba\"]\n   const names2: array<string> = [\"abc\", \"cba\", \"nba\"]\n   \n   names.push(\"why\")\n   names2.push(\"why\")\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   数组中的数据类型只能为声明时的数据类型。\n\n# object 对象类型\n\n描述一个对象：\n\nconst myinfo: object = { \n  name: \"simon\",\n  age: 18,\n\theight: 1.88\n}\n\n\n1\n2\n3\n4\n5\n\n\n但是不能直接获取数据也不能设置数据。\n\n# symbol 类型\n\n通过 symbol 来定义相同的名称的变量，因为 symbol 函数返回的是不同的值。\n\nconst s1: symbol = symbol(\"title\")\nconst s2: symbol = symbol(\"title\")\nconst person = {\n  [s1]:\"程序员\",\n  [s2]:\"老师\"\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# null/undefined 类型\n\n在 typescript 中，它们各自的类型也是 undefined 和 null ，也就意味着它们既是实际的值，也是自己的类型。\n\nlet n: null = null\nlet u: undefined = undefined\n\n\n1\n2\n\n\n\n# typescript 类型\n\n# any 类型\n\n当确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用 any 类型（类似于 dart 语言中的 dynamic 类型）如果对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候可以使用 any （包括在 vue 源码中，也会使用到 any 来进行某些类型的适配）。\n\n * any 类型有点像一种讨巧的 typescript 手段：\n * 可以对 any 类型的变量进行任何的操作，包括获取不存在的属性、方法；\n * 可以给一个 any 类型的变量赋值任何的值，比如数字、字符串的值；\n\nlet a: any = \"why\";\na = 123;\na = true;\nconst aarray: any[] = [\"why\", 18, 1.88];\n\n\n1\n2\n3\n4\n\n\n# unknown 类型\n\n是 typescript 中比较特殊的一种类型，它用于描述类型不确定的变量。\n\nfunction foo(): string {\n  return \"foo!\"\n}\n\nfunction bar(): number {\n  return 123;\n}\n\nconst flag = true\nlet result: unknown\n\nif(flag) { \n  result = foo()\n} else {\n  result = bar()\n}\n\nif(typeof result === \"string\"）{\n   console.log(result.length)\n}\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# void 类型\n\n通常用来指定一个函数是没有返回值的，那么它的返回值就是 void 类型。可以将 null 和 undefined 赋值给 void 类型，也就是函数可以返回 null 或者 undefined 。\n\nfunction sum(num1: number, num2: number): void{\n  console.log(num1 + num2)\n} // 没有写任何类型，默认的返回值类型就是void\n\n\n1\n2\n3\n\n\n# never 类型\n\n表示永远不会发生值的类型，比如一个函数。\n\n * 如果一个函数中是一个死循环或者抛出一个异常，该函数不会返回任何类型的值，所以写 void 类型或者其他类型都不合适，就可以使用 never 类型。\n   \n   function loopfun(): never { \n     while(true) {\n       console.log(\"123\")\n     }\n   }\n   \n   function looperr(): never {\n     throw new error()\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   function handlemessage(message: number|string) {\n     switch (typeof message) {\n       case 'string':\n         console.log('foo')\n         break\n       case 'number':\n         console.log('bar'）\n         break\n       default:\n         const check: never = message\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n# tuple 类型\n\n是元组类型，很多语言中也有这种数据类型，比如 python、swift 等。\n\nconst tinfo: [string, number,number] = [\"why\", 18, 1.88];\nconst item1 = tinfo[0] // why,并且知道类型是string类型\nconst item2 = tinfo[1];// 18,并且知道类型是number类型\n\n\n1\n2\n3\n\n\n * tuple 类型与数组类型的区别：数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中。（不同类型的数据可以存放对象或元组）元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型\n\n * tuple 的应用场景：通常作为返回的值，使用的时候很方便：\n\nfunction usestate<t>(state: t): [t, (newstate: t) => void]{\n  let currentstate = state\n  const changestate = (new state: t)=>{\n    currentstate = newstate\n  }\n  return [currentstate, changestate]\n}\n\nconst [counter, setcounter] = usestate(10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 函数类型\n\n# 函数的参数类型\n\n函数是 javascript 非常重要的组成部分，typescript 允许指定函数的参数和返回值的类型。\n\n在声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型：\n\nfunction greet (name: string) {\n  console. log(\"hello\" + name.touppercase())\n}\n\ngreet(123) // 报错，参数类型有误\ngreet(\"abc\", \"cba\") // 报错，参数数量有误\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 函数的返回值类型\n\n添加返回值类型的注解，放在函数列表的后面：\n\nfunction sum (num1: number, num2: number): number { \n  return num1 + num2\n}\n\n\n1\n2\n3\n\n\n和变量的类型注解一样，通常情况下不需要返回类型注解，因为 typescript 会根据 return 返回值推断函数的返回类型。（某些第三方库处于方便理解，会明确指定返回类型）\n\n# 匿名函数的参数\n\n匿名函数与函数声明会有一些不同：\n\n * 当一个函数出现在 typescript 可以确定该函数会被如何调用的地方时；\n * 该函数的参数会自动指定类型；\n\n🌰 例子：\n\nconst names = ['abc', 'cba', 'nba']\nnames.foreach(item => {\n  console.log(item.touppercase())\n})\n\n\n1\n2\n3\n4\n\n\n> 并没有指定 item 的类型，但是 item 是一个 string 类型：\n> \n>  * 并没有指定 item 的类型，但是 item 是一个 string 类型；\n>  * 过程称之为上下文类型（contextual typing），因为函数执行的上下文可以帮助确定参数和返回值的类型。\n\n\n# 对象类型\n\n当希望限定一个函数接受的参数是一个对象：\n\n * 可以使用对象类型：\n   \n   function printcoordinate(point: {x: number, y: number}) {\n     console.log（\"x坐标:\", point.x)\n     console.log(\"y坐标:\", point.y)\n   }\n   \n   printcoordinate({x: 10,y: 30})\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 这里使用了一个对象来作为类型：\n   \n   * 在对象可以添加属性，并且告知 typescript 该属性需要是什么类型；\n   * 属性之间可以使用，或者 ; 来分割，最后一个分隔符是可选的；\n   * 每个属性的类型部分也是可选的，如果不指定，那么就是 any 类型；\n\n\n# 可选属性类型\n\n对象类型也可以指定哪些属性是可选的，可以在属性的后面添加一个 ? 。\n\nfunction printcoordinate(point: {x: number, y: number, z?: number}) {\n  console. 1og(\"x坐标:\",point.x)\n  console. log(\"y坐标:\",point.y)\n  if (point.z) {\n    console.log(\"z坐标:\",point.z)\n  }\n}\n\nprintcoordinate({x: 10, y: 30}）\nprintcoordinate({x: 20,y: 30, z: 40}）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 联合类型\n\ntypescript 的类型系统允许使用多种运算符，从现有类型中构建新类型。使用第一种组合类型的方法：联合类型（union type）\n\n * 联合类型是由两个或者多个其他类型组成的类型；\n * 表示可以是这些类型中的任何一个值；\n * 联合类型中的每一个类型被称之为联合成员（union's members）;\n\nfunction printid(id: number | string) {\n  console.1og(\"你的id是:\",id)\n}\n\nprintid(10)\nprintid(\"abc\")\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 函数中使用联合类型\n\n传入给一个联合类型的值是非常简单的：\n\n * 只要保证是联合类型中的某一个类型的值即可\n * 但是拿到这个值之后，应该如何使用它呢？因为它可能是任何一种类型。\n * 比如我们拿到的值可能是 string 或者 number ，我们就不能对其调用 string 上的一些方法。\n\n解决方法：\n\n * 需要使用缩小（narrow）联合；\n * typescript 可以根据我们缩小的代码结构，推断出更加具体的类型；\n\nfunction printid(id: number | string) {\n  if(typeof id === 'string'）{ \n     //确定id是string类型\n     console.log(\"你的id是:\", id.touppercase())\n\t} else {\n    //确定id是number类型\n\t\tconsole.log(\"你的id是\", id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 可选类型补充\n\n可选类型可以看做是 类型 和 undefined 的联合类型：\n\nfunction print(message?: string) {\n  console.log(message)\n}\n\nprint()\nprint('xx')\nprint(undefined)\nprint(null) // 报错，不是两者其中之一的类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 类型别名\n\n此前通过在类型注解中编写 对象类型 和 联合类型，当想要要多次在其他地方使用时，就要编写多次。此时可以给对象类型起一个别名，使用 type 声明。\n\ntype id = number | string\n\nfunction printid(id: id) {\n  console.log(\"您的id:\",id)\n}\n\n\n1\n2\n3\n4\n5\n\n\ntype point {\n\tx: number\n\ty: number\n}\n\nfunction printpoint(point: point) {\n  console.log(point.x, point.y)\n}\n\nfunction sumpoint(point: point) {\n  console.log(point.x + point.y)\n}\n\nprintpoint({x: 20, y: 20})\nsumpoint({x: 20, y: 20})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类型断言\n\n有时候 typescript 无法获取具体的类型信息，这时需要使用类型断言（type assertions）。\n\n例子：比如通过 document.getelementbyid ，typescript 只知道该函数会返回 htmlelement ，但并不知道它具体的类型。可以使用 as 进行类型断言：\n\nconst myel = document.getelementbyid(\"my-img\") as htmlimageelement\nmyel.src=\"图片地址\"\n\n\n1\n2\n\n\ntypescript 只允许类型断言转换为 更具体 或者 不太具体 的类型版本，此规则可防止不可能的强制转换：\n\nconst name = 'string' as number; // 不能转换，因为已经确定为字符串类型\nconst name = ('string' as unknown) as number;\n\n\n1\n2\n\n\n\n# 非空类型断言\n\n当编写一下代码时，执行 ts 的编译阶段会报错：\n\nfunction printmessage(message?: string) {\n  console.log(message.touppercase()) // 此时传入的message有可能是undefined，所以不能执行方法\n}\n\nprintmessage('hello')\n\n\n1\n2\n3\n4\n5\n\n\n但是，我们确定传入的参数是有值的，此时可以使用非空类型断言。\n\nfunction printmessage(message?: string) {\n  console.log(message!.touppercase())\n}\n\n\n1\n2\n3\n\n\n非空断言使用的是 ! ，表示可以确定某个标识符是有值的，跳过 ts 在编译阶段对它的检测；\n\n\n# 可选链的使用\n\n可选链并不是 typescript 独有的特性，它是 es11（es2020）中增加的特性。\n\n * 可选链使用可选链操作符 ? ；\n * 作用：当对象的属性不存在时，会短路直接返回 undefined ；如果存在，那么才会继续执行。\n\ntype person = {\n  name: string\n  friend?: {\n    name: string\n    age?: number,\n    girlfriend? :{\n      name: string\n    }\n  }\n}\n\nconst info: person = {\n  name: 'why',\n  friend: {\n    name: 'kobe',\n    girlfriend: {\n    \tname: 'lily'\n    }\n  }\n}\n\nconsole.log(info.friend?.name)\nconsole.log(info.friend?.age)\nconsole.log(info.friend?.girlfriend?.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ?? 和 !! 的使用\n\n!! 操作符：\n\n * 将一个其他类型转换成 boolean 类型；\n * 类似于 boolean(变量) 的方式；\n\nconst message = ''\nlet flag = boolean(message)\nlet flag2 = !!messgae\nconsole.log(flag1, flag2) // false, false\n\n\n1\n2\n3\n4\n\n\n?? 操作符：\n\n * 是 es11 增加的新特性；\n * 空值合并操作符（ ?? ）是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数；\n\nconst message = '321'\nconst result = message ?? '123' \nconsole.log(result) // message不为空所以返回message本身内容\n\n\n1\n2\n3\n\n\n\n# 字面量类型\n\n除了前面的类型以外，也可以使用字面量类型（literal types）定义。\n\nlet message: 'hello world' = 'hello world'\nmessage = 'hello typescript' // 只能声明为 'hello world'\n\n\n1\n2\n\n\n上面的例子看上去没有太大的意义，但是可以讲多个字面量类型联合在一起：\n\ntype alignment = 'left' | 'right' | 'center'\nfunction changealign(align: alignment) {\n  console.log('修改方向'， align)\n}\n\n\n1\n2\n3\n4\n\n\n\n# 字面量推理\n\nconst info = {\n  url: 'https://github.com/',\n  method: 'get'\n}\n\nfunction request(url: string, method: 'get'|'post') {\n  console.log(url, method)\n}\n\nrequest(info.url, info.method) // 第二个参数报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为对象在进行字面量推理的时候， info 其实是一个 {url: string, method: string} ，所以不能把一个 string 赋值给一个字面量类型。\n\n\n# 类型缩小\n\n（type narrowing）\n\n * 通过类似于 typeof padding === ‘number’ 的判断语句，改变 typescript 的执行路径。\n * 在给定的执行路径，缩小比声明时更小的类型，这个过程称之为类型缩小。\n * typeof padding === ‘number’ 可以称为 类型保护（type guards）.\n\n常见类型保护有：\n\n * typeof\n * 平等缩小（ === 、 !== ）\n * intanceof\n * in\n * …\n\n\n# typeof\n\n在 typescript 中，检查返回的值 typeof 是一种类型保护：因为 typescript 对如何 typeof 操作不同的值进行编码。\n\ntype id = number | string\nfunction printid(id: id) {\n  if(typeof id === 'string'){\n    consosle.log(id.touppercase())\n  } else {\n    console.log(id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 平等缩小\n\n可以使用 switch 或者相等的一些运算符来表达相等性（ === 、 !== 、 != ）\n\ntype direction = 'left'|'right'|'center'\nfunction turndirection(direction: direction){\n  switch(direction){\n    case 'left':\n      \tconsole.log('left')\n      \tbreak;\n    case 'right':\n        console.log('right')\n        break;\n    case 'center':\n        console.log('center')\n        break;\n    default:\n        console.log('default')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# instanceof\n\njavascript 中 instanceof 运算符来检查一个值是否是另一个值的「实例」。\n\nfunction printvalue(date: date|string){\n    if(date instanceof date){\n        console.log(date.tolocalestring())\n    } else {\n        console.log(date)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# in\n\njavascript 运算符 in 用于确定对象是否具有带名称的属性：\n\n * 如果指定的属性在指定的对象或其原型链中，则 in 运算符返回 true 。\n\ntype fish = {swim: () => void}\ntype dog = {run: () => void}\n\nfunction move(animal: fish | dog) {\n  if('swim' in animal) {\n    animal.swim()\n  } else {\n    animal.run()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 枚举类型\n\n枚举类型是为数不多的 typescript 特性有的特性之一：\n\n * 枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型；\n\n * 枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型。\n   \n   * 枚举类型默认是有值的，默认值如下；\n     \n     enum direction {\n       left = 0,\n       right = 1,\n       top = 2,\n       bottom = 3\n     }\n     \n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * 当然也可以给枚举其他值： 这个时候会从 100 进行递增；\n     \n     enum direction {\n       left = 100,\n       right,\n       top,\n       bottom\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n   \n   * 也可以给他们赋值其他的类型：\n     \n     enum direction {\n       left,\n       right,\n       top = 'top',\n       bottom = 'bottom'\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\nenum direction {\n  left,\n  right,\n  top,\n  bottom\n}\n\nfunction turndirection (direction: direction) {\n  switch (direction） {\n     \tcase direction.left:\n          console.log(\"转向左边~\"）\n          break;\n\t\t\tcase direction.right:\n\t\t\t\t\tconsole.log(\"转向右边~\"）\n\t\t\t\t\tbreak;\n      case direction.top:\n\t      console.log（\"转向上边~\"）\n  \t    break;\n\t\t\tcase direction. bottom:\n        console.log（\"转向下边~\"）\n        break;\n     \tdefault:\n        const mydirection: never = direction;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚙 TypeScript 函数类型",frontmatter:{title:"🚙 TypeScript 函数类型",date:"2022-04-28T11:06:46.000Z",permalink:"/pages/47c91c/",categories:["🚶🏻 前端巩固基础","ʦ TypeScript"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/60.%20%CA%A6%20TypeScript/03.%20%F0%9F%9A%99%20TypeScript%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/03. 🚙 TypeScript 函数类型.md",key:"v-ed559c8a",path:"/pages/47c91c/",headers:[{level:2,title:"函数的类型",slug:"函数的类型",normalizedTitle:"函数的类型",charIndex:2},{level:2,title:"参数的可选类型",slug:"参数的可选类型",normalizedTitle:"参数的可选类型",charIndex:643},{level:2,title:"默认参数",slug:"默认参数",normalizedTitle:"默认参数",charIndex:946},{level:2,title:"剩余参数",slug:"剩余参数",normalizedTitle:"剩余参数",charIndex:1135},{level:2,title:"this",slug:"this",normalizedTitle:"this",charIndex:1457},{level:3,title:"可推导的 this 类型",slug:"可推导的-this-类型",normalizedTitle:"可推导的 this 类型",charIndex:1466},{level:3,title:"不确定的 this 类型",slug:"不确定的-this-类型",normalizedTitle:"不确定的 this 类型",charIndex:1730},{level:3,title:"指定的 this 类型",slug:"指定的-this-类型",normalizedTitle:"指定的 this 类型",charIndex:2142},{level:2,title:"函数的重载",slug:"函数的重载",normalizedTitle:"函数的重载",charIndex:2316},{level:3,title:"联合类型的重载",slug:"联合类型的重载",normalizedTitle:"联合类型的重载",charIndex:2928}],headersStr:"函数的类型 参数的可选类型 默认参数 剩余参数 this 可推导的 this 类型 不确定的 this 类型 指定的 this 类型 函数的重载 联合类型的重载",content:"# 函数的类型\n\n在 JavaScript 中，函数是重要的组成部分，并且函数可以作为一等公民（可以作为参数，也可以作为返回值进行传递）\n\n * 在使用函数的过程中，函数也可以有自己的类型，可以编写函数函数类型的表达式（Function Type Expressions），来表示函数类型；\n\ntype CalcFunc = (num1: number, num2: number) => void \n\nfunction calc(fn: CalcFunc) {\n\tconsole.log(fn(20, 30))\n}\n\nfunction sum(num1: number, num2: number) {\n\treturn num1 + num2\n}\n\nfunction mul(num1: number, num2: number) {\n\treturn num1 * num2\n}\n\ncalc(sum)\ncalc(mul)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n>  * 上面 (num1: number, num2: number) => void 代表的就是一个函数类型。\n>    * 接收两个参数的函数： num1 和 num2 ，并且都是 number 类型。\n>    * 并且这个函数没有返回值，所有是 void 。\n>  * 某些语言中， num1 和 num2 可以省略，但是 TypeScript 不可以省略。\n\n\n# 参数的可选类型\n\n函数的某个参数是可选的：\n\nfunction foo(x: number, y?: number) {\n  console.log(x,y)\n}\n\n\n1\n2\n3\n\n\n这个时候参数 x 依然是有类型的，它的类型是 number | undefined 。\n\n另外可选类型需要在必传参数的后面否则报错，如下错误示范：\n\nfunction foo(x?: number, y: number) {\n  // A required parameter cannot follw an optional parameter.\n  console.log(x,y)\n}\n\n\n1\n2\n3\n4\n\n\n\n# 默认参数\n\n从 ES6 开始，JavaScript 是支持默认参数的，TypeScript 也是支持默认参数的。\n\n例子：\n\nfunction foo(x: number, y: number = 6) {\n  console.log(x, y)\n}\n\nfoo(10)\n\n\n1\n2\n3\n4\n5\n\n\n> 此时的 y 是 undefined 和 number 的联合类型。\n\n\n# 剩余参数\n\n从 ES6 开始，JavaScript 也支持剩余参数，剩余参数语法允许将一个不定数量的参数放到一个数组中。\n\nfunction sum(...nums: number[]) {\n  let total = 0\n  for (const num of nums){\n    total += num\n  }\n  return total\n}\n\nconst result1 = sum(10, 20, 30)\nconsole.log(result1)\nconst result2 = sum(10, 20, 30, 40)\nconsole.log(result2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# this\n\n\n# 可推导的 this 类型\n\n先观察一个例子：\n\nconst info = {\n  name: 'simon',\n  sayHello() {\n    console.log(this.name)\n  }\n}\ninfo.sayhello()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个例子可以正常运行。也就是说 TypeScript 在编译时，认为 this 是可以正确去使用的。TypeScript 认为函数 sayHello 有一个对应的 this 的外部对象 info ，所以在使用时，就会把 this 当做该对象。\n\n\n# 不确定的 this 类型\n\n但在某些情况下，并不清楚 this 的指向：\n\nfunction sayHello(){\n  console.log(this.name)\n}\n\nconst info = {\n  name: 'simon',\n  sayHello\n}\n\ninfo.sayHello() // error 编译器报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * TypeScript 进行类型检测的目的是让代码更加的安全；\n * 所以这里对于 sayHello 的调用来说，虽然将其放到了 info 中，通过 info 去调用， this 依然是指向 info 对象的；\n * 但是对于 TypeScript 编译器来说，这个代码是非常不安全的，因为也有可能直接调用函数，或者通过别的对象来调用函数。所以 TypeScript 不允许 this 的不确定情况发生，所以要指定 this 的类型。\n\n\n# 指定的 this 类型\n\n当 this 的类型不确定时，TypeScript 需要指定 this 的类型：\n\ntype NameType = {\n  name: string\n}\n\nfunction sayHello(this: nameType){\n  console.log(this.name)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 函数的重载\n\n🌰 例子：当写了一个 add 函数，希望可以对字符串和数字进行相加：\n\nfunction sum(a1: number | string, a2: number | string): number | string {\n  return a1 + a2 // 报错，不能实现联合类型的相加\n}\n\n\n1\n2\n3\n\n\n** 可以编写不同的重载签名（overload signatures）来表示函数可以以不同的方式进行调用。** 一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现。\n\n对于 sum 函数的重载：\n\n * 在调用 sum 函数时，会根据传入的参数类型决定执行函数体时，到底执行哪一个函数的重载签名：\n\nfunction sum(a1: number, a2: number): number;\nfunction sum(a1: string, a2: string): string;\nfunction sum(a1: any, a2: any): any {\n  return a1 + a2\n}\n\nconsole.log(sum(1,1))\nconsole.log(sum('aaa', 'bbb'))\n\n// 注意下面：有的实现体函数不能直接被调用\nsum({name: 'simon'}, {age: 18})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 联合类型的重载\n\n🌰 例子：需求，定义一个函数，可以传入字符串或者数组，获取它们的长度。有两种实现方案：\n\n * 使用联合类型：\n   \n   function getLength(a: stirng|any[]){\n     return a.length\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 实现函数的重载：\n   \n   function getLength(a: string): number;\n   function getLength(a: any[]): number;\n   function getLength(a: any) {\n     return a.length\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n在实际开发中，尽量使用联合类型实现。",normalizedContent:"# 函数的类型\n\n在 javascript 中，函数是重要的组成部分，并且函数可以作为一等公民（可以作为参数，也可以作为返回值进行传递）\n\n * 在使用函数的过程中，函数也可以有自己的类型，可以编写函数函数类型的表达式（function type expressions），来表示函数类型；\n\ntype calcfunc = (num1: number, num2: number) => void \n\nfunction calc(fn: calcfunc) {\n\tconsole.log(fn(20, 30))\n}\n\nfunction sum(num1: number, num2: number) {\n\treturn num1 + num2\n}\n\nfunction mul(num1: number, num2: number) {\n\treturn num1 * num2\n}\n\ncalc(sum)\ncalc(mul)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n>  * 上面 (num1: number, num2: number) => void 代表的就是一个函数类型。\n>    * 接收两个参数的函数： num1 和 num2 ，并且都是 number 类型。\n>    * 并且这个函数没有返回值，所有是 void 。\n>  * 某些语言中， num1 和 num2 可以省略，但是 typescript 不可以省略。\n\n\n# 参数的可选类型\n\n函数的某个参数是可选的：\n\nfunction foo(x: number, y?: number) {\n  console.log(x,y)\n}\n\n\n1\n2\n3\n\n\n这个时候参数 x 依然是有类型的，它的类型是 number | undefined 。\n\n另外可选类型需要在必传参数的后面否则报错，如下错误示范：\n\nfunction foo(x?: number, y: number) {\n  // a required parameter cannot follw an optional parameter.\n  console.log(x,y)\n}\n\n\n1\n2\n3\n4\n\n\n\n# 默认参数\n\n从 es6 开始，javascript 是支持默认参数的，typescript 也是支持默认参数的。\n\n例子：\n\nfunction foo(x: number, y: number = 6) {\n  console.log(x, y)\n}\n\nfoo(10)\n\n\n1\n2\n3\n4\n5\n\n\n> 此时的 y 是 undefined 和 number 的联合类型。\n\n\n# 剩余参数\n\n从 es6 开始，javascript 也支持剩余参数，剩余参数语法允许将一个不定数量的参数放到一个数组中。\n\nfunction sum(...nums: number[]) {\n  let total = 0\n  for (const num of nums){\n    total += num\n  }\n  return total\n}\n\nconst result1 = sum(10, 20, 30)\nconsole.log(result1)\nconst result2 = sum(10, 20, 30, 40)\nconsole.log(result2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# this\n\n\n# 可推导的 this 类型\n\n先观察一个例子：\n\nconst info = {\n  name: 'simon',\n  sayhello() {\n    console.log(this.name)\n  }\n}\ninfo.sayhello()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个例子可以正常运行。也就是说 typescript 在编译时，认为 this 是可以正确去使用的。typescript 认为函数 sayhello 有一个对应的 this 的外部对象 info ，所以在使用时，就会把 this 当做该对象。\n\n\n# 不确定的 this 类型\n\n但在某些情况下，并不清楚 this 的指向：\n\nfunction sayhello(){\n  console.log(this.name)\n}\n\nconst info = {\n  name: 'simon',\n  sayhello\n}\n\ninfo.sayhello() // error 编译器报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * typescript 进行类型检测的目的是让代码更加的安全；\n * 所以这里对于 sayhello 的调用来说，虽然将其放到了 info 中，通过 info 去调用， this 依然是指向 info 对象的；\n * 但是对于 typescript 编译器来说，这个代码是非常不安全的，因为也有可能直接调用函数，或者通过别的对象来调用函数。所以 typescript 不允许 this 的不确定情况发生，所以要指定 this 的类型。\n\n\n# 指定的 this 类型\n\n当 this 的类型不确定时，typescript 需要指定 this 的类型：\n\ntype nametype = {\n  name: string\n}\n\nfunction sayhello(this: nametype){\n  console.log(this.name)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 函数的重载\n\n🌰 例子：当写了一个 add 函数，希望可以对字符串和数字进行相加：\n\nfunction sum(a1: number | string, a2: number | string): number | string {\n  return a1 + a2 // 报错，不能实现联合类型的相加\n}\n\n\n1\n2\n3\n\n\n** 可以编写不同的重载签名（overload signatures）来表示函数可以以不同的方式进行调用。** 一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现。\n\n对于 sum 函数的重载：\n\n * 在调用 sum 函数时，会根据传入的参数类型决定执行函数体时，到底执行哪一个函数的重载签名：\n\nfunction sum(a1: number, a2: number): number;\nfunction sum(a1: string, a2: string): string;\nfunction sum(a1: any, a2: any): any {\n  return a1 + a2\n}\n\nconsole.log(sum(1,1))\nconsole.log(sum('aaa', 'bbb'))\n\n// 注意下面：有的实现体函数不能直接被调用\nsum({name: 'simon'}, {age: 18})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 联合类型的重载\n\n🌰 例子：需求，定义一个函数，可以传入字符串或者数组，获取它们的长度。有两种实现方案：\n\n * 使用联合类型：\n   \n   function getlength(a: stirng|any[]){\n     return a.length\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 实现函数的重载：\n   \n   function getlength(a: string): number;\n   function getlength(a: any[]): number;\n   function getlength(a: any) {\n     return a.length\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n在实际开发中，尽量使用联合类型实现。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🏎 TypeScript 中的类与接口",frontmatter:{title:"🏎 TypeScript 中的类与接口",date:"2022-04-30T15:50:24.000Z",permalink:"/pages/f615a2/",categories:["🚶🏻 前端巩固基础","ʦ TypeScript"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/60.%20%CA%A6%20TypeScript/04.%20%F0%9F%8F%8E%20TypeScript%20%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.html",relativePath:"101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/04. 🏎 TypeScript 中的类与接口.md",key:"v-9293f6fe",path:"/pages/f615a2/",headers:[{level:2,title:"类的使用",slug:"类的使用",normalizedTitle:"类的使用",charIndex:2},{level:2,title:"类的定义",slug:"类的定义",normalizedTitle:"类的定义",charIndex:330},{level:2,title:"类的继承",slug:"类的继承",normalizedTitle:"类的继承",charIndex:1092},{level:2,title:"类的成员修饰符",slug:"类的成员修饰符",normalizedTitle:"类的成员修饰符",charIndex:1616},{level:3,title:"只读属性 readonly",slug:"只读属性-readonly",normalizedTitle:"只读属性 readonly",charIndex:2301},{level:3,title:"getters/setters",slug:"getters-setters",normalizedTitle:"getters/setters",charIndex:2613},{level:3,title:"静态成员",slug:"静态成员",normalizedTitle:"静态成员",charIndex:3060},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:3314},{level:2,title:"类的类型",slug:"类的类型",normalizedTitle:"类的类型",charIndex:4431},{level:3,title:"接口的声明",slug:"接口的声明",normalizedTitle:"接口的声明",charIndex:4813},{level:3,title:"可选属性",slug:"可选属性",normalizedTitle:"可选属性",charIndex:4992},{level:3,title:"只读属性",slug:"只读属性",normalizedTitle:"只读属性",charIndex:2301},{level:3,title:"索引类型",slug:"索引类型",normalizedTitle:"索引类型",charIndex:5702},{level:3,title:"函数类型",slug:"函数类型",normalizedTitle:"函数类型",charIndex:6140},{level:3,title:"接口集成",slug:"接口集成",normalizedTitle:"接口集成",charIndex:6514},{level:3,title:"接口的实现",slug:"接口的实现",normalizedTitle:"接口的实现",charIndex:6927},{level:3,title:"交叉类型",slug:"交叉类型",normalizedTitle:"交叉类型",charIndex:7394},{level:3,title:"接口 interface 与 type 的区别",slug:"接口-interface-与-type-的区别",normalizedTitle:"接口 interface 与 type 的区别",charIndex:7974},{level:3,title:"字面量赋值",slug:"字面量赋值",normalizedTitle:"字面量赋值",charIndex:8458}],headersStr:"类的使用 类的定义 类的继承 类的成员修饰符 只读属性 readonly getters/setters 静态成员 抽象类 类的类型 接口的声明 可选属性 只读属性 索引类型 函数类型 接口集成 接口的实现 交叉类型 接口 interface 与 type 的区别 字面量赋值",content:"# 类的使用\n\n在早期的 JavaScrip t 开发中（ES5）我们需要通过函数和原型链来实现类和继承，从 ES6 开始，引入了 class 关键字，可以更加方便的定义和使用类。\n\nTypeScript 作为 JavaScript 的超集，也是支持使用 class 关键字的，并且还可以对类的属性和方法等进行静态类型检测。\n\n实际上在 JavaScript 的开发过程中，我们更加习惯于函数式编程：\n\n * 比如 React 开发中，目前更多使用的函数组件以及结合 Hook 的开发模式；\n * 比如在 Vue3 开发中，目前也更加推崇使用 Composition API。\n\n但是在封装某些业务的时候，类具有更强大封装性，所以我们也需要掌握它们。\n\n\n# 类的定义\n\n通常会使用 class 关键字：\n\n * 在面向对象的世界里，任何事物都可以使用类的结构来描述；\n * 类中包含特有的属性和方法。\n\n🌰 定义一个 Person 类：\n\n * 声明类的一些属性，在类的内部，声明类的属性以及对应的类型。\n   * 如果类型没有声明，那么它们默认是 any 类型的。\n   * 也可以给属性设置初始化值。\n   * 在默认的 strictPropertyInitialization 模式下面，类属性是必须初始化的，如果没有初始化，那么编译时就会报错。\n   * 如果在 strictPropertyInitialization 模式下确实不希望给属性初始化，可以使用 name!: string 语法。\n * 类可以有自己的构造函数 constructor ，当通过 new 关键字创建一个 实例时，构造函数会被调用；\n   * 构造函数不需要返回任何值，默认返回当前创建出来的实例。\n * 类中可以有自己的函数，定义的函数称之为方法。\n\nclass Person {\n  name!: string\n  age: number\n  \n  constructor(name: string, age: number) {\n    // this.name = name // 不希望name初始化时\n    this.age = age\n  }\n\n  running() {\n    console.log(this.name + 'running')\n  }\n\t\n  eating() {\n    console.log(this.name + 'eating')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 类的继承\n\n面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。\n\n使用 extends 关键字实现继承，子类中使用 super 来访问父类。\n\n🌰 例子： Student 类继承 Person 类：\n\nclass Student extends Person {\n  sno: number\n  \n  constructor(name: string, age: number, sno: number) {\n    super(name, age)\n    this.sno = sno\n  }\n  \n  studying() {\n    cosole.log(this.name + ' studying')\n  }\n  \n  eating() {\n   \tconsole.log('student eating') \n  }\n  \n  running() {\n    super.running();\n    console.log('student running')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 类的成员修饰符\n\n在 TypeScript 中，类的属性和方法支持三种修饰符： public 、 private 、 protected ：\n\n * public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是 public 的；\n * private 修饰的是仅在同一类中可见、私有的属性或方法；\n * protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法；\n\n🌰 例子：\n\nclass Person {\n  protected name: string\n  \n  constructor (name: string) {\n    this.name = name;\n  }\n}\n\nclass Student extends Person {\n  constructor (name: string) {\n    super (name)\n  }\n  \n  running() {\n    console.log(this.name + 'running')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nclass Person {\n  private name: string\n  \n  constructor (name: string) {\n    this.name = name\n  }\n}\n\nconst p = new Person(\"simon\") // 报错，name是私有的不能读写，只能在同一个类中读写\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 只读属性 readonly\n\n * 如果有一个属性不希望外界可以任意的修改，** 只希望确定值后直接使用，那么可以使用 readonly **。\n\n🌰 例子：\n\nclass Person {\n  readonly name: string\n  \n  constructor (name: string) {\n    this. name = name\n  }\n}\n\nconst p = new Person(\"simon\")\nconsole.log(p.name)\n\n// p.name=\"bimon\" // 只读属性不能修改\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# getters/setters\n\n在前面一些私有属性 pirate 是不能直接访问的，或者某些属性想要监听它的获取 (getter) 和设置 (setter) 的过程， 这个时候可以使用存取器。\n\n🌰 例子：\n\nclass Person {\n  private _name: string\n  \n  set name(newName) {\n    this._name = newName\n  }\n  \n  get name() {\n    return this._name\n  }\n  \n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nconst p = new Person('simon') // setter\np.name = 'bimon' // getter\nconsole.log(p.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 静态成员\n\n之前在类中定义的成员和方法都属于对象级别的，在开发中，有时候也需要定义类级别的成员和方法。通过 static 关键字定义静态成员。\n\n🌰 例子：\n\nclass Student {\n  static time: string = '20:00'\n  statc attendClass(){\n    console.log('去上课')\n  }\n}\n\ncosole.log(Student.time)\nStudent.attendClass()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 抽象类\n\n * 继承是多态使用的前提：\n   \n   * 所以在定义很多通用的调用接口时，通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。\n   * 但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法可以定义为抽象方法。\n\n * 抽象方法：TypeScript 中没有具体实现的方法（方法体）。\n   \n   * 抽象方法必须存在于抽象类；\n   * 抽象类是使用 abstract 关键字声明的类。\n\n * 抽象类的特点：\n   \n   * 抽象类是不能被实例的。（不能通过 new 创建实例对象）\n   * 抽象方法必须被子类实现，否则该类必须是一个抽象类。\n\n🌰 抽象类例子：\n\n// 形状抽象类\nabstract class Shape {\n  abstract getArea(): number\n}\n\n// 圆形实现形状抽象类\nclass Circle extends Shape {\n  private r: number\n  constructor(r: number) {\n    super()\n    this.r = r\n  }\n  \n  getArea(){\n    return this.r * this.r * 3.14\n  }\n}\n\n// 矩形实现形状抽象类\nclass Rectangle extends Shape {\n  private width: number\n  private height: number\n  \n  constructor(width: number, height: number) {\n    super()\n    this.width = width\n    this.height = height\n  }\n  \n  getArea(){\n    retun this.width * this.height\n  }\n}\n\nconst circle = new Circle(10)\nconst rectangle = new Rectangle(20, 30)\n\nfunction calArea(shape: Shpae) {\n  console.log(shape.getArea())\n}\n\ncalArea(circle)\ncalArea(rectangle)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 类的类型\n\n类本身也是可以作为一种数据类型的。\n\n🌰 例子：\n\nclass Person {\n  name: string\n  \n  constructor(name: string) {\n\t\tthis.name = name\n  }\n\n  running() {\n    console.log(this.name + 'running')\n  }\n}\n\nconst p1: Person = new Person('simon')\nconst p2: Person = {\n  name: 'bimon',\n  running: function() {\n    console.log(this.name + ' running')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 接口的声明\n\n在 TypeScript 可以通过 type 关键字声明一个对象类型：\n\ntype Point = {\n\tx: number\n  y: number\n}\n\n\n1\n2\n3\n4\n\n\n对象类型的另一种声明方式就是通过接口来声明：\n\ninterface Point{\n  x: number,\n  y: number\n}\n\n\n1\n2\n3\n4\n\n\n\n# 可选属性\n\n在接口中可以使用 ? 定义可选属性：\n\ninterface Person {\n  name: string\n  age?: number\n\tfriend?: {\n    name: string\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 创建对象时可以使用接口定义的类型\nconst person: Person {\n  name: 'simon',\n  age: 3\n}\n\nconsole.log(person.name)\nconsole.log(person?.age)\nconsole.log(person?.friend?.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 只读属性\n\n在接口中可以使用 readonly 定义只读属性，意味着这个类型的属性值不可以被修改。\n\ninterface Person {\n  readonly name: string\n  age?: number\n\treadonly friend?: {\n    name: string\n  }\n}\n\nconst person: Person {\n  name: 'simon',\n  age: 3,\n  friend: {\n    name: 'bimon'\n  }\n}\n\nperson.name = 'bimon' // 不可被修改\n// 但是\nif(person.friend) {\n  person.friend.name = 'cimon' // 可以被修改\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 索引类型\n\n前面用 interface 来定义对象类型，这个时候其中的属性名、类型、方法都是确定的，但是有时候会遇到不确定属性名称的类型。可以定义索引类型解决。\n\n🌰 例子：\n\n// 定义索引类型\ninterface FrontLanguage{\n  [index: number]: string\n}\n\nconst frontend: FrontLanguage = {\n  1: 'HTML',\n  2: 'CSS',\n  3: 'JavaScript'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ninterface LanguageBirth {\n  [name: string]: number\n  Java: number\n}\n\nconst language: LanguageBirth {\n  Java: 1995,\n  \"JavaScript\": 1996,\n   \"C\": 1972\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 函数类型\n\n前面都是通过 interface 来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型。\n\n🌰 例子：\n\ninterface CalFunc {\n  (num1: number, num2: number): number\n}\n\nconst add: CalFunc = (num1, num2) => {\n  return num1 + num2\n}\n\nconst sub: CalcFunc = (num1, num2) => {\n  return num1 - num2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 当然一般还是使用类型别名定义函数：\n> \n> type CalFunc = (num1: number, num2: number) => number\n> \n> \n> 1\n\n\n# 接口集成\n\n接口和类一样都可以被继承，也是使用 extends 关键字。同时接口是支持「多继承」的。（类不支持多继承）\n\ninterface Person {\n  name: string,\n  eating: () => void\n}\n\ninterface Animal {\n  running: () => void\n}\n\ninterface Student extends Person, Animal {\n  sno: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nconst stu: Student {\n  sno: 110,\n  name: 'simon',\n \teating: function() {\n    // ...\n  },\n  running : function() {\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 接口的实现\n\n接口定义后，也是可以被类实现的，使用关键字 implements ：\n\n * 如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入；\n * 这就是面向接口开发。\n\ninterface ISwim {\n  swimming: () => void\n}\n\ninterface IRun {\n  runnnig: () => void\n}\n\nclass Person implements ISwim, IRun {\n  swimming() {\n   \tconsole.log(\"swimming\")\n  }\n  running() {\n    console.log(\"running\")\n  }\n}\n\nfunction swim(swimmer: Iswim){\n  swimmer.swmming()\n}\n\nconst p = new Person()\nswim(p)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 交叉类型\n\n> 在前 TypeScript 中有联合类型：\n> \n> type Alignment = 'left' | 'right' | 'center'\n> \n> \n> 1\n> \n> \n> 还有一种类型合并（交叉类型）：\n> \n>  * 交叉类型表示需要满足多个类型的条件。\n>  * 使用符号 & 。\n> \n> type MyType = number & string\n> // 表示 number 和 string 两种类型都要满足\n> // 但是有同时满足是一个number又是一个string的值吗？其实是没有的，所以MyType其实是一个never类型\n> \n> \n> 1\n> 2\n> 3\n\n在开发中，使用交叉类型通常是对对象类型进行交叉的。\n\n🌰 例子：\n\ninterface Colorful {\n\tcolor: string\n}\n\ninterface IRun {\n  running: () => void\n}\n\ntype NewType = Colorful & IRun\n\nconst obj: newType = {\n\tcolor: 'red',\n  running: function() { \n    // ... \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 接口 interface 与 type 的区别\n\ninterface 和 type 都可以用来定义对象类型，那么在开发中定义对象类型时要使用哪一个呢？\n\n * 如果是定义非对象类型，通常推荐使用 type ，比如 Direction 、 Alignment 、一些 Function ；\n * 如果是定义对象类型，那么两者是有区别的：\n   * interface 可以重复地对某个接口来定义属性和方法；\n   * 而 type 定义的是别名，别名是不能重复的。\n\n🌰 例子：\n\ninterface IPerson {\n\tname: string\n  running:() => void\n}\n\ninterface IPerson {\n  age: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ntype 不可以重名\n\ntype IPerson {\n\tname: string\n  running:() => void\n}\n\n// 错误用法\ntype IPerson {\n  age: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 字面量赋值\n\ninterface IPerson {\n  name: string\n  eating:() => void\n}\n\nconst p: IPerson = {\n  name: \"why\",\n  age:18, // 不存在所以报错\n  eating: function() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这是因为 TypeScript 在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。\n\n但是现将一个对象声明（变量标识符），然后再赋值给一个有类型限制的变量，TypeScript 会进行擦除操作（freshness）。\n\nconst obj = {\n  name:\"why\",\n  age: 18,\n  eating: function() {\n  }\n}\n\nconst P: IPerson = obj\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 类的使用\n\n在早期的 javascrip t 开发中（es5）我们需要通过函数和原型链来实现类和继承，从 es6 开始，引入了 class 关键字，可以更加方便的定义和使用类。\n\ntypescript 作为 javascript 的超集，也是支持使用 class 关键字的，并且还可以对类的属性和方法等进行静态类型检测。\n\n实际上在 javascript 的开发过程中，我们更加习惯于函数式编程：\n\n * 比如 react 开发中，目前更多使用的函数组件以及结合 hook 的开发模式；\n * 比如在 vue3 开发中，目前也更加推崇使用 composition api。\n\n但是在封装某些业务的时候，类具有更强大封装性，所以我们也需要掌握它们。\n\n\n# 类的定义\n\n通常会使用 class 关键字：\n\n * 在面向对象的世界里，任何事物都可以使用类的结构来描述；\n * 类中包含特有的属性和方法。\n\n🌰 定义一个 person 类：\n\n * 声明类的一些属性，在类的内部，声明类的属性以及对应的类型。\n   * 如果类型没有声明，那么它们默认是 any 类型的。\n   * 也可以给属性设置初始化值。\n   * 在默认的 strictpropertyinitialization 模式下面，类属性是必须初始化的，如果没有初始化，那么编译时就会报错。\n   * 如果在 strictpropertyinitialization 模式下确实不希望给属性初始化，可以使用 name!: string 语法。\n * 类可以有自己的构造函数 constructor ，当通过 new 关键字创建一个 实例时，构造函数会被调用；\n   * 构造函数不需要返回任何值，默认返回当前创建出来的实例。\n * 类中可以有自己的函数，定义的函数称之为方法。\n\nclass person {\n  name!: string\n  age: number\n  \n  constructor(name: string, age: number) {\n    // this.name = name // 不希望name初始化时\n    this.age = age\n  }\n\n  running() {\n    console.log(this.name + 'running')\n  }\n\t\n  eating() {\n    console.log(this.name + 'eating')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 类的继承\n\n面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。\n\n使用 extends 关键字实现继承，子类中使用 super 来访问父类。\n\n🌰 例子： student 类继承 person 类：\n\nclass student extends person {\n  sno: number\n  \n  constructor(name: string, age: number, sno: number) {\n    super(name, age)\n    this.sno = sno\n  }\n  \n  studying() {\n    cosole.log(this.name + ' studying')\n  }\n  \n  eating() {\n   \tconsole.log('student eating') \n  }\n  \n  running() {\n    super.running();\n    console.log('student running')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 类的成员修饰符\n\n在 typescript 中，类的属性和方法支持三种修饰符： public 、 private 、 protected ：\n\n * public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是 public 的；\n * private 修饰的是仅在同一类中可见、私有的属性或方法；\n * protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法；\n\n🌰 例子：\n\nclass person {\n  protected name: string\n  \n  constructor (name: string) {\n    this.name = name;\n  }\n}\n\nclass student extends person {\n  constructor (name: string) {\n    super (name)\n  }\n  \n  running() {\n    console.log(this.name + 'running')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nclass person {\n  private name: string\n  \n  constructor (name: string) {\n    this.name = name\n  }\n}\n\nconst p = new person(\"simon\") // 报错，name是私有的不能读写，只能在同一个类中读写\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 只读属性 readonly\n\n * 如果有一个属性不希望外界可以任意的修改，** 只希望确定值后直接使用，那么可以使用 readonly **。\n\n🌰 例子：\n\nclass person {\n  readonly name: string\n  \n  constructor (name: string) {\n    this. name = name\n  }\n}\n\nconst p = new person(\"simon\")\nconsole.log(p.name)\n\n// p.name=\"bimon\" // 只读属性不能修改\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# getters/setters\n\n在前面一些私有属性 pirate 是不能直接访问的，或者某些属性想要监听它的获取 (getter) 和设置 (setter) 的过程， 这个时候可以使用存取器。\n\n🌰 例子：\n\nclass person {\n  private _name: string\n  \n  set name(newname) {\n    this._name = newname\n  }\n  \n  get name() {\n    return this._name\n  }\n  \n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nconst p = new person('simon') // setter\np.name = 'bimon' // getter\nconsole.log(p.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 静态成员\n\n之前在类中定义的成员和方法都属于对象级别的，在开发中，有时候也需要定义类级别的成员和方法。通过 static 关键字定义静态成员。\n\n🌰 例子：\n\nclass student {\n  static time: string = '20:00'\n  statc attendclass(){\n    console.log('去上课')\n  }\n}\n\ncosole.log(student.time)\nstudent.attendclass()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 抽象类\n\n * 继承是多态使用的前提：\n   \n   * 所以在定义很多通用的调用接口时，通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。\n   * 但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法可以定义为抽象方法。\n\n * 抽象方法：typescript 中没有具体实现的方法（方法体）。\n   \n   * 抽象方法必须存在于抽象类；\n   * 抽象类是使用 abstract 关键字声明的类。\n\n * 抽象类的特点：\n   \n   * 抽象类是不能被实例的。（不能通过 new 创建实例对象）\n   * 抽象方法必须被子类实现，否则该类必须是一个抽象类。\n\n🌰 抽象类例子：\n\n// 形状抽象类\nabstract class shape {\n  abstract getarea(): number\n}\n\n// 圆形实现形状抽象类\nclass circle extends shape {\n  private r: number\n  constructor(r: number) {\n    super()\n    this.r = r\n  }\n  \n  getarea(){\n    return this.r * this.r * 3.14\n  }\n}\n\n// 矩形实现形状抽象类\nclass rectangle extends shape {\n  private width: number\n  private height: number\n  \n  constructor(width: number, height: number) {\n    super()\n    this.width = width\n    this.height = height\n  }\n  \n  getarea(){\n    retun this.width * this.height\n  }\n}\n\nconst circle = new circle(10)\nconst rectangle = new rectangle(20, 30)\n\nfunction calarea(shape: shpae) {\n  console.log(shape.getarea())\n}\n\ncalarea(circle)\ncalarea(rectangle)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 类的类型\n\n类本身也是可以作为一种数据类型的。\n\n🌰 例子：\n\nclass person {\n  name: string\n  \n  constructor(name: string) {\n\t\tthis.name = name\n  }\n\n  running() {\n    console.log(this.name + 'running')\n  }\n}\n\nconst p1: person = new person('simon')\nconst p2: person = {\n  name: 'bimon',\n  running: function() {\n    console.log(this.name + ' running')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 接口的声明\n\n在 typescript 可以通过 type 关键字声明一个对象类型：\n\ntype point = {\n\tx: number\n  y: number\n}\n\n\n1\n2\n3\n4\n\n\n对象类型的另一种声明方式就是通过接口来声明：\n\ninterface point{\n  x: number,\n  y: number\n}\n\n\n1\n2\n3\n4\n\n\n\n# 可选属性\n\n在接口中可以使用 ? 定义可选属性：\n\ninterface person {\n  name: string\n  age?: number\n\tfriend?: {\n    name: string\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 创建对象时可以使用接口定义的类型\nconst person: person {\n  name: 'simon',\n  age: 3\n}\n\nconsole.log(person.name)\nconsole.log(person?.age)\nconsole.log(person?.friend?.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 只读属性\n\n在接口中可以使用 readonly 定义只读属性，意味着这个类型的属性值不可以被修改。\n\ninterface person {\n  readonly name: string\n  age?: number\n\treadonly friend?: {\n    name: string\n  }\n}\n\nconst person: person {\n  name: 'simon',\n  age: 3,\n  friend: {\n    name: 'bimon'\n  }\n}\n\nperson.name = 'bimon' // 不可被修改\n// 但是\nif(person.friend) {\n  person.friend.name = 'cimon' // 可以被修改\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 索引类型\n\n前面用 interface 来定义对象类型，这个时候其中的属性名、类型、方法都是确定的，但是有时候会遇到不确定属性名称的类型。可以定义索引类型解决。\n\n🌰 例子：\n\n// 定义索引类型\ninterface frontlanguage{\n  [index: number]: string\n}\n\nconst frontend: frontlanguage = {\n  1: 'html',\n  2: 'css',\n  3: 'javascript'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ninterface languagebirth {\n  [name: string]: number\n  java: number\n}\n\nconst language: languagebirth {\n  java: 1995,\n  \"javascript\": 1996,\n   \"c\": 1972\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 函数类型\n\n前面都是通过 interface 来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型。\n\n🌰 例子：\n\ninterface calfunc {\n  (num1: number, num2: number): number\n}\n\nconst add: calfunc = (num1, num2) => {\n  return num1 + num2\n}\n\nconst sub: calcfunc = (num1, num2) => {\n  return num1 - num2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 当然一般还是使用类型别名定义函数：\n> \n> type calfunc = (num1: number, num2: number) => number\n> \n> \n> 1\n\n\n# 接口集成\n\n接口和类一样都可以被继承，也是使用 extends 关键字。同时接口是支持「多继承」的。（类不支持多继承）\n\ninterface person {\n  name: string,\n  eating: () => void\n}\n\ninterface animal {\n  running: () => void\n}\n\ninterface student extends person, animal {\n  sno: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nconst stu: student {\n  sno: 110,\n  name: 'simon',\n \teating: function() {\n    // ...\n  },\n  running : function() {\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 接口的实现\n\n接口定义后，也是可以被类实现的，使用关键字 implements ：\n\n * 如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入；\n * 这就是面向接口开发。\n\ninterface iswim {\n  swimming: () => void\n}\n\ninterface irun {\n  runnnig: () => void\n}\n\nclass person implements iswim, irun {\n  swimming() {\n   \tconsole.log(\"swimming\")\n  }\n  running() {\n    console.log(\"running\")\n  }\n}\n\nfunction swim(swimmer: iswim){\n  swimmer.swmming()\n}\n\nconst p = new person()\nswim(p)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 交叉类型\n\n> 在前 typescript 中有联合类型：\n> \n> type alignment = 'left' | 'right' | 'center'\n> \n> \n> 1\n> \n> \n> 还有一种类型合并（交叉类型）：\n> \n>  * 交叉类型表示需要满足多个类型的条件。\n>  * 使用符号 & 。\n> \n> type mytype = number & string\n> // 表示 number 和 string 两种类型都要满足\n> // 但是有同时满足是一个number又是一个string的值吗？其实是没有的，所以mytype其实是一个never类型\n> \n> \n> 1\n> 2\n> 3\n\n在开发中，使用交叉类型通常是对对象类型进行交叉的。\n\n🌰 例子：\n\ninterface colorful {\n\tcolor: string\n}\n\ninterface irun {\n  running: () => void\n}\n\ntype newtype = colorful & irun\n\nconst obj: newtype = {\n\tcolor: 'red',\n  running: function() { \n    // ... \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 接口 interface 与 type 的区别\n\ninterface 和 type 都可以用来定义对象类型，那么在开发中定义对象类型时要使用哪一个呢？\n\n * 如果是定义非对象类型，通常推荐使用 type ，比如 direction 、 alignment 、一些 function ；\n * 如果是定义对象类型，那么两者是有区别的：\n   * interface 可以重复地对某个接口来定义属性和方法；\n   * 而 type 定义的是别名，别名是不能重复的。\n\n🌰 例子：\n\ninterface iperson {\n\tname: string\n  running:() => void\n}\n\ninterface iperson {\n  age: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ntype 不可以重名\n\ntype iperson {\n\tname: string\n  running:() => void\n}\n\n// 错误用法\ntype iperson {\n  age: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 字面量赋值\n\ninterface iperson {\n  name: string\n  eating:() => void\n}\n\nconst p: iperson = {\n  name: \"why\",\n  age:18, // 不存在所以报错\n  eating: function() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这是因为 typescript 在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。\n\n但是现将一个对象声明（变量标识符），然后再赋值给一个有类型限制的变量，typescript 会进行擦除操作（freshness）。\n\nconst obj = {\n  name:\"why\",\n  age: 18,\n  eating: function() {\n  }\n}\n\nconst p: iperson = obj\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚐 TypeScript 泛型",frontmatter:{title:"🚐 TypeScript 泛型",date:"2022-04-30T17:18:53.000Z",permalink:"/pages/9cb8e3/",categories:["🚶🏻 前端巩固基础","ʦ TypeScript"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/60.%20%CA%A6%20TypeScript/05.%20%F0%9F%9A%90%20TypeScript%20%E6%B3%9B%E5%9E%8B.html",relativePath:"101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/05. 🚐 TypeScript 泛型.md",key:"v-9def6d84",path:"/pages/9cb8e3/",headers:[{level:3,title:"使用泛型实现类型参数化",slug:"使用泛型实现类型参数化",normalizedTitle:"使用泛型实现类型参数化",charIndex:427},{level:3,title:"泛型接口",slug:"泛型接口",normalizedTitle:"泛型接口",charIndex:1120},{level:3,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:1690},{level:3,title:"泛型约束",slug:"泛型约束",normalizedTitle:"泛型约束",charIndex:1937}],headersStr:"使用泛型实现类型参数化 泛型接口 泛型类 泛型约束",content:"> 软件工程的主要目的是构建不仅仅明确和一致的 API，还要让你的代码具有很强的可重用性：\n> \n>  * 比如我们可以通过函数来封装一些 API，通过传入不同的函数参数，让函数帮助我们完成不同的操作；\n>  * 但是对于参数的类型是否也可以参数化呢？\n\n类型的参数化：\n\n * 实现需求：封装一个函数，传入一个参数，并返回这个参数。\n\n * 按照 TypeScript 的思想，要考虑这个参数和返回值的类型需要一致。\n   \n   function foo(arg: number): number {\n     return arg\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 拓展到更多的类型（ string 、 boolean 等类型）：\n   \n   function foo(arg: any): any {\n     return arg\n   }\n   \n   \n   1\n   2\n   3\n   \n\n\n# 使用泛型实现类型参数化\n\n> 虽然使用 any 是可以的，但是定义为 any 类型的时候，我们其实已经丢失了类型信息：\n> \n>  * 比如我们传入的是一个 number，那么希望返回的可不是 any 类型，而是 number 类型；\n>  * 所以，需要在函数中可以捕获到参数的类型是 number ，并且同时使用它来作为返回值的类型。\n\n可以使用一种特性的变量「类型变量（type variable）」，它作用于类型，而不是值。\n\nfunction foo<Type>(arg: Type): Type {\n  return arg\n}\n\n\n1\n2\n3\n\n\n可以使用两种方式来调用它：\n\n * 通过 <类型> 的方式传递给函数。\n\n * 通过类型推导，自动推导出我们传入变量的类型。在这里会推导出它们是字面量类型的，因为字面量类型对于上面的函数是适用的。\n   \n   foo<string>('abc')\n   foo<number>(123)\n   \n   \n   1\n   2\n   \n   \n   foo('abc')\n   foo(123)\n   \n   \n   1\n   2\n   \n\n * 在泛型中可以传入多个类型：\n   \n   function foo<T, E>(a1: T, a2: E)\n   \n   \n   1\n   \n\n * 在开发中看到一些常用的名称：\n   \n   * T：Type 的缩写，类型\n   * K、V：key 和 value 的缩写，键值对\n   * E：Element 的缩写，元素\n   * O：Object 的缩写，对象\n\n\n# 泛型接口\n\n * 在定义接口时可以使用泛型：\n   \n   interface IFoo<T> {\n     initialValue: T,\n     valueList: T[],\n     handleValue: (value: T) => void\n   }\n   \n   const foo: IFoo<number> = {\n     initalValue: 0,\n     valueList: [0, 1, 3],\n     handleValue: function(value: number) {\n       console.log(value)\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n   \n   可以设置默认值为 number 类型：\n   \n   interface IFoo<T = number> {\n     initialValue: T,\n     valueList: T[],\n     handleValue: (value: T) => void\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 泛型类\n\nclass Point<T> {\n  X: T\n  y: T\n  \n  constructor(x: T, y: T) {\n    this.x = x\n    this.y = y\n  }\n}\nconst p1 = new Point(10, 20)\nconst p2 = new Point<number>(10, 20)\nconst p3: Point<number> = new Point(10, 20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 泛型约束\n\n有时候希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中：\n\n * 比如 string 和 array 都是有 length 的，或者某些对象也是会有 length 属性的；\n\n * 那么只要是拥有 length 的属性都可以作为参数类型：\n   \n   interface ILength {\n     length: number\n   }\n   \n   function getLength<T extends ILength>(args: T) {\n     return args.length\n   }\n   \n   console.log(getLength('abc'))\n   console.log(getLength(['abc', 'cba']))\n   console.log(getLength({length: 100, name: 'simon'}))\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   ",normalizedContent:"> 软件工程的主要目的是构建不仅仅明确和一致的 api，还要让你的代码具有很强的可重用性：\n> \n>  * 比如我们可以通过函数来封装一些 api，通过传入不同的函数参数，让函数帮助我们完成不同的操作；\n>  * 但是对于参数的类型是否也可以参数化呢？\n\n类型的参数化：\n\n * 实现需求：封装一个函数，传入一个参数，并返回这个参数。\n\n * 按照 typescript 的思想，要考虑这个参数和返回值的类型需要一致。\n   \n   function foo(arg: number): number {\n     return arg\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 拓展到更多的类型（ string 、 boolean 等类型）：\n   \n   function foo(arg: any): any {\n     return arg\n   }\n   \n   \n   1\n   2\n   3\n   \n\n\n# 使用泛型实现类型参数化\n\n> 虽然使用 any 是可以的，但是定义为 any 类型的时候，我们其实已经丢失了类型信息：\n> \n>  * 比如我们传入的是一个 number，那么希望返回的可不是 any 类型，而是 number 类型；\n>  * 所以，需要在函数中可以捕获到参数的类型是 number ，并且同时使用它来作为返回值的类型。\n\n可以使用一种特性的变量「类型变量（type variable）」，它作用于类型，而不是值。\n\nfunction foo<type>(arg: type): type {\n  return arg\n}\n\n\n1\n2\n3\n\n\n可以使用两种方式来调用它：\n\n * 通过 <类型> 的方式传递给函数。\n\n * 通过类型推导，自动推导出我们传入变量的类型。在这里会推导出它们是字面量类型的，因为字面量类型对于上面的函数是适用的。\n   \n   foo<string>('abc')\n   foo<number>(123)\n   \n   \n   1\n   2\n   \n   \n   foo('abc')\n   foo(123)\n   \n   \n   1\n   2\n   \n\n * 在泛型中可以传入多个类型：\n   \n   function foo<t, e>(a1: t, a2: e)\n   \n   \n   1\n   \n\n * 在开发中看到一些常用的名称：\n   \n   * t：type 的缩写，类型\n   * k、v：key 和 value 的缩写，键值对\n   * e：element 的缩写，元素\n   * o：object 的缩写，对象\n\n\n# 泛型接口\n\n * 在定义接口时可以使用泛型：\n   \n   interface ifoo<t> {\n     initialvalue: t,\n     valuelist: t[],\n     handlevalue: (value: t) => void\n   }\n   \n   const foo: ifoo<number> = {\n     initalvalue: 0,\n     valuelist: [0, 1, 3],\n     handlevalue: function(value: number) {\n       console.log(value)\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n   \n   可以设置默认值为 number 类型：\n   \n   interface ifoo<t = number> {\n     initialvalue: t,\n     valuelist: t[],\n     handlevalue: (value: t) => void\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 泛型类\n\nclass point<t> {\n  x: t\n  y: t\n  \n  constructor(x: t, y: t) {\n    this.x = x\n    this.y = y\n  }\n}\nconst p1 = new point(10, 20)\nconst p2 = new point<number>(10, 20)\nconst p3: point<number> = new point(10, 20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 泛型约束\n\n有时候希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中：\n\n * 比如 string 和 array 都是有 length 的，或者某些对象也是会有 length 属性的；\n\n * 那么只要是拥有 length 的属性都可以作为参数类型：\n   \n   interface ilength {\n     length: number\n   }\n   \n   function getlength<t extends ilength>(args: t) {\n     return args.length\n   }\n   \n   console.log(getlength('abc'))\n   console.log(getlength(['abc', 'cba']))\n   console.log(getlength({length: 100, name: 'simon'}))\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   ",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚕 TypeScript 模块化与类型声明",frontmatter:{title:"🚕 TypeScript 模块化与类型声明",date:"2022-04-30T17:18:53.000Z",permalink:"/pages/eb9b04/",categories:["🚶🏻 前端巩固基础","ʦ TypeScript"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/60.%20%CA%A6%20TypeScript/06.%20%F0%9F%9A%95%20TypeScript%20%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E.html",relativePath:"101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/06. 🚕 TypeScript 模块化与类型声明.md",key:"v-a1774298",path:"/pages/eb9b04/",headers:[{level:2,title:"TypeScript 的模块化",slug:"typescript-的模块化",normalizedTitle:"typescript 的模块化",charIndex:2},{level:2,title:"TypeScript 的类型声明",slug:"typescript-的类型声明",normalizedTitle:"typescript 的类型声明",charIndex:713},{level:3,title:"内置类型声明",slug:"内置类型声明",normalizedTitle:"内置类型声明",charIndex:1011},{level:3,title:"外部定义类型声明和自定义类型声明",slug:"外部定义类型声明和自定义类型声明",normalizedTitle:"外部定义类型声明和自定义类型声明",charIndex:1227},{level:3,title:"声明模块",slug:"声明模块",normalizedTitle:"声明模块",charIndex:2202},{level:3,title:"声明文件",slug:"声明文件",normalizedTitle:"声明文件",charIndex:1117},{level:3,title:"声明命名空间",slug:"声明命名空间",normalizedTitle:"声明命名空间",charIndex:2814}],headersStr:"TypeScript 的模块化 TypeScript 的类型声明 内置类型声明 外部定义类型声明和自定义类型声明 声明模块 声明文件 声明命名空间",content:'# TypeScript 的模块化\n\nTypeScript 支持两种方式来控制我们的作用域：\n\n * 模块化：每个文件可以是一个独立的模块，支持 ES Module，也支持 CommonJS；\n   \n   export function add(num1: number, num2: number) {\n     return num1 + num2\n   }\n   \n   export function sub (num1: number, num2: number) { \n     return num1 - num2\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 命名空间：通过 namespace 来声明一个命名空间：命名空间在 TypeScript 早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题。\n   \n   export namespace Time {\n     export function format(time: string) {\n       return "2022-02-22"\n     }\n   }\n   \n   export namespace Price {\n     export function format(price: number) {\n       return" 222.22"\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n\n# TypeScript 的类型声明\n\n>  * 之前提到的 Typescrip t 中的类型，几乎都是自己编写的，但是也有用到一些其他的类型，但是这些其他的类型来自哪里？\n>    * 涉及到 TypeScript 对类型的管理和查找规则。\n\n * TypeScript 有另一种文件格式「 .d.ts 」文件。\n   * 之前编写的 TypeScript 代码（ .ts 文件）最终都会输出为 .js 文件。是通常编写代码的地方。\n   * d.ts 用来作「类型的声明」。仅仅用来做类型检测，告诉 TypeScript 有哪些类型。\n * TypeScript 查找类型声明的地方：\n   * 内置类型声明；\n   * 外部定义类型声明；\n   * 自定义类型声明；\n\n\n# 内置类型声明\n\n内置类型声明是 Typescript 自带的、帮助我们内置了 JavaScript 运行时的一些标准化 API 的声明文件。\n\n * 包括 Math 、 Data 等内置类型， 也包括 DOM API，比如 Window 、 Document 等。\n * 内置类型声明通常在我们安装 typescript 的环境中会带有的。\n\n\n# 外部定义类型声明和自定义类型声明\n\n外部类型声明通常是使用一些库（比如第三方库）时，需要的一些类型声明。这些库有两种类型声明方式：\n\n * 在自己库中进行类型声明（编写 .d.ts 文件），比如 axio。\n * 通过社区的一个公有库 DefinitelyTyped 存放类型声明文件：\n   * 该库的 GitHub 地址：https://github.com/DefinitelyTyped/DefinitelyTyped/\n   * 该库查找声明安装方式的地址：https://www.typescriptlang.org/dt/search?search=\n   * 比如安装 React 的类型声明： npm i @types/react --save-de 。\n\n自定义类型声明的使用场景：\n\n * 情况一：使用的第三方库是一个纯的 JavaScript 库，没有对应的声明文件，比如：lodash\n * 情况二：给自己的代码中声明一些类型，方便在其他地方直接进行使用；\n\n🌰 例子：\n\ndeclare let wName: string;\ndeclare let wAge: number;\ndeclare let wHeight: number;\n\ndeclare function wFoo(): void;\ndeclare function wBar(): void;\n\ndeclare class Person {\n  name: string\n  age: number\n\t\n  constructor(name: string, age: number)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nlet wName = "simon"\nlet wAge = 18\nlet wHeight = 1.88\n\nfunction wFoo() {\n  console.log("wFoo")\n}\nfunction wBar() {\n  console.log ("wBar")\n}\nfunction Person (name, age) {\n  this.name = name\n  this.age = age\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 声明模块\n\n声明模块的语法： declare module \'模块名\' {} 。\n\n在声明模块的内部，可以通过 export 导出对应库的类、函数等。\n\n声明模块，比如 lodash 模块默认不能使用的情况，可以自己来声明这个模块：\n\ndeclare module "lodash" {\n  export function join(args: any[]): any;\n}\n\n\n1\n2\n3\n\n\n\n# 声明文件\n\n在某些情况下，可以声明文件：\n\n * 比如在开发 Vue 的过程中，默认是不识别 .vue 文件的，那么就需要对其进行文件的声明；（在 Vue 3 中，基于 TypeScript 开发有一个文件 shims-vue.d.ts ）\n * 比如在开发中我们使用了 jpg 这类图片文件，默认 Typescript 也是不支持的，也需要对其进行声明。\n\ndeclare module \'*.vue\' {\n  import { DefineComponent } from \'vue\'\n  const component: DefineComponent\n  \n\texport default component\n}\n\ndeclare module \'*.jpg\' {\n  const src: string\n  export default src\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 声明命名空间\n\n * 比如在 Vue 开发中的 index.html 中直接引入了 jQuery：\n   \n   * CDN 地址： https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.j\n\n * 我们可以进行命名空间的声明：\n\ndeclare namespace $ {\n  function ajax(settings: any): void\n}\n\n\n1\n2\n3\n\n * 然后在 main.ts 使用：\n\n$.ajax({\n  url: "**",\n  success: (res: any) => {\n    console.log (res);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# typescript 的模块化\n\ntypescript 支持两种方式来控制我们的作用域：\n\n * 模块化：每个文件可以是一个独立的模块，支持 es module，也支持 commonjs；\n   \n   export function add(num1: number, num2: number) {\n     return num1 + num2\n   }\n   \n   export function sub (num1: number, num2: number) { \n     return num1 - num2\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 命名空间：通过 namespace 来声明一个命名空间：命名空间在 typescript 早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题。\n   \n   export namespace time {\n     export function format(time: string) {\n       return "2022-02-22"\n     }\n   }\n   \n   export namespace price {\n     export function format(price: number) {\n       return" 222.22"\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n\n# typescript 的类型声明\n\n>  * 之前提到的 typescrip t 中的类型，几乎都是自己编写的，但是也有用到一些其他的类型，但是这些其他的类型来自哪里？\n>    * 涉及到 typescript 对类型的管理和查找规则。\n\n * typescript 有另一种文件格式「 .d.ts 」文件。\n   * 之前编写的 typescript 代码（ .ts 文件）最终都会输出为 .js 文件。是通常编写代码的地方。\n   * d.ts 用来作「类型的声明」。仅仅用来做类型检测，告诉 typescript 有哪些类型。\n * typescript 查找类型声明的地方：\n   * 内置类型声明；\n   * 外部定义类型声明；\n   * 自定义类型声明；\n\n\n# 内置类型声明\n\n内置类型声明是 typescript 自带的、帮助我们内置了 javascript 运行时的一些标准化 api 的声明文件。\n\n * 包括 math 、 data 等内置类型， 也包括 dom api，比如 window 、 document 等。\n * 内置类型声明通常在我们安装 typescript 的环境中会带有的。\n\n\n# 外部定义类型声明和自定义类型声明\n\n外部类型声明通常是使用一些库（比如第三方库）时，需要的一些类型声明。这些库有两种类型声明方式：\n\n * 在自己库中进行类型声明（编写 .d.ts 文件），比如 axio。\n * 通过社区的一个公有库 definitelytyped 存放类型声明文件：\n   * 该库的 github 地址：https://github.com/definitelytyped/definitelytyped/\n   * 该库查找声明安装方式的地址：https://www.typescriptlang.org/dt/search?search=\n   * 比如安装 react 的类型声明： npm i @types/react --save-de 。\n\n自定义类型声明的使用场景：\n\n * 情况一：使用的第三方库是一个纯的 javascript 库，没有对应的声明文件，比如：lodash\n * 情况二：给自己的代码中声明一些类型，方便在其他地方直接进行使用；\n\n🌰 例子：\n\ndeclare let wname: string;\ndeclare let wage: number;\ndeclare let wheight: number;\n\ndeclare function wfoo(): void;\ndeclare function wbar(): void;\n\ndeclare class person {\n  name: string\n  age: number\n\t\n  constructor(name: string, age: number)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nlet wname = "simon"\nlet wage = 18\nlet wheight = 1.88\n\nfunction wfoo() {\n  console.log("wfoo")\n}\nfunction wbar() {\n  console.log ("wbar")\n}\nfunction person (name, age) {\n  this.name = name\n  this.age = age\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 声明模块\n\n声明模块的语法： declare module \'模块名\' {} 。\n\n在声明模块的内部，可以通过 export 导出对应库的类、函数等。\n\n声明模块，比如 lodash 模块默认不能使用的情况，可以自己来声明这个模块：\n\ndeclare module "lodash" {\n  export function join(args: any[]): any;\n}\n\n\n1\n2\n3\n\n\n\n# 声明文件\n\n在某些情况下，可以声明文件：\n\n * 比如在开发 vue 的过程中，默认是不识别 .vue 文件的，那么就需要对其进行文件的声明；（在 vue 3 中，基于 typescript 开发有一个文件 shims-vue.d.ts ）\n * 比如在开发中我们使用了 jpg 这类图片文件，默认 typescript 也是不支持的，也需要对其进行声明。\n\ndeclare module \'*.vue\' {\n  import { definecomponent } from \'vue\'\n  const component: definecomponent\n  \n\texport default component\n}\n\ndeclare module \'*.jpg\' {\n  const src: string\n  export default src\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 声明命名空间\n\n * 比如在 vue 开发中的 index.html 中直接引入了 jquery：\n   \n   * cdn 地址： https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.j\n\n * 我们可以进行命名空间的声明：\n\ndeclare namespace $ {\n  function ajax(settings: any): void\n}\n\n\n1\n2\n3\n\n * 然后在 main.ts 使用：\n\n$.ajax({\n  url: "**",\n  success: (res: any) => {\n    console.log (res);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚠 TypeScript 的常用配置",frontmatter:{title:"🚠 TypeScript 的常用配置",date:"2022-04-30T17:18:53.000Z",permalink:"/pages/48e822/",categories:["🚶🏻 前端巩固基础","ʦ TypeScript"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/60.%20%CA%A6%20TypeScript/07.%20%F0%9F%9A%A0%20TypeScript%20%E7%9A%84%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html",relativePath:"101. 🚶🏻 前端巩固基础/60. ʦ TypeScript/07. 🚠 TypeScript 的常用配置.md",key:"v-94e34874",path:"/pages/48e822/",headersStr:null,content:"tsconfig.json 是用于配置 TypeScript 编译时的配置选项。",normalizedContent:"tsconfig.json 是用于配置 typescript 编译时的配置选项。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚞 axios 在 Vue 项目中的封装",frontmatter:{title:"🚞 axios 在 Vue 项目中的封装",date:"2022-06-24T22:11:28.000Z",permalink:"/pages/2626b9/",categories:["🚶🏻 前端巩固基础","🚟 axios"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/90.%20%F0%9F%9A%9F%20axios/02.%20%F0%9F%9A%9E%20axios%20%E5%9C%A8%20Vue%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85.html",relativePath:"101. 🚶🏻 前端巩固基础/90. 🚟 axios/02. 🚞 axios 在 Vue 项目中的封装.md",key:"v-413e5888",path:"/pages/2626b9/",headers:[{level:2,title:"封装的内容",slug:"封装的内容",normalizedTitle:"封装的内容",charIndex:117},{level:3,title:"设置接口的前缀",slug:"设置接口的前缀",normalizedTitle:"设置接口的前缀",charIndex:425},{level:3,title:"设置请求头与超时时间",slug:"设置请求头与超时时间",normalizedTitle:"设置请求头与超时时间",charIndex:990},{level:3,title:"封装请求方法",slug:"封装请求方法",normalizedTitle:"封装请求方法",charIndex:1507},{level:3,title:"请求拦截器",slug:"请求拦截器",normalizedTitle:"请求拦截器",charIndex:362},{level:3,title:"响应拦截器",slug:"响应拦截器",normalizedTitle:"响应拦截器",charIndex:394}],headersStr:"封装的内容 设置接口的前缀 设置请求头与超时时间 封装请求方法 请求拦截器 响应拦截器",content:"> axios 拥有友好的 API 调用，可以轻松在项目中直接使用。但是随着项目规模越大，如果每发起一次 HTTP 请求，都要进行一遍一遍如 超时时间、请求头、请求地址、错误处理等的重复配置，不仅浪费时间而且让代码变得冗余。\n\n\n# 封装的内容\n\n在发送请求之前，应该要与后端协商好 请求头、协议、请求地址、请求超时时间的约定。以便对 axios 进行进一步的封装一下内容：\n\n * 设置接口请求的前缀。 根据开发、测试、生产的三种不同环境，分别配置不同的请求地址前缀。\n * 请求头。例如用户登录状态的验证，在每次发送请求中的请求头中添加 token；或者在请求头中携带一些参数。\n * 状态码。根据接口返回不同的 status ，执行不同的业务。\n * 请求方法。对 get 、 post 等方法进行再一次封装。\n * 请求拦截器：根据请求的请求头决定，决定哪些请求可以访问。\n * 响应拦截器：根据后端返回的状态码判断执行不同的业务。\n\n\n# 设置接口的前缀\n\n通常方法。根据 node 环境变量判断区分开发、测试、生产环境。\n\nif (process.env.NODE_ENV === 'development') {\n  axios.defaults.baseURL = 'http://dev.xxx.com'\n} else if (process.env.NODE_ENV === 'production') {\n  axios.defaults.baseURL = 'http://prod.xxx.com'\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 在本地开发调试时，配置代理服务器 devServer ：\n> \n> devServer: {\n>     proxy: {\n>       '/proxyApi': {\n>         target: 'http://dev.xxx.com',\n>         changeOrigin: true,\n>         pathRewrite: {\n>           '/proxyApi': ''\n>         }\n>       }\n>     }\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n\n\n# 设置请求头与超时时间\n\n大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头。这里设置的是基础的请求头。当需要特殊的请求头时，再将特殊的请求头作为参数传入，覆盖基础配置。\n\nconst service = axios.create({\n    ...\n    timeout: 30000,  // 请求 30s 超时\n\t  headers: {\n        get: {\n          'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        },\n        post: {\n          'Content-Type': 'application/json;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        }\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 封装请求方法\n\n// get 请求\nexport function httpGet({\n  url,\n  params = {}\n}) {\n  return new Promise((resolve, reject) => {\n    axios.get(url, {\n      params\n    }).then((res) => {\n      resolve(res.data)\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nexport function httpPost({\n  url,\n  data = {},\n  params = {}\n}) {\n  return new Promise((resolve, reject) => {\n    axios({\n      url,\n      method: 'post',\n      transformRequest: [function (data) {\n        let ret = ''\n        for (let it in data) {\n          ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&'\n        }\n        return ret\n      }],\n      // 发送的数据\n      data,\n      // \burl参数\n      params\n\n    }).then(res => {\n      resolve(res.data)\n    })\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nimport { httpGet, httpPost } from './http'\nexport const getorglist = (params = {}) => httpGet({ url: 'apps/api/org/list', params })\n\n\n1\n2\n\n\n\n# 请求拦截器\n\n这里以在每次请求之前添加 token 为例子。设置如下的拦截器：\n\naxios.interceptors.request.use(\n  config => {\n    // 每次发送请求之前判断是否存在token\n    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的\n    token && (config.headers.Authorization = token)\n    return config\n  },\n  error => {\n    return Promise.error(error)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 响应拦截器\n\n响应拦截器可以在接收到响应之后先完成一系列的逻辑。\n\n这里以根据状态码判断登录状态、授权，处理错误为例：\n\n// 响应拦截器\naxios.interceptors.response.use(response => {\n  // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据\n  // 否则的话抛出错误\n  if (response.status === 200) {\n    if (response.data.code === 511) {\n      // 未授权调取授权接口\n    } else if (response.data.code === 510) {\n      // 未登录跳转登录页\n    } else {\n      return Promise.resolve(response)\n    }\n  } else {\n    return Promise.reject(response)\n  }\n}, error => {\n  // 我们可以在这里对异常状态作统一处理\n  if (error.response.status) {\n    // 处理请求失败的情况\n    // 对不同返回码对相应处理\n    return Promise.reject(error.response)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"> axios 拥有友好的 api 调用，可以轻松在项目中直接使用。但是随着项目规模越大，如果每发起一次 http 请求，都要进行一遍一遍如 超时时间、请求头、请求地址、错误处理等的重复配置，不仅浪费时间而且让代码变得冗余。\n\n\n# 封装的内容\n\n在发送请求之前，应该要与后端协商好 请求头、协议、请求地址、请求超时时间的约定。以便对 axios 进行进一步的封装一下内容：\n\n * 设置接口请求的前缀。 根据开发、测试、生产的三种不同环境，分别配置不同的请求地址前缀。\n * 请求头。例如用户登录状态的验证，在每次发送请求中的请求头中添加 token；或者在请求头中携带一些参数。\n * 状态码。根据接口返回不同的 status ，执行不同的业务。\n * 请求方法。对 get 、 post 等方法进行再一次封装。\n * 请求拦截器：根据请求的请求头决定，决定哪些请求可以访问。\n * 响应拦截器：根据后端返回的状态码判断执行不同的业务。\n\n\n# 设置接口的前缀\n\n通常方法。根据 node 环境变量判断区分开发、测试、生产环境。\n\nif (process.env.node_env === 'development') {\n  axios.defaults.baseurl = 'http://dev.xxx.com'\n} else if (process.env.node_env === 'production') {\n  axios.defaults.baseurl = 'http://prod.xxx.com'\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 在本地开发调试时，配置代理服务器 devserver ：\n> \n> devserver: {\n>     proxy: {\n>       '/proxyapi': {\n>         target: 'http://dev.xxx.com',\n>         changeorigin: true,\n>         pathrewrite: {\n>           '/proxyapi': ''\n>         }\n>       }\n>     }\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n\n\n# 设置请求头与超时时间\n\n大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头。这里设置的是基础的请求头。当需要特殊的请求头时，再将特殊的请求头作为参数传入，覆盖基础配置。\n\nconst service = axios.create({\n    ...\n    timeout: 30000,  // 请求 30s 超时\n\t  headers: {\n        get: {\n          'content-type': 'application/x-www-form-urlencoded;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        },\n        post: {\n          'content-type': 'application/json;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        }\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 封装请求方法\n\n// get 请求\nexport function httpget({\n  url,\n  params = {}\n}) {\n  return new promise((resolve, reject) => {\n    axios.get(url, {\n      params\n    }).then((res) => {\n      resolve(res.data)\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nexport function httppost({\n  url,\n  data = {},\n  params = {}\n}) {\n  return new promise((resolve, reject) => {\n    axios({\n      url,\n      method: 'post',\n      transformrequest: [function (data) {\n        let ret = ''\n        for (let it in data) {\n          ret += encodeuricomponent(it) + '=' + encodeuricomponent(data[it]) + '&'\n        }\n        return ret\n      }],\n      // 发送的数据\n      data,\n      // \burl参数\n      params\n\n    }).then(res => {\n      resolve(res.data)\n    })\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nimport { httpget, httppost } from './http'\nexport const getorglist = (params = {}) => httpget({ url: 'apps/api/org/list', params })\n\n\n1\n2\n\n\n\n# 请求拦截器\n\n这里以在每次请求之前添加 token 为例子。设置如下的拦截器：\n\naxios.interceptors.request.use(\n  config => {\n    // 每次发送请求之前判断是否存在token\n    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的\n    token && (config.headers.authorization = token)\n    return config\n  },\n  error => {\n    return promise.error(error)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 响应拦截器\n\n响应拦截器可以在接收到响应之后先完成一系列的逻辑。\n\n这里以根据状态码判断登录状态、授权，处理错误为例：\n\n// 响应拦截器\naxios.interceptors.response.use(response => {\n  // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据\n  // 否则的话抛出错误\n  if (response.status === 200) {\n    if (response.data.code === 511) {\n      // 未授权调取授权接口\n    } else if (response.data.code === 510) {\n      // 未登录跳转登录页\n    } else {\n      return promise.resolve(response)\n    }\n  } else {\n    return promise.reject(response)\n  }\n}, error => {\n  // 我们可以在这里对异常状态作统一处理\n  if (error.response.status) {\n    // 处理请求失败的情况\n    // 对不同返回码对相应处理\n    return promise.reject(error.response)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🚋 axios 理解与使用",frontmatter:{title:"🚋 axios 理解与使用",date:"2022-04-26T23:07:26.000Z",permalink:"/pages/a24b1b/",categories:["🚶🏻 前端巩固基础","🚟 axios"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/90.%20%F0%9F%9A%9F%20axios/01.%20%F0%9F%9A%8B%20axios%20%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8.html",relativePath:"101. 🚶🏻 前端巩固基础/90. 🚟 axios/01. 🚋 axios 理解与使用.md",key:"v-2b1a6bb0",path:"/pages/a24b1b/",headers:[{level:3,title:"axios 特点",slug:"axios-特点",normalizedTitle:"axios 特点",charIndex:351},{level:3,title:"axios 的基本使用",slug:"axios-的基本使用",normalizedTitle:"axios 的基本使用",charIndex:517},{level:3,title:"axios 语法",slug:"axios-语法",normalizedTitle:"axios 语法",charIndex:1795},{level:3,title:"axios 响应对象",slug:"axios-响应对象",normalizedTitle:"axios 响应对象",charIndex:2706},{level:3,title:"axios 请求对象",slug:"axios-请求对象",normalizedTitle:"axios 请求对象",charIndex:2912},{level:3,title:"axios 更多 API",slug:"axios-更多-api",normalizedTitle:"axios 更多 api",charIndex:3949},{level:4,title:"axios 的默认配置",slug:"axios-的默认配置",normalizedTitle:"axios 的默认配置",charIndex:3965},{level:4,title:"axios 创建实例对象",slug:"axios-创建实例对象",normalizedTitle:"axios 创建实例对象",charIndex:4421},{level:4,title:"axios 拦截器",slug:"axios-拦截器",normalizedTitle:"axios 拦截器",charIndex:4852},{level:4,title:"axios 取消请求",slug:"axios-取消请求",normalizedTitle:"axios 取消请求",charIndex:6437}],headersStr:"axios 特点 axios 的基本使用 axios 语法 axios 响应对象 axios 请求对象 axios 更多 API axios 的默认配置 axios 创建实例对象 axios 拦截器 axios 取消请求",content:"🔗 相关链接：axios GitHub axios/axios: Promise based HTTP client for the browser and node.js (github.com)\n\n>  * 是目前前端最流行的 AJAX 请求库。\n>  * React / Vue 官方推荐使用 axios 发送 AJAX 请求。\n\n> 可以使用 json-server 搭建一个测试的 http 服务。（创建一个虚拟的 RESTful 风格的请求 API ）\n> \n>  * 全局安装 json-server：\n> \n> $ npm install -g json-server\n> \n> \n> 1\n> \n> \n> （详细步骤查看 json-server Github README）\n\n\n# axios 特点\n\n（feaatures from axios GitHub official doc）\n\n * 是基于 XHR + Promise 的异步 AJAX 请求库\n * 浏览器端 /node 端都可以使用\n * 支持请求 / 响应拦截器\n * 支持请求取消\n * 请求 / 响应数据转换\n * 批量发送多个请求\n\n\n# axios 的基本使用\n\n🌰 例子：\n\n\n\n * 发送 GET 请求：\n\nbtns[0].onclick = function (){\n    // 发送AJAX请求GET\n    axios({\n     \t\t// 请求方法\n        method: 'GET',\n      \t// 请求路径url\n        url: 'http://localhost:3000/posts/2',\n    }).then(response => {\n      \t// 返回promise类型\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 发送 POST 请求：\n\nbtns[1].onclick = function (){\n    // 发送AJAX请求POST\n    axios({\n        method: 'POST',\n        url: 'http://localhost:3000/posts',\n        // 设置请求体\n        data: {\n            title: 'testAddPosts',\n            author: 'Simon'\n        }\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 发送 PUT 请求：\n\nbtns[2].onclick = function (){\n    // 发送AJAX请求PUT 更新数据\n    axios({\n        method: 'PUT',\n        url: 'http://localhost:3000/posts/3',\n        // 设置请求体\n        data: {\n            title: 'testAddPosts',\n            author: 'Nomis'\n        }\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 发送 DELETE 请求：\n\nbtns[3].onclick = function (){\n    // 发送AJAX请求PUT 更新数据\n    axios({\n        method: 'DELETE',\n        url: 'http://localhost:3000/posts/4',\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# axios 语法\n\n发送请求的方法：\n\n * axios(config) ： 通用 / 最本质的发任意类型请求的方式\n\n * axios(url[, config]) ：可以只指定 url 发 get 请求\n\n * axios.request(config) ：等同于 axios(config)\n\n * axios.get(url[, config]) ： 发 get 请求\n\n * axios.delete(url[, config]) ： 发 delete 请求\n\n * axios.post(url[, data, config]) ：发 post 请求\n\n * axios.put(url[, data, config]) ： 发 put 请求\n\n🌰 例子（使用 axios.request(config)） ）：\n\n// 发送get请求\nbtns[0].onclick = function (){\n    axios.request({\n        method: 'GET',\n        url: 'http://localhost:3000/posts'\n    }).then(response=>{\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子（使用 axios.post() 发送 post 请求）：\n\nbtns[1].onclick = function () {\n    axios.post(\n        'http://localhost:3000/posts', {\n            title: 'testAddPosts',\n            author: 'Simon'\n        }\n    ).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（ axios.put() 、 axios.delete() 的使用与上大同小异）\n\n\n# axios 响应对象\n\n\n\n响应对象 response 对象\n\n * config ：配置对象的属性。\n * data ：响应体的结果（服务器返回的结果）（axios 自动将服务器返回的结果转化为对象方便处理）。\n * headers ：响应头信息。\n * request ：AJAX 原生请求对象（axios 发送请求时创建的）。\n * status ：响应状态码 / status ： 响应字符串。\n\n\n# axios 请求对象\n\naxios 发送请求时的配置对象 config ：\n\n{\n  url: '/user', // 请求的路径\n  method: 'get', // 请求方法，默认为get\n  baseURL: 'https://localhost:3000/api', // 基础结构，在设置url只设置路径即可，axios自动拼接为完整的请求路径\n  transformRequest: [function (data, headers) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }], // 对请求的数据进行处理再发送到服务器\n  transformResponse: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }], // 对服务器响应的结果进行处理再接收\n\n  headers: {'X-Requested-With': 'XMLHttpRequest'}, // 请求头信息自定义控制\n\n  params: {\n    id: 1,\n    name: simon\n  }, // 设置发送请求时传递的参数，在对象中设置\n\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function (params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  }, // 参数序列化（对请求的参数处理格式）\n\n  data: {\n    firstName: 'Fred'\n  }, // 请求体设置，参数为对象会转为json，字符串直接传递\n\n\ttimeout: 1000, // default is `0` (no timeout)\n  // ... 更多前往官方文档中参考\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# axios 更多 API\n\n# axios 的默认配置\n\naxios.defalut.* （将常用的请求方法，请求路径中设置为默认后，后面调使用 axios 请求方法时可以调用为默认配置使用。）\n\n🌰 例子：\n\naxios.default.method = 'GET' // 设置默认请求类型为get\naxios.default.baseURL = 'http://localhost:3000' // 设置基础的URL\naxios.default.params = {id: 1} // 设置默认的请求参数\naxios.default.timeout = 3000; // 设置默认的超时时间\n\nbtns[0].onclick = function () {\n    axios.request({\n        url: '/posts'\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# axios 创建实例对象\n\naxios.create({config}) 。作用：如果服务器的接口（端口）有多个，在每次创建请求时创建的请求对象可以根据不同的服务器进行不同的配置。\n\n// 创建axios实例对象, 与aixos的功能近乎一样\nconst getDuanzi = axios.create({\n    baseURL: 'https://api.apiopen.top',\n    timeout: 2000\n})\n\n// 请求\n/*getDuanzi({\n    url: '/getJoke'\n}).then(response=>{\n    console.log(response)\n})*/\n\ngetDuanzi.get('/getJoke').then(response=>{\n    console.log(response.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# axios 拦截器\n\naxios.interceptors.*.use 实质上是函数，分为两种：请求拦截器、响应拦截器，内部原理与 Promise 有关：\n\n * 请求拦截器：发送请求之前，借助指定回调（函数）对请求的参数进行预处理（检测），如果没有问题则发送请求，有问题则拦截。\n * 响应拦截器：服务器返回结果，借助的回调对返回的结果进行预处理，结果格式化或者结果问题监测。\n\n🌰 例子（请求拦截器与响应拦截器的配置）：\n\n// 配置请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 请求发送之前对请求的操作\n    console.log('request success')\n    return config;\n}, function (error) {\n    console.log('request fail')\n    return Promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n// 配置响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 成功响应后(响应码在200以内)对响应进行的操作\n    console.log('response success')\n    return response;\n}, function (error) {\n    // 响应出错(响应码200以外)对响应的操作\n    console.log('response  fail')\n    return Promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n请求 / 响应成功后，拦截器进行的顺序如下：\n\n\n\n当请求中出现错误抛出异常时，拦截器执行情况如下：\n\n\n\n拦截器执行顺序：\n\n * 请求拦截器最后声明的先执行。\n * 响应拦截器的先声明的先执行。\n\n🌰 请求拦截器处理请求参数配置 config ：\n\naxios.interceptors.request.use(function (config) {\n    // 请求发送之前对请求的操作\n    config.params = {a: 100}\n    config.timeout = 2000\n    console.log('request interceptors success')\n    return config;\n}, function (error) {\n    console.log('request interceptors fail')\n    return Promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 响应拦截器处理响应参数 response ：\n\naxios.interceptors.response.use(function (response) {\n    console.log('response interceptors success')\n    console.log(response) // Promise创建的响应结果对象\n    console.log(response.data) // 只有响应体\n    return response;\n}, function (error) {\n    console.log('response interceptors  fail')\n    return Promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# axios 取消请求\n\naxios.CancelToken()\n\n> 在 json-server 中开启延时响应：\n> \n> $ json-server --watch db.json -d 2000\n> \n> \n> 1\n\n🌰 例子：\n\n//获取按钮\nconst btns = document.querySelectorAll('button');\n//2.声明全局变量\nlet cancel = null;\n//发送请求\nbtns[0].onclick = function(){\n    //检测上一次的请求是否已经完成\n    if(cancel !== null){\n        //取消上一次的请求\n        cancel();\n    }\n    axios({\n        method: 'GET',\n        url: 'http://localhost:3000/posts',\n        //1. 添加配置对象的属性\n        cancelToken: new axios.CancelToken(function(c){\n            //3. 将 c 的值赋值给 cancel\n            cancel = c;\n        })\n    }).then(response => {\n        console.log(response);\n        //将 cancel 的值初始化\n        cancel = null;\n    })\n}\n\n//绑定第二个事件取消请求\nbtns[1].onclick = function(){\n    cancel();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",normalizedContent:"🔗 相关链接：axios github axios/axios: promise based http client for the browser and node.js (github.com)\n\n>  * 是目前前端最流行的 ajax 请求库。\n>  * react / vue 官方推荐使用 axios 发送 ajax 请求。\n\n> 可以使用 json-server 搭建一个测试的 http 服务。（创建一个虚拟的 restful 风格的请求 api ）\n> \n>  * 全局安装 json-server：\n> \n> $ npm install -g json-server\n> \n> \n> 1\n> \n> \n> （详细步骤查看 json-server github readme）\n\n\n# axios 特点\n\n（feaatures from axios github official doc）\n\n * 是基于 xhr + promise 的异步 ajax 请求库\n * 浏览器端 /node 端都可以使用\n * 支持请求 / 响应拦截器\n * 支持请求取消\n * 请求 / 响应数据转换\n * 批量发送多个请求\n\n\n# axios 的基本使用\n\n🌰 例子：\n\n\n\n * 发送 get 请求：\n\nbtns[0].onclick = function (){\n    // 发送ajax请求get\n    axios({\n     \t\t// 请求方法\n        method: 'get',\n      \t// 请求路径url\n        url: 'http://localhost:3000/posts/2',\n    }).then(response => {\n      \t// 返回promise类型\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 发送 post 请求：\n\nbtns[1].onclick = function (){\n    // 发送ajax请求post\n    axios({\n        method: 'post',\n        url: 'http://localhost:3000/posts',\n        // 设置请求体\n        data: {\n            title: 'testaddposts',\n            author: 'simon'\n        }\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 发送 put 请求：\n\nbtns[2].onclick = function (){\n    // 发送ajax请求put 更新数据\n    axios({\n        method: 'put',\n        url: 'http://localhost:3000/posts/3',\n        // 设置请求体\n        data: {\n            title: 'testaddposts',\n            author: 'nomis'\n        }\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 发送 delete 请求：\n\nbtns[3].onclick = function (){\n    // 发送ajax请求put 更新数据\n    axios({\n        method: 'delete',\n        url: 'http://localhost:3000/posts/4',\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# axios 语法\n\n发送请求的方法：\n\n * axios(config) ： 通用 / 最本质的发任意类型请求的方式\n\n * axios(url[, config]) ：可以只指定 url 发 get 请求\n\n * axios.request(config) ：等同于 axios(config)\n\n * axios.get(url[, config]) ： 发 get 请求\n\n * axios.delete(url[, config]) ： 发 delete 请求\n\n * axios.post(url[, data, config]) ：发 post 请求\n\n * axios.put(url[, data, config]) ： 发 put 请求\n\n🌰 例子（使用 axios.request(config)） ）：\n\n// 发送get请求\nbtns[0].onclick = function (){\n    axios.request({\n        method: 'get',\n        url: 'http://localhost:3000/posts'\n    }).then(response=>{\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子（使用 axios.post() 发送 post 请求）：\n\nbtns[1].onclick = function () {\n    axios.post(\n        'http://localhost:3000/posts', {\n            title: 'testaddposts',\n            author: 'simon'\n        }\n    ).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（ axios.put() 、 axios.delete() 的使用与上大同小异）\n\n\n# axios 响应对象\n\n\n\n响应对象 response 对象\n\n * config ：配置对象的属性。\n * data ：响应体的结果（服务器返回的结果）（axios 自动将服务器返回的结果转化为对象方便处理）。\n * headers ：响应头信息。\n * request ：ajax 原生请求对象（axios 发送请求时创建的）。\n * status ：响应状态码 / status ： 响应字符串。\n\n\n# axios 请求对象\n\naxios 发送请求时的配置对象 config ：\n\n{\n  url: '/user', // 请求的路径\n  method: 'get', // 请求方法，默认为get\n  baseurl: 'https://localhost:3000/api', // 基础结构，在设置url只设置路径即可，axios自动拼接为完整的请求路径\n  transformrequest: [function (data, headers) {\n    // do whatever you want to transform the data\n\n    return data;\n  }], // 对请求的数据进行处理再发送到服务器\n  transformresponse: [function (data) {\n    // do whatever you want to transform the data\n\n    return data;\n  }], // 对服务器响应的结果进行处理再接收\n\n  headers: {'x-requested-with': 'xmlhttprequest'}, // 请求头信息自定义控制\n\n  params: {\n    id: 1,\n    name: simon\n  }, // 设置发送请求时传递的参数，在对象中设置\n\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsserializer: function (params) {\n    return qs.stringify(params, {arrayformat: 'brackets'})\n  }, // 参数序列化（对请求的参数处理格式）\n\n  data: {\n    firstname: 'fred'\n  }, // 请求体设置，参数为对象会转为json，字符串直接传递\n\n\ttimeout: 1000, // default is `0` (no timeout)\n  // ... 更多前往官方文档中参考\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# axios 更多 api\n\n# axios 的默认配置\n\naxios.defalut.* （将常用的请求方法，请求路径中设置为默认后，后面调使用 axios 请求方法时可以调用为默认配置使用。）\n\n🌰 例子：\n\naxios.default.method = 'get' // 设置默认请求类型为get\naxios.default.baseurl = 'http://localhost:3000' // 设置基础的url\naxios.default.params = {id: 1} // 设置默认的请求参数\naxios.default.timeout = 3000; // 设置默认的超时时间\n\nbtns[0].onclick = function () {\n    axios.request({\n        url: '/posts'\n    }).then(response => {\n        console.log(response)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# axios 创建实例对象\n\naxios.create({config}) 。作用：如果服务器的接口（端口）有多个，在每次创建请求时创建的请求对象可以根据不同的服务器进行不同的配置。\n\n// 创建axios实例对象, 与aixos的功能近乎一样\nconst getduanzi = axios.create({\n    baseurl: 'https://api.apiopen.top',\n    timeout: 2000\n})\n\n// 请求\n/*getduanzi({\n    url: '/getjoke'\n}).then(response=>{\n    console.log(response)\n})*/\n\ngetduanzi.get('/getjoke').then(response=>{\n    console.log(response.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# axios 拦截器\n\naxios.interceptors.*.use 实质上是函数，分为两种：请求拦截器、响应拦截器，内部原理与 promise 有关：\n\n * 请求拦截器：发送请求之前，借助指定回调（函数）对请求的参数进行预处理（检测），如果没有问题则发送请求，有问题则拦截。\n * 响应拦截器：服务器返回结果，借助的回调对返回的结果进行预处理，结果格式化或者结果问题监测。\n\n🌰 例子（请求拦截器与响应拦截器的配置）：\n\n// 配置请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 请求发送之前对请求的操作\n    console.log('request success')\n    return config;\n}, function (error) {\n    console.log('request fail')\n    return promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n// 配置响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 成功响应后(响应码在200以内)对响应进行的操作\n    console.log('response success')\n    return response;\n}, function (error) {\n    // 响应出错(响应码200以外)对响应的操作\n    console.log('response  fail')\n    return promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n请求 / 响应成功后，拦截器进行的顺序如下：\n\n\n\n当请求中出现错误抛出异常时，拦截器执行情况如下：\n\n\n\n拦截器执行顺序：\n\n * 请求拦截器最后声明的先执行。\n * 响应拦截器的先声明的先执行。\n\n🌰 请求拦截器处理请求参数配置 config ：\n\naxios.interceptors.request.use(function (config) {\n    // 请求发送之前对请求的操作\n    config.params = {a: 100}\n    config.timeout = 2000\n    console.log('request interceptors success')\n    return config;\n}, function (error) {\n    console.log('request interceptors fail')\n    return promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 响应拦截器处理响应参数 response ：\n\naxios.interceptors.response.use(function (response) {\n    console.log('response interceptors success')\n    console.log(response) // promise创建的响应结果对象\n    console.log(response.data) // 只有响应体\n    return response;\n}, function (error) {\n    console.log('response interceptors  fail')\n    return promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# axios 取消请求\n\naxios.canceltoken()\n\n> 在 json-server 中开启延时响应：\n> \n> $ json-server --watch db.json -d 2000\n> \n> \n> 1\n\n🌰 例子：\n\n//获取按钮\nconst btns = document.queryselectorall('button');\n//2.声明全局变量\nlet cancel = null;\n//发送请求\nbtns[0].onclick = function(){\n    //检测上一次的请求是否已经完成\n    if(cancel !== null){\n        //取消上一次的请求\n        cancel();\n    }\n    axios({\n        method: 'get',\n        url: 'http://localhost:3000/posts',\n        //1. 添加配置对象的属性\n        canceltoken: new axios.canceltoken(function(c){\n            //3. 将 c 的值赋值给 cancel\n            cancel = c;\n        })\n    }).then(response => {\n        console.log(response);\n        //将 cancel 的值初始化\n        cancel = null;\n    })\n}\n\n//绑定第二个事件取消请求\nbtns[1].onclick = function(){\n    cancel();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"💽 使用 TypeScript 重构 axios 库",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"801. 💽 TypeScript-Axios",imgUrl:null,description:null}},title:"💽 使用 TypeScript 重构 axios 库",date:"2020-03-11T21:50:55.000Z",permalink:"/typescript-axios",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/90.%20%F0%9F%9A%9F%20axios/10.%20%F0%9F%92%BD%20%E4%BD%BF%E7%94%A8%20TypeScript%20%E9%87%8D%E6%9E%84%20axios%20%E5%BA%93.html",relativePath:"101. 🚶🏻 前端巩固基础/90. 🚟 axios/10. 💽 使用 TypeScript 重构 axios 库.md",key:"v-212948d8",path:"/typescript-axios/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧩 Web Components",frontmatter:{title:"🧩 Web Components",date:"2022-06-05T16:06:02.000Z",permalink:"/pages/57c232/",categories:["🏃 前端核心框架","🎹 Web Components 组件化"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/01.%20%F0%9F%8E%B9%20Web%20Components/01.%20%F0%9F%A7%A9%20Web%20Components%20.html",relativePath:"105. 🏃 前端核心框架/01. 🎹 Web Components/01. 🧩 Web Components .md",key:"v-2321347c",path:"/pages/57c232/",headers:[{level:2,title:"组件化架构概念",slug:"组件化架构概念",normalizedTitle:"组件化架构概念",charIndex:165}],headersStr:"组件化架构概念",content:"Web Components 是一系列仍在制定中的现代标准。允许创建可以重用的定制元素，可以在 Web 应用中使用它们。\n\n实际上与现在的主流前端框架 Vue / React 的组件概念相似。\n\n> 🍞 相关文档：\n> \n>  * Web Components | MDN\n>  * WEBCOMPONENTS.ORG\n\n\n# 组件化架构概念\n\n在开发复杂的应用原则中，不要让应用的开发变得复杂。如果某一个部分变得复杂了，就将其拆分为简单的部分，然后再组合起来 —— 将复杂的事情简单化。\n\n> 🌰 例子：\n> \n>  * 将用户界面拆分为若干个组件，每个组件占有相应的位置，执行其明确的任务，并且于其他组件区分开。\n>  * 组件也可以包含子组件，比如消息组件可能是更高阶组件「消息列表」的子组件。可点击的用户头像可能也是一个组件。\n\n如何划分一个组件：\n\n * 通常情况下，如果一个独立的可视化实体，可以描述其可以做什么，如何在页面上交互，那么就可以将其划分为一个组件。\n   \n   例如，页面上存在几个模块，每个模块都有自己的角色，所以可以将它们划分为一个组件。\n\n一个组件的内容包括：\n\n * JavaScript 类；\n * DOM 结构，并且拥有自己的类管理，无法被外部代码操作（封装的原则）；\n * CSS 样式，作用在该组件上。\n * API：事件、类方法，让组件与其他组件交互。\n\n现代的浏览器原生支持 Web Components：\n\n * Custom Elememts：自定义 HTML 元素；\n * Shadow DOM：为组件创建内部 DOM，外部不可见；\n * CSS Scoping： 用于组件内部的范围样式；\n * Event retargeting：组件的事件相关。",normalizedContent:"web components 是一系列仍在制定中的现代标准。允许创建可以重用的定制元素，可以在 web 应用中使用它们。\n\n实际上与现在的主流前端框架 vue / react 的组件概念相似。\n\n> 🍞 相关文档：\n> \n>  * web components | mdn\n>  * webcomponents.org\n\n\n# 组件化架构概念\n\n在开发复杂的应用原则中，不要让应用的开发变得复杂。如果某一个部分变得复杂了，就将其拆分为简单的部分，然后再组合起来 —— 将复杂的事情简单化。\n\n> 🌰 例子：\n> \n>  * 将用户界面拆分为若干个组件，每个组件占有相应的位置，执行其明确的任务，并且于其他组件区分开。\n>  * 组件也可以包含子组件，比如消息组件可能是更高阶组件「消息列表」的子组件。可点击的用户头像可能也是一个组件。\n\n如何划分一个组件：\n\n * 通常情况下，如果一个独立的可视化实体，可以描述其可以做什么，如何在页面上交互，那么就可以将其划分为一个组件。\n   \n   例如，页面上存在几个模块，每个模块都有自己的角色，所以可以将它们划分为一个组件。\n\n一个组件的内容包括：\n\n * javascript 类；\n * dom 结构，并且拥有自己的类管理，无法被外部代码操作（封装的原则）；\n * css 样式，作用在该组件上。\n * api：事件、类方法，让组件与其他组件交互。\n\n现代的浏览器原生支持 web components：\n\n * custom elememts：自定义 html 元素；\n * shadow dom：为组件创建内部 dom，外部不可见；\n * css scoping： 用于组件内部的范围样式；\n * event retargeting：组件的事件相关。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍙 Custom Elements 自定义标签",frontmatter:{title:"🍙 Custom Elements 自定义标签",date:"2022-06-05T16:29:52.000Z",permalink:"/pages/a3a824/",categories:["🏃 前端核心框架","🎹 Web Components 组件化"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/01.%20%F0%9F%8E%B9%20Web%20Components/02.%20%F0%9F%8D%99%20Custom%20Elements%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BEmd.html",relativePath:"105. 🏃 前端核心框架/01. 🎹 Web Components/02. 🍙 Custom Elements 自定义标签md.md",key:"v-5f62ebdd",path:"/pages/a3a824/",headers:[{level:2,title:"创建自定义标签",slug:"创建自定义标签",normalizedTitle:"创建自定义标签",charIndex:24},{level:3,title:"🌰 例子 / 自定义格式化时间元素标签",slug:"🌰-例子-自定义格式化时间元素标签",normalizedTitle:"🌰 例子 / 自定义格式化时间元素标签",charIndex:1266},{level:2,title:"自定义标签元素的渲染顺序",slug:"自定义标签元素的渲染顺序",normalizedTitle:"自定义标签元素的渲染顺序",charIndex:4811},{level:2,title:"自定义内建的标签元素",slug:"自定义内建的标签元素",normalizedTitle:"自定义内建的标签元素",charIndex:6303}],headersStr:"创建自定义标签 🌰 例子 / 自定义格式化时间元素标签 自定义标签元素的渲染顺序 自定义内建的标签元素",content:"可以通过描述带有 自己的方法、属性、事件等的类 创建自定义标签。自定义标签创建之后，可以与 原生 HTML 内建一同使用。\n\n> 虽然 HTML 内建的标签有很多，但有时未必能满足开发的要求。\n\n有两种类型的自定义标签：\n\n * 自主自定义标签 / Autonomous custom element ，继承自 HTMLElement 的抽象类；\n * 自定义内建元素 / Customized built-in element：继承自 HTML 的元素，例如可以自定义 HTMLButton Element。\n\n\n# 创建自定义标签\n\n创建自定义标签时，需要告诉浏览器一些细节：如何展示、添加元素到页面和将其从页面移除时要做什么。\n\n可以通过创建带有几个特殊方法的类实现：\n\nclass MyElement extends HTMLElement {\n  constructor() {\n    super(); \n    // 在此创建元素\n  }\n  \n  connectedCallback() {\n    // 元素被添加到文档之后，浏览器调用这个方法\n    // 如果反复被添加/移除，那么这个方法会反复被调用\n  }\n  \n  disconnectedCallback() {\n    // 元素被添加到文档之后，浏览器调用这个方法\n    // 如果反复被添加/移除，那么这个方法会反复被调用\n  }\n  \n  static get observedAttributes() {\n    return [/*被监视的属性，发生变化时返回*/]\n  }\n  \n  attributeChangedCallback(name, oldValue, newValue) {\n    // 当上面数组中的属性发生变化的时候，这个方法会被调用\n  }\n\n  adoptedCallback() {\n    // 在元素被移动到新的文档的时候，这个方法会被调用\n    // （document.adoptNode 会用到, 非常少见）\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n声明上面的方法之后，需要注册元素：\n\ncustomElements.define(\"my-element\", MyElement)\n\n\n1\n\n\n> 此时，浏览器知道这个元素是 MyElement 类服务的。任何带有 <my-element> 标签的元素被创建的时候，一个 MyElement 的实例也会被创建，并且前面提到的方法也会被调用。\n> \n> 同样可以使用 document.createElement('my-element') 在 JavaScript 里创建元素。\n\n提示\n\n命名相关问题：\n\n * 自定义元素标签的名称必须包括一个 - 。\n * 这样确保了不会与内建的元素标签发生冲突。\n\n\n# 🌰 例子 / 自定义格式化时间元素标签\n\n> 原生 HTML 标签中 <time> 可以显示 日期和时间。但是不会进行任何的格式化处理。\n\n创建一个可以适用当前浏览器语言的时间格式的 <time-formatted> 元素。\n\nJavaScript 部分：\n\nclass TimeFormatted extends HTMLElement {\n  connectedCallback() {\n    let date = new Date(this.getAttribute('datetime') || Date.now())\n    \n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('yaer') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date)\n  }\n}\n\ncustomElements.define('time-formatted', TimeFormatted)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nHTML：\n\n<time-formatted\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\n\n\n1\n2\n3\n4\n5\n\n\n> connectedCallback() ：在元素被添加到页面时（或者 HTML 解析器检测到这个元素），调用这个方法。使用内建的时间日期格式化工具 Intl.DateTimeFormat() 。\n\n> 自定义元素的升级：\n> \n>  * 如果浏览器在 customElements.define 之前的任何地方见到了 <time-formatted> 元素，并不会报错。但会把这个元素当作未知元素，就像任何非标准标签一样。\n> \n>  * :not(:defined) CSS 选择器可以对这样「未定义」的元素加上样式。\n> \n>  * 当 customElement.define 被调用的时候，它们被「升级」了：一个新的 TimeFormatted 元素为每一个标签创建了，并且 connectedCallback 被调用。它们变成了 :defined 。\n> \n> 可以通过这些方法来获取更多的自定义标签的信息：\n> \n>  * customElements.get(name) ：返回指定 custom element name 的类。\n>  * customElements.whenDefined(name) ：返回一个 promise，将会在这个具有给定 name 的自定义元素变为已定义状态的时候 resolve（不带值）。\n\n> 注意元素的内容是在 connectedCallback 中渲染（创建）的。\n> \n>  * 如果在 constructor 被调用的时候渲染，为时过早。因为虽然这个元素实例被创建，但是还没插入页面，浏览器还不能处理 / 创建元素属性，此时获取特性 getAttribute() 会得到 null 。\n>  * 在 connectedCallback 有利于性能。这个元素不仅仅是被添加为了另一个元素的子元素，同样也成为了页面的一部分。因此可以构建分离的 DOM，创建元素并且让它们为之后的使用准备好。它们只有在插入页面的时候才会真的被渲染。\n\n为了让这个时间格式化组件的属性随着当前的时间发生变化，可以使用 监视属性 observedAttributes() 方法，当属性发生变化时 attributeChangedCallback 方法调用，并且只有指定的属性发生变化才会调用，优化性能。\n\nclass TimeFormatted extends HTMLElement {\n\n  render() { // (1)\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n\tconnectedCallback() {\n    if(!this.rendered) {\n      this.render();\n      this.redered = true;\n    }\n  }\n  \n  static get observedAttributes() {\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n\tattributeChangedCallback(name, oldValue, newValue) { \n    this.render();\n  }\n}\n\ncustomElements.define(\"time-formatted\", TimeFormatted);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n创建元素：\n\n<time-formatted\n  id=\"elem\"\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用定时器，每秒渲染：\n\n<script>\nsetInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)\n<\/script>\n\n\n1\n2\n3\n\n>  * 将渲染的逻辑移动到 render() 方法中。这个方法在元素被插入到页面的时候调用。\n>  * attributeChangedCallback 在 observedAttributes() 里的属性改变的时候被调用。在属性改变时重新渲染。\n>  * 计时器修改 datetime 会触发重新渲染。\n\n\n# 自定义标签元素的渲染顺序\n\n在 HTML 解析器构建 DOM 的时候，会按照先后顺序处理元素，先处理父级元素再处理子元素。\n\n> 🌰 例子：如果有 <outer><inner></inner></outer> ，那么 <outer> 元素会首先被创建并接入到 DOM，然后才是 <inner> 。\n\n这个渲染顺序对 自定义标签元素的渲染顺序 产生了影响。\n\n🌰 例子 / 如果想要在 connectedCallback 中访问 this.innerHTML ，什么也获取不到。因为此时子元素还不存在， DOM 还没有完成构建， HMTL 解析器会先创建 <user-info> 然后再处理子元素，而子元素还没加载。\n\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n  connectedCallback() {\n    alert(this.innerHTML); \n  }\n});\n<\/script>\n\n<user-info>John</user-info>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果要给自定义标签元素 传入信息，可以使用 元素属性，它们是即时生效的。或者，如果需要子元素，可以使用延迟时间为零的 setTimeout 来推迟访问子元素。\n\n🌰 例子：\n\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n  connectedCallback() {\n    setTimeout(() => alert(this.innerHTML)); // John (*)\n  }\n});\n<\/script>\n\n<user-info>John</user-info>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 现在可以访问子元素的内容了。因为是在 HTML 解析完成之后，才异步执行这段程序，可以在这里处理必要的子元素并且结束初始化过程。\n> \n> 但是这个方法不是完美的。如果嵌套的 自定义标签元素同样使用了 setTimeout 初始化自身，那么它们会 按照先后顺序执行：外层的 setTimeout 首先触发，然后才是内层的。这样外层元素还是早于内层元素结束初始化。\n> \n> 🌰 例子：\n> \n> <script>\n> customElements.define('user-info', class extends HTMLElement {\n>   connectedCallback() {\n>     alert(`${this.id} 已连接。`);\n>     setTimeout(() => alert(`${this.id} 初始化完成。`));\n>   }\n> });\n> <\/script>\n> \n> <user-info id=\"outer\">\n>   <user-info id=\"inner\"></user-info>\n> </user-info>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> > 可以看到，外层的元素并没有等待内层的元素。\n\n并没有内建的回调方法可以在嵌套元素渲染完成之后触发的事件。如果要实现这样的回调。比如，内层元素可以分派像 initialized 这样的事件，同时外层的元素监听这样的事件并做出响应。\n\n\n# 自定义内建的标签元素\n\n上面一种的自定义标签元素可能无法被搜索引擎识别或者无障碍设备处理。\n\n复用继承已有的内建元素的类：\n\n🌰 例子 / 按钮 HTMLButtonElement ：\n\nclass HelloButton extends HTMLButtonElement { /* custom element 方法 */ }\n\ncustomElements.define('hello-button', HelloButton, {extends: 'button'});\n\n\n1\n2\n3\n\n\n> 在 createElements.define 时要使用第三个参数。保证 hello-button 标签共享的类是 button 。\n\n插入一个普通的 <button> 标签， 添加 is=\"hello-button\" 特性：\n\n<button is=\"hello-button\">...</button>\n\n\n1\n\n\n完整的例子：\n\n<script>\n// 这个按钮在被点击的时候说 \"hello\"\nclass HelloButton extends HTMLButtonElement {\n  constructor() {\n    super();\n    this.addEventListener('click', () => alert(\"Hello!\"));\n  }\n}\n<\/script>\n\n<button is=\"hello-button\">Click me</button>\n\n<button is=\"hello-button\" disabled>Disabled</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 新定义的按钮继承了内建按钮，所以它拥有和内建按钮相同的样式和标准特性，比如 disabled 属性。",normalizedContent:"可以通过描述带有 自己的方法、属性、事件等的类 创建自定义标签。自定义标签创建之后，可以与 原生 html 内建一同使用。\n\n> 虽然 html 内建的标签有很多，但有时未必能满足开发的要求。\n\n有两种类型的自定义标签：\n\n * 自主自定义标签 / autonomous custom element ，继承自 htmlelement 的抽象类；\n * 自定义内建元素 / customized built-in element：继承自 html 的元素，例如可以自定义 htmlbutton element。\n\n\n# 创建自定义标签\n\n创建自定义标签时，需要告诉浏览器一些细节：如何展示、添加元素到页面和将其从页面移除时要做什么。\n\n可以通过创建带有几个特殊方法的类实现：\n\nclass myelement extends htmlelement {\n  constructor() {\n    super(); \n    // 在此创建元素\n  }\n  \n  connectedcallback() {\n    // 元素被添加到文档之后，浏览器调用这个方法\n    // 如果反复被添加/移除，那么这个方法会反复被调用\n  }\n  \n  disconnectedcallback() {\n    // 元素被添加到文档之后，浏览器调用这个方法\n    // 如果反复被添加/移除，那么这个方法会反复被调用\n  }\n  \n  static get observedattributes() {\n    return [/*被监视的属性，发生变化时返回*/]\n  }\n  \n  attributechangedcallback(name, oldvalue, newvalue) {\n    // 当上面数组中的属性发生变化的时候，这个方法会被调用\n  }\n\n  adoptedcallback() {\n    // 在元素被移动到新的文档的时候，这个方法会被调用\n    // （document.adoptnode 会用到, 非常少见）\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n声明上面的方法之后，需要注册元素：\n\ncustomelements.define(\"my-element\", myelement)\n\n\n1\n\n\n> 此时，浏览器知道这个元素是 myelement 类服务的。任何带有 <my-element> 标签的元素被创建的时候，一个 myelement 的实例也会被创建，并且前面提到的方法也会被调用。\n> \n> 同样可以使用 document.createelement('my-element') 在 javascript 里创建元素。\n\n提示\n\n命名相关问题：\n\n * 自定义元素标签的名称必须包括一个 - 。\n * 这样确保了不会与内建的元素标签发生冲突。\n\n\n# 🌰 例子 / 自定义格式化时间元素标签\n\n> 原生 html 标签中 <time> 可以显示 日期和时间。但是不会进行任何的格式化处理。\n\n创建一个可以适用当前浏览器语言的时间格式的 <time-formatted> 元素。\n\njavascript 部分：\n\nclass timeformatted extends htmlelement {\n  connectedcallback() {\n    let date = new date(this.getattribute('datetime') || date.now())\n    \n    this.innerhtml = new intl.datetimeformat(\"default\", {\n      year: this.getattribute('yaer') || undefined,\n      month: this.getattribute('month') || undefined,\n      day: this.getattribute('day') || undefined,\n      hour: this.getattribute('hour') || undefined,\n      minute: this.getattribute('minute') || undefined,\n      second: this.getattribute('second') || undefined,\n      timezonename: this.getattribute('time-zone-name') || undefined,\n    }).format(date)\n  }\n}\n\ncustomelements.define('time-formatted', timeformatted)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nhtml：\n\n<time-formatted\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\n\n\n1\n2\n3\n4\n5\n\n\n> connectedcallback() ：在元素被添加到页面时（或者 html 解析器检测到这个元素），调用这个方法。使用内建的时间日期格式化工具 intl.datetimeformat() 。\n\n> 自定义元素的升级：\n> \n>  * 如果浏览器在 customelements.define 之前的任何地方见到了 <time-formatted> 元素，并不会报错。但会把这个元素当作未知元素，就像任何非标准标签一样。\n> \n>  * :not(:defined) css 选择器可以对这样「未定义」的元素加上样式。\n> \n>  * 当 customelement.define 被调用的时候，它们被「升级」了：一个新的 timeformatted 元素为每一个标签创建了，并且 connectedcallback 被调用。它们变成了 :defined 。\n> \n> 可以通过这些方法来获取更多的自定义标签的信息：\n> \n>  * customelements.get(name) ：返回指定 custom element name 的类。\n>  * customelements.whendefined(name) ：返回一个 promise，将会在这个具有给定 name 的自定义元素变为已定义状态的时候 resolve（不带值）。\n\n> 注意元素的内容是在 connectedcallback 中渲染（创建）的。\n> \n>  * 如果在 constructor 被调用的时候渲染，为时过早。因为虽然这个元素实例被创建，但是还没插入页面，浏览器还不能处理 / 创建元素属性，此时获取特性 getattribute() 会得到 null 。\n>  * 在 connectedcallback 有利于性能。这个元素不仅仅是被添加为了另一个元素的子元素，同样也成为了页面的一部分。因此可以构建分离的 dom，创建元素并且让它们为之后的使用准备好。它们只有在插入页面的时候才会真的被渲染。\n\n为了让这个时间格式化组件的属性随着当前的时间发生变化，可以使用 监视属性 observedattributes() 方法，当属性发生变化时 attributechangedcallback 方法调用，并且只有指定的属性发生变化才会调用，优化性能。\n\nclass timeformatted extends htmlelement {\n\n  render() { // (1)\n    let date = new date(this.getattribute('datetime') || date.now());\n\n    this.innerhtml = new intl.datetimeformat(\"default\", {\n      year: this.getattribute('year') || undefined,\n      month: this.getattribute('month') || undefined,\n      day: this.getattribute('day') || undefined,\n      hour: this.getattribute('hour') || undefined,\n      minute: this.getattribute('minute') || undefined,\n      second: this.getattribute('second') || undefined,\n      timezonename: this.getattribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n\tconnectedcallback() {\n    if(!this.rendered) {\n      this.render();\n      this.redered = true;\n    }\n  }\n  \n  static get observedattributes() {\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n\tattributechangedcallback(name, oldvalue, newvalue) { \n    this.render();\n  }\n}\n\ncustomelements.define(\"time-formatted\", timeformatted);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n创建元素：\n\n<time-formatted\n  id=\"elem\"\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用定时器，每秒渲染：\n\n<script>\nsetinterval(() => elem.setattribute('datetime', new date()), 1000); // (5)\n<\/script>\n\n\n1\n2\n3\n\n>  * 将渲染的逻辑移动到 render() 方法中。这个方法在元素被插入到页面的时候调用。\n>  * attributechangedcallback 在 observedattributes() 里的属性改变的时候被调用。在属性改变时重新渲染。\n>  * 计时器修改 datetime 会触发重新渲染。\n\n\n# 自定义标签元素的渲染顺序\n\n在 html 解析器构建 dom 的时候，会按照先后顺序处理元素，先处理父级元素再处理子元素。\n\n> 🌰 例子：如果有 <outer><inner></inner></outer> ，那么 <outer> 元素会首先被创建并接入到 dom，然后才是 <inner> 。\n\n这个渲染顺序对 自定义标签元素的渲染顺序 产生了影响。\n\n🌰 例子 / 如果想要在 connectedcallback 中访问 this.innerhtml ，什么也获取不到。因为此时子元素还不存在， dom 还没有完成构建， hmtl 解析器会先创建 <user-info> 然后再处理子元素，而子元素还没加载。\n\n<script>\ncustomelements.define('user-info', class extends htmlelement {\n  connectedcallback() {\n    alert(this.innerhtml); \n  }\n});\n<\/script>\n\n<user-info>john</user-info>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果要给自定义标签元素 传入信息，可以使用 元素属性，它们是即时生效的。或者，如果需要子元素，可以使用延迟时间为零的 settimeout 来推迟访问子元素。\n\n🌰 例子：\n\n<script>\ncustomelements.define('user-info', class extends htmlelement {\n  connectedcallback() {\n    settimeout(() => alert(this.innerhtml)); // john (*)\n  }\n});\n<\/script>\n\n<user-info>john</user-info>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 现在可以访问子元素的内容了。因为是在 html 解析完成之后，才异步执行这段程序，可以在这里处理必要的子元素并且结束初始化过程。\n> \n> 但是这个方法不是完美的。如果嵌套的 自定义标签元素同样使用了 settimeout 初始化自身，那么它们会 按照先后顺序执行：外层的 settimeout 首先触发，然后才是内层的。这样外层元素还是早于内层元素结束初始化。\n> \n> 🌰 例子：\n> \n> <script>\n> customelements.define('user-info', class extends htmlelement {\n>   connectedcallback() {\n>     alert(`${this.id} 已连接。`);\n>     settimeout(() => alert(`${this.id} 初始化完成。`));\n>   }\n> });\n> <\/script>\n> \n> <user-info id=\"outer\">\n>   <user-info id=\"inner\"></user-info>\n> </user-info>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> > 可以看到，外层的元素并没有等待内层的元素。\n\n并没有内建的回调方法可以在嵌套元素渲染完成之后触发的事件。如果要实现这样的回调。比如，内层元素可以分派像 initialized 这样的事件，同时外层的元素监听这样的事件并做出响应。\n\n\n# 自定义内建的标签元素\n\n上面一种的自定义标签元素可能无法被搜索引擎识别或者无障碍设备处理。\n\n复用继承已有的内建元素的类：\n\n🌰 例子 / 按钮 htmlbuttonelement ：\n\nclass hellobutton extends htmlbuttonelement { /* custom element 方法 */ }\n\ncustomelements.define('hello-button', hellobutton, {extends: 'button'});\n\n\n1\n2\n3\n\n\n> 在 createelements.define 时要使用第三个参数。保证 hello-button 标签共享的类是 button 。\n\n插入一个普通的 <button> 标签， 添加 is=\"hello-button\" 特性：\n\n<button is=\"hello-button\">...</button>\n\n\n1\n\n\n完整的例子：\n\n<script>\n// 这个按钮在被点击的时候说 \"hello\"\nclass hellobutton extends htmlbuttonelement {\n  constructor() {\n    super();\n    this.addeventlistener('click', () => alert(\"hello!\"));\n  }\n}\n<\/script>\n\n<button is=\"hello-button\">click me</button>\n\n<button is=\"hello-button\" disabled>disabled</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 新定义的按钮继承了内建按钮，所以它拥有和内建按钮相同的样式和标准特性，比如 disabled 属性。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥮 template 模版元素",frontmatter:{title:"🥮 template 模版元素",date:"2022-06-05T18:18:13.000Z",permalink:"/pages/f0961b/",categories:["🏃 前端核心框架","🎹 Web Components 组件化"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/01.%20%F0%9F%8E%B9%20Web%20Components/04.%20%F0%9F%A5%AE%20template%20%E6%A8%A1%E7%89%88%E5%85%83%E7%B4%A0.html",relativePath:"105. 🏃 前端核心框架/01. 🎹 Web Components/04. 🥮 template 模版元素.md",key:"v-5577614c",path:"/pages/f0961b/",headers:[{level:2,title:"创建模版元素",slug:"创建模版元素",normalizedTitle:"创建模版元素",charIndex:127},{level:2,title:"插入模版",slug:"插入模版",normalizedTitle:"插入模版",charIndex:811},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1964}],headersStr:"创建模版元素 插入模版 总结",content:'内建的 <template> 元素用来存储 HTML 模板。浏览器将 忽略它的内容，仅检查语法的有效性，但是可以在 JavaScript 中 访问和使用它来创建其他元素。理论上，可以在 HTML 的任何位置创建不可见元素来存储 HTML 模版。\n\n\n# 创建模版元素\n\n模版元素 <template> 的优势：\n\n * 内容可以是任何有效的 HTML。即使它通常需要特定的封闭标签。\n   \n   🌰 例子：\n   \n   <template>\n     <tr>\n       <td>Contents</td>\n     </tr>\n   </template>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 通常如果在 <tr> 内放置类似 <div> 的元素，浏览器会检测到无效的 DOM 结构并对其进行 “修复”，然后用 <table> 封闭 <tr> ，那不是我们想要的。\n   > \n   > 而 <template> 则会完全保留储存的内容。\n   \n   🌰 例子 / 尝试将脚本和样式放入模版元素中：\n   \n   <template>\n     <style>\n       p { font-weight: bold; }\n     </style>\n     <script>\n       alert("Hello");\n     <\/script>\n   </template>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   > 浏览器认为 <template> 的内容 “不在文档中”：样式不会被应用，脚本也不会被执行， <video autoplay> 也不会运行，等。\n   \n   但是当将内容插入文档时，该内容将变为活动状态（应用样式，运行脚本等）。\n\n\n# 插入模版\n\n模板的 content 属性可看作是 DocumentFragment （ 一种特殊的 DOM 节点 🍥 JavaScript DOM 操作）。可以将其视为普通的 DOM 节点，除了它有一个特殊属性：将模版插入某个位置时，会被插入的是其子节点。\n\n🌰 例子：\n\n<template id="tmpl">\n  <script>\n    alert("Hello");\n  <\/script>\n  <div class="message">Hello, world!</div>\n</template>\n\n<script>\n\tlet elem = document.createElement(\'div\')\n  \n  // 克隆模版元素以便重用\n  elem.append(templ.content.cloneNode(true))\n\n\t// 将元素插入到文档中\n  document.body.append(elem)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n🌰 例子 / 插入模版到影子 DOM ：\n\n<template id="tmpl">\n  <style> p { font-weight: bold; } </style>\n  <p id="message"></p>\n</template>\n\n<div id="elem">Click me</div>\n\n<script>\n\telem.onclick = function() {\n    elem.attachShadow({mode: \'open\'});\n    \n    elem.shadowRoot.append(templ.content.cloneNode(true));\n  \n  \telem.shadowRoot.getElementById(\'message\').innerHTML = "Hello from shadow DOM";\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 将 tmpl.content 作为 DocumentFragment 克隆和插入，它的子节点（ <style> ， <p> ）将代为插入。他们会变成一个 shadow DOM ：\n> \n> <div id="elem">\n>   #shadow-root\n>     <style> p { font-weight: bold; } </style>\n>     <p id="message"></p>\n> </div>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 总结\n\n * <template> 的内容可以是任何语法正确的 HTML。\n * <template> 内容被视为 “超出文档范围”，因此它不会产生任何影响。\n * 可以在 JavaScript 中访问 template.content ，将其克隆以在新组件中重复使用。\n\n<template> 标签非常独特，因为：\n\n * 浏览器将检查其中的 HTML 语法（与在脚本中使用模板字符串不同）。\n * 但允许使用任何顶级 HTML 标签，即使没有适当包装元素的无意义的元素（例如 <tr> ）。\n * 其内容是交互式的：插入其文档后，脚本会运行， <video autoplay> 会自动播放。\n\n<template> 元素不具有任何迭代机制，数据绑定或变量替换的功能，但可以在其基础上实现这些功能。',normalizedContent:'内建的 <template> 元素用来存储 html 模板。浏览器将 忽略它的内容，仅检查语法的有效性，但是可以在 javascript 中 访问和使用它来创建其他元素。理论上，可以在 html 的任何位置创建不可见元素来存储 html 模版。\n\n\n# 创建模版元素\n\n模版元素 <template> 的优势：\n\n * 内容可以是任何有效的 html。即使它通常需要特定的封闭标签。\n   \n   🌰 例子：\n   \n   <template>\n     <tr>\n       <td>contents</td>\n     </tr>\n   </template>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 通常如果在 <tr> 内放置类似 <div> 的元素，浏览器会检测到无效的 dom 结构并对其进行 “修复”，然后用 <table> 封闭 <tr> ，那不是我们想要的。\n   > \n   > 而 <template> 则会完全保留储存的内容。\n   \n   🌰 例子 / 尝试将脚本和样式放入模版元素中：\n   \n   <template>\n     <style>\n       p { font-weight: bold; }\n     </style>\n     <script>\n       alert("hello");\n     <\/script>\n   </template>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   > 浏览器认为 <template> 的内容 “不在文档中”：样式不会被应用，脚本也不会被执行， <video autoplay> 也不会运行，等。\n   \n   但是当将内容插入文档时，该内容将变为活动状态（应用样式，运行脚本等）。\n\n\n# 插入模版\n\n模板的 content 属性可看作是 documentfragment （ 一种特殊的 dom 节点 🍥 javascript dom 操作）。可以将其视为普通的 dom 节点，除了它有一个特殊属性：将模版插入某个位置时，会被插入的是其子节点。\n\n🌰 例子：\n\n<template id="tmpl">\n  <script>\n    alert("hello");\n  <\/script>\n  <div class="message">hello, world!</div>\n</template>\n\n<script>\n\tlet elem = document.createelement(\'div\')\n  \n  // 克隆模版元素以便重用\n  elem.append(templ.content.clonenode(true))\n\n\t// 将元素插入到文档中\n  document.body.append(elem)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n🌰 例子 / 插入模版到影子 dom ：\n\n<template id="tmpl">\n  <style> p { font-weight: bold; } </style>\n  <p id="message"></p>\n</template>\n\n<div id="elem">click me</div>\n\n<script>\n\telem.onclick = function() {\n    elem.attachshadow({mode: \'open\'});\n    \n    elem.shadowroot.append(templ.content.clonenode(true));\n  \n  \telem.shadowroot.getelementbyid(\'message\').innerhtml = "hello from shadow dom";\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 将 tmpl.content 作为 documentfragment 克隆和插入，它的子节点（ <style> ， <p> ）将代为插入。他们会变成一个 shadow dom ：\n> \n> <div id="elem">\n>   #shadow-root\n>     <style> p { font-weight: bold; } </style>\n>     <p id="message"></p>\n> </div>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 总结\n\n * <template> 的内容可以是任何语法正确的 html。\n * <template> 内容被视为 “超出文档范围”，因此它不会产生任何影响。\n * 可以在 javascript 中访问 template.content ，将其克隆以在新组件中重复使用。\n\n<template> 标签非常独特，因为：\n\n * 浏览器将检查其中的 html 语法（与在脚本中使用模板字符串不同）。\n * 但允许使用任何顶级 html 标签，即使没有适当包装元素的无意义的元素（例如 <tr> ）。\n * 其内容是交互式的：插入其文档后，脚本会运行， <video autoplay> 会自动播放。\n\n<template> 元素不具有任何迭代机制，数据绑定或变量替换的功能，但可以在其基础上实现这些功能。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍘 Shadow DOM 影子 DOM",frontmatter:{title:"🍘 Shadow DOM 影子 DOM",date:"2022-06-05T17:52:02.000Z",permalink:"/pages/639649/",categories:["🏃 前端核心框架","🎹 Web Components 组件化"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/01.%20%F0%9F%8E%B9%20Web%20Components/03.%20%F0%9F%8D%98%20Shadow%20DOM%20%E5%BD%B1%E5%AD%90%20DOM.html",relativePath:"105. 🏃 前端核心框架/01. 🎹 Web Components/03. 🍘 Shadow DOM 影子 DOM.md",key:"v-45d11251",path:"/pages/639649/",headers:[{level:2,title:"内建的 Shadow DOM",slug:"内建的-shadow-dom",normalizedTitle:"内建的 shadow dom",charIndex:86},{level:2,title:"Shadow DOM tree",slug:"shadow-dom-tree",normalizedTitle:"shadow dom tree",charIndex:470},{level:2,title:"Shadow DOM 封装",slug:"shadow-dom-封装",normalizedTitle:"shadow dom 封装",charIndex:1769},{level:2,title:"Shadow DOM 插槽",slug:"shadow-dom-插槽",normalizedTitle:"shadow dom 插槽",charIndex:2564},{level:3,title:"具名插槽",slug:"具名插槽",normalizedTitle:"具名插槽",charIndex:2948},{level:3,title:"插槽后备内容",slug:"插槽后备内容",normalizedTitle:"插槽后备内容",charIndex:5532},{level:3,title:"默认插槽",slug:"默认插槽",normalizedTitle:"默认插槽",charIndex:5662},{level:3,title:"更新插槽",slug:"更新插槽",normalizedTitle:"更新插槽",charIndex:7082},{level:3,title:"插槽 API",slug:"插槽-api",normalizedTitle:"插槽 api",charIndex:7091},{level:2,title:"Shadow DOM 样式",slug:"shadow-dom-样式",normalizedTitle:"shadow dom 样式",charIndex:7102},{level:3,title:":host",slug:"host",normalizedTitle:":host",charIndex:7120},{level:3,title:"级联",slug:"级联",normalizedTitle:"级联",charIndex:7130},{level:2,title:"Shadow DOM 的事件",slug:"shadow-dom-的事件",normalizedTitle:"shadow dom 的事件",charIndex:7137}],headersStr:"内建的 Shadow DOM Shadow DOM tree Shadow DOM 封装 Shadow DOM 插槽 具名插槽 插槽后备内容 默认插槽 更新插槽 插槽 API Shadow DOM 样式 :host 级联 Shadow DOM 的事件",content:'Shadow DOM 为封装而生。它可以让一个组件拥有自己的「影子」DOM 树，这个 DOM 树 不能在主文档中被任意访问，可能拥有 局部样式规则，还有其他特性。\n\n\n# 内建的 Shadow DOM\n\n🌰 例子：\n\n<html>\n  <input type="range">\n</html>\n\n\n1\n2\n3\n\n\n\n例如这个内建的范围选择器。浏览器在内部使用 DOM/CSS 来绘制它们。这个 DOM 结构一般来说对我们是隐藏的。但可以在开发者工具里面看见它。比如，在 Chrome 里，需要打开「Show user agent shadow DOM」选项。 #shadow-root 下的内容就是 影子 DOM。\n\n对于影子 DOM 元素，不能使用 一般的 JavaScript 或者 CSS 选择器来获取，因为它们不是常规的元素。\n\n * 有自己的 id 空间。\n * 对主文档的 JavaScript 选择器隐身，比如 querySelector 。\n * 只使用 shadow tree 内部的样式，不使用主文档的样式。\n\n\n# Shadow DOM tree\n\n> 一个 DOM 元素可以有以下两类 DOM 子树：\n> \n>  * light tree ：常规 DOM 子树，由 HTML 子元素组成。\n>  * shadow tree ：隐藏的 DOM 子树，不在 HTML 中反映，无法被察觉。\n\n如果一个元素同时有以上两种子树，那么浏览器只渲染 shadow ，但是同样可以设置两种树的组合。\n\n影子树可以在自定义元素中使用，作用是隐藏组件内部结构和添加只在组件内有效的样式。\n\n使用 element.attachShadaw({mode: ...}) 创建一个影子树。\n\n> 两个限制：\n> \n>  * 每个元素只能创建一个影子树；\n>  * 元素必须是 自定义元素 或者下列元素之一：「article」、「aside」、「blockquote」、「body」、「div」、「footer」、「h1…h6」、「header」、「main」、「nav」、「p」、「section」或者「span」。其他元素，比如 <img> ，不能容纳 影子树。\n> \n> mode 选项可以设定封装层级。必须是以下两个值之一：\n> \n>  * open ：任何代码都可以访问 elem 的 shadow tree。通过 elem.shadowRoot 访问。\n>  * closed ： elem.shadowRoot 永远是 null 。只能通过 attachShadow 返回的指针来访问 shadow DOM（并且可能隐藏在一个 class 中）。浏览器原生的 shadow tree，比如 <input type="range"> ，是封闭的。没有任何方法可以访问它们。\n> \n> attachShadow 返回的 shadow root 和任何元素一样，可以使用 innerHTML 或者其他 DOM 方法，比如 append 拓展它。\n\n🌰 例子 / <show-hello> 元素将它的内部 DOM 隐藏在了影子里面。\n\n<script>\ncustomElements.define(\'show-hello\', class extends HTMLElement {\n  connectedCallback() {\n    const shadow = this.attachShadow({mode: \'open\'});\n    shadow.innerHTML = `<p>\n      Hello, ${this.getAttribute(\'name\')}\n    </p>`;\n  }\n});\n<\/script>\n\n<show-hello name="John"></show-hello>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n有 shadow root 的元素叫做「shadow tree host」，可以通过 shadow root 的 host 属性访问：\n\nconsole.log(elem.shadowRoot.host == elem) // true\n\n\n1\n\n\n\n# Shadow DOM 封装\n\nShadow DOM 被非常明显地和主文档分开：\n\n 1. Shadow DOM 元素对于 light DOM 中的 querySelector 不可见。实际上，Shadow DOM 中的元素可能与 light DOM 中某些元素的 id 冲突。这些元素必须在 shadow tree 中独一无二。\n 2. Shadow DOM 有自己的样式。外部样式规则在 shadow DOM 中不产生作用。\n\n🌰 例子：\n\n<style>\n  /* 文档样式对 #elem 内的 shadow tree 无作用 (1) */\n  p { color: red; }\n</style>\n\n<div id="elem"></div>\n\n<script>\n  elem.attachShadow({mode: \'open\'});\n    // shadow tree 有自己的样式 (2)\n  elem.shadowRoot.innerHTML = `\n    <style> p { font-weight: bold; } </style>\n    <p>Hello, John!</p>\n  `;\n\n  // <p> 只对 shadow tree 里面的查询可见 (3)\n  alert(document.querySelectorAll(\'p\').length); // 0\n  alert(elem.shadowRoot.querySelectorAll(\'p\').length); // 1\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 可以看到，样式对影子树没有效果，但是内部的样式有效果。\n> \n> 为了获取 shadow tree 内部的元素，可以从树的内部查询。\n\n\n# Shadow DOM 插槽\n\n许多类型的组件，例如标签、菜单、照片库等等，需要内容去渲染。\n\n🌰 例子 / 像 HTML 内建的标签元素，自定义组件需要实际的内容起作用，如下的 自定义菜单组件，需要实际的标题、内容项目：\n\n<custom-menu>\n  <title>Candy menu</title>\n  <item>Lollipop</item>\n  <item>Fruit Toast</item>\n  <item>Cup Cake</item>\n</custom-menu>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以尝试分析元素的内容，并动态服秩重新排列 DOM 节点。但是在 Shadow DOM 中，动态添加元素可能会丢失 CSS 样式。\n\nShadow DOM 支持使用 <slot> 插槽元素，由 light DOM 中的内容自动填充。\n\n\n# 具名插槽\n\n🌰 例子 ：\n\n<script>\ncustomElements.define(\'user-card\', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: \'open\'})\n    this.shadowRoot.innerRoot = `\n    \t<div>Name:\n    \t\t<slot name="username"></slot>\n\t\t\t</div>\n\t\t\t<div>Birthday:\n    \t\t<slot name="birthday"></slot>\n\t\t\t</div>\n\t\t`;\n  }\n});\n<\/script>\n\n<user-card>\n\t<span slot="username">John Smith</span>\n  <span slot="birthday">2001.01.01</span>\n</user-card>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 上面的例子中，从 <slot name="X"> 定义了和一个 插入点，一个带有 slot="X" 的元素被渲染的地方。\n> \n> 然后浏览器执行「组合」：从 light DOM 中获取元素并且渲染到 shadow DOM 中的对象应的插槽中，最终可以获取一个能被填充数据的通用组件。\n> \n> 最后在浏览器编译后的 DOM 结构：\n> \n> <user-card>\n>   #shadow-root\n>     <div>Name:\n>       <slot name="username"></slot>\n>     </div>\n>     <div>Birthday:\n>       <slot name="birthday"></slot>\n>     </div>\n>   <span slot="username">John Smith</span>\n>   <span slot="birthday">01.01.2001</span>\n> </user-card>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 现在元素同时拥有 light DOM 和 shadow DOM。为了渲染 shadow DOM 中的每一个 <slot name="..."> 元素，浏览器在 light DOM 中寻找相同名字的 slot="..." ：\n> 最终结果「扁平化」后的 DOM：\n> \n> <user-card>\n>   #shadow-root\n>     <div>Name:\n>       <slot name="username">\n>         \x3c!-- slotted element is inserted into the slot --\x3e\n>         <span slot="username">John Smith</span>\n>       </slot>\n>     </div>\n>     <div>Birthday:\n>       <slot name="birthday">\n>         <span slot="birthday">01.01.2001</span>\n>       </slot>\n>     </div>\n> </user-card>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> \n> \n> > 扁平化 DOM（flattered DOM） 仅仅用来创建渲染和事件处理，是虚拟的。虽然是渲染出来了，但文档中的节点事实上并没有移动。如果调用 querySelectorAll 容易验证获取到的元素长度，节点仍然会在它们的位置：\n> > \n> > alert( document.querySelectorAll(\'user-card span\').length ); // 2\n> > \n> > \n> > 1\n\n提示\n\n * 仅仅可以在 顶层子元素（直接子代） 设置 slot="..." 特性。对于嵌套的元素将被忽略。\n   \n   🌰 例子：\n   \n   <user-card>\n     <span slot="username">John Smith</span>\n     <div>\n       \x3c!-- invalid slot, must be direct child of user-card --\x3e\n       <span slot="birthday">01.01.2001</span>\n     </div>\n   </user-card>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n如果在 light DOM 里有多个 相同插槽名 的元素，那么它们会被一个接一个地添加到插槽中。\n\n🌰 例子 ：\n\n<user-card>\n  <span slot="username">John</span>\n  <span slot="username">Smith</span>\n</user-card>\n\n\n1\n2\n3\n4\n\n\n结果：\n\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name="username">\n        <span slot="username">John</span>\n        <span slot="username">Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name="birthday"></slot>\n    </div>\n</user-card>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 插槽后备内容\n\n在一个 <slot> 内部放点什么，它将成为后备内容。如果没有相应的填充内容，展示这个后备内容。\n\n<div>Name:\n  <slot name="username">Anonymous</slot>\n</div>\n\n\n1\n2\n3\n\n\n\n# 默认插槽\n\nshadow DOM 中第一个没有名字的 <slot> 是一个默认插槽。它从 light DOM 中获取没有放置在其他位置的所有节点。\n\n🌰 例子：\n\n<script>\ncustomElements.define(\'user-card\', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: \'open\'});\n    this.shadowRoot.innerHTML = `\n    <div>Name:\n      <slot name="username"></slot>\n    </div>\n    <div>Birthday:\n      <slot name="birthday"></slot>\n    </div>\n    <fieldset>\n      <legend>Other information</legend>\n      <slot></slot>\n    </fieldset>\n    `;\n  }\n});\n<\/script>\n\n<user-card>\n  <div>I like to swim.</div>\n  <span slot="username">John Smith</span>\n  <span slot="birthday">01.01.2001</span>\n  <div>...And play volleyball too!</div>\n</user-card>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 所有未被插入的 light DOM 内容进入 其他信息 Other information 字段集。元素一个接一个的附加到插槽中，因此未插入插槽的信息都在默认插槽中。\n> \n> 最终的扁平化 DOM：\n> \n> <user-card>\n>   #shadow-root\n>     <div>Name:\n>       <slot name="username">\n>         <span slot="username">John Smith</span>\n>       </slot>\n>     </div>\n>     <div>Birthday:\n>       <slot name="birthday">\n>         <span slot="birthday">01.01.2001</span>\n>       </slot>\n>     </div>\n>     <fieldset>\n>       <legend>About me</legend>\n>       <slot>\n>         <div>Hello</div>\n>         <div>I am John!</div>\n>       </slot>\n>     </fieldset>\n> </user-card>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n\n\n# 更新插槽\n\n\n# 插槽 API\n\n\n# Shadow DOM 样式\n\n\n# :host\n\n\n# 级联\n\n\n# Shadow DOM 的事件',normalizedContent:'shadow dom 为封装而生。它可以让一个组件拥有自己的「影子」dom 树，这个 dom 树 不能在主文档中被任意访问，可能拥有 局部样式规则，还有其他特性。\n\n\n# 内建的 shadow dom\n\n🌰 例子：\n\n<html>\n  <input type="range">\n</html>\n\n\n1\n2\n3\n\n\n\n例如这个内建的范围选择器。浏览器在内部使用 dom/css 来绘制它们。这个 dom 结构一般来说对我们是隐藏的。但可以在开发者工具里面看见它。比如，在 chrome 里，需要打开「show user agent shadow dom」选项。 #shadow-root 下的内容就是 影子 dom。\n\n对于影子 dom 元素，不能使用 一般的 javascript 或者 css 选择器来获取，因为它们不是常规的元素。\n\n * 有自己的 id 空间。\n * 对主文档的 javascript 选择器隐身，比如 queryselector 。\n * 只使用 shadow tree 内部的样式，不使用主文档的样式。\n\n\n# shadow dom tree\n\n> 一个 dom 元素可以有以下两类 dom 子树：\n> \n>  * light tree ：常规 dom 子树，由 html 子元素组成。\n>  * shadow tree ：隐藏的 dom 子树，不在 html 中反映，无法被察觉。\n\n如果一个元素同时有以上两种子树，那么浏览器只渲染 shadow ，但是同样可以设置两种树的组合。\n\n影子树可以在自定义元素中使用，作用是隐藏组件内部结构和添加只在组件内有效的样式。\n\n使用 element.attachshadaw({mode: ...}) 创建一个影子树。\n\n> 两个限制：\n> \n>  * 每个元素只能创建一个影子树；\n>  * 元素必须是 自定义元素 或者下列元素之一：「article」、「aside」、「blockquote」、「body」、「div」、「footer」、「h1…h6」、「header」、「main」、「nav」、「p」、「section」或者「span」。其他元素，比如 <img> ，不能容纳 影子树。\n> \n> mode 选项可以设定封装层级。必须是以下两个值之一：\n> \n>  * open ：任何代码都可以访问 elem 的 shadow tree。通过 elem.shadowroot 访问。\n>  * closed ： elem.shadowroot 永远是 null 。只能通过 attachshadow 返回的指针来访问 shadow dom（并且可能隐藏在一个 class 中）。浏览器原生的 shadow tree，比如 <input type="range"> ，是封闭的。没有任何方法可以访问它们。\n> \n> attachshadow 返回的 shadow root 和任何元素一样，可以使用 innerhtml 或者其他 dom 方法，比如 append 拓展它。\n\n🌰 例子 / <show-hello> 元素将它的内部 dom 隐藏在了影子里面。\n\n<script>\ncustomelements.define(\'show-hello\', class extends htmlelement {\n  connectedcallback() {\n    const shadow = this.attachshadow({mode: \'open\'});\n    shadow.innerhtml = `<p>\n      hello, ${this.getattribute(\'name\')}\n    </p>`;\n  }\n});\n<\/script>\n\n<show-hello name="john"></show-hello>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n有 shadow root 的元素叫做「shadow tree host」，可以通过 shadow root 的 host 属性访问：\n\nconsole.log(elem.shadowroot.host == elem) // true\n\n\n1\n\n\n\n# shadow dom 封装\n\nshadow dom 被非常明显地和主文档分开：\n\n 1. shadow dom 元素对于 light dom 中的 queryselector 不可见。实际上，shadow dom 中的元素可能与 light dom 中某些元素的 id 冲突。这些元素必须在 shadow tree 中独一无二。\n 2. shadow dom 有自己的样式。外部样式规则在 shadow dom 中不产生作用。\n\n🌰 例子：\n\n<style>\n  /* 文档样式对 #elem 内的 shadow tree 无作用 (1) */\n  p { color: red; }\n</style>\n\n<div id="elem"></div>\n\n<script>\n  elem.attachshadow({mode: \'open\'});\n    // shadow tree 有自己的样式 (2)\n  elem.shadowroot.innerhtml = `\n    <style> p { font-weight: bold; } </style>\n    <p>hello, john!</p>\n  `;\n\n  // <p> 只对 shadow tree 里面的查询可见 (3)\n  alert(document.queryselectorall(\'p\').length); // 0\n  alert(elem.shadowroot.queryselectorall(\'p\').length); // 1\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 可以看到，样式对影子树没有效果，但是内部的样式有效果。\n> \n> 为了获取 shadow tree 内部的元素，可以从树的内部查询。\n\n\n# shadow dom 插槽\n\n许多类型的组件，例如标签、菜单、照片库等等，需要内容去渲染。\n\n🌰 例子 / 像 html 内建的标签元素，自定义组件需要实际的内容起作用，如下的 自定义菜单组件，需要实际的标题、内容项目：\n\n<custom-menu>\n  <title>candy menu</title>\n  <item>lollipop</item>\n  <item>fruit toast</item>\n  <item>cup cake</item>\n</custom-menu>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以尝试分析元素的内容，并动态服秩重新排列 dom 节点。但是在 shadow dom 中，动态添加元素可能会丢失 css 样式。\n\nshadow dom 支持使用 <slot> 插槽元素，由 light dom 中的内容自动填充。\n\n\n# 具名插槽\n\n🌰 例子 ：\n\n<script>\ncustomelements.define(\'user-card\', class extends htmlelement {\n  connectedcallback() {\n    this.attachshadow({mode: \'open\'})\n    this.shadowroot.innerroot = `\n    \t<div>name:\n    \t\t<slot name="username"></slot>\n\t\t\t</div>\n\t\t\t<div>birthday:\n    \t\t<slot name="birthday"></slot>\n\t\t\t</div>\n\t\t`;\n  }\n});\n<\/script>\n\n<user-card>\n\t<span slot="username">john smith</span>\n  <span slot="birthday">2001.01.01</span>\n</user-card>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 上面的例子中，从 <slot name="x"> 定义了和一个 插入点，一个带有 slot="x" 的元素被渲染的地方。\n> \n> 然后浏览器执行「组合」：从 light dom 中获取元素并且渲染到 shadow dom 中的对象应的插槽中，最终可以获取一个能被填充数据的通用组件。\n> \n> 最后在浏览器编译后的 dom 结构：\n> \n> <user-card>\n>   #shadow-root\n>     <div>name:\n>       <slot name="username"></slot>\n>     </div>\n>     <div>birthday:\n>       <slot name="birthday"></slot>\n>     </div>\n>   <span slot="username">john smith</span>\n>   <span slot="birthday">01.01.2001</span>\n> </user-card>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 现在元素同时拥有 light dom 和 shadow dom。为了渲染 shadow dom 中的每一个 <slot name="..."> 元素，浏览器在 light dom 中寻找相同名字的 slot="..." ：\n> 最终结果「扁平化」后的 dom：\n> \n> <user-card>\n>   #shadow-root\n>     <div>name:\n>       <slot name="username">\n>         \x3c!-- slotted element is inserted into the slot --\x3e\n>         <span slot="username">john smith</span>\n>       </slot>\n>     </div>\n>     <div>birthday:\n>       <slot name="birthday">\n>         <span slot="birthday">01.01.2001</span>\n>       </slot>\n>     </div>\n> </user-card>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> \n> \n> > 扁平化 dom（flattered dom） 仅仅用来创建渲染和事件处理，是虚拟的。虽然是渲染出来了，但文档中的节点事实上并没有移动。如果调用 queryselectorall 容易验证获取到的元素长度，节点仍然会在它们的位置：\n> > \n> > alert( document.queryselectorall(\'user-card span\').length ); // 2\n> > \n> > \n> > 1\n\n提示\n\n * 仅仅可以在 顶层子元素（直接子代） 设置 slot="..." 特性。对于嵌套的元素将被忽略。\n   \n   🌰 例子：\n   \n   <user-card>\n     <span slot="username">john smith</span>\n     <div>\n       \x3c!-- invalid slot, must be direct child of user-card --\x3e\n       <span slot="birthday">01.01.2001</span>\n     </div>\n   </user-card>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n如果在 light dom 里有多个 相同插槽名 的元素，那么它们会被一个接一个地添加到插槽中。\n\n🌰 例子 ：\n\n<user-card>\n  <span slot="username">john</span>\n  <span slot="username">smith</span>\n</user-card>\n\n\n1\n2\n3\n4\n\n\n结果：\n\n<user-card>\n  #shadow-root\n    <div>name:\n      <slot name="username">\n        <span slot="username">john</span>\n        <span slot="username">smith</span>\n      </slot>\n    </div>\n    <div>birthday:\n      <slot name="birthday"></slot>\n    </div>\n</user-card>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 插槽后备内容\n\n在一个 <slot> 内部放点什么，它将成为后备内容。如果没有相应的填充内容，展示这个后备内容。\n\n<div>name:\n  <slot name="username">anonymous</slot>\n</div>\n\n\n1\n2\n3\n\n\n\n# 默认插槽\n\nshadow dom 中第一个没有名字的 <slot> 是一个默认插槽。它从 light dom 中获取没有放置在其他位置的所有节点。\n\n🌰 例子：\n\n<script>\ncustomelements.define(\'user-card\', class extends htmlelement {\n  connectedcallback() {\n    this.attachshadow({mode: \'open\'});\n    this.shadowroot.innerhtml = `\n    <div>name:\n      <slot name="username"></slot>\n    </div>\n    <div>birthday:\n      <slot name="birthday"></slot>\n    </div>\n    <fieldset>\n      <legend>other information</legend>\n      <slot></slot>\n    </fieldset>\n    `;\n  }\n});\n<\/script>\n\n<user-card>\n  <div>i like to swim.</div>\n  <span slot="username">john smith</span>\n  <span slot="birthday">01.01.2001</span>\n  <div>...and play volleyball too!</div>\n</user-card>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 所有未被插入的 light dom 内容进入 其他信息 other information 字段集。元素一个接一个的附加到插槽中，因此未插入插槽的信息都在默认插槽中。\n> \n> 最终的扁平化 dom：\n> \n> <user-card>\n>   #shadow-root\n>     <div>name:\n>       <slot name="username">\n>         <span slot="username">john smith</span>\n>       </slot>\n>     </div>\n>     <div>birthday:\n>       <slot name="birthday">\n>         <span slot="birthday">01.01.2001</span>\n>       </slot>\n>     </div>\n>     <fieldset>\n>       <legend>about me</legend>\n>       <slot>\n>         <div>hello</div>\n>         <div>i am john!</div>\n>       </slot>\n>     </fieldset>\n> </user-card>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n\n\n# 更新插槽\n\n\n# 插槽 api\n\n\n# shadow dom 样式\n\n\n# :host\n\n\n# 级联\n\n\n# shadow dom 的事件',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥯 Vue 2.x 脚手架创建项目",frontmatter:{title:"🥯 Vue 2.x 脚手架创建项目",date:"2022-03-11T16:10:56.000Z",permalink:"/pages/1a639e/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 组件化编程"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/04.%20%E2%98%94%EF%B8%8F%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/10.%20%F0%9F%A5%AF%20Vue%202.x%20%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE.html",relativePath:"105. 🏃 前端核心框架/04. ☔️ 核心框架项目搭建/10. 🥯 Vue 2.x 脚手架创建项目.md",key:"v-0acda84f",path:"/pages/1a639e/",headers:[{level:2,title:"Vue 脚手架的基本使用",slug:"vue-脚手架的基本使用",normalizedTitle:"vue 脚手架的基本使用",charIndex:108},{level:3,title:"使用 Vue 脚手架",slug:"使用-vue-脚手架",normalizedTitle:"使用 vue 脚手架",charIndex:125},{level:3,title:"render 函数分析",slug:"render-函数分析",normalizedTitle:"render 函数分析",charIndex:851},{level:3,title:"vue-cli 默认配置分析",slug:"vue-cli-默认配置分析",normalizedTitle:"vue-cli 默认配置分析",charIndex:1067},{level:3,title:"ref 属性分析",slug:"ref-属性分析",normalizedTitle:"ref 属性分析",charIndex:1211},{level:3,title:"props 配置分析",slug:"props-配置分析",normalizedTitle:"props 配置分析",charIndex:1369},{level:2,title:"mixin 混入配置",slug:"mixin-混入配置",normalizedTitle:"mixin 混入配置",charIndex:2175},{level:2,title:"插件的使用",slug:"插件的使用",normalizedTitle:"插件的使用",charIndex:2550},{level:2,title:"scoped 局部样式",slug:"scoped-局部样式",normalizedTitle:"scoped 局部样式",charIndex:3175},{level:2,title:"$nextTick",slug:"nexttick",normalizedTitle:"$nexttick",charIndex:3335}],headersStr:"Vue 脚手架的基本使用 使用 Vue 脚手架 render 函数分析 vue-cli 默认配置分析 ref 属性分析 props 配置分析 mixin 混入配置 插件的使用 scoped 局部样式 $nextTick",content:" * Vue CLI（Command Line Interface 命令行接口工具），Vue 脚手架是 Vue 官方提供的标准化开发工具（平台）；\n * 脚手架文档：Vue CLI (vuejs.org)；\n\n\n# Vue 脚手架的基本使用\n\n\n# 使用 Vue 脚手架\n\n * 第一次使用时，全局安装 @vue/cli ：\n   \n   $ npm install -g @vue/cli\n   \n   \n   1\n   \n\n * 使用时，进入要创建脚手架项目的目录；\n\n * 创建项目：\n   \n   $ vue create project_name\n   \n   \n   1\n   \n\n * 选择预设配置版本：\n\n * 成功创建项目，使用命令运行：\n   \n    $ cd project_name\n    $ npm run serve\n   \n   \n   1\n   2\n   \n\n⭐️ 预设 Vue 脚手架文件结构：\n\n├── node_modules 包依赖文件文件夹\n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源文件夹\n│   │   └── logo.png\n│   │── component: 存放组件文件夹\n│   │   └── HelloWorld.vue 组件示例\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# render 函数分析\n\n⭐️ 了解 ** 不同版本的 Vue.js ** ：\n\n * vue.js ： 完整版本的 Vue，包含核心功能和模版解析器；\n\n * vue.runtime.*.js ：运行版本的 Vue，只包含核心功能，无模版解析器；\n   \n   > 所以在开发 main.js 中不能使用 template 配置项，使用 render 函数可以接收到 createElement 参数去渲染模版结构内容。\n\n\n# vue-cli 默认配置分析\n\nVue 脚手架隐藏了所有 webpack 相关的配置，通过以下命令可以看查看具体的 webpack 配置：\n\n$ vue inspect > output.js\n\n\n1\n\n\nvue.config.js 修改默认配置，对脚手架个性化配置… （了解）\n\n\n# ref 属性分析\n\nref 是一个特殊的标签属性：\n\n * 可被用来给元素或者自组件注册引用信息（⭐️ 不直接使用 id ， id 的替代者）；\n\n * 使用 ref 在 HTML 标签上使用获取的是真实 DOM 元素，应用在组件上获取的是组件的实例对象；\n\n * 🔗 🌰 02-src-ref 属性：\n\n\n# props 配置分析\n\nprops 可以让组件接收外部传送给组件的数据的配置属性：\n\n * 传递数据语法：⭐️ 在组件标签中： <Demo name=\"xxx\"/> ；\n\n * 接收数据语法：\n   \n   * 第一种写法（仅接受数据）： props:[‘name’]\n   \n   * 第二种写法（限制类型）：\n     \n      props: {\n         name: String,\n         age: Number\n     },\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 第三种写法（限制类型 + 必要性限制 + 指定默认值）：\n     \n     props: {\n       name:{\n         type: String, // 类型\n         required: true, // 必须\n         default: 'defalutName' // 默认值\n       },\n       age :{\n         type: Number,\n           required: true,\n             default: 99\n       }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n\n * ⚠️备注： props 接收数据是只读的，Vue 底层会监测对 props 数据的修改，如果进行了修改就会发出警告，若业务需求确实需要修改，可以复制 props 接收到的数据到 data 中然后再修改。\n\n * 🔗 🌰 03-src-props配置分析 ：\n\n\n# mixin 混入配置\n\nmixin 可以把多个组件共用的配置提取成一个混入对象:\n\n * 使用：\n   \n   * 第一步：定义混入：\n   \n   export const mixinName = {\n     data(){....},\n     methods:{....}      \n     // ....\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   * 第二部：使用混入：\n     \n     * 全局混入：在入口文件 main.js 引入混合后，进行全局配置 Vue.mixin(mixinName) ；\n   \n   * 局部混入： 定义 mixins 配置项： mixing:[‘mixinName’] ；\n\n * 🔗 🌰 04-src-mixin混入配置 ：\n\n\n# 插件的使用\n\n插件可以增强 Vue 中的功能：\n\n * 本质： 包含 install 方法的一个对象， install 的第一个参数是 Vue ，第二个以后的参数是插件使用者传递的数据；\n\n * 使用：\n   \n   * 第一步：定义插件：\n   \n   对象.install = function (Vue, options) {\n       // 1. 添加全局过滤器\n       Vue.filter(....)\n   \n       // 2. 添加全局指令\n       Vue.directive(....)\n   \n       // 3. 配置全局混入(合)\n       Vue.mixin(....)\n   \n       // 4. 添加实例方法\n       Vue.prototype.$myMethod = function () {...}\n       Vue.prototype.$myProperty = xxxx\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n   \n   * 第二步：使用插件：\n     \n     在入口文件 main.js 引入插件后，配置 Vue.use(pluginName)\n\n🔗 🌰 05-src-plugin插件的使用 ：\n\n\n# scoped 局部样式\n\nscoped 使样式在局部生效，防止发生冲突；\n\n * 使用格式： <style scoped> </style> ；\n\n另外， lang 属性可以选择 CSS 预编译处理器，例如使用 lang=“less” ，默认为 css ;\n\n🔗 🌰 06-src-scoped局部样式 ：\n\n\n# $nextTick\n\n * 使用语法： this.$nextTick(function() { … })\n * 作用：在下一次 DOM 更新结束后执行其指定的回调函数。\n * 一般在改变了数据之后，要基于更新的新 DOM 进行某些操作时，可以定义在 $nextTick() 的回调函数中执行。\n\n> 模版渲染更新原则，Vue 不会在某个回调函数中，监测到某个数值更新后变重新渲染模版，而是等所有的数值更新后才重新渲染模版，以提高效率。",normalizedContent:" * vue cli（command line interface 命令行接口工具），vue 脚手架是 vue 官方提供的标准化开发工具（平台）；\n * 脚手架文档：vue cli (vuejs.org)；\n\n\n# vue 脚手架的基本使用\n\n\n# 使用 vue 脚手架\n\n * 第一次使用时，全局安装 @vue/cli ：\n   \n   $ npm install -g @vue/cli\n   \n   \n   1\n   \n\n * 使用时，进入要创建脚手架项目的目录；\n\n * 创建项目：\n   \n   $ vue create project_name\n   \n   \n   1\n   \n\n * 选择预设配置版本：\n\n * 成功创建项目，使用命令运行：\n   \n    $ cd project_name\n    $ npm run serve\n   \n   \n   1\n   2\n   \n\n⭐️ 预设 vue 脚手架文件结构：\n\n├── node_modules 包依赖文件文件夹\n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源文件夹\n│   │   └── logo.png\n│   │── component: 存放组件文件夹\n│   │   └── helloworld.vue 组件示例\n│   │── app.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── readme.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# render 函数分析\n\n⭐️ 了解 ** 不同版本的 vue.js ** ：\n\n * vue.js ： 完整版本的 vue，包含核心功能和模版解析器；\n\n * vue.runtime.*.js ：运行版本的 vue，只包含核心功能，无模版解析器；\n   \n   > 所以在开发 main.js 中不能使用 template 配置项，使用 render 函数可以接收到 createelement 参数去渲染模版结构内容。\n\n\n# vue-cli 默认配置分析\n\nvue 脚手架隐藏了所有 webpack 相关的配置，通过以下命令可以看查看具体的 webpack 配置：\n\n$ vue inspect > output.js\n\n\n1\n\n\nvue.config.js 修改默认配置，对脚手架个性化配置… （了解）\n\n\n# ref 属性分析\n\nref 是一个特殊的标签属性：\n\n * 可被用来给元素或者自组件注册引用信息（⭐️ 不直接使用 id ， id 的替代者）；\n\n * 使用 ref 在 html 标签上使用获取的是真实 dom 元素，应用在组件上获取的是组件的实例对象；\n\n * 🔗 🌰 02-src-ref 属性：\n\n\n# props 配置分析\n\nprops 可以让组件接收外部传送给组件的数据的配置属性：\n\n * 传递数据语法：⭐️ 在组件标签中： <demo name=\"xxx\"/> ；\n\n * 接收数据语法：\n   \n   * 第一种写法（仅接受数据）： props:[‘name’]\n   \n   * 第二种写法（限制类型）：\n     \n      props: {\n         name: string,\n         age: number\n     },\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 第三种写法（限制类型 + 必要性限制 + 指定默认值）：\n     \n     props: {\n       name:{\n         type: string, // 类型\n         required: true, // 必须\n         default: 'defalutname' // 默认值\n       },\n       age :{\n         type: number,\n           required: true,\n             default: 99\n       }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n\n * ⚠️备注： props 接收数据是只读的，vue 底层会监测对 props 数据的修改，如果进行了修改就会发出警告，若业务需求确实需要修改，可以复制 props 接收到的数据到 data 中然后再修改。\n\n * 🔗 🌰 03-src-props配置分析 ：\n\n\n# mixin 混入配置\n\nmixin 可以把多个组件共用的配置提取成一个混入对象:\n\n * 使用：\n   \n   * 第一步：定义混入：\n   \n   export const mixinname = {\n     data(){....},\n     methods:{....}      \n     // ....\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   * 第二部：使用混入：\n     \n     * 全局混入：在入口文件 main.js 引入混合后，进行全局配置 vue.mixin(mixinname) ；\n   \n   * 局部混入： 定义 mixins 配置项： mixing:[‘mixinname’] ；\n\n * 🔗 🌰 04-src-mixin混入配置 ：\n\n\n# 插件的使用\n\n插件可以增强 vue 中的功能：\n\n * 本质： 包含 install 方法的一个对象， install 的第一个参数是 vue ，第二个以后的参数是插件使用者传递的数据；\n\n * 使用：\n   \n   * 第一步：定义插件：\n   \n   对象.install = function (vue, options) {\n       // 1. 添加全局过滤器\n       vue.filter(....)\n   \n       // 2. 添加全局指令\n       vue.directive(....)\n   \n       // 3. 配置全局混入(合)\n       vue.mixin(....)\n   \n       // 4. 添加实例方法\n       vue.prototype.$mymethod = function () {...}\n       vue.prototype.$myproperty = xxxx\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n   \n   * 第二步：使用插件：\n     \n     在入口文件 main.js 引入插件后，配置 vue.use(pluginname)\n\n🔗 🌰 05-src-plugin插件的使用 ：\n\n\n# scoped 局部样式\n\nscoped 使样式在局部生效，防止发生冲突；\n\n * 使用格式： <style scoped> </style> ；\n\n另外， lang 属性可以选择 css 预编译处理器，例如使用 lang=“less” ，默认为 css ;\n\n🔗 🌰 06-src-scoped局部样式 ：\n\n\n# $nexttick\n\n * 使用语法： this.$nexttick(function() { … })\n * 作用：在下一次 dom 更新结束后执行其指定的回调函数。\n * 一般在改变了数据之后，要基于更新的新 dom 进行某些操作时，可以定义在 $nexttick() 的回调函数中执行。\n\n> 模版渲染更新原则，vue 不会在某个回调函数中，监测到某个数值更新后变重新渲染模版，而是等所有的数值更新后才重新渲染模版，以提高效率。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🪝 Vue 3 + TypeScript 项目搭建",frontmatter:{title:"🪝 Vue 3 + TypeScript 项目搭建",date:"2022-04-28T11:14:31.000Z",permalink:"/pages/bb1311/",categories:["📚 前端笔记","⛽️ 项目相关"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/04.%20%E2%98%94%EF%B8%8F%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/11.%20%F0%9F%AA%9D%20%20Vue%203%20%20+%20TypeScript%20%20%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html",relativePath:"105. 🏃 前端核心框架/04. ☔️ 核心框架项目搭建/11. 🪝  Vue 3  + TypeScript  项目搭建.md",key:"v-3fae4a68",path:"/pages/bb1311/",headers:[{level:2,title:"Vue 3 创建项目",slug:"vue-3-创建项目",normalizedTitle:"vue 3 创建项目",charIndex:2},{level:2,title:"代码规范",slug:"代码规范",normalizedTitle:"代码规范",charIndex:123},{level:3,title:".editorconfig 配置",slug:"editorconfig-配置",normalizedTitle:".editorconfig 配置",charIndex:132},{level:3,title:"Prettier 工具",slug:"prettier-工具",normalizedTitle:"prettier 工具",charIndex:611},{level:3,title:"使用 ESLint 检测代码规范",slug:"使用-eslint-检测代码规范",normalizedTitle:"使用 eslint 检测代码规范",charIndex:1543},{level:3,title:"Before commit 代码规范 / husky 使用",slug:"before-commit-代码规范-husky-使用",normalizedTitle:"before commit 代码规范 /husky 使用",charIndex:2035},{level:3,title:"Git Commit 规范",slug:"git-commit-规范",normalizedTitle:"git commit 规范",charIndex:2598},{level:4,title:"代码提交风格",slug:"代码提交风格",normalizedTitle:"代码提交风格",charIndex:2615},{level:4,title:"代码提交验证",slug:"代码提交验证",normalizedTitle:"代码提交验证",charIndex:3914},{level:2,title:"第三方库集成",slug:"第三方库集成",normalizedTitle:"第三方库集成",charIndex:4375},{level:3,title:"vue.config.js 配置",slug:"vue-config-js-配置",normalizedTitle:"vue.config.js 配置",charIndex:4386},{level:3,title:"vue-router集成",slug:"vue-router集成",normalizedTitle:"vue-router 集成",charIndex:4766},{level:3,title:"vuex集成",slug:"vuex集成",normalizedTitle:"vuex 集成",charIndex:5727},{level:3,title:"element-plus集成",slug:"element-plus集成",normalizedTitle:"element-plus 集成",charIndex:6093},{level:4,title:"全局引入",slug:"全局引入",normalizedTitle:"全局引入",charIndex:6354},{level:4,title:"局部引入",slug:"局部引入",normalizedTitle:"局部引入",charIndex:6647},{level:3,title:"axios 集成",slug:"axios-集成",normalizedTitle:"axios 集成",charIndex:8789},{level:2,title:"tsconfig.json",slug:"tsconfig-json",normalizedTitle:"tsconfig.json",charIndex:10809},{level:2,title:"shims-vue.d.ts",slug:"shims-vue-d-ts",normalizedTitle:"shims-vue.d.ts",charIndex:12022}],headersStr:"Vue 3 创建项目 代码规范 .editorconfig 配置 Prettier 工具 使用 ESLint 检测代码规范 Before commit 代码规范 / husky 使用 Git Commit 规范 代码提交风格 代码提交验证 第三方库集成 vue.config.js 配置 vue-router集成 vuex集成 element-plus集成 全局引入 局部引入 axios 集成 tsconfig.json shims-vue.d.ts",content:'# Vue 3 创建项目\n\nvue create project-name\n\n\n1\n\n\n创建 Vue 脚手架时选择的 featue：\n\n * Babel\n * TypeScript\n * Vuex\n * CSS 预处理器\n * 语法检查\n\n\n# 代码规范\n\n\n# .editorconfig 配置\n\nEditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n\n# http://editorconfig.org\n\nroot = true\n\n[*] # 表示所有文件适用\ncharset = utf-8 # 设置文件字符集为 utf-8\nindent_style = space # 缩进风格（tab | space）\nindent_size = 2 # 缩进大小\nend_of_line = lf # 控制换行类型(lf | cr | crlf)\ntrim_trailing_whitespace = true # 去除行首的任意空白字符\ninsert_final_newline = true # 始终在文件末尾插入一个新行\n\n[*.md] # 表示仅 md 文件适用以下规则\nmax_line_length = off\ntrim_trailing_whitespace = false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Prettier 工具\n\n> Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n\n * 安装 prettier\n\nnpm install prettier -D\n\n\n1\n\n\n * 配置 .prettierrc 文件：\n   \n   * useTabs ：使用 tab 缩进还是空格缩进，选择 false；\n   \n   * tabWidth ：tab 是空格的情况下，是几个空格，选择 2 个；\n   \n   * printWidth ：当行字符的长度，推荐 80，也有人喜欢 100 或者 120；\n   \n   * singleQuote ：使用单引号还是双引号，选择 true ，使用单引号；\n   \n   * trailingComma ：在多行输入的尾逗号是否添加，设置为 none ；\n   \n   * semi ：语句末尾是否要加分号，默认值 true ，选择 false 表示不加；\n\n{\n  "useTabs": false,\n  "tabWidth": 2,\n  "printWidth": 80,\n  "singleQuote": true,\n  "trailingComma": "none",\n  "semi": false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 创建 .prettierignore 忽略文件：\n\n/dist/*\n.local\n.output.js\n/node_modules/**\n\n**/*.svg\n**/*.sh\n\n/public/*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 测试 prettier 是否生效\n   \n   * 测试一：在代码中保存代码；\n   \n   * 测试二：配置一次性修改的命令；\n\n在 package.json 中配置一个 scripts ：\n\n    "prettier": "prettier --write ."\n\n\n1\n\n\n\n# 使用 ESLint 检测代码规范\n\n在前面创建项目的时候，就选择了 ESLint ，所以 Vue 会默认帮助我们配置需要的 ESLint 环境。\n\n * 解决 eslint 和 prettier 冲突的问题：\n * 安装插件：（vue 在创建项目时，如果选择 prettier + ESlint，那么这两个插件会自动安装）\n\nnpm i eslint-plugin-prettier eslint-config-prettier -D\n\n\n1\n\n\n在 eslintrc.js 中添加 prettier 插件：\n\n  extends: [\n    "plugin:vue/vue3-essential",\n    "eslint:recommended",\n    "@vue/typescript/recommended",\n    "@vue/prettier",\n    "@vue/prettier/@typescript-eslint",\n    \'plugin:prettier/recommended\' // 添加\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Before commit 代码规范 /husky 使用\n\n虽然我们已经要求项目使用 eslint 了，但是不能保证组员提交代码之前都将 eslint 中的问题解决掉了：\n\n * 也就是我们希望保证代码仓库中的代码都是符合 eslint 规范的；\n\n * 那么我们需要在组员执行 git commit 命令的时候对其进行校验，如果不符合 eslint 规范，那么自动通过规范进行修复；\n\n那么如何做到这一点呢？可以通过 Husky 工具：\n\n * husky 是一个 git hook 工具，可以帮助我们触发 git 提交的各个阶段：pre-commit、commit-msg、pre-push。\n\n这里我们可以使用自动配置命令：\n\nnpx husky-init && npm install\n\n\n1\n\n\n\n\n点击查看\n\n这里会做三件事：\n\n * 安装 husky 相关的依赖：\n\n\n\n * 在项目目录下创建 .husky 文件夹：\n\nnpx huksy install\n\n\n1\n\n\n\n\n * 在 package.json 中添加一个脚本：\n\n\n\n接下来，我们需要去完成一个操作：在进行 commit 时，执行 lint 脚本：\n\n\n\n这个时候我们执行 git commit 的时候会自动对代码进行 lint 校验。\n\n\n# Git Commit 规范\n\n# 代码提交风格\n\n通常我们的 git commit 会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。\n\n但是如果每次手动来编写这些是比较麻烦的事情，可以使用一个工具：Commitizen（Commitizen 是一个帮助我们编写规范 commit message 的工具）。\n\n * 安装 Commitizen\n   \n   npm install commitizen -D\n   \n   \n   1\n   \n\n * 安装 cz-conventional-changelog，并且初始化 cz-conventional-changelog：\n   \n   npx commitizen init cz-conventional-changelog --save-dev --save-exact\n   \n   \n   1\n   \n   \n   这个命令会帮助我们安装 cz-conventional-changelog：\n   \n   \n   \n   并且在 package.json 中进行配置：\n   \n   "config": {\n     "commitizen": {\n       "path": "./node_mudules/cz-conventional-changelog"\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n配置完 Commitizen 后，提交代码需要使用 npx cz ：\n\n * 选择 type：\n\nTYPE       作用\nfeat       新增特性 (feature)\nfix        修复 Bug (bug fix)\ndocs       修改文档 (documentation)\nstyle      代码格式修改 (white-space, formatting, missing semi colons, etc)\nrefactor   代码重构 (refactor)\nperf       改善性能 (A code change that improves performance)\ntest       测试 (when adding missing tests)\nbuild      变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）\nci         更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis,\n           Circle 等\nchore      变更构建流程或辅助工具 (比如更改测试环境)\nrevert     代码回退\n\n点击查看\n * 第二步选择本次修改的范围（作用域）\n\n\n\n * 第三步选择提交的信息\n\n\n\n * 第四步提交详细的描述信息\n\n\n\n * 第五步是否是一次重大的更改\n\n\n\n * 第六步是否影响某个 open issue\n\n\n\n我们也可以在 scripts 中构建一个命令来执行 cz：\n\n\n\n# 代码提交验证\n\n如果我们按照 cz 来规范了提交风格，但是依然有同事通过 git commit 按照不规范的格式提交应该怎么办呢？\n\n * 我们可以通过 commitlint 来限制提交；\n\n安装 @commitlint/config-conventional 和 @commitlint/cli\n\nnpm i @commitlint/config-conventional @commitlint/cli -D\n\n\n1\n\n\n在根目录创建 commitlint.config.js 文件，配置 commitlint\n\nmodule.exports = {\n  extends: [\'@commitlint/config-conventional\']\n}\n\n\n1\n2\n3\n\n\n使用 husky 生成 commit-msg 文件，验证提交信息：\n\nnpx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"\n\n\n1\n\n\n（拦截提交）\n\n\n# 第三方库集成\n\n\n# vue.config.js 配置\n\nvue.config.js 有三种配置方式：\n\n * 方式一：直接通过 CLI 提供给我们的选项来配置：\n   * 比如 publicPath：配置应用程序部署的子目录（默认是 / ，相当于部署在 https://www.my-app.com/ ）；\n   * 比如 outputDir：修改输出的文件夹；\n * 方式二：通过 configureWebpack 修改 webpack 的配置：\n   * 可以是一个对象，直接会被合并；\n   * 可以是一个函数，会接收一个 config，可以通过 config 来修改配置；\n * 方式三：通过 chainWebpack 修改 webpack 的配置：\n   * 是一个函数，会接收一个基于 webpack-chain 的 config 对象，可以对配置进行修改；\n\n\n# vue-router 集成\n\n安装 vue-router 的最新版本：\n\nnpm install vue-router@next\n\n\n1\n\n\n创建 router 对象（ router/main.js ）：\n\nimport { createRouter, createWebHashHistory } from \'vue-router\'\nimport { RouteRecordRaw } from \'vue-router\' // 约束routes的类型\n\nconst routes: RouteRecordRaw[] = [\n  {\n    path: \'/\',\n    redirect: \'/main\'\n  },\n  {\n    path: \'/main\',\n    component: () => import(\'../views/main/main.vue\')\n  },\n  {\n    path: \'/login\',\n    component: () => import(\'../views/login/login.vue\')\n  }\n]\n\nconst router = createRouter({\n  routes,\n  history: createWebHashHistory()\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n安装 router（ main.ts ）：\n\nimport router from \'./router\'\n\ncreateApp(App).use(router).mount(\'#app\')\n\n\n1\n2\n3\n\n\n在 App.vue 中配置跳转：\n\n<template>\n  <div id="app">\n    <router-link to="/login">登录</router-link>\n    <router-link to="/main">首页</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# vuex 集成\n\n安装最新版 vuex：\n\nnpm install vuex@next\n\n\n1\n\n\n创建 store 对象：\n\nimport { createStore } from \'vuex\'\n\nconst store = createStore({\n  state() {\n    return {\n      name: \'coderwhy\'\n    }\n  }\n})\n\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n安装 store：\n\ncreateApp(App).use(router).use(store).mount(\'#app\')\n\n\n1\n\n\n在 App.vue 中使用：\n\n<h2>{{ $store.state.name }}</h2>\n\n\n1\n\n\n\n# element-plus 集成\n\nElement Plus，桌面端组件库\n\n * 相信很多同学在 Vue2 中都使用过 element-ui，而 element-plus 正是 element-ui 针对于 Vue3 开发的一个 UI 组件库；\n * 它的使用方式和很多其他的组件库是一样的，所以学会 element-plus，其他类似于 ant-design-vue、NaiveUI、VantUI 都是差不多的；\n\n安装 element-plus\n\n$ npm install element-plus\n\n\n1\n\n\n# 全局引入\n\n一种引入 element-plus 的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：\n\nimport ElementPlus from \'element-plus\'\nimport \'element-plus/lib/theme-chalk/index.css\'\n\nimport router from \'./router\'\nimport store from \'./store\'\n\ncreateApp(App).use(router).use(store).use(ElementPlus).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 局部引入\n\n使用 unplugin-vue-components 实现按需引入：\n\n * 安装 unplugin-vue-components ：\n\nnpm i unplugin-vue-components unplugin-auto-import -D\n\n\n1\n\n\n * vue.config.js （这里是 Vue-CLI s 配置方法，其他脚手架需要参考文档）\n   \n   const AutoImport = require(\'unplugin-auto-import/webpack\')\n   const Components = require(\'unplugin-vue-components/webpack\')\n   const { ElementPlusResolver } = require(\'unplugin-vue-components/resolvers\')\n   \n   module.exports = {\n       configureWebpack: {\n         plugins: [\n           AutoImport({\n             resolvers: [ElementPlusResolver()],\n           }),\n           Components({\n             resolvers: [ElementPlusResolver()],\n           }),\n         ],\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * 然后在 main.ts 全局注册组件：\n   \n   import {\n     ElButton,\n     ElTable,\n     ElAlert,\n     ElAside,\n     ElAutocomplete,\n     ElAvatar,\n     ElBacktop,\n     ElBadge,\n   } from \'element-plus\'\n   import \'element-plus/dist/index.css\'\n   \n   const app = createApp(App)\n   \n   const components = [\n     ElButton,\n     ElTable,\n     ElAlert,\n     ElAside,\n     ElAutocomplete,\n     ElAvatar,\n     ElBacktop,\n     ElBadge\n   ]\n   \n   for (const cpn of components) {\n     app.component(cpn.name, cpn)\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\nfrom: 实现自动引入 + 按需引入 element-plus 原来如此简单 - SegmentFault 思否\n\n（在非 <template> 中使用组件仍然需要手动引入）\n\n（最新引入还是得看官方文档，特别是引入 CSS 包，一旦找不到样式就没有效果。找 bug 都快怀疑人生了）\n\n点击查看\n * 安装 webpack-bundle-analyzer 看打包信息：\n\n$ npm install --save-dev webpack-bundle-analyzer\n\n\n1\n\n\nnpm run build --report\n\n\n1\n\n\n不用做任何配置，就可以看到终端打印出来打包后各文件大小。\n\n如果想看详细的打包后文件的信息，可以在 vue.config.js 中做如下配置：\n\nconst BundleAnalyzerPlugin = require(\'webpack-bundle-analyzer\').BundleAnalyzerPlugin;\n\nmodule.exports = {\n    configureWebpack: {\n        plugins: [\n            new BundleAnalyzerPlugin()\n        ]\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后打开地址 http://127.0.0.1:8888 就可以了。\n据我个人测试，完整引入时，打包后 chunk.js 文件大小为 400k 左右。按需引入后，打包后 chunk.js 文件大小为 200k 左右。\n\n附加内容：Vue-CLI 环境变量\n\n\n# axios 集成\n\n安装 axios：\n\nnpm install axios\n\n\n1\n\n\n封装 axios：\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from \'axios\'\nimport { Result } from \'./types\'\nimport { useUserStore } from \'/@/store/modules/user\'\n\nclass HYRequest {\n  private instance: AxiosInstance\n\n  private readonly options: AxiosRequestConfig\n\n  constructor(options: AxiosRequestConfig) {\n    this.options = options\n    this.instance = axios.create(options)\n\n    this.instance.interceptors.request.use(\n      (config) => {\n        const token = useUserStore().getToken\n        if (token) {\n          config.headers.Authorization = `Bearer ${token}`\n        }\n        return config\n      },\n      (err) => {\n        return err\n      }\n    )\n\n    this.instance.interceptors.response.use(\n      (res) => {\n        // 拦截响应的数据\n        if (res.data.code === 0) {\n          return res.data.data\n        }\n        return res.data\n      },\n      (err) => {\n        return err\n      }\n    )\n  }\n\n  request<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.instance\n        .request<any, AxiosResponse<Result<T>>>(config)\n        .then((res) => {\n          resolve((res as unknown) as Promise<T>)\n        })\n        .catch((err) => {\n          reject(err)\n        })\n    })\n  }\n\n  get<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'GET\' })\n  }\n\n  post<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'POST\' })\n  }\n\n  patch<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'PATCH\' })\n  }\n\n  delete<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'DELETE\' })\n  }\n}\n\nexport default HYRequest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n# tsconfig.json\n\ntsconfig.json・TypeScript 中文网・TypeScript——JavaScript 的超集 (tslang.cn)\n\n{\n  // 编译配置\n  "compilerOptions": {\n    // 目标代码\n    "target": "esnext",\n    // 目标代码要使用的模块化方案\n    "module": "esnext",\n    // 开启严格模式\n    "strict": true,\n    // jsx进行怎样的处理\n    "jsx": "preserve",\n    // 辅助导入功能\n    "importHelpers": true,\n    // 按照node解析模块\n    "moduleResolution": "node",\n    // 跳过一些第三方库的类型监测（axios/loadash）\n    "skipLibCheck": true,\n    // esModule和commonJS混合使用\n    // export defalt / module.exports = {}\n    "esModuleInterop": true,\n    "allowSyntheticDefaultImports": true,\n    // 生成映射文件 （ts=>js）\n    "sourceMap": true,\n\t\t// 文件路径解析时基本路径\n    "baseUrl": ".",\n    // 指定具体要解析使用的类型 webpack\n    "types": ["webpack-env"],\n    // 路径解析匹配（类似webpack alias）\n    "paths": {\n      "@/*": ["src/*"]\n    },\n    // 可以指定在项目中可以使用哪些库的类型(Proxy/window/Document)\n    "lib": ["esnext", "dom", "dom.iterable", "scripthost"]\n  },\n  // 要解析的文件后缀名\n  "include": [\n    "src/**/*.ts",\n    "src/**/*.tsx",\n    "src/**/*.vue",\n    "tests/**/*.ts",\n    "tests/**/*.tsx"\n  ],\n  // 排除的文件\n  "exclude": ["node_modules"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# shims-vue.d.ts\n\n类型声明：\n\n/* eslint-disable */\ndeclare module \'*.vue\' {\n  import type { DefineComponent } from \'vue\'\n  const component: DefineComponent<{}, {}, any>\n  export default component\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 规范、限制组件中配置传入的类型。 preps 、 setup() …。',normalizedContent:'# vue 3 创建项目\n\nvue create project-name\n\n\n1\n\n\n创建 vue 脚手架时选择的 featue：\n\n * babel\n * typescript\n * vuex\n * css 预处理器\n * 语法检查\n\n\n# 代码规范\n\n\n# .editorconfig 配置\n\neditorconfig 有助于为不同 ide 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n\n# http://editorconfig.org\n\nroot = true\n\n[*] # 表示所有文件适用\ncharset = utf-8 # 设置文件字符集为 utf-8\nindent_style = space # 缩进风格（tab | space）\nindent_size = 2 # 缩进大小\nend_of_line = lf # 控制换行类型(lf | cr | crlf)\ntrim_trailing_whitespace = true # 去除行首的任意空白字符\ninsert_final_newline = true # 始终在文件末尾插入一个新行\n\n[*.md] # 表示仅 md 文件适用以下规则\nmax_line_length = off\ntrim_trailing_whitespace = false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# prettier 工具\n\n> prettier 是一款强大的代码格式化工具，支持 javascript、typescript、css、scss、less、jsx、angular、vue、graphql、json、markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n\n * 安装 prettier\n\nnpm install prettier -d\n\n\n1\n\n\n * 配置 .prettierrc 文件：\n   \n   * usetabs ：使用 tab 缩进还是空格缩进，选择 false；\n   \n   * tabwidth ：tab 是空格的情况下，是几个空格，选择 2 个；\n   \n   * printwidth ：当行字符的长度，推荐 80，也有人喜欢 100 或者 120；\n   \n   * singlequote ：使用单引号还是双引号，选择 true ，使用单引号；\n   \n   * trailingcomma ：在多行输入的尾逗号是否添加，设置为 none ；\n   \n   * semi ：语句末尾是否要加分号，默认值 true ，选择 false 表示不加；\n\n{\n  "usetabs": false,\n  "tabwidth": 2,\n  "printwidth": 80,\n  "singlequote": true,\n  "trailingcomma": "none",\n  "semi": false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 创建 .prettierignore 忽略文件：\n\n/dist/*\n.local\n.output.js\n/node_modules/**\n\n**/*.svg\n**/*.sh\n\n/public/*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 测试 prettier 是否生效\n   \n   * 测试一：在代码中保存代码；\n   \n   * 测试二：配置一次性修改的命令；\n\n在 package.json 中配置一个 scripts ：\n\n    "prettier": "prettier --write ."\n\n\n1\n\n\n\n# 使用 eslint 检测代码规范\n\n在前面创建项目的时候，就选择了 eslint ，所以 vue 会默认帮助我们配置需要的 eslint 环境。\n\n * 解决 eslint 和 prettier 冲突的问题：\n * 安装插件：（vue 在创建项目时，如果选择 prettier + eslint，那么这两个插件会自动安装）\n\nnpm i eslint-plugin-prettier eslint-config-prettier -d\n\n\n1\n\n\n在 eslintrc.js 中添加 prettier 插件：\n\n  extends: [\n    "plugin:vue/vue3-essential",\n    "eslint:recommended",\n    "@vue/typescript/recommended",\n    "@vue/prettier",\n    "@vue/prettier/@typescript-eslint",\n    \'plugin:prettier/recommended\' // 添加\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# before commit 代码规范 /husky 使用\n\n虽然我们已经要求项目使用 eslint 了，但是不能保证组员提交代码之前都将 eslint 中的问题解决掉了：\n\n * 也就是我们希望保证代码仓库中的代码都是符合 eslint 规范的；\n\n * 那么我们需要在组员执行 git commit 命令的时候对其进行校验，如果不符合 eslint 规范，那么自动通过规范进行修复；\n\n那么如何做到这一点呢？可以通过 husky 工具：\n\n * husky 是一个 git hook 工具，可以帮助我们触发 git 提交的各个阶段：pre-commit、commit-msg、pre-push。\n\n这里我们可以使用自动配置命令：\n\nnpx husky-init && npm install\n\n\n1\n\n\n\n\n点击查看\n\n这里会做三件事：\n\n * 安装 husky 相关的依赖：\n\n\n\n * 在项目目录下创建 .husky 文件夹：\n\nnpx huksy install\n\n\n1\n\n\n\n\n * 在 package.json 中添加一个脚本：\n\n\n\n接下来，我们需要去完成一个操作：在进行 commit 时，执行 lint 脚本：\n\n\n\n这个时候我们执行 git commit 的时候会自动对代码进行 lint 校验。\n\n\n# git commit 规范\n\n# 代码提交风格\n\n通常我们的 git commit 会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。\n\n但是如果每次手动来编写这些是比较麻烦的事情，可以使用一个工具：commitizen（commitizen 是一个帮助我们编写规范 commit message 的工具）。\n\n * 安装 commitizen\n   \n   npm install commitizen -d\n   \n   \n   1\n   \n\n * 安装 cz-conventional-changelog，并且初始化 cz-conventional-changelog：\n   \n   npx commitizen init cz-conventional-changelog --save-dev --save-exact\n   \n   \n   1\n   \n   \n   这个命令会帮助我们安装 cz-conventional-changelog：\n   \n   \n   \n   并且在 package.json 中进行配置：\n   \n   "config": {\n     "commitizen": {\n       "path": "./node_mudules/cz-conventional-changelog"\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n配置完 commitizen 后，提交代码需要使用 npx cz ：\n\n * 选择 type：\n\ntype       作用\nfeat       新增特性 (feature)\nfix        修复 bug (bug fix)\ndocs       修改文档 (documentation)\nstyle      代码格式修改 (white-space, formatting, missing semi colons, etc)\nrefactor   代码重构 (refactor)\nperf       改善性能 (a code change that improves performance)\ntest       测试 (when adding missing tests)\nbuild      变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）\nci         更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: travis,\n           circle 等\nchore      变更构建流程或辅助工具 (比如更改测试环境)\nrevert     代码回退\n\n点击查看\n * 第二步选择本次修改的范围（作用域）\n\n\n\n * 第三步选择提交的信息\n\n\n\n * 第四步提交详细的描述信息\n\n\n\n * 第五步是否是一次重大的更改\n\n\n\n * 第六步是否影响某个 open issue\n\n\n\n我们也可以在 scripts 中构建一个命令来执行 cz：\n\n\n\n# 代码提交验证\n\n如果我们按照 cz 来规范了提交风格，但是依然有同事通过 git commit 按照不规范的格式提交应该怎么办呢？\n\n * 我们可以通过 commitlint 来限制提交；\n\n安装 @commitlint/config-conventional 和 @commitlint/cli\n\nnpm i @commitlint/config-conventional @commitlint/cli -d\n\n\n1\n\n\n在根目录创建 commitlint.config.js 文件，配置 commitlint\n\nmodule.exports = {\n  extends: [\'@commitlint/config-conventional\']\n}\n\n\n1\n2\n3\n\n\n使用 husky 生成 commit-msg 文件，验证提交信息：\n\nnpx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"\n\n\n1\n\n\n（拦截提交）\n\n\n# 第三方库集成\n\n\n# vue.config.js 配置\n\nvue.config.js 有三种配置方式：\n\n * 方式一：直接通过 cli 提供给我们的选项来配置：\n   * 比如 publicpath：配置应用程序部署的子目录（默认是 / ，相当于部署在 https://www.my-app.com/ ）；\n   * 比如 outputdir：修改输出的文件夹；\n * 方式二：通过 configurewebpack 修改 webpack 的配置：\n   * 可以是一个对象，直接会被合并；\n   * 可以是一个函数，会接收一个 config，可以通过 config 来修改配置；\n * 方式三：通过 chainwebpack 修改 webpack 的配置：\n   * 是一个函数，会接收一个基于 webpack-chain 的 config 对象，可以对配置进行修改；\n\n\n# vue-router 集成\n\n安装 vue-router 的最新版本：\n\nnpm install vue-router@next\n\n\n1\n\n\n创建 router 对象（ router/main.js ）：\n\nimport { createrouter, createwebhashhistory } from \'vue-router\'\nimport { routerecordraw } from \'vue-router\' // 约束routes的类型\n\nconst routes: routerecordraw[] = [\n  {\n    path: \'/\',\n    redirect: \'/main\'\n  },\n  {\n    path: \'/main\',\n    component: () => import(\'../views/main/main.vue\')\n  },\n  {\n    path: \'/login\',\n    component: () => import(\'../views/login/login.vue\')\n  }\n]\n\nconst router = createrouter({\n  routes,\n  history: createwebhashhistory()\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n安装 router（ main.ts ）：\n\nimport router from \'./router\'\n\ncreateapp(app).use(router).mount(\'#app\')\n\n\n1\n2\n3\n\n\n在 app.vue 中配置跳转：\n\n<template>\n  <div id="app">\n    <router-link to="/login">登录</router-link>\n    <router-link to="/main">首页</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# vuex 集成\n\n安装最新版 vuex：\n\nnpm install vuex@next\n\n\n1\n\n\n创建 store 对象：\n\nimport { createstore } from \'vuex\'\n\nconst store = createstore({\n  state() {\n    return {\n      name: \'coderwhy\'\n    }\n  }\n})\n\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n安装 store：\n\ncreateapp(app).use(router).use(store).mount(\'#app\')\n\n\n1\n\n\n在 app.vue 中使用：\n\n<h2>{{ $store.state.name }}</h2>\n\n\n1\n\n\n\n# element-plus 集成\n\nelement plus，桌面端组件库\n\n * 相信很多同学在 vue2 中都使用过 element-ui，而 element-plus 正是 element-ui 针对于 vue3 开发的一个 ui 组件库；\n * 它的使用方式和很多其他的组件库是一样的，所以学会 element-plus，其他类似于 ant-design-vue、naiveui、vantui 都是差不多的；\n\n安装 element-plus\n\n$ npm install element-plus\n\n\n1\n\n\n# 全局引入\n\n一种引入 element-plus 的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：\n\nimport elementplus from \'element-plus\'\nimport \'element-plus/lib/theme-chalk/index.css\'\n\nimport router from \'./router\'\nimport store from \'./store\'\n\ncreateapp(app).use(router).use(store).use(elementplus).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 局部引入\n\n使用 unplugin-vue-components 实现按需引入：\n\n * 安装 unplugin-vue-components ：\n\nnpm i unplugin-vue-components unplugin-auto-import -d\n\n\n1\n\n\n * vue.config.js （这里是 vue-cli s 配置方法，其他脚手架需要参考文档）\n   \n   const autoimport = require(\'unplugin-auto-import/webpack\')\n   const components = require(\'unplugin-vue-components/webpack\')\n   const { elementplusresolver } = require(\'unplugin-vue-components/resolvers\')\n   \n   module.exports = {\n       configurewebpack: {\n         plugins: [\n           autoimport({\n             resolvers: [elementplusresolver()],\n           }),\n           components({\n             resolvers: [elementplusresolver()],\n           }),\n         ],\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * 然后在 main.ts 全局注册组件：\n   \n   import {\n     elbutton,\n     eltable,\n     elalert,\n     elaside,\n     elautocomplete,\n     elavatar,\n     elbacktop,\n     elbadge,\n   } from \'element-plus\'\n   import \'element-plus/dist/index.css\'\n   \n   const app = createapp(app)\n   \n   const components = [\n     elbutton,\n     eltable,\n     elalert,\n     elaside,\n     elautocomplete,\n     elavatar,\n     elbacktop,\n     elbadge\n   ]\n   \n   for (const cpn of components) {\n     app.component(cpn.name, cpn)\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\nfrom: 实现自动引入 + 按需引入 element-plus 原来如此简单 - segmentfault 思否\n\n（在非 <template> 中使用组件仍然需要手动引入）\n\n（最新引入还是得看官方文档，特别是引入 css 包，一旦找不到样式就没有效果。找 bug 都快怀疑人生了）\n\n点击查看\n * 安装 webpack-bundle-analyzer 看打包信息：\n\n$ npm install --save-dev webpack-bundle-analyzer\n\n\n1\n\n\nnpm run build --report\n\n\n1\n\n\n不用做任何配置，就可以看到终端打印出来打包后各文件大小。\n\n如果想看详细的打包后文件的信息，可以在 vue.config.js 中做如下配置：\n\nconst bundleanalyzerplugin = require(\'webpack-bundle-analyzer\').bundleanalyzerplugin;\n\nmodule.exports = {\n    configurewebpack: {\n        plugins: [\n            new bundleanalyzerplugin()\n        ]\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后打开地址 http://127.0.0.1:8888 就可以了。\n据我个人测试，完整引入时，打包后 chunk.js 文件大小为 400k 左右。按需引入后，打包后 chunk.js 文件大小为 200k 左右。\n\n附加内容：vue-cli 环境变量\n\n\n# axios 集成\n\n安装 axios：\n\nnpm install axios\n\n\n1\n\n\n封装 axios：\n\nimport axios, { axiosinstance, axiosrequestconfig, axiosresponse } from \'axios\'\nimport { result } from \'./types\'\nimport { useuserstore } from \'/@/store/modules/user\'\n\nclass hyrequest {\n  private instance: axiosinstance\n\n  private readonly options: axiosrequestconfig\n\n  constructor(options: axiosrequestconfig) {\n    this.options = options\n    this.instance = axios.create(options)\n\n    this.instance.interceptors.request.use(\n      (config) => {\n        const token = useuserstore().gettoken\n        if (token) {\n          config.headers.authorization = `bearer ${token}`\n        }\n        return config\n      },\n      (err) => {\n        return err\n      }\n    )\n\n    this.instance.interceptors.response.use(\n      (res) => {\n        // 拦截响应的数据\n        if (res.data.code === 0) {\n          return res.data.data\n        }\n        return res.data\n      },\n      (err) => {\n        return err\n      }\n    )\n  }\n\n  request<t = any>(config: axiosrequestconfig): promise<t> {\n    return new promise((resolve, reject) => {\n      this.instance\n        .request<any, axiosresponse<result<t>>>(config)\n        .then((res) => {\n          resolve((res as unknown) as promise<t>)\n        })\n        .catch((err) => {\n          reject(err)\n        })\n    })\n  }\n\n  get<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'get\' })\n  }\n\n  post<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'post\' })\n  }\n\n  patch<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'patch\' })\n  }\n\n  delete<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'delete\' })\n  }\n}\n\nexport default hyrequest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n# tsconfig.json\n\ntsconfig.json・typescript 中文网・typescript——javascript 的超集 (tslang.cn)\n\n{\n  // 编译配置\n  "compileroptions": {\n    // 目标代码\n    "target": "esnext",\n    // 目标代码要使用的模块化方案\n    "module": "esnext",\n    // 开启严格模式\n    "strict": true,\n    // jsx进行怎样的处理\n    "jsx": "preserve",\n    // 辅助导入功能\n    "importhelpers": true,\n    // 按照node解析模块\n    "moduleresolution": "node",\n    // 跳过一些第三方库的类型监测（axios/loadash）\n    "skiplibcheck": true,\n    // esmodule和commonjs混合使用\n    // export defalt / module.exports = {}\n    "esmoduleinterop": true,\n    "allowsyntheticdefaultimports": true,\n    // 生成映射文件 （ts=>js）\n    "sourcemap": true,\n\t\t// 文件路径解析时基本路径\n    "baseurl": ".",\n    // 指定具体要解析使用的类型 webpack\n    "types": ["webpack-env"],\n    // 路径解析匹配（类似webpack alias）\n    "paths": {\n      "@/*": ["src/*"]\n    },\n    // 可以指定在项目中可以使用哪些库的类型(proxy/window/document)\n    "lib": ["esnext", "dom", "dom.iterable", "scripthost"]\n  },\n  // 要解析的文件后缀名\n  "include": [\n    "src/**/*.ts",\n    "src/**/*.tsx",\n    "src/**/*.vue",\n    "tests/**/*.ts",\n    "tests/**/*.tsx"\n  ],\n  // 排除的文件\n  "exclude": ["node_modules"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# shims-vue.d.ts\n\n类型声明：\n\n/* eslint-disable */\ndeclare module \'*.vue\' {\n  import type { definecomponent } from \'vue\'\n  const component: definecomponent<{}, {}, any>\n  export default component\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 规范、限制组件中配置传入的类型。 preps 、 setup() …。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌨 Vue 的基本使用",frontmatter:{title:"🌨 Vue 的基本使用",date:"2022-03-11T15:51:45.000Z",permalink:"/pages/85a3ba/",categories:["📚 前端笔记","🏃 核心部分","🌧️ Vuejs"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/01.%20%F0%9F%8C%A8%20Vue%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/01. 🌨 Vue 的基本使用.md",key:"v-72be4f88",path:"/pages/85a3ba/",headers:[{level:2,title:"基础学习中使用 Vue",slug:"基础学习中使用-vue",normalizedTitle:"基础学习中使用 vue",charIndex:494},{level:3,title:"使用 Vue 工作步骤",slug:"使用-vue-工作步骤",normalizedTitle:"使用 vue 工作步骤",charIndex:1360}],headersStr:"基础学习中使用 Vue 使用 Vue 工作步骤",content:"🔗 相关链接：\n\n * 📁 官方文档：Vue.js (vuejs.org)\n   * 🇨🇳 中文文档：Vue.js (vuejs.org)\n\n🚠 实例代码仓库：https://github.com/simon1uo/vue-notes\n\nVue 是一个动态构建用户界面的渐进式 JavaScript 框架；\n\n> 相关概念：\n> \n>  * 渐进式： 自底向上逐层的应用；\n> \n>  * 简单应用：只需要轻量小巧的核心库；\n> \n>  * 复杂应用：可引入各式各样的 Vue 插件；\n\n特点：\n\n * 遵循组件化模式，提高代码的复用率、更好维护；\n\n * 声明式编码，无需操作 DOM，提高开发效率；（非命令式编码）\n\n * 使用虚拟 DOM + Diff 算法，尽量复用 DOM 节点；\n\n * 编码简洁、体积小、运行效率高，适合移动 / PC 端开发；\n\n * 只关注 UI, 也可以引入其它第三方库开发项目；\n   \n   其他 JS 框架的关联：\n\n * 借鉴 Angular 的模板和数据绑定技术；\n\n * 借鉴 React 的组件化和虚拟 DOM 技术；\n\n\n# 基础学习中使用 Vue\n\n * 为了在学习过程中得到警告提示，使用开发版本的 Vue.js:\n   \n   在文档中引入 vue.js ：\n   \n   <script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"><\/script>\n   \n   \n   1\n   \n   \n   > 此处引入的是 cdn 的 Vue 2 开发环境版本。生产环境版本可以替换为 https://cdn.jsdelivr.net/npm/vue@2 （优化尺寸和速度）\n\n * 安装浏览器拓展 🔗 Vue Devtools\n\n * （可选项） 关闭生产环境提示：\n   \n   Vue.config.producitonTip = false;\n   \n   \n   1\n   \n\n🌰 第一个 Vue 页面：\n\n<body>\n    \x3c!-- 1. 准备容器 --\x3e\n    <div id=\"app\">\n        <h1> hello, {{name}}, {{age}}</h1> \n    </div>\n    <script>\n        Vue.config.producitonTip = false;\n        // 创建一个Vue实例\n        const x = new Vue({\n            el: '#app',\n            data: {\n                name: 'simon',\n                age: '1',\n            }   \n        });\n    <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n>  * el 指定当前 Vue 实例为哪个容器服务，通常为 CSS 选择器；\n>  * data 存储数据；\n\n\n# 使用 Vue 工作步骤\n\n 1. 创建 Vue 实例，传入一个配置对象；\n 2. 准备一个容器，内可使用特殊的 Vue 语法（如 {{}} 引用数据）；\n 3. 容器内的代码被称为 Vue 模版；\n\n提示\n\n注意：\n\n * 一个实例只能为一个容器服务，多个实例不能接管同一个容器 —— 容器与实例一对一；\n * 真实开发中只有一个 Vue 实例，并且会配合着组件一起使用；\n * {variable} 中的 xx 要写 JavaScript 表达式，且 variable 可以自动读取到 data 中的所有属性；\n * 一旦 data 中的数据发生改变，那么模板中用到该数据的地方也会自动更新；",normalizedContent:"🔗 相关链接：\n\n * 📁 官方文档：vue.js (vuejs.org)\n   * 🇨🇳 中文文档：vue.js (vuejs.org)\n\n🚠 实例代码仓库：https://github.com/simon1uo/vue-notes\n\nvue 是一个动态构建用户界面的渐进式 javascript 框架；\n\n> 相关概念：\n> \n>  * 渐进式： 自底向上逐层的应用；\n> \n>  * 简单应用：只需要轻量小巧的核心库；\n> \n>  * 复杂应用：可引入各式各样的 vue 插件；\n\n特点：\n\n * 遵循组件化模式，提高代码的复用率、更好维护；\n\n * 声明式编码，无需操作 dom，提高开发效率；（非命令式编码）\n\n * 使用虚拟 dom + diff 算法，尽量复用 dom 节点；\n\n * 编码简洁、体积小、运行效率高，适合移动 / pc 端开发；\n\n * 只关注 ui, 也可以引入其它第三方库开发项目；\n   \n   其他 js 框架的关联：\n\n * 借鉴 angular 的模板和数据绑定技术；\n\n * 借鉴 react 的组件化和虚拟 dom 技术；\n\n\n# 基础学习中使用 vue\n\n * 为了在学习过程中得到警告提示，使用开发版本的 vue.js:\n   \n   在文档中引入 vue.js ：\n   \n   <script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"><\/script>\n   \n   \n   1\n   \n   \n   > 此处引入的是 cdn 的 vue 2 开发环境版本。生产环境版本可以替换为 https://cdn.jsdelivr.net/npm/vue@2 （优化尺寸和速度）\n\n * 安装浏览器拓展 🔗 vue devtools\n\n * （可选项） 关闭生产环境提示：\n   \n   vue.config.producitontip = false;\n   \n   \n   1\n   \n\n🌰 第一个 vue 页面：\n\n<body>\n    \x3c!-- 1. 准备容器 --\x3e\n    <div id=\"app\">\n        <h1> hello, {{name}}, {{age}}</h1> \n    </div>\n    <script>\n        vue.config.producitontip = false;\n        // 创建一个vue实例\n        const x = new vue({\n            el: '#app',\n            data: {\n                name: 'simon',\n                age: '1',\n            }   \n        });\n    <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n>  * el 指定当前 vue 实例为哪个容器服务，通常为 css 选择器；\n>  * data 存储数据；\n\n\n# 使用 vue 工作步骤\n\n 1. 创建 vue 实例，传入一个配置对象；\n 2. 准备一个容器，内可使用特殊的 vue 语法（如 {{}} 引用数据）；\n 3. 容器内的代码被称为 vue 模版；\n\n提示\n\n注意：\n\n * 一个实例只能为一个容器服务，多个实例不能接管同一个容器 —— 容器与实例一对一；\n * 真实开发中只有一个 vue 实例，并且会配合着组件一起使用；\n * {variable} 中的 xx 要写 javascript 表达式，且 variable 可以自动读取到 data 中的所有属性；\n * 一旦 data 中的数据发生改变，那么模板中用到该数据的地方也会自动更新；",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌕 Vue 模版语法",frontmatter:{title:"🌕 Vue 模版语法",date:"2022-03-11T15:53:27.000Z",permalink:"/pages/c0d42b/",categories:["📚 前端笔记","🏃 核心部分","🌧️ Vuejs"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/02.%20%F0%9F%8C%95%20Vue%20%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/02. 🌕 Vue 模版语法.md",key:"v-bbee9aae",path:"/pages/c0d42b/",headers:[{level:2,title:"插值语法",slug:"插值语法",normalizedTitle:"插值语法",charIndex:190},{level:3,title:"双大括号插值",slug:"双大括号插值",normalizedTitle:"双大括号插值",charIndex:199},{level:3,title:"v-html",slug:"v-html",normalizedTitle:"v-html",charIndex:776},{level:3,title:"v-bind:*",slug:"v-bind",normalizedTitle:"v-bind:*",charIndex:970},{level:2,title:"指令语法 v-*",slug:"指令语法-v",normalizedTitle:"指令语法 v-*",charIndex:1401},{level:2,title:"数据绑定",slug:"数据绑定",normalizedTitle:"数据绑定",charIndex:208},{level:3,title:"单向数据绑定",slug:"单向数据绑定",normalizedTitle:"单向数据绑定",charIndex:1563},{level:3,title:"双向数据绑定",slug:"双向数据绑定",normalizedTitle:"双向数据绑定",charIndex:1633}],headersStr:"插值语法 双大括号插值 v-html v-bind:* 指令语法 v-* 数据绑定 单向数据绑定 双向数据绑定",content:"Vue.js 使用了基于 HTML 的模版语法，可以声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模版都是合法的 HTML 语法，能够被遵循规范的浏览器和 HTML 解析器解析。\n\n> 底层的实现上，Vue 将模版编译称虚拟的 DOM 渲染函数，结合响应系统，Vue 能够智能地计算出最少需要渲染多少组件，并且把 DOM 操作次数减少到最少。\n\n\n# 插值语法\n\n\n# 双大括号插值\n\n是数据绑定最常见的形式，使用 双大括号 进行文本插值。\n\n * 功能： 用于解析标签体的内容（指定标签体的内容）；\n\n * 语法： 如下：\n   \n   <span>Message: {{ msg }}</span>\n   \n   \n   1\n   \n   \n   > 双大括号中的内容需要是 JavaScript 表达式。\n   \n   > 区分 JavaScript 表达式 和 JavaScript 代码（语句）：\n   > \n   >  * 表达式：会产生一个值，放在需要使用值的地方；（可以讲表达式看作是特殊的 JavaScript 语句（代码））\n   >    * a\n   >    * a+b\n   >    * demo()\n   >    * x === y ? ’a’ : ’b’\n   >  * 代码（语句）：\n   >    * if() { }\n   >    * for() { }\n   > \n   > 并且模版表达式都被放在一个沙盒中，只能访问 全局变量的一个白名单 例如 Math / Date 。不应该在模版表达式中试图访问用户定义的全局变量。\n\n🌰 例子 / JavaScript 表达式：\n\n{{ number + 1}}\n{{ ok ? 'Yes' : 'No'}}\n\n\n1\n2\n\n\n\n# v-html\n\n用于将 html 代码渲染成 HTML 内容。\n\n🌰 例子：\n\n<span v-html=\"rawHtml\"></span></p>\n\n\n1\n\n\n> rwaHtml 的内容为 <span style=\"color: red\">This should be red.</span> 。\n\n> 最好只对可信的内容使用 HTML 差值，否则会容易导致 XSS 攻击。\n\n\n# v-bind:*\n\nHTML 标签的特性（Attribute）并不能使用 双大括号 进行数据绑定，所以可以使用 v-bind 指令。\n\n🌰 例子：\n\n<div v-bind:id=\"dynamicId\">\n  ...\n</div>\n\n\n1\n2\n3\n\n\n🌰 例子 / 对于布尔类型的特性：\n\n<button v-bind:disabled=\"isButtonDisabled\">\n  Button\n</button>\n\n\n1\n2\n3\n\n\n> 只要 isButtonDisabled 就意味着 true 。如果 isButtonDisabled 的值为 null / undefined / false ，那么 disabled 特性不会被包含在渲染出来的 <button> 中。\n\n🌰 例子 / v-bind 使用 JavaScript 表达式：\n\n<div v-bind:id=\"'list-' + id\">\n  \n</div>\n\n\n1\n2\n3\n\n\n\n# 指令语法 v-*\n\n * 功能： 解析标签（包括：标签属性、标签体内容、绑定事件）；当表达式的值发生改变时，将其产生的连带影响，响应式的作用于 DOM。\n\n * 语法： v-bind:href='xxxx' 中的 xxxx 会作为 JavaScript 的表达式解析。\n\n\n# 数据绑定\n\n分为两种： 单向和双向；\n\n\n# 单向数据绑定\n\n语法： v-bind:href='xxx' 或者简写为 :href ；\n\n特点： 数据只能从 data 流向页面；\n\n\n# 双向数据绑定\n\n语法： v-model:value='xxx' 或者简写为 v-model='xxx' ；（默认收集 value 值）\n\n特点：数据不仅能从 data 流向页面，还可以从页面流向 data ；\n\n⚠️ 注意：双向绑定一半应用在表单类的元素（输入类）；\n\n⚠️ 补充内容： el 和 data 的另一种写法：\n\n除了上面在定义 vue 实例时同时指定容器以外，\n\n 1. 分析 vue 实例对象：\n    \n    \n    \n    $ 开头的属性和方法供我们使用。可以在原型中找到 $mount ：\n    \n    \n\n 2. 所以用 $mount(‘’) 也能指定容器：（ el 的第二种写法）\n    \n    v.$('#root');\n    \n    \n    1\n    \n    \n    适合定义 vue 实例后，在考虑置顶哪个容器使用该实例的情况。\n\n除了 data 用对象式写的方法以外，还可以使用函数式的写法：（学习组件时必须使用）\n\nnew Vue({\n  data:function() {\n\t\treturn {\n      // console.log('@@@',this)\n      name: 'simon'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n不能使用箭头函数（ this 对象会指向 window 对象），使用简写函数也可：\n\nnew Vue({\n  data(){\n    return {\n      name: 'simon'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"vue.js 使用了基于 html 的模版语法，可以声明式地将 dom 绑定至底层 vue 实例的数据。所有 vue.js 的模版都是合法的 html 语法，能够被遵循规范的浏览器和 html 解析器解析。\n\n> 底层的实现上，vue 将模版编译称虚拟的 dom 渲染函数，结合响应系统，vue 能够智能地计算出最少需要渲染多少组件，并且把 dom 操作次数减少到最少。\n\n\n# 插值语法\n\n\n# 双大括号插值\n\n是数据绑定最常见的形式，使用 双大括号 进行文本插值。\n\n * 功能： 用于解析标签体的内容（指定标签体的内容）；\n\n * 语法： 如下：\n   \n   <span>message: {{ msg }}</span>\n   \n   \n   1\n   \n   \n   > 双大括号中的内容需要是 javascript 表达式。\n   \n   > 区分 javascript 表达式 和 javascript 代码（语句）：\n   > \n   >  * 表达式：会产生一个值，放在需要使用值的地方；（可以讲表达式看作是特殊的 javascript 语句（代码））\n   >    * a\n   >    * a+b\n   >    * demo()\n   >    * x === y ? ’a’ : ’b’\n   >  * 代码（语句）：\n   >    * if() { }\n   >    * for() { }\n   > \n   > 并且模版表达式都被放在一个沙盒中，只能访问 全局变量的一个白名单 例如 math / date 。不应该在模版表达式中试图访问用户定义的全局变量。\n\n🌰 例子 / javascript 表达式：\n\n{{ number + 1}}\n{{ ok ? 'yes' : 'no'}}\n\n\n1\n2\n\n\n\n# v-html\n\n用于将 html 代码渲染成 html 内容。\n\n🌰 例子：\n\n<span v-html=\"rawhtml\"></span></p>\n\n\n1\n\n\n> rwahtml 的内容为 <span style=\"color: red\">this should be red.</span> 。\n\n> 最好只对可信的内容使用 html 差值，否则会容易导致 xss 攻击。\n\n\n# v-bind:*\n\nhtml 标签的特性（attribute）并不能使用 双大括号 进行数据绑定，所以可以使用 v-bind 指令。\n\n🌰 例子：\n\n<div v-bind:id=\"dynamicid\">\n  ...\n</div>\n\n\n1\n2\n3\n\n\n🌰 例子 / 对于布尔类型的特性：\n\n<button v-bind:disabled=\"isbuttondisabled\">\n  button\n</button>\n\n\n1\n2\n3\n\n\n> 只要 isbuttondisabled 就意味着 true 。如果 isbuttondisabled 的值为 null / undefined / false ，那么 disabled 特性不会被包含在渲染出来的 <button> 中。\n\n🌰 例子 / v-bind 使用 javascript 表达式：\n\n<div v-bind:id=\"'list-' + id\">\n  \n</div>\n\n\n1\n2\n3\n\n\n\n# 指令语法 v-*\n\n * 功能： 解析标签（包括：标签属性、标签体内容、绑定事件）；当表达式的值发生改变时，将其产生的连带影响，响应式的作用于 dom。\n\n * 语法： v-bind:href='xxxx' 中的 xxxx 会作为 javascript 的表达式解析。\n\n\n# 数据绑定\n\n分为两种： 单向和双向；\n\n\n# 单向数据绑定\n\n语法： v-bind:href='xxx' 或者简写为 :href ；\n\n特点： 数据只能从 data 流向页面；\n\n\n# 双向数据绑定\n\n语法： v-model:value='xxx' 或者简写为 v-model='xxx' ；（默认收集 value 值）\n\n特点：数据不仅能从 data 流向页面，还可以从页面流向 data ；\n\n⚠️ 注意：双向绑定一半应用在表单类的元素（输入类）；\n\n⚠️ 补充内容： el 和 data 的另一种写法：\n\n除了上面在定义 vue 实例时同时指定容器以外，\n\n 1. 分析 vue 实例对象：\n    \n    \n    \n    $ 开头的属性和方法供我们使用。可以在原型中找到 $mount ：\n    \n    \n\n 2. 所以用 $mount(‘’) 也能指定容器：（ el 的第二种写法）\n    \n    v.$('#root');\n    \n    \n    1\n    \n    \n    适合定义 vue 实例后，在考虑置顶哪个容器使用该实例的情况。\n\n除了 data 用对象式写的方法以外，还可以使用函数式的写法：（学习组件时必须使用）\n\nnew vue({\n  data:function() {\n\t\treturn {\n      // console.log('@@@',this)\n      name: 'simon'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n不能使用箭头函数（ this 对象会指向 window 对象），使用简写函数也可：\n\nnew vue({\n  data(){\n    return {\n      name: 'simon'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌔 Vue 数据绑定原理",frontmatter:{title:"🌔 Vue 数据绑定原理",date:"2022-03-11T15:55:42.000Z",permalink:"/pages/14aa98/",categories:["📚 前端笔记","🏃 核心部分","🌧️ Vuejs"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/03.%20%F0%9F%8C%94%20Vue%20%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/03. 🌔 Vue 数据绑定原理.md",key:"v-2bd5f0c1",path:"/pages/14aa98/",headers:[{level:2,title:"MVVM 模型",slug:"mvvm-模型",normalizedTitle:"mvvm 模型",charIndex:2},{level:2,title:"数据代理",slug:"数据代理",normalizedTitle:"数据代理",charIndex:179}],headersStr:"MVVM 模型 数据代理",content:"# MVVM 模型\n\n * M（Model）：对应 data 中的数据；\n * V（View）视图（模版）；\n * VM（ViewModel）：Vue 实例对象；\n\n通过测试观察：\n\n * data 中的属性最后会出现在 vm （指定的 Vue 实例对象）；\n * vm 中的所有属性以及 Vue 原型上的所有属性，在 Vue 模版中都可直接使用；\n\n\n# 数据代理\n\n通过一个对象代理对另一个对象中属性的操作（读写）；\n\nVue 中的数据代理（P13）：通过 vm 对象来代理 data 对象中属性的操作（读写）;\n\nVue 中数据代理的好处：\n\n * 更加方便的操作 data 中的数据\n\n基本原理：\n\n通过 Object.defineProperty() 把 data 对象中所有属性添加到 vm 上。 为每一个添加到 vm 上的属性，都指定一个 getter / setter 。 在 getter / setter 内部去操作（读 / 写） data 中对应的属性。\n\n",normalizedContent:"# mvvm 模型\n\n * m（model）：对应 data 中的数据；\n * v（view）视图（模版）；\n * vm（viewmodel）：vue 实例对象；\n\n通过测试观察：\n\n * data 中的属性最后会出现在 vm （指定的 vue 实例对象）；\n * vm 中的所有属性以及 vue 原型上的所有属性，在 vue 模版中都可直接使用；\n\n\n# 数据代理\n\n通过一个对象代理对另一个对象中属性的操作（读写）；\n\nvue 中的数据代理（p13）：通过 vm 对象来代理 data 对象中属性的操作（读写）;\n\nvue 中数据代理的好处：\n\n * 更加方便的操作 data 中的数据\n\n基本原理：\n\n通过 object.defineproperty() 把 data 对象中所有属性添加到 vm 上。 为每一个添加到 vm 上的属性，都指定一个 getter / setter 。 在 getter / setter 内部去操作（读 / 写） data 中对应的属性。\n\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 Vue 事件处理",frontmatter:{title:"🌗 Vue 事件处理",date:"2022-06-29T16:44:56.000Z",permalink:"/pages/9aa1bb/",categories:["🏃 前端核心框架","🌧️ Vue 基础"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/04.%20%F0%9F%8C%97%20Vue%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/04. 🌗 Vue 事件处理.md",key:"v-ee275a20",path:"/pages/9aa1bb/",headers:[{level:2,title:"事件处理",slug:"事件处理",normalizedTitle:"事件处理",charIndex:2},{level:3,title:"绑定监听",slug:"绑定监听",normalizedTitle:"绑定监听",charIndex:11},{level:3,title:"事件修饰符",slug:"事件修饰符",normalizedTitle:"事件修饰符",charIndex:424},{level:3,title:"键盘事件",slug:"键盘事件",normalizedTitle:"键盘事件",charIndex:1312},{level:3,title:"按键修饰符",slug:"按键修饰符",normalizedTitle:"按键修饰符",charIndex:1880}],headersStr:"事件处理 绑定监听 事件修饰符 键盘事件 按键修饰符",content:'# 事件处理\n\n\n# 绑定监听\n\n * 绑定事件使用： v-on:xxx=‘func’ ，可以简写为 @xxx=‘func’ 或者 @xxx=‘func($event)’ ， xxx 是事件名；\n   \n   * 默认事件形参： event ；\n   \n   * 隐含属性对象： $event ；\n\n * 事件的回调需要配置在 methods 对象中，最终会在 vm 实例对象中（配置在 data 中会被错误地进行数据代理，浪费性能）；\n   \n   * 在 methods 中配置函数不能使用箭头函数（如前所述， this 不再是 vm 而是 window ）;\n   \n   * 在 method 中配置的函数，都是被 Vue 管理的函数， this 指向 vm 或者组件实例对象；\n\n * 关于事件的传参：\n   \n   * @click=“demo” 和 @click=“demo($event)” 的效果一致，但是后者可以传参。\n\n\n# 事件修饰符\n\n⭐️ .prevent 阻止事件的默认行为（ event.preventDefault() ）；\n\n🌰 例子：\n\n<a href="https://www.atguigu.com" @click.prevent="showInfo">点我提示信息</a>\n\n\n1\n\n\n⭐️ .stop 停止事件冒泡（ event.stopPropagation() ）；\n\n🌰 例子：\n\n<div class="demo1" @click="showInfo">\n  <button @click.stop="showInfo">点我提示信息</button>\n</div>\n\n\n1\n2\n3\n\n\n⭐️ .once 事件只能触发一次：\n\n🌰 例子：\n\n<button @click.once="showInfo">点我提示信息</button>\n\n\n1\n\n\n.capture 事件的捕获模式：（不管事件的冒泡，只遵循设置的事件捕获的顺序）\n\n🌰 例子：\n\n<div class="box1" @click.capture="showMsg(1)">\n  div1\n  <div class="box2" @click="showMsg(2)">\n    div2\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n.passive 鼠标滚动滚轮 -> 触发 demo 事件 -> 完成后才进行下一步滚轮滚动：事件的默认行为立即执行，无需等待事件回调执行完毕；（多用于移动端）\n\n🌰 例子：\n\n<ul @wheel.passive="demo" class="list">\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n  <li>4</li>\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n\n\n⚠️ 事件修饰符可以连续写：（顺序不产生影响）\n\n🌰 例子：\n\n<a href="https://www.atguigu.com" @click.prevent.stop="showInfo">点我提示信息</a>\n\n\n1\n\n\n\n# 键盘事件\n\n使用 @keyup=“xxx” 或者 @keydown=“xxx” 监听键盘事件；\n\n使用按键别名监听特定的键盘按键，例如： @keyup.enter=\'xxx\' ；\n\n> Vue 中提供的常用的按键别名：回车 enter 、 删除 delete (捕获「删除」和「退格」键)、 退出 esc 、空格 space 、 换行 tab (特殊，必须配合 keydown 去使用)、上 up 、下 down 、 左 left 、 右 right ；（正确的按键名是大写开头，小写开头是按键别名）\n\nVue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case （短横线命名）（例如：对于切换大小写按键 Caps Lock 的别名为 caps-lock （极少使用））；\n\n * 系统修饰键（用法特殊）： ctrl 、 alt 、 shift 、 meta / cmd ：\n\n * 配合 keyup 使用时：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n\n * 配合 keydown 使用时：正常触发事件。\n\n * 也可以使用 keyCode 去指定具体的按键（因不统一不推荐）： Vue.config.keyCodes.自定义键名 = 键码 ，可以去定制按键别名；\n\n\n# 按键修饰符\n\n * keycode ：操作的是某个 keycode 值的键；\n * keyName ：操作的某个按键名的键（少）；',normalizedContent:'# 事件处理\n\n\n# 绑定监听\n\n * 绑定事件使用： v-on:xxx=‘func’ ，可以简写为 @xxx=‘func’ 或者 @xxx=‘func($event)’ ， xxx 是事件名；\n   \n   * 默认事件形参： event ；\n   \n   * 隐含属性对象： $event ；\n\n * 事件的回调需要配置在 methods 对象中，最终会在 vm 实例对象中（配置在 data 中会被错误地进行数据代理，浪费性能）；\n   \n   * 在 methods 中配置函数不能使用箭头函数（如前所述， this 不再是 vm 而是 window ）;\n   \n   * 在 method 中配置的函数，都是被 vue 管理的函数， this 指向 vm 或者组件实例对象；\n\n * 关于事件的传参：\n   \n   * @click=“demo” 和 @click=“demo($event)” 的效果一致，但是后者可以传参。\n\n\n# 事件修饰符\n\n⭐️ .prevent 阻止事件的默认行为（ event.preventdefault() ）；\n\n🌰 例子：\n\n<a href="https://www.atguigu.com" @click.prevent="showinfo">点我提示信息</a>\n\n\n1\n\n\n⭐️ .stop 停止事件冒泡（ event.stoppropagation() ）；\n\n🌰 例子：\n\n<div class="demo1" @click="showinfo">\n  <button @click.stop="showinfo">点我提示信息</button>\n</div>\n\n\n1\n2\n3\n\n\n⭐️ .once 事件只能触发一次：\n\n🌰 例子：\n\n<button @click.once="showinfo">点我提示信息</button>\n\n\n1\n\n\n.capture 事件的捕获模式：（不管事件的冒泡，只遵循设置的事件捕获的顺序）\n\n🌰 例子：\n\n<div class="box1" @click.capture="showmsg(1)">\n  div1\n  <div class="box2" @click="showmsg(2)">\n    div2\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n.passive 鼠标滚动滚轮 -> 触发 demo 事件 -> 完成后才进行下一步滚轮滚动：事件的默认行为立即执行，无需等待事件回调执行完毕；（多用于移动端）\n\n🌰 例子：\n\n<ul @wheel.passive="demo" class="list">\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n  <li>4</li>\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n\n\n⚠️ 事件修饰符可以连续写：（顺序不产生影响）\n\n🌰 例子：\n\n<a href="https://www.atguigu.com" @click.prevent.stop="showinfo">点我提示信息</a>\n\n\n1\n\n\n\n# 键盘事件\n\n使用 @keyup=“xxx” 或者 @keydown=“xxx” 监听键盘事件；\n\n使用按键别名监听特定的键盘按键，例如： @keyup.enter=\'xxx\' ；\n\n> vue 中提供的常用的按键别名：回车 enter 、 删除 delete (捕获「删除」和「退格」键)、 退出 esc 、空格 space 、 换行 tab (特殊，必须配合 keydown 去使用)、上 up 、下 down 、 左 left 、 右 right ；（正确的按键名是大写开头，小写开头是按键别名）\n\nvue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case （短横线命名）（例如：对于切换大小写按键 caps lock 的别名为 caps-lock （极少使用））；\n\n * 系统修饰键（用法特殊）： ctrl 、 alt 、 shift 、 meta / cmd ：\n\n * 配合 keyup 使用时：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n\n * 配合 keydown 使用时：正常触发事件。\n\n * 也可以使用 keycode 去指定具体的按键（因不统一不推荐）： vue.config.keycodes.自定义键名 = 键码 ，可以去定制按键别名；\n\n\n# 按键修饰符\n\n * keycode ：操作的是某个 keycode 值的键；\n * keyname ：操作的某个按键名的键（少）；',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌓 Vue 计算属性与侦听器 watch",frontmatter:{title:"🌓 Vue 计算属性与侦听器 watch",date:"2022-03-11T15:57:10.000Z",permalink:"/pages/c10950/",categories:["📚 前端笔记","🏃 核心部分","🌧️ Vuejs"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/05.%20%F0%9F%8C%93%20Vue%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8md.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/05. 🌓 Vue 计算属性与侦听器md.md",key:"v-9639b96e",path:"/pages/c10950/",headers:[{level:2,title:"计算属性 computed",slug:"计算属性-computed",normalizedTitle:"计算属性 computed",charIndex:2},{level:2,title:"侦听器 watch",slug:"侦听器-watch",normalizedTitle:"侦听器 watch",charIndex:1307},{level:3,title:"使用监视与计算属性对比",slug:"使用监视与计算属性对比",normalizedTitle:"使用监视与计算属性对比",charIndex:3272}],headersStr:"计算属性 computed 侦听器 watch 使用监视与计算属性对比",content:"# 计算属性 computed\n\nVue 中不推荐在模版中使用复杂的表达式，应该重构为「计算属性」或方法；（官网风格指南）\n\n要显示的「属性」不存在时，要通过「已有属性（在 Vue 下管理）」计算得到时可以使用计算属性 computed ：\n\n * 原理：底层借助了 Objcet.defineProperty() 方法提供的 getter 和 setter 。\n   \n   * get 函数什么时候执行？\n     \n     * 初次读取时会执行一次（将保存在缓存提供重复使用）；\n     * 依赖的数据发生改变时会被再次调用；\n   \n   * 与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便。\n\n * ⚠️注意：\n   \n   * 最终的计算属性会出现在 vm ，直接读取使用（会自动调用 get ）即可；\n   * 如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。\n\n * 使用方法：\n   \n   * 在 computed 对象中定义计算属性（ get() 和 set() ）；\n   * 在页面中使用 {{方法名}} 来显示计算的结果；\n   * 只读不改的简写，省略 set() 只有 get() 时，直接当计算属性的 get() ；\n\n🌰 例子：\n\n<div id=\"#app\">\n  {{ msg }}\n  {{ reversedMsg}}\n</div>\n\n\n1\n2\n3\n4\n\n\nconst vm = new Vue({\n  el: \"#app\",\n  data: {\n    msg: \"Hello\"\n  },\n  computed: {\n    reversedMessage: function() {\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 / setter ：\n\n（计算属性的完整写法）：\n\ncomputed: {\n  fullName: {\n    // getter\n    get: function() {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function() {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 现在设置 fullName 的值时，例如将 vm.fullName = 'John Doe' ， setter 会被调用，此时 firstName 和 lastName 也会相应发生改变。\n\n\n# 侦听器 watch\n\n（监听属性）提供了一个更加通用、能够自定义的方法，来相应数据的变化。当需要数据变化时执行异步或者开销较大的操作时，使用 watch 最合适。\n\n当被监视的属性发生变化时，回调函数自动调用进行相关的操作：\n\n * ⚠️：监视的「属性」必须存在才能进行监视；\n\n * 监视的两种写法：通过在 new Vue 时传入 watch 配置来监视指定的属性或者通过 vm 对象的 $watch() 监视 ；\n\n * 监视的 watch(oldValue, newValue) 可以通过参数获取变化的值（旧值和新值）；\n\n * 监视的简写（适用于不需要配置 immediate 等参数）；\n\n深度监视：\n\n * Vue 中的 watch 默认不监测对象内部值的改变（一层）；\n * 配置 deep: true 可以监测对象内部值的改变；\n * ⚠️注意：\n   * Vue 自身可以检测对象的内部值改变，但是 Vue 提供的监视属性 watch 默认不可以；\n   * 使用 watch 可以根据数据的具体结构，决定是否采用深度监视；\n\n🌰 例子：\n\n<div id=\"demo\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>\n    {{ answer }}\n  </p>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"><\/script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"><\/script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 `question` 发生改变，这个函数就会运行\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n> 参考自官网的例子。使用 watch 允许执行一个异步操作，限制执行该操作的频率，并且在得到最终结果之前，设置 answer 的中间状态，这些都是 computed 无法做到的。\n\n\n# 使用监视与计算属性对比\n\n * computed 能完成时， watch 都能完成：当 watch 和 computed 都能实现时，首选用 computed 提高性能；\n * watch 能完成的功能， computed 不一定完成：当时需要实现一些异步功能（例如延时显示）时，就使用 watch （ computed 依靠 return 获取值）\n\n🌰 例子：\n\n<div id=\"app\">\n  {{ fullName }}\n</div>\n\n\n1\n2\n3\n\n\nconst vm = new Vue({\n\tel: \"#app\",\n  data: {\n    firstName: 'foo',\n    lastName: 'bar',\n    fullName: 'foo bar'\n  },\n  watch: {\n    firstName: function(value) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function(value) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 通过监视属性 watch 侦听 firstName 和 lastName 的变化，修改 fullName 的值。但是两个代码逻辑发生了重复。明显使用 computed 计算属性的效率更高：\n> \n> computed: {\n>   fullName: function() {\n>     return this.firstName + ' ' + this.lastName\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5",normalizedContent:"# 计算属性 computed\n\nvue 中不推荐在模版中使用复杂的表达式，应该重构为「计算属性」或方法；（官网风格指南）\n\n要显示的「属性」不存在时，要通过「已有属性（在 vue 下管理）」计算得到时可以使用计算属性 computed ：\n\n * 原理：底层借助了 objcet.defineproperty() 方法提供的 getter 和 setter 。\n   \n   * get 函数什么时候执行？\n     \n     * 初次读取时会执行一次（将保存在缓存提供重复使用）；\n     * 依赖的数据发生改变时会被再次调用；\n   \n   * 与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便。\n\n * ⚠️注意：\n   \n   * 最终的计算属性会出现在 vm ，直接读取使用（会自动调用 get ）即可；\n   * 如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。\n\n * 使用方法：\n   \n   * 在 computed 对象中定义计算属性（ get() 和 set() ）；\n   * 在页面中使用 {{方法名}} 来显示计算的结果；\n   * 只读不改的简写，省略 set() 只有 get() 时，直接当计算属性的 get() ；\n\n🌰 例子：\n\n<div id=\"#app\">\n  {{ msg }}\n  {{ reversedmsg}}\n</div>\n\n\n1\n2\n3\n4\n\n\nconst vm = new vue({\n  el: \"#app\",\n  data: {\n    msg: \"hello\"\n  },\n  computed: {\n    reversedmessage: function() {\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 / setter ：\n\n（计算属性的完整写法）：\n\ncomputed: {\n  fullname: {\n    // getter\n    get: function() {\n      return this.firstname + ' ' + this.lastname\n    },\n    // setter\n    set: function() {\n      var names = newvalue.split(' ')\n      this.firstname = names[0]\n      this.lastname = names[names.length - 1]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 现在设置 fullname 的值时，例如将 vm.fullname = 'john doe' ， setter 会被调用，此时 firstname 和 lastname 也会相应发生改变。\n\n\n# 侦听器 watch\n\n（监听属性）提供了一个更加通用、能够自定义的方法，来相应数据的变化。当需要数据变化时执行异步或者开销较大的操作时，使用 watch 最合适。\n\n当被监视的属性发生变化时，回调函数自动调用进行相关的操作：\n\n * ⚠️：监视的「属性」必须存在才能进行监视；\n\n * 监视的两种写法：通过在 new vue 时传入 watch 配置来监视指定的属性或者通过 vm 对象的 $watch() 监视 ；\n\n * 监视的 watch(oldvalue, newvalue) 可以通过参数获取变化的值（旧值和新值）；\n\n * 监视的简写（适用于不需要配置 immediate 等参数）；\n\n深度监视：\n\n * vue 中的 watch 默认不监测对象内部值的改变（一层）；\n * 配置 deep: true 可以监测对象内部值的改变；\n * ⚠️注意：\n   * vue 自身可以检测对象的内部值改变，但是 vue 提供的监视属性 watch 默认不可以；\n   * 使用 watch 可以根据数据的具体结构，决定是否采用深度监视；\n\n🌰 例子：\n\n<div id=\"demo\">\n  <p>\n    ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>\n    {{ answer }}\n  </p>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"><\/script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"><\/script>\n<script>\nvar watchexamplevm = new vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'i cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 `question` 发生改变，这个函数就会运行\n    question: function (newquestion, oldquestion) {\n      this.answer = 'waiting for you to stop typing...'\n      this.debouncedgetanswer()\n    }\n  },\n  created: function () {\n    this.debouncedgetanswer = _.debounce(this.getanswer, 500)\n  },\n  methods: {\n    getanswer: function () {\n      if (this.question.indexof('?') === -1) {\n        this.answer = 'questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'error! could not reach the api. ' + error\n        })\n    }\n  }\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n> 参考自官网的例子。使用 watch 允许执行一个异步操作，限制执行该操作的频率，并且在得到最终结果之前，设置 answer 的中间状态，这些都是 computed 无法做到的。\n\n\n# 使用监视与计算属性对比\n\n * computed 能完成时， watch 都能完成：当 watch 和 computed 都能实现时，首选用 computed 提高性能；\n * watch 能完成的功能， computed 不一定完成：当时需要实现一些异步功能（例如延时显示）时，就使用 watch （ computed 依靠 return 获取值）\n\n🌰 例子：\n\n<div id=\"app\">\n  {{ fullname }}\n</div>\n\n\n1\n2\n3\n\n\nconst vm = new vue({\n\tel: \"#app\",\n  data: {\n    firstname: 'foo',\n    lastname: 'bar',\n    fullname: 'foo bar'\n  },\n  watch: {\n    firstname: function(value) {\n      this.fullname = val + ' ' + this.lastname\n    },\n    lastname: function(value) {\n      this.fullname = this.firstname + ' ' + val\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 通过监视属性 watch 侦听 firstname 和 lastname 的变化，修改 fullname 的值。但是两个代码逻辑发生了重复。明显使用 computed 计算属性的效率更高：\n> \n> computed: {\n>   fullname: function() {\n>     return this.firstname + ' ' + this.lastname\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 Vue 样式绑定",frontmatter:{title:"🌗 Vue 样式绑定",date:"2022-06-29T19:15:30.000Z",permalink:"/pages/64e761/",categories:["🏃 前端核心框架","🌧️ Vue 基础"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/06.%20%F0%9F%8C%97%20Vue%20%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/06. 🌗 Vue 样式绑定.md",key:"v-65d2e9dd",path:"/pages/64e761/",headers:[{level:2,title:"class 列表绑定",slug:"class-列表绑定",normalizedTitle:"class 列表绑定",charIndex:155},{level:3,title:"style 内联样式绑定",slug:"style-内联样式绑定",normalizedTitle:"style 内联样式绑定",charIndex:1843}],headersStr:"class 列表绑定 style 内联样式绑定",content:"在应用界面中，某个（些）元素的样式是会发生变化的。使用 class / style 绑定实现动态样式效果的技术。因为 class 和 style 都是 HTML 标签的特性（Attribute），所以可以通过 v-bind 绑定相应的字符串表达式。但是字符串表达式容易出错，所以还可绑定对象或者数组。\n\n\n# class 列表绑定\n\n语法： v-bind:class=\"xxx\" （或者简写为 :class=“xxx” ） ，有三种写法：\n\n * xxx 表达式可以是字符串 classA ，适用于类名不确定时；\n * xxx 表达式可以是数组 ['classA','classB'] ，适用于要绑定多个样式，但是个数不确定、名字不确定；\n * xxx 表达式可以是对象： {classA:isA, classB: isB} ，适用于绑定多个样式，个数不确定、名字不确定、是否使用也不确定；\n\n🌰 例子 / 绑定数组：\n\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n\n\n1\n\n\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n\n\n1\n2\n3\n4\n\n\n在数组中也可以根据条件切换 class ：\n\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n\n\n1\n\n\n> 最好的写法还是使用对象语法。\n\n🌰 例子 / 绑定对象，动态切换 class ：\n\n<div\n  class=\"static\"\n  v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n\n\n1\n2\n3\n4\n\n\ndata 中的相关数据：\n\ndata: {\n  isActive: true,\n  hasError: false\n}\n\n\n1\n2\n3\n4\n\n\n> 最后渲染的结果为：\n> \n> <div class=\"static active\"></div>\n> \n> \n> 1\n\n绑定的数据对象可以不用内联定义在模版里，而是在 data 中：\n\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在模版中可以直接绑定这个对象变量即可：\n\n<div :class=\"classObject\">\n  ... \n</div>\n\n\n1\n2\n3\n\n\n使用 computed 计算属性，可以使得这个类对象变换更加灵活：\n\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n🌰 例子 / 在 Vue 组件的 class property 中，如果原来的元素已经存在 class ，而在使用的时候又添加 class ，不会覆盖原来的 class 列表。\n\n🌰 例子：\n\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n\n\n1\n2\n3\n\n\n<my-component class=\"baz boo\"></my-component>\n\n\n1\n\n\n最终渲染的结果为：\n\n<p class=\"foo bar baz boo\">Hi</p>\n\n\n1\n\n\n🌰 例子 / 对于数据绑定 class 也适用：\n\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n\n\n1\n\n\n最终渲染结果为：\n\n<p class=\"foo bar active\">Hi</p>\n\n\n1\n\n\n\n# style 内联样式绑定\n\n语法： v-bind:style=\"xxx\" （简写为 :style=“xxx” ）：\n\n * xxx 表达式是样式对象，可动态修改样式属性值，例如 {fontSize: fontSize +‘px’} ；（多个单词的 CSS 样式采用驼峰命名）\n * xxx 表达式是数组，将多个样式对象同时应用在一个元素中， [a,b] 其中 a,b 是样式对象；\n\n🌰 例子：\n\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n\n\n1\n\n\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n\n\n1\n2\n3\n4\n\n\n🌰 例子：\n\n<div v-bind:style=\"styleObject\"></div>\n\n\n1\n\n\ndata: {\n  styleObject: {\n    color: 'red',\n    fontSize: '13px'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 数组：\n\n<div v-bind:style=\"[baseStyles, overridingStyles]\"></div>\n\n\n1\n\n\n对于可能不兼容本浏览器的样式属性，Vue 会自动侦测并添加响应的浏览器引擎前缀。\n\n并且当样式 property 中绑定的是多个兼容浏览器引擎的值的数组例如：\n\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n\n\n1\n\n\n这样只会渲染中最后一个被浏览器支持的值。这个例子中如果浏览器支持不带前缀的 flex ，就只会渲染 display: flex 。",normalizedContent:"在应用界面中，某个（些）元素的样式是会发生变化的。使用 class / style 绑定实现动态样式效果的技术。因为 class 和 style 都是 html 标签的特性（attribute），所以可以通过 v-bind 绑定相应的字符串表达式。但是字符串表达式容易出错，所以还可绑定对象或者数组。\n\n\n# class 列表绑定\n\n语法： v-bind:class=\"xxx\" （或者简写为 :class=“xxx” ） ，有三种写法：\n\n * xxx 表达式可以是字符串 classa ，适用于类名不确定时；\n * xxx 表达式可以是数组 ['classa','classb'] ，适用于要绑定多个样式，但是个数不确定、名字不确定；\n * xxx 表达式可以是对象： {classa:isa, classb: isb} ，适用于绑定多个样式，个数不确定、名字不确定、是否使用也不确定；\n\n🌰 例子 / 绑定数组：\n\n<div v-bind:class=\"[activeclass, errorclass]\"></div>\n\n\n1\n\n\ndata: {\n  activeclass: 'active',\n  errorclass: 'text-danger'\n}\n\n\n1\n2\n3\n4\n\n\n在数组中也可以根据条件切换 class ：\n\n<div v-bind:class=\"[isactive ? activeclass : '', errorclass]\"></div>\n\n\n1\n\n\n> 最好的写法还是使用对象语法。\n\n🌰 例子 / 绑定对象，动态切换 class ：\n\n<div\n  class=\"static\"\n  v-bind:class=\"{ active: isactive, 'text-danger': haserror }\"\n></div>\n\n\n1\n2\n3\n4\n\n\ndata 中的相关数据：\n\ndata: {\n  isactive: true,\n  haserror: false\n}\n\n\n1\n2\n3\n4\n\n\n> 最后渲染的结果为：\n> \n> <div class=\"static active\"></div>\n> \n> \n> 1\n\n绑定的数据对象可以不用内联定义在模版里，而是在 data 中：\n\ndata: {\n  classobject: {\n    active: true,\n    'text-danger': false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在模版中可以直接绑定这个对象变量即可：\n\n<div :class=\"classobject\">\n  ... \n</div>\n\n\n1\n2\n3\n\n\n使用 computed 计算属性，可以使得这个类对象变换更加灵活：\n\ndata: {\n  isactive: true,\n  error: null\n},\ncomputed: {\n  classobject: function () {\n    return {\n      active: this.isactive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n🌰 例子 / 在 vue 组件的 class property 中，如果原来的元素已经存在 class ，而在使用的时候又添加 class ，不会覆盖原来的 class 列表。\n\n🌰 例子：\n\nvue.component('my-component', {\n  template: '<p class=\"foo bar\">hi</p>'\n})\n\n\n1\n2\n3\n\n\n<my-component class=\"baz boo\"></my-component>\n\n\n1\n\n\n最终渲染的结果为：\n\n<p class=\"foo bar baz boo\">hi</p>\n\n\n1\n\n\n🌰 例子 / 对于数据绑定 class 也适用：\n\n<my-component v-bind:class=\"{ active: isactive }\"></my-component>\n\n\n1\n\n\n最终渲染结果为：\n\n<p class=\"foo bar active\">hi</p>\n\n\n1\n\n\n\n# style 内联样式绑定\n\n语法： v-bind:style=\"xxx\" （简写为 :style=“xxx” ）：\n\n * xxx 表达式是样式对象，可动态修改样式属性值，例如 {fontsize: fontsize +‘px’} ；（多个单词的 css 样式采用驼峰命名）\n * xxx 表达式是数组，将多个样式对象同时应用在一个元素中， [a,b] 其中 a,b 是样式对象；\n\n🌰 例子：\n\n<div v-bind:style=\"{ color: activecolor, fontsize: fontsize + 'px' }\"></div>\n\n\n1\n\n\ndata: {\n  activecolor: 'red',\n  fontsize: 30\n}\n\n\n1\n2\n3\n4\n\n\n🌰 例子：\n\n<div v-bind:style=\"styleobject\"></div>\n\n\n1\n\n\ndata: {\n  styleobject: {\n    color: 'red',\n    fontsize: '13px'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / 数组：\n\n<div v-bind:style=\"[basestyles, overridingstyles]\"></div>\n\n\n1\n\n\n对于可能不兼容本浏览器的样式属性，vue 会自动侦测并添加响应的浏览器引擎前缀。\n\n并且当样式 property 中绑定的是多个兼容浏览器引擎的值的数组例如：\n\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n\n\n1\n\n\n这样只会渲染中最后一个被浏览器支持的值。这个例子中如果浏览器支持不带前缀的 flex ，就只会渲染 display: flex 。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌑 Vue 指令",frontmatter:{title:"🌑 Vue 指令",date:"2022-03-11T16:04:09.000Z",permalink:"/pages/55d982/",categories:["📚 前端笔记","🏃 核心部分","🌧️ Vuejs"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/07.%20%F0%9F%8C%91%20Vue%20%E6%8C%87%E4%BB%A4.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/07. 🌑 Vue 指令.md",key:"v-410d79ac",path:"/pages/55d982/",headers:[{level:2,title:"内置指令 v-*",slug:"内置指令-v",normalizedTitle:"内置指令 v-*",charIndex:2},{level:2,title:"自定义指令",slug:"自定义指令",normalizedTitle:"自定义指令",charIndex:766},{level:3,title:"函数式",slug:"函数式",normalizedTitle:"函数式",charIndex:832},{level:3,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:105}],headersStr:"内置指令 v-* 自定义指令 函数式 对象",content:"# 内置指令 v-*\n\n> 已经提到过的内置指令：\n> \n>  * v-bind：单向绑定解析表达式，可简写为 : ；\n> \n>  * v-model：双向数据绑定；\n> \n>  * v-for：遍历数组 / 对象 / 字符串；\n> \n>  * v-on：绑定事件监听，可简写为 @ ；\n> \n>  * v-if：条件渲染（动态控制节点是否存存在）\n>    \n>    v-else：条件渲染（动态控制节点是否存存在）\n> \n>  * v-show：条件渲染（动态控制节点是否展示）\n\nv-text ：向其所在的节点中渲染文本内容；\n\n（与插值语法的区别： v-text 会替换掉节点中的内容， 插值语法则不会）\n\nv-html ：与 v-text 相似，但是 v-html 可以支持结构的解析渲染（文本内容可以包含 HTML 标签）；\n\n（⚠️：安全性问题： 在网站上任意渲染 HTML 内容非常危险，容易导致 XSS 攻击；一定要在可信的内容上使用 v-html ，永远不要使用在用户可提交的内容中）\n\nv-cloak ： 一个特殊的没有值的属性，Vue 实例创建完毕并且接管容器后会删掉 v-cloak 属性；所以可以使用 CSS 配合 v-cloak 解决网速慢网页延迟显示未经渲染的 Vue 内容问题。\n\nv-once ：一个特殊的没有值的属性，在 v-once 所在的节点在初次渲染之后就视为静态内容。（只会被渲染一次）之后数据的改变不会引起 v-once 属性所在的结构更新，可用于优化性能。（区别开事件中的 once 特性）\n\nv-pre ：一个特殊的没有值的属性，可以让 Vue 跳过 v-pre 属性所在节点的编译过程。可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快容器中内容的编译。\n\n\n# 自定义指令\n\n使用 new Vue({directives: {...}}) 配置自定义指令，\n\n⚠️：原理不靠返回的值。\n\n\n# 函数式\n\n语法： new Vue({directives: { 指令名(){ … } }})\n\n\n# 对象\n\n语法： new Vue({directives: {指令名:{配置对象...}}}) ；\n\n常用的三个回调函数：\n\n * bind ：指令与元素成功绑定时调用；\n * inserted ：指令所在元素被插入页面时调用；\n * update ：指令所在模版结构被重新解析时调用；\n\n其他问题注意：\n\n * 指令定义时不加 v- ，使用时需要加 v-\n\n * 指令名称使用多个名字时要用 - 分隔开来（kebab-cab 命名），在 directives 中定义该指令时要使用字符串的形式 word-word(){} ；\n\n * 指令中回调函数的 this 问题：不论是函数式还是对象式， this 都会指向 window 对象。\n\n * 全局指令使用 Vue.directive('xxx', function(element, binding){}) 或者 Vue.directive(‘xxx’, { xxx }) 配置。",normalizedContent:"# 内置指令 v-*\n\n> 已经提到过的内置指令：\n> \n>  * v-bind：单向绑定解析表达式，可简写为 : ；\n> \n>  * v-model：双向数据绑定；\n> \n>  * v-for：遍历数组 / 对象 / 字符串；\n> \n>  * v-on：绑定事件监听，可简写为 @ ；\n> \n>  * v-if：条件渲染（动态控制节点是否存存在）\n>    \n>    v-else：条件渲染（动态控制节点是否存存在）\n> \n>  * v-show：条件渲染（动态控制节点是否展示）\n\nv-text ：向其所在的节点中渲染文本内容；\n\n（与插值语法的区别： v-text 会替换掉节点中的内容， 插值语法则不会）\n\nv-html ：与 v-text 相似，但是 v-html 可以支持结构的解析渲染（文本内容可以包含 html 标签）；\n\n（⚠️：安全性问题： 在网站上任意渲染 html 内容非常危险，容易导致 xss 攻击；一定要在可信的内容上使用 v-html ，永远不要使用在用户可提交的内容中）\n\nv-cloak ： 一个特殊的没有值的属性，vue 实例创建完毕并且接管容器后会删掉 v-cloak 属性；所以可以使用 css 配合 v-cloak 解决网速慢网页延迟显示未经渲染的 vue 内容问题。\n\nv-once ：一个特殊的没有值的属性，在 v-once 所在的节点在初次渲染之后就视为静态内容。（只会被渲染一次）之后数据的改变不会引起 v-once 属性所在的结构更新，可用于优化性能。（区别开事件中的 once 特性）\n\nv-pre ：一个特殊的没有值的属性，可以让 vue 跳过 v-pre 属性所在节点的编译过程。可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快容器中内容的编译。\n\n\n# 自定义指令\n\n使用 new vue({directives: {...}}) 配置自定义指令，\n\n⚠️：原理不靠返回的值。\n\n\n# 函数式\n\n语法： new vue({directives: { 指令名(){ … } }})\n\n\n# 对象\n\n语法： new vue({directives: {指令名:{配置对象...}}}) ；\n\n常用的三个回调函数：\n\n * bind ：指令与元素成功绑定时调用；\n * inserted ：指令所在元素被插入页面时调用；\n * update ：指令所在模版结构被重新解析时调用；\n\n其他问题注意：\n\n * 指令定义时不加 v- ，使用时需要加 v-\n\n * 指令名称使用多个名字时要用 - 分隔开来（kebab-cab 命名），在 directives 中定义该指令时要使用字符串的形式 word-word(){} ；\n\n * 指令中回调函数的 this 问题：不论是函数式还是对象式， this 都会指向 window 对象。\n\n * 全局指令使用 vue.directive('xxx', function(element, binding){}) 或者 vue.directive(‘xxx’, { xxx }) 配置。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌒 Vue 条件渲染与列表渲染",frontmatter:{title:"🌒 Vue 条件渲染与列表渲染",date:"2022-03-11T16:01:42.000Z",permalink:"/pages/fcee68/",categories:["📚 前端笔记","🏃 核心部分","🌧️ Vuejs"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/08.%20%F0%9F%8C%92%20Vue%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/08. 🌒 Vue 条件渲染与列表渲染.md",key:"v-b4901270",path:"/pages/fcee68/",headers:[{level:2,title:"条件渲染",slug:"条件渲染",normalizedTitle:"条件渲染",charIndex:2},{level:3,title:"v-if",slug:"v-if",normalizedTitle:"v-if",charIndex:11},{level:3,title:"v-show",slug:"v-show",normalizedTitle:"v-show",charIndex:1333},{level:3,title:"比较 v-if 与 v-show",slug:"比较-v-if-与-v-show",normalizedTitle:"比较 v-if 与 v-show",charIndex:1466},{level:2,title:"列表渲染",slug:"列表渲染",normalizedTitle:"列表渲染",charIndex:1727},{level:4,title:"列表渲染指令",slug:"列表渲染指令",normalizedTitle:"列表渲染指令",charIndex:1735},{level:3,title:"列表过滤器",slug:"列表过滤器",normalizedTitle:"列表过滤器",charIndex:2551},{level:2,title:"过滤器",slug:"过滤器",normalizedTitle:"过滤器",charIndex:2553}],headersStr:"条件渲染 v-if v-show 比较 v-if 与 v-show 列表渲染 列表渲染指令 列表过滤器 过滤器",content:'# 条件渲染\n\n\n# v-if\n\nv-if 与 v-else-if 、 v-else 配合使用，适用于切换频率低的场景：\n\n * 语法： v-if=‘xxx’ 。\n * 特点：不展示的 DOM 元素会被 直接移除。\n * 注意：\n   * v-if 与 v-else-if 、 v-else 要接连一起使用，否则不会被识别，结构不能被「打断」；\n   * ⚠️使用 <template> </template> 模版标签可以避免结构被打断。\n   * 不建议 v-for 与 v-if 一起使用。因为 v-for 会具有更高的优先级。\n\n🌰 例子：\n\n<h1 v-if="awesome">Vue is awesome!</h1>\n\n\n1\n\n\n🌰 例子 / 在 template 标签上使用，条件渲染模版分组：\n\n<template v-if="ok">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n> 可以将 <template> 元素包裹的元素看成一个元素组，当要动态显示这一部分的内容就可以使用条件渲染实现。最终渲染的结果不会包括 <template> 元素。\n\n🌰 例子 / v-if ~ v-else 结合使用。\n\n<div v-if="Math.random() > 0.5">\n  Now you see me\n</div>\n<div v-else>\n  Now you don\'t\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / v-if ~ v-else-if 的使用：\n\n<div v-if="type === \'A\'">\n  A\n</div>\n<div v-else-if="type === \'B\'">\n  B\n</div>\n<div v-else-if="type === \'C\'">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n🌰 例子 / 使用 key 管理可服复用的动态元素：\n\n<template v-if="loginType === \'username\'">\n  <label>Username</label>\n  <input placeholder="Enter your username" key="username-input">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder="Enter your email address" key="email-input">\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 原本不加 key ，因为两个模版都使用了相同的元素，切换模版时不会替换掉 <input> ，只有其中的 placeholder 特性被替换了。给模版添加一个具有一个唯一的值 key 特性，就可以实现重新渲染这个元素。\n\n\n# v-show\n\nv-show ： 适用于切换频率高的场景：\n\n * 语法： v-show=“xxx” ，\n * 特点：不展示的 DOM 元素不被移除，仅仅通过 display 样式隐藏。\n * 注意： v-show 不支持用于 <template> 元素。\n\n\n# 比较 v-if 与 v-show\n\n * v-if 是「真正」的条件渲染，会确保在切哈 u 你过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n * 当需要频繁切换，使用 v-show ；因为 v-if 有着更高的切换开销，而 v-show 是是渲染开销高。\n\n * 当初始条件不成立时， v-if 的所有子节点不会被渲染解析（在项目中使用）；只有在知道条件第一次变为真时，才会开始渲染条件块。\n\n * 使用 v-if 时，元素可能无法获取；但使用 v-show 的元素一定可以获取（DOM 有无移除）。\n\n\n# 列表渲染\n\n# 列表渲染指令\n\n用于遍历展示「列表」中的数据\n\n * 语法： v-for=“(item, index) in xxx” :key="index"\n * 可用于遍历：数组、对象、字符串、指定遍历次数；\n\n🌰 例子：\n\n<ul id="example-1">\n  <li v-for="item in items" :key="item.message">\n    {{ item.message }}\n  </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\nvar example1 = new Vue({\n  el: \'#example-1\',\n  data: {\n    items: [\n      { message: \'Foo\' },\n      { message: \'Bar\' }\n    ]\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子 / 遍历一个对象的属性：\n\n<ul id="v-for-object" class="demo">\n  <li v-for="(name, value, index) in object">\n    {{ index }}, {{ name }}: {{ value }}\n  </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\nnew Vue({\n  el: \'#v-for-object\',\n  data: {\n    object: {\n      title: \'How to do lists in Vue\',\n      author: \'Jane Doe\',\n      publishedAt: \'2016-04-10\'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。\n\n\n# 列表过滤器\n\n🌰：在列表中模糊搜索（ watch 实现与 computed 实现对比）\n\n\n# 过滤器\n\n * 定义：对要显示的数据进行特定格式化后再显示（适用简单逻辑的处理）；\n\n * 语法：\n   \n   * 注册过滤器（建议全局）： Vue.filter(name, callback) （或者定义为局部过滤器 new Vue(filters:{})\n   * 使用过滤器： { {var | filterName} } 或者在数据单向绑定 v-bind:属性="var | filterName" （⚠️ 不能在 v-model 中使用）；\n\n * ⚠️ 注意：\n   \n   * 过滤器的参数问题：第一个参数要过滤的数据；第二个参数开始的额外参数可以是过滤器格式字符串（可以设置默认参数，以防没有传参）；\n   \n   * 可以多个过滤器叠加使用， 但是是逐层过滤的；\n   \n   * 没有改变原本的数据，产生新的对应的数据；\n\n * 🌰 示例：格式化日期；\n\n> 🔗 相关链接：bootcdn.cn -\n> \n> 日期格式化相关： moment.js/days 轻量化\n\n> 在 Vue 3 中过滤已经被计算属性取代。',normalizedContent:'# 条件渲染\n\n\n# v-if\n\nv-if 与 v-else-if 、 v-else 配合使用，适用于切换频率低的场景：\n\n * 语法： v-if=‘xxx’ 。\n * 特点：不展示的 dom 元素会被 直接移除。\n * 注意：\n   * v-if 与 v-else-if 、 v-else 要接连一起使用，否则不会被识别，结构不能被「打断」；\n   * ⚠️使用 <template> </template> 模版标签可以避免结构被打断。\n   * 不建议 v-for 与 v-if 一起使用。因为 v-for 会具有更高的优先级。\n\n🌰 例子：\n\n<h1 v-if="awesome">vue is awesome!</h1>\n\n\n1\n\n\n🌰 例子 / 在 template 标签上使用，条件渲染模版分组：\n\n<template v-if="ok">\n  <h1>title</h1>\n  <p>paragraph 1</p>\n  <p>paragraph 2</p>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n> 可以将 <template> 元素包裹的元素看成一个元素组，当要动态显示这一部分的内容就可以使用条件渲染实现。最终渲染的结果不会包括 <template> 元素。\n\n🌰 例子 / v-if ~ v-else 结合使用。\n\n<div v-if="math.random() > 0.5">\n  now you see me\n</div>\n<div v-else>\n  now you don\'t\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / v-if ~ v-else-if 的使用：\n\n<div v-if="type === \'a\'">\n  a\n</div>\n<div v-else-if="type === \'b\'">\n  b\n</div>\n<div v-else-if="type === \'c\'">\n  c\n</div>\n<div v-else>\n  not a/b/c\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n🌰 例子 / 使用 key 管理可服复用的动态元素：\n\n<template v-if="logintype === \'username\'">\n  <label>username</label>\n  <input placeholder="enter your username" key="username-input">\n</template>\n<template v-else>\n  <label>email</label>\n  <input placeholder="enter your email address" key="email-input">\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 原本不加 key ，因为两个模版都使用了相同的元素，切换模版时不会替换掉 <input> ，只有其中的 placeholder 特性被替换了。给模版添加一个具有一个唯一的值 key 特性，就可以实现重新渲染这个元素。\n\n\n# v-show\n\nv-show ： 适用于切换频率高的场景：\n\n * 语法： v-show=“xxx” ，\n * 特点：不展示的 dom 元素不被移除，仅仅通过 display 样式隐藏。\n * 注意： v-show 不支持用于 <template> 元素。\n\n\n# 比较 v-if 与 v-show\n\n * v-if 是「真正」的条件渲染，会确保在切哈 u 你过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n * 当需要频繁切换，使用 v-show ；因为 v-if 有着更高的切换开销，而 v-show 是是渲染开销高。\n\n * 当初始条件不成立时， v-if 的所有子节点不会被渲染解析（在项目中使用）；只有在知道条件第一次变为真时，才会开始渲染条件块。\n\n * 使用 v-if 时，元素可能无法获取；但使用 v-show 的元素一定可以获取（dom 有无移除）。\n\n\n# 列表渲染\n\n# 列表渲染指令\n\n用于遍历展示「列表」中的数据\n\n * 语法： v-for=“(item, index) in xxx” :key="index"\n * 可用于遍历：数组、对象、字符串、指定遍历次数；\n\n🌰 例子：\n\n<ul id="example-1">\n  <li v-for="item in items" :key="item.message">\n    {{ item.message }}\n  </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\nvar example1 = new vue({\n  el: \'#example-1\',\n  data: {\n    items: [\n      { message: \'foo\' },\n      { message: \'bar\' }\n    ]\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n🌰 例子 / 遍历一个对象的属性：\n\n<ul id="v-for-object" class="demo">\n  <li v-for="(name, value, index) in object">\n    {{ index }}, {{ name }}: {{ value }}\n  </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\nnew vue({\n  el: \'#v-for-object\',\n  data: {\n    object: {\n      title: \'how to do lists in vue\',\n      author: \'jane doe\',\n      publishedat: \'2016-04-10\'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 在遍历对象时，会按 object.keys() 的结果遍历，但是不能保证它的结果在不同的 javascript 引擎下都一致。\n\n\n# 列表过滤器\n\n🌰：在列表中模糊搜索（ watch 实现与 computed 实现对比）\n\n\n# 过滤器\n\n * 定义：对要显示的数据进行特定格式化后再显示（适用简单逻辑的处理）；\n\n * 语法：\n   \n   * 注册过滤器（建议全局）： vue.filter(name, callback) （或者定义为局部过滤器 new vue(filters:{})\n   * 使用过滤器： { {var | filtername} } 或者在数据单向绑定 v-bind:属性="var | filtername" （⚠️ 不能在 v-model 中使用）；\n\n * ⚠️ 注意：\n   \n   * 过滤器的参数问题：第一个参数要过滤的数据；第二个参数开始的额外参数可以是过滤器格式字符串（可以设置默认参数，以防没有传参）；\n   \n   * 可以多个过滤器叠加使用， 但是是逐层过滤的；\n   \n   * 没有改变原本的数据，产生新的对应的数据；\n\n * 🌰 示例：格式化日期；\n\n> 🔗 相关链接：bootcdn.cn -\n> \n> 日期格式化相关： moment.js/days 轻量化\n\n> 在 vue 3 中过滤已经被计算属性取代。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌞 Vue 声明周期",frontmatter:{title:"🌞 Vue 声明周期",date:"2022-03-11T16:04:44.000Z",permalink:"/pages/021159/",categories:["📚 前端笔记","🏃 核心部分","🌧️ Vuejs"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/09.%20%F0%9F%8C%9E%20Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/09. 🌞 Vue 生命周期.md",key:"v-81352ca6",path:"/pages/021159/",headers:[{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:2},{level:3,title:"生命周期分析",slug:"生命周期分析",normalizedTitle:"生命周期分析",charIndex:172}],headersStr:"生命周期 生命周期分析",content:"# 生命周期\n\n生命周期（又名生命周期回调函数、生命周期函数、生命周期钩子）：\n\n * Vue 在关键时刻帮助我们调用的一些特殊名称的函数（引入如：挂载函数 mouted(){...} 的应用）；\n * 生命周期函数的名字不可以更改，但函数的具体内容是根据需求编写的；\n * 生命周期中的 this 指向的是 vm 或者组件实例对象；\n\n\n# 生命周期分析\n\n * 创建流程：（创建数据监测、数据代理）\n   * 将要创建：调用 beforeCreate\n   * 创建完毕：调用 created\n\n\n\n\n\n⚠️注意： outerHTML 容器的范围；\n\n * 挂载流程、更新流程、销毁流程：\n   * 将要挂载：调用 beforeMount\n   * ⭐️ 挂载完毕：完成初始化（定时器、发送请求），调用 mounted\n   * 将要更新：调用 beforeUpdate\n   * 更新完毕：调用 updated\n   * ⭐️ 将要销毁：完成收尾工作（关闭定时器、取消订阅信息、解绑自定义事件），调用 beforeDestroy ；\n   * 销毁完毕：调用 destroyed\n\n\n\n⭐️ 常用生命周期回调函数：\n\n * mounted 进行初始化操作，如发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等；\n * beforeDestroyed 进行销毁前的收尾工作，如清除计时器、解绑自定义事件、取消订阅消息等收尾工作；\n\n⭐️ 关于销毁 Vue 示例：\n\n * 销毁后 Vue 开发者工具中无任何内容（ <Root> ）；\n * 销毁后自定义事件会失效，但是原生 DOM 事件仍然有效；\n * 一般不会在 beforeDestroyed 中操作任何数据，因为即使操作了也不会出发数据更新流程。",normalizedContent:"# 生命周期\n\n生命周期（又名生命周期回调函数、生命周期函数、生命周期钩子）：\n\n * vue 在关键时刻帮助我们调用的一些特殊名称的函数（引入如：挂载函数 mouted(){...} 的应用）；\n * 生命周期函数的名字不可以更改，但函数的具体内容是根据需求编写的；\n * 生命周期中的 this 指向的是 vm 或者组件实例对象；\n\n\n# 生命周期分析\n\n * 创建流程：（创建数据监测、数据代理）\n   * 将要创建：调用 beforecreate\n   * 创建完毕：调用 created\n\n\n\n\n\n⚠️注意： outerhtml 容器的范围；\n\n * 挂载流程、更新流程、销毁流程：\n   * 将要挂载：调用 beforemount\n   * ⭐️ 挂载完毕：完成初始化（定时器、发送请求），调用 mounted\n   * 将要更新：调用 beforeupdate\n   * 更新完毕：调用 updated\n   * ⭐️ 将要销毁：完成收尾工作（关闭定时器、取消订阅信息、解绑自定义事件），调用 beforedestroy ；\n   * 销毁完毕：调用 destroyed\n\n\n\n⭐️ 常用生命周期回调函数：\n\n * mounted 进行初始化操作，如发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等；\n * beforedestroyed 进行销毁前的收尾工作，如清除计时器、解绑自定义事件、取消订阅消息等收尾工作；\n\n⭐️ 关于销毁 vue 示例：\n\n * 销毁后 vue 开发者工具中无任何内容（ <root> ）；\n * 销毁后自定义事件会失效，但是原生 dom 事件仍然有效；\n * 一般不会在 beforedestroyed 中操作任何数据，因为即使操作了也不会出发数据更新流程。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌟 Vue 关键问题",frontmatter:{title:"🌟 Vue 关键问题",date:"2021-11-17T23:05:17.000Z",permalink:"/pages/701e29/",categories:["前端笔记","Vue 笔记"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/20.%20%F0%9F%8C%9F%20Vue%20%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/20. 🌟 Vue 关键问题.md",key:"v-01f863d2",path:"/pages/701e29/",headers:[{level:3,title:"Vue 中的函数写法原则（涉及this）",slug:"vue-中的函数写法原则-涉及this",normalizedTitle:"vue 中的函数写法原则（涉及 this）",charIndex:null},{level:3,title:"Vue 中的 key 作用和原理",slug:"vue-中的-key-作用和原理",normalizedTitle:"vue 中的 key 作用和原理",charIndex:195},{level:3,title:"Vue 中的数据监测原理（数据更新时的问题）",slug:"vue-中的数据监测原理-数据更新时的问题",normalizedTitle:"vue 中的数据监测原理（数据更新时的问题）",charIndex:802},{level:2,title:"Vue 中的 this 指向问题",slug:"vue-中的-this-指向问题",normalizedTitle:"vue 中的 this 指向问题",charIndex:1680}],headersStr:"Vue 中的函数写法原则（涉及this） Vue 中的 key 作用和原理 Vue 中的数据监测原理（数据更新时的问题） Vue 中的 this 指向问题",content:"# Vue 中的函数写法原则（涉及 this ）\n\n>  1. 所被 Vue 管理的函数，最好写成普通的函数，这时的 this 才会指向 vm 或者组件实例对象；\n>  2. 所有不被 Vue 所管理的函数（定时器的回调函数 setTimeout() 、ajax 的回调函数等），最好写成箭头函数以保证此时的 this 指向 vm 或者组件实例对象（找不到 this 时往外层找）\n\n\n# Vue 中的 key 作用和原理\n\n🔑：虚拟 DOM 中 key 的作用：\n\n * key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据新的数据生成新的虚拟 DOM，随后 Vue 会用差异对比算法进行新虚拟 DOM 与旧的虚拟 DOM 的比较，比较规则为：\n * 旧虚拟 DOM 中找到了与新虚拟 DOM 中相同的 key：\n   * 若虚拟 DOM 中的内容不变，复用之前的真实 DOM；\n   * 若虚拟 DOM 中的内容发生变化， 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM；\n * 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key：\n   * 创建新的真实 DOM，随后渲染到页面。\n\n⚠️： 开发中应该如何使用标识 key：\n\n * 最好使用每条数据的唯一标识作为 key，比如 id、手机号等唯一标识值；\n * 如果不存在对数据逆序添加、删除等破坏数据顺序的操作，仅用于渲染列表用于展示，可使用 index 作为 key。\n\n🌰：在遍历列表时，使用 index 作为 key 可能会引发的问题：\n\n * 若对数据进行逆序添加、逆序删除等破坏数据顺序的操作时：会产生没有必要的真实 DOM 更新，界面效果没有问题， 但效率降低；\n * 若结构中具有数据输入类的 DOM，会产生错误的 DOM 更新（数据与输入类 DOM 对应出错），导致界面效果出错。\n\n\n# Vue 中的数据监测原理（数据更新时的问题）\n\n⚠️看列表渲染系列教程：\n\n📺尚硅谷 Vue 教程 - 数据监测原理_对象\n\n\n\n\n\n📺尚硅谷 Vue 教程 - Vue.set () 的使用\n\n📺尚硅谷 Vue 教程 数据监测原理_数组\n\n\n\n\n\nTODO 官网数组更新检测原理\n\n⭐️ 总结：\n\n * Vue 会监视 data 中的「所有层次」的数据；\n\n * ❓ 如何监视「对象」中的数据：通过 setter 实现监视，并且要在 new Vue 中就在 data 中传入要监测的数据：\n   \n   * 对象中后面追加的数据 *（简单粗暴赋值），Vue 默认不会承认并且不做「⚠️响应式处理」；\n   \n   * 如需添加新的数据并且令 Vue 承认并做响应式，使用以下 API：\n     \n     > Vue.set(target.propertyName/index, value) 或者\n     > \n     > vm.$set(target.propertyName/index, value) （ vm 为一个实例化的 Vue 对象）\n\n * ❓ 如何监视「数组」中的数据：通过包裹数组更新元素的方法（本质上）：\n   \n   * 调用了原生（原型 prototype）对应的的方法对数组进行更新；\n   * 重新解析模版，进而更新页面；\n   * ⚠️ 要在 Vue 更新数组中的某个元素必须使用如下方法：\n     * 数组对象的修改数组的 7 个 API（ push() 、 pop() 、 unshift() 、 shift() 、 splice() 、 sort() 、 reverse() ）； （ ➕ filter() 不会对原数组改变（替换数组） ）\n     * 使用 Vue 供对象修改数据的 API（ Vue.set() 或者 vm.$set() 上面详细） ；\n\n * ⚠️ 特别注意： Vue.set() 或者 vm.$set() 不能给 vm 或者 vm._data （根叔对象）添加属性！\n\n\n# Vue 中的 this 指向问题\n\n * 指向「Vue 实例对象」：在 new Vue(options) 中的配置： data 函数、 methods 、 watch 、 computed 中的函数。\n * 指向「VueComponent 实例对象」：在组件中的配置： data 函数、 methods 、 watch 、 computed 中的函数。\n\n⚠️： 「VueComponent 实例对象」 简称为 vc 对象；「Vue 实例对象」简称为 vm 对象；",normalizedContent:"# vue 中的函数写法原则（涉及 this ）\n\n>  1. 所被 vue 管理的函数，最好写成普通的函数，这时的 this 才会指向 vm 或者组件实例对象；\n>  2. 所有不被 vue 所管理的函数（定时器的回调函数 settimeout() 、ajax 的回调函数等），最好写成箭头函数以保证此时的 this 指向 vm 或者组件实例对象（找不到 this 时往外层找）\n\n\n# vue 中的 key 作用和原理\n\n🔑：虚拟 dom 中 key 的作用：\n\n * key 是虚拟 dom 对象的标识，当数据发生变化时，vue 会根据新的数据生成新的虚拟 dom，随后 vue 会用差异对比算法进行新虚拟 dom 与旧的虚拟 dom 的比较，比较规则为：\n * 旧虚拟 dom 中找到了与新虚拟 dom 中相同的 key：\n   * 若虚拟 dom 中的内容不变，复用之前的真实 dom；\n   * 若虚拟 dom 中的内容发生变化， 则生成新的真实 dom，随后替换掉页面中之前的真实 dom；\n * 旧虚拟 dom 中未找到与新虚拟 dom 相同的 key：\n   * 创建新的真实 dom，随后渲染到页面。\n\n⚠️： 开发中应该如何使用标识 key：\n\n * 最好使用每条数据的唯一标识作为 key，比如 id、手机号等唯一标识值；\n * 如果不存在对数据逆序添加、删除等破坏数据顺序的操作，仅用于渲染列表用于展示，可使用 index 作为 key。\n\n🌰：在遍历列表时，使用 index 作为 key 可能会引发的问题：\n\n * 若对数据进行逆序添加、逆序删除等破坏数据顺序的操作时：会产生没有必要的真实 dom 更新，界面效果没有问题， 但效率降低；\n * 若结构中具有数据输入类的 dom，会产生错误的 dom 更新（数据与输入类 dom 对应出错），导致界面效果出错。\n\n\n# vue 中的数据监测原理（数据更新时的问题）\n\n⚠️看列表渲染系列教程：\n\n📺尚硅谷 vue 教程 - 数据监测原理_对象\n\n\n\n\n\n📺尚硅谷 vue 教程 - vue.set () 的使用\n\n📺尚硅谷 vue 教程 数据监测原理_数组\n\n\n\n\n\ntodo 官网数组更新检测原理\n\n⭐️ 总结：\n\n * vue 会监视 data 中的「所有层次」的数据；\n\n * ❓ 如何监视「对象」中的数据：通过 setter 实现监视，并且要在 new vue 中就在 data 中传入要监测的数据：\n   \n   * 对象中后面追加的数据 *（简单粗暴赋值），vue 默认不会承认并且不做「⚠️响应式处理」；\n   \n   * 如需添加新的数据并且令 vue 承认并做响应式，使用以下 api：\n     \n     > vue.set(target.propertyname/index, value) 或者\n     > \n     > vm.$set(target.propertyname/index, value) （ vm 为一个实例化的 vue 对象）\n\n * ❓ 如何监视「数组」中的数据：通过包裹数组更新元素的方法（本质上）：\n   \n   * 调用了原生（原型 prototype）对应的的方法对数组进行更新；\n   * 重新解析模版，进而更新页面；\n   * ⚠️ 要在 vue 更新数组中的某个元素必须使用如下方法：\n     * 数组对象的修改数组的 7 个 api（ push() 、 pop() 、 unshift() 、 shift() 、 splice() 、 sort() 、 reverse() ）； （ ➕ filter() 不会对原数组改变（替换数组） ）\n     * 使用 vue 供对象修改数据的 api（ vue.set() 或者 vm.$set() 上面详细） ；\n\n * ⚠️ 特别注意： vue.set() 或者 vm.$set() 不能给 vm 或者 vm._data （根叔对象）添加属性！\n\n\n# vue 中的 this 指向问题\n\n * 指向「vue 实例对象」：在 new vue(options) 中的配置： data 函数、 methods 、 watch 、 computed 中的函数。\n * 指向「vuecomponent 实例对象」：在组件中的配置： data 函数、 methods 、 watch 、 computed 中的函数。\n\n⚠️： 「vuecomponent 实例对象」 简称为 vc 对象；「vue 实例对象」简称为 vm 对象；",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"✨ Vue 实用实例",frontmatter:{title:"✨ Vue 实用实例",date:"2021-11-20T22:31:52.000Z",permalink:"/pages/905c0c/",categories:["前端笔记","Vue 笔记"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/10.%20%F0%9F%8C%A7%EF%B8%8F%20Vue%20%E5%9F%BA%E7%A1%80/30.%20%E2%9C%A8%20Vue%20%E5%AE%9E%E7%94%A8%E5%AE%9E%E4%BE%8B.html",relativePath:"105. 🏃 前端核心框架/10. 🌧️ Vue 基础/30. ✨ Vue 实用实例.md",key:"v-224eac3e",path:"/pages/905c0c/",headers:[{level:2,title:"Vue 中的表单收集中数据双向绑定",slug:"vue-中的表单收集中数据双向绑定",normalizedTitle:"vue 中的表单收集中数据双向绑定",charIndex:2},{level:2,title:"生成对象的标识 id",slug:"生成对象的标识-id",normalizedTitle:"生成对象的标识 id",charIndex:523}],headersStr:"Vue 中的表单收集中数据双向绑定 生成对象的标识 id",content:"# Vue 中的表单收集中数据双向绑定\n\n原理： 数据的双向绑定（ v-model ） 实现；\n\n * 对于输入框，直接收集的是用户输入的 value 值\n * 对于单选 radio 控件，收集给标签配置的 value 值（同一组 radio 控件使用 name 分组）\n * 对于多选 checkbox 控件：\n   * 没有配置 input 的 value ，则收集的是是否勾选情况 checked （一般为勾选 true 或者未勾选 false ）；\n   * 对于 input 有配置 value 值，则收集的是 value 组成的数组；（⚠️ 绑定的 data 也要为数组类型）；\n\n> v-model 中的三个修饰符：\n> \n>  * trim ：对输入字符串的「首尾空格字符」过滤；\n>  * number ：对输入字符串转为有效数字（一般配合 input 的类型为 number 使用）（对于 3a0 只取 3 ）；\n>  * lazy ：当对当前表单控件失去焦点时才会收集数据（常用于长文字 textarea 收集）；\n\n🍞 更多使用表单控件的例子查看官网文档：表单输入绑定 — Vue.js (vuejs.org)\n\n\n# 生成对象的标识 id\n\n可选择使用 uuid ，精简版时使用 nanoid\n\n安装 nanoid ：\n\n$ npm i nanoid\n\n\n1\n\n\n引入 nanoid 库：\n\nimport {nanoid} from 'nanoid'\n\n\n1\n\n\n使用 nanoid ，在要用的属性值中使用 nanoid() ，如： id: nanoid() ;",normalizedContent:"# vue 中的表单收集中数据双向绑定\n\n原理： 数据的双向绑定（ v-model ） 实现；\n\n * 对于输入框，直接收集的是用户输入的 value 值\n * 对于单选 radio 控件，收集给标签配置的 value 值（同一组 radio 控件使用 name 分组）\n * 对于多选 checkbox 控件：\n   * 没有配置 input 的 value ，则收集的是是否勾选情况 checked （一般为勾选 true 或者未勾选 false ）；\n   * 对于 input 有配置 value 值，则收集的是 value 组成的数组；（⚠️ 绑定的 data 也要为数组类型）；\n\n> v-model 中的三个修饰符：\n> \n>  * trim ：对输入字符串的「首尾空格字符」过滤；\n>  * number ：对输入字符串转为有效数字（一般配合 input 的类型为 number 使用）（对于 3a0 只取 3 ）；\n>  * lazy ：当对当前表单控件失去焦点时才会收集数据（常用于长文字 textarea 收集）；\n\n🍞 更多使用表单控件的例子查看官网文档：表单输入绑定 — vue.js (vuejs.org)\n\n\n# 生成对象的标识 id\n\n可选择使用 uuid ，精简版时使用 nanoid\n\n安装 nanoid ：\n\n$ npm i nanoid\n\n\n1\n\n\n引入 nanoid 库：\n\nimport {nanoid} from 'nanoid'\n\n\n1\n\n\n使用 nanoid ，在要用的属性值中使用 nanoid() ，如： id: nanoid() ;",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌘 Vue 组件化编程概念",frontmatter:{title:"🌘 Vue 组件化编程概念",date:"2022-03-11T16:08:47.000Z",permalink:"/pages/5935fd/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 组件化编程"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/01.%20%F0%9F%8C%98%20Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/01. 🌘 Vue 组件化编程概念.md",key:"v-146a511a",path:"/pages/5935fd/",headers:[{level:3,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:51},{level:3,title:"组件",slug:"组件",normalizedTitle:"组件",charIndex:159},{level:3,title:"模块化和组件化",slug:"模块化和组件化",normalizedTitle:"模块化和组件化",charIndex:262},{level:2,title:"非单文件组件",slug:"非单文件组件",normalizedTitle:"非单文件组件",charIndex:352},{level:2,title:"单文件组件",slug:"单文件组件",normalizedTitle:"单文件组件",charIndex:353}],headersStr:"模块 组件 模块化和组件化 非单文件组件 单文件组件",content:"传统方式编写网页应用中存在的问题：\n\n * 依赖关系混乱、不好维护；\n * 代码复用率不高；\n\n\n# 模块\n\n * 理解：向外提供特定功能的 JavaScript 的程序，一般是一个 JavaScript 文件；\n * 作用：复用、简化 JavaScript 的编写，提高 JavaScript 运行的效率；\n\n\n# 组件\n\n * 理解：实现局部（最小化、特定、可嵌套使用）功能效果的代码和资源的集合（HTML/CSS/JavaScript 等静态资源）\n * 作用：复用编码、简化项目编码，提高网页应用运行效率；\n\n\n# 模块化和组件化\n\n * 当应用中的 JavaScript 以模块来编写，则这个应用是模块化应用；\n * 当应用中的功能都是多组件方式来编写的，则这个应用是一个组件化应用；\n\n\n# 非单文件组件\n\n * 理解：一个组件中可以包含有 n 个组件；\n\n⭐️ 使用组件的三大步骤：\n\n 1. 定义组件（创建组件）\n 2. 注册组件（通常在局部注册）\n 3. 使用组件（在模版中写组件标签）\n\n定义组件的方法：\n\n * 语法： Vue.extend(options) 创建， options 和 new Vue(options) 时配置的几乎一样但有区别；\n * options 配置项的区别：\n   * el ：一定不可以写 el 配置，最终所有的组件都要经过一个 vm 实例管理，由 vm 决定服务哪个容器；\n   * data ：一定要写成函数式，以使每个示例可以维护一份被返回的对象独立的拷贝，避免组件被复用时数据存在引用关系；\n * 使用 template 配置组件的结构；\n\n注册组件的方法：\n\n * 局部注册语法： new Vue({components:{}}) 中 components 配置项配置组件；\n * 全局注册（少用）语法： Vue.component('组件名',组件) ;\n\n使用组件（编写组件标签）： <组件名></组件名> ；\n\n⚠️ 组件注意事项：\n\n * 组件的命名：\n   \n   * 一个单词组成：可以首字母小写或则大写；\n   * 多个单词组成：\n     * 使用 kebab-case 命名法： my-school ；\n     * 使用大驼峰命名法： MySchool （⚠️需要 Vue 脚手架支持）；\n   * 组件命名尽可能回避 HTML 中已有的元素名称；\n   * 可以使用 name 配置指定组件在开发者工具中显示的名称；\n\n * 组件标签的用法：\n   \n   * 双标签写法： <school></school>\n   * 单标签闭合写法： <school/> （⚠️不能使用在脚手架中，否则在该组件后的后续组件不能渲染）\n\n * 组件的简写方法：\n   \n   const school = Vue.extend({options}) \n   // ==> \n   const school = { options }\n   \n   \n   1\n   2\n   3\n   \n\n⭐️ 关于组件本质 VueComponent ：\n\n * 以上示例如 school 组件本质是一个名为 VueComponent 的构造函数，且是通过 Vue.extend 生成的；\n * 只需要使用标签 <school/> 或者 <school></school> ，Vue 解析时就会帮我们创建 school 组件的示例对象；（即 Vue 执行 new VueComponent(options） （每使用一次就会创建一次）\n * ⚠️ 特别注意：每次调用 Vue.extend 时，返回的都是一个 VueComponent ；\n\n注意\n\n⭐️ 重要的内置关系 🔗 尚硅谷 - Vue 重要的内置关系：\n\nVueComponent.prototype.__proto__ === Vue.prototype\n\n * Vue 与 VueComponent 的关系：\n   \n   \n\n * ⭐️ 此关系作用：让组件实例对象（vc）可以访问 Vue 原型上的属性、方法；\n\n\n# 单文件组件\n\n * 理解： 一个文件中只包含有 1 个组件；\n\n * 文件命名注意：与组件命名 name 相同。\n\n * 🔗 基本使用：\n   \n   \n   \n   1. 定义组件： Component.vue\n   2. 汇总所有组件： App.vue\n   3. 入口文件 main.js 定义 vm 示例，注册 App 组件\n   4. 容器 index.html",normalizedContent:"传统方式编写网页应用中存在的问题：\n\n * 依赖关系混乱、不好维护；\n * 代码复用率不高；\n\n\n# 模块\n\n * 理解：向外提供特定功能的 javascript 的程序，一般是一个 javascript 文件；\n * 作用：复用、简化 javascript 的编写，提高 javascript 运行的效率；\n\n\n# 组件\n\n * 理解：实现局部（最小化、特定、可嵌套使用）功能效果的代码和资源的集合（html/css/javascript 等静态资源）\n * 作用：复用编码、简化项目编码，提高网页应用运行效率；\n\n\n# 模块化和组件化\n\n * 当应用中的 javascript 以模块来编写，则这个应用是模块化应用；\n * 当应用中的功能都是多组件方式来编写的，则这个应用是一个组件化应用；\n\n\n# 非单文件组件\n\n * 理解：一个组件中可以包含有 n 个组件；\n\n⭐️ 使用组件的三大步骤：\n\n 1. 定义组件（创建组件）\n 2. 注册组件（通常在局部注册）\n 3. 使用组件（在模版中写组件标签）\n\n定义组件的方法：\n\n * 语法： vue.extend(options) 创建， options 和 new vue(options) 时配置的几乎一样但有区别；\n * options 配置项的区别：\n   * el ：一定不可以写 el 配置，最终所有的组件都要经过一个 vm 实例管理，由 vm 决定服务哪个容器；\n   * data ：一定要写成函数式，以使每个示例可以维护一份被返回的对象独立的拷贝，避免组件被复用时数据存在引用关系；\n * 使用 template 配置组件的结构；\n\n注册组件的方法：\n\n * 局部注册语法： new vue({components:{}}) 中 components 配置项配置组件；\n * 全局注册（少用）语法： vue.component('组件名',组件) ;\n\n使用组件（编写组件标签）： <组件名></组件名> ；\n\n⚠️ 组件注意事项：\n\n * 组件的命名：\n   \n   * 一个单词组成：可以首字母小写或则大写；\n   * 多个单词组成：\n     * 使用 kebab-case 命名法： my-school ；\n     * 使用大驼峰命名法： myschool （⚠️需要 vue 脚手架支持）；\n   * 组件命名尽可能回避 html 中已有的元素名称；\n   * 可以使用 name 配置指定组件在开发者工具中显示的名称；\n\n * 组件标签的用法：\n   \n   * 双标签写法： <school></school>\n   * 单标签闭合写法： <school/> （⚠️不能使用在脚手架中，否则在该组件后的后续组件不能渲染）\n\n * 组件的简写方法：\n   \n   const school = vue.extend({options}) \n   // ==> \n   const school = { options }\n   \n   \n   1\n   2\n   3\n   \n\n⭐️ 关于组件本质 vuecomponent ：\n\n * 以上示例如 school 组件本质是一个名为 vuecomponent 的构造函数，且是通过 vue.extend 生成的；\n * 只需要使用标签 <school/> 或者 <school></school> ，vue 解析时就会帮我们创建 school 组件的示例对象；（即 vue 执行 new vuecomponent(options） （每使用一次就会创建一次）\n * ⚠️ 特别注意：每次调用 vue.extend 时，返回的都是一个 vuecomponent ；\n\n注意\n\n⭐️ 重要的内置关系 🔗 尚硅谷 - vue 重要的内置关系：\n\nvuecomponent.prototype.__proto__ === vue.prototype\n\n * vue 与 vuecomponent 的关系：\n   \n   \n\n * ⭐️ 此关系作用：让组件实例对象（vc）可以访问 vue 原型上的属性、方法；\n\n\n# 单文件组件\n\n * 理解： 一个文件中只包含有 1 个组件；\n\n * 文件命名注意：与组件命名 name 相同。\n\n * 🔗 基本使用：\n   \n   \n   \n   1. 定义组件： component.vue\n   2. 汇总所有组件： app.vue\n   3. 入口文件 main.js 定义 vm 示例，注册 app 组件\n   4. 容器 index.html",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌈 Vue 组件基础",frontmatter:{title:"🌈 Vue 组件基础",date:"2022-06-30T00:05:51.000Z",permalink:"/pages/f7e44a/",categories:["🏃 前端核心框架","⛈ Vue 组件编程"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/02.%F0%9F%8C%88%20Vue%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/02.🌈 Vue 组件注册.md",key:"v-1377e2ab",path:"/pages/f7e44a/",headers:[{level:2,title:"组件的命名方式",slug:"组件的命名方式",normalizedTitle:"组件的命名方式",charIndex:23},{level:2,title:"注册组件",slug:"注册组件",normalizedTitle:"注册组件",charIndex:391},{level:3,title:"全局注册组件",slug:"全局注册组件",normalizedTitle:"全局注册组件",charIndex:400},{level:3,title:"局部注册组件",slug:"局部注册组件",normalizedTitle:"局部注册组件",charIndex:798},{level:3,title:"模块管理组件",slug:"模块管理组件",normalizedTitle:"模块管理组件",charIndex:883},{level:3,title:"自动导入基础组件",slug:"自动导入基础组件",normalizedTitle:"自动导入基础组件",charIndex:1224}],headersStr:"组件的命名方式 注册组件 全局注册组件 局部注册组件 模块管理组件 自动导入基础组件",content:"> 重读 Vue 官方文档写的笔记。\n\n\n# 组件的命名方式\n\n两种命名方式：\n\n * kebab-case：\n   \n   Vue.component('my-component-name', { /* ... */ })\n   \n   \n   1\n   \n   \n   使用短横线分隔命名时，必须引用这个自定义元素时也使用相同的命名 ，例如 <my-component-name> 。\n\n * PascalCase：\n   \n   Vue.component('MyComponent', { /* ... */ })\n   \n   \n   1\n   \n   \n   使用首字母大写命名，引用这个自定义元素时两种命名方法都可以使用，如 <MyComponent> 以及 <my-component> 。但是直接在 DOM 种使用时只有 kebab-case 命名有效。\n\n\n# 注册组件\n\n\n# 全局注册组件\n\n全局注册的组件可以在任何新创建的 Vue 根实例的模版中使用。在所有的子组件中也是如此，子组件中也可以使用全局注册的组件。\n\n🌰 例子：\n\nVue.component('my-component-a', {\n  // options\n})\nVue.component('my-component-b', {\n  // options\n})\n\nnew Vue({ el: '#app' })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<div id=\"app\">\n  <my-component-a></my-component-a>\n  <my-component-b></my-component-b>\n</div>\n\n\n1\n2\n3\n4\n\n\n提示\n\n全局注册意味着不管有无使用这个组件，最后使用打包工具（如 webpack） 构建项目时都会被包含在最终构建的结果当中。\n\n\n# 局部注册组件\n\n组件可以在一个普通的 JavaScript 中定义。并且在 components 选项中选择要使用的组件。\n\n局部注册的组件在其子组件中不可用。\n\n\n# 模块管理组件\n\n一般在项目的 src 创建 components 目录，将每个组件放置在各自的文件中。然后需要在局部注册组件之前，导入要使用的组件到当前的文件中。\n\n🌰 例子：\n\n有已经定义好的组件 ComponentA 和 ComponentB ，在 ComponentC 中导入这两个组件并且局部注册：\n\nimport ComponentA from './ComponentA'\nimport ComponentC from './ComponentB'\n\nexport default {\n  components: {\n    ComponentA,\n    ComponentC\n  },\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 自动导入基础组件\n\n一般许多基础组件需要在各个组件中频繁使用，例如 按钮、输入框、图标等基础组件，这样会导致局部注册组件的列表很长。\n\n可以使用 require.context 全局注册这些组件，然后再应用的入口文件（ src/main.js ） 全局导入这些基础组件的注册。\n\nimport Vue from 'vue'\nimport upperFirst from 'lodash/upperFirst'\nimport camelCase from 'lodash/camelCase'\n\nconst requireComponent = require.context(\n  // 其组件目录的相对路径\n  './components',\n  // 是否查询其子目录\n  false,\n  // 匹配基础组件文件名的正则表达式\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(fileName => {\n  // 获取组件配置\n  const componentConfig = requireComponent(fileName)\n\n  // 获取组件的 PascalCase 命名\n  const componentName = upperFirst(\n    camelCase(\n      // 获取和目录深度无关的文件名\n      fileName\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n  // 全局注册组件\n  Vue.component(\n    componentName,\n    // 如果这个组件选项是通过 `export default` 导出的，\n    // 那么就会优先使用 `.default`，\n    // 否则回退到使用模块的根。\n    componentConfig.default || componentConfig\n  )\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n详细参考：vue-enterprise-boilerplate/src/components at main · bencodezen/vue-enterprise-boilerplate (github.com) / _global.js 全局注册基础组件。\n\n注意\n\n全局注册组件必须要在 Vue 根实例创建（ new Vue ）之间发生。",normalizedContent:"> 重读 vue 官方文档写的笔记。\n\n\n# 组件的命名方式\n\n两种命名方式：\n\n * kebab-case：\n   \n   vue.component('my-component-name', { /* ... */ })\n   \n   \n   1\n   \n   \n   使用短横线分隔命名时，必须引用这个自定义元素时也使用相同的命名 ，例如 <my-component-name> 。\n\n * pascalcase：\n   \n   vue.component('mycomponent', { /* ... */ })\n   \n   \n   1\n   \n   \n   使用首字母大写命名，引用这个自定义元素时两种命名方法都可以使用，如 <mycomponent> 以及 <my-component> 。但是直接在 dom 种使用时只有 kebab-case 命名有效。\n\n\n# 注册组件\n\n\n# 全局注册组件\n\n全局注册的组件可以在任何新创建的 vue 根实例的模版中使用。在所有的子组件中也是如此，子组件中也可以使用全局注册的组件。\n\n🌰 例子：\n\nvue.component('my-component-a', {\n  // options\n})\nvue.component('my-component-b', {\n  // options\n})\n\nnew vue({ el: '#app' })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<div id=\"app\">\n  <my-component-a></my-component-a>\n  <my-component-b></my-component-b>\n</div>\n\n\n1\n2\n3\n4\n\n\n提示\n\n全局注册意味着不管有无使用这个组件，最后使用打包工具（如 webpack） 构建项目时都会被包含在最终构建的结果当中。\n\n\n# 局部注册组件\n\n组件可以在一个普通的 javascript 中定义。并且在 components 选项中选择要使用的组件。\n\n局部注册的组件在其子组件中不可用。\n\n\n# 模块管理组件\n\n一般在项目的 src 创建 components 目录，将每个组件放置在各自的文件中。然后需要在局部注册组件之前，导入要使用的组件到当前的文件中。\n\n🌰 例子：\n\n有已经定义好的组件 componenta 和 componentb ，在 componentc 中导入这两个组件并且局部注册：\n\nimport componenta from './componenta'\nimport componentc from './componentb'\n\nexport default {\n  components: {\n    componenta,\n    componentc\n  },\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 自动导入基础组件\n\n一般许多基础组件需要在各个组件中频繁使用，例如 按钮、输入框、图标等基础组件，这样会导致局部注册组件的列表很长。\n\n可以使用 require.context 全局注册这些组件，然后再应用的入口文件（ src/main.js ） 全局导入这些基础组件的注册。\n\nimport vue from 'vue'\nimport upperfirst from 'lodash/upperfirst'\nimport camelcase from 'lodash/camelcase'\n\nconst requirecomponent = require.context(\n  // 其组件目录的相对路径\n  './components',\n  // 是否查询其子目录\n  false,\n  // 匹配基础组件文件名的正则表达式\n  /base[a-z]\\w+\\.(vue|js)$/\n)\n\nrequirecomponent.keys().foreach(filename => {\n  // 获取组件配置\n  const componentconfig = requirecomponent(filename)\n\n  // 获取组件的 pascalcase 命名\n  const componentname = upperfirst(\n    camelcase(\n      // 获取和目录深度无关的文件名\n      filename\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n  // 全局注册组件\n  vue.component(\n    componentname,\n    // 如果这个组件选项是通过 `export default` 导出的，\n    // 那么就会优先使用 `.default`，\n    // 否则回退到使用模块的根。\n    componentconfig.default || componentconfig\n  )\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n详细参考：vue-enterprise-boilerplate/src/components at main · bencodezen/vue-enterprise-boilerplate (github.com) / _global.js 全局注册基础组件。\n\n注意\n\n全局注册组件必须要在 vue 根实例创建（ new vue ）之间发生。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌊 Vue Prop",frontmatter:{title:"🌊 Vue Prop",date:"2022-07-01T16:29:10.000Z",permalink:"/pages/50df35/",categories:["🏃 前端核心框架","⛈ Vue 组件编程"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/10.%20%F0%9F%8C%8A%20Vue%20Prop.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/10. 🌊 Vue Prop.md",key:"v-17acde74",path:"/pages/50df35/",headers:[{level:2,title:"Prop",slug:"prop",normalizedTitle:"prop",charIndex:3},{level:3,title:"Prop 的大小写",slug:"prop-的大小写",normalizedTitle:"prop 的大小写",charIndex:514},{level:3,title:"Prop 的类型",slug:"prop-的类型",normalizedTitle:"prop 的类型",charIndex:849},{level:3,title:"传入静态或者动态 Prop",slug:"传入静态或者动态-prop",normalizedTitle:"传入静态或者动态 prop",charIndex:1287},{level:2,title:"Prop 是单向数据流",slug:"prop-是单向数据流",normalizedTitle:"prop 是单向数据流",charIndex:1632},{level:2,title:"Prop 的类型验证",slug:"prop-的类型验证",normalizedTitle:"prop 的类型验证",charIndex:2007}],headersStr:"Prop Prop 的大小写 Prop 的类型 传入静态或者动态 Prop Prop 是单向数据流 Prop 的类型验证",content:"使用 Prop 可以向子组件传递数据。\n\n\n# Prop\n\n这是一个可以在组件注册时自定义的特性。当一个值传递给一个组件的 prop 特性（Attribute）时，就变成了这个组件的属性（Property）。\n\n一个组件默认可以拥有任意数量的 Prop，任何值都可以传递给 Prop。然后再组件实例当中，可以通过 Prop 列表访问这个值，就像访问 data 中的值。\n\n🌰 例子：\n\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n\n\n1\n2\n3\n4\n\n\n<div id=\"blog-post-demo\" class=\"demo\">\n  <blog-post title=\"My journey with Vue\"></blog-post>\n  <blog-post title=\"Blogging with Vue\"></blog-post>\n  <blog-post title=\"Why Vue is so fun\"></blog-post>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n\n# Prop 的大小写\n\n由于 HTML 中的 特性 Attribute 命名方式 大小写不敏感，浏览器会讲所有大写的字符解释为小写字符。\n\n规范：Prop 名如果为 camelCase 驼峰命名法，在模版中需要使用其等价的 kebab-case 短横线分隔命名。\n\n🌰 例子：\n\nVue.component('blog-post', {\n  // 在 JavaScript 中是 camelCase 的\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n\n\n1\n2\n3\n4\n5\n\n\n<blog-post post-title=\"hello!\"></blog-post>\n\n\n1\n\n\n\n# Prop 的类型\n\n当没有指定 Prop 的类型时，可以简化 Prop 的列表写为 字符串列表：\n\nprops: ['title', 'likes', 'isPublished', 'commentIds', 'author']\n\n\n1\n\n\n如果希望每个 prop 都有指定的值类型。可以以对象的形式列出 prop。property 的名称和值分别是 prop 各自的名称和类型。当传送的 Prop 类型不相符合时，浏览器的控制台会报错。\n\n🌰 例子：\n\nprops: {\n  title: String,\n\tlikes: Numebr,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 传入静态或者动态 Prop\n\n通常可以传送给 prop 静态的值：\n\n<blog-post title=\"My journey with Vue\"></blog-post>\n\n\n1\n\n\n此时组件中接收到的是一个普通的字符串。\n\n要动态传送不同类型的值，需要使用到 v-bind ，传入一个 JavaScript 表达式。更多的类型参照 Prop — Vue.js (vuejs.org)。\n\n🌰 例子：\n\n<blog-post :title=\"post.title\"></blog-post>\n\n\n1\n\n\n或者拼接：\n\n<blog-post :title=\"post.title + ' by ' + post.author.name\"\n></blog-post>\n\n\n1\n2\n\n\n\n# Prop 是单向数据流\n\n利用 Prop 可以实现 父组件传送数据到子组件。但是不可以反过来，这样防止子组件意外变更父组件的状态，导致应用的数据流向不明。因为，每当父组件发生变更，子组件的所有 prop 都会刷新为最新的值，如果子组件内部改变 prop 的值。\n\n注意，JavaScript 对象和数组是通过引用传入的，所以对于一个数组或者对象的 prop 来说，子组件中更改变更这个对象可能会影响到父组件 ⚠️。\n\n常见的可能会修改 Prop 的情况：\n\n * 父组件传送 初始值 给子组件使用，子组件希望这个初始值能够作为一个变量数据修改。此时可以将这个初始值定义到 data property（定义一个新的 data 变量）。\n\n * 子组件接收到来自父组件的原始数据，子组件需要对这个原始数据转换。最好使用这个数据定义一个计算属性。\n\n\n# Prop 的类型验证\n\nProp 的类型 type 可以是下列原生构造函数中的一个：\n\n * String\n * Number\n * Boolean\n * Array\n * Object\n * Date\n * Function\n * Symbol\n\ntype 可以是一个自定义构造 has 农户，并且通过 insanceof 检查确认这个类型。\n\n🌰 例子：\n\nfunction Person (firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\n\n\n1\n2\n3\n4\n\n\nVue.component('blog-post', {\n  props: {\n    author: Person\n  }\n})\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"使用 prop 可以向子组件传递数据。\n\n\n# prop\n\n这是一个可以在组件注册时自定义的特性。当一个值传递给一个组件的 prop 特性（attribute）时，就变成了这个组件的属性（property）。\n\n一个组件默认可以拥有任意数量的 prop，任何值都可以传递给 prop。然后再组件实例当中，可以通过 prop 列表访问这个值，就像访问 data 中的值。\n\n🌰 例子：\n\nvue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n\n\n1\n2\n3\n4\n\n\n<div id=\"blog-post-demo\" class=\"demo\">\n  <blog-post title=\"my journey with vue\"></blog-post>\n  <blog-post title=\"blogging with vue\"></blog-post>\n  <blog-post title=\"why vue is so fun\"></blog-post>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n\n# prop 的大小写\n\n由于 html 中的 特性 attribute 命名方式 大小写不敏感，浏览器会讲所有大写的字符解释为小写字符。\n\n规范：prop 名如果为 camelcase 驼峰命名法，在模版中需要使用其等价的 kebab-case 短横线分隔命名。\n\n🌰 例子：\n\nvue.component('blog-post', {\n  // 在 javascript 中是 camelcase 的\n  props: ['posttitle'],\n  template: '<h3>{{ posttitle }}</h3>'\n})\n\n\n1\n2\n3\n4\n5\n\n\n<blog-post post-title=\"hello!\"></blog-post>\n\n\n1\n\n\n\n# prop 的类型\n\n当没有指定 prop 的类型时，可以简化 prop 的列表写为 字符串列表：\n\nprops: ['title', 'likes', 'ispublished', 'commentids', 'author']\n\n\n1\n\n\n如果希望每个 prop 都有指定的值类型。可以以对象的形式列出 prop。property 的名称和值分别是 prop 各自的名称和类型。当传送的 prop 类型不相符合时，浏览器的控制台会报错。\n\n🌰 例子：\n\nprops: {\n  title: string,\n\tlikes: numebr,\n  ispublished: boolean,\n  commentids: array,\n  author: object,\n  callback: function,\n  contactspromise: promise // or any other constructor\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 传入静态或者动态 prop\n\n通常可以传送给 prop 静态的值：\n\n<blog-post title=\"my journey with vue\"></blog-post>\n\n\n1\n\n\n此时组件中接收到的是一个普通的字符串。\n\n要动态传送不同类型的值，需要使用到 v-bind ，传入一个 javascript 表达式。更多的类型参照 prop — vue.js (vuejs.org)。\n\n🌰 例子：\n\n<blog-post :title=\"post.title\"></blog-post>\n\n\n1\n\n\n或者拼接：\n\n<blog-post :title=\"post.title + ' by ' + post.author.name\"\n></blog-post>\n\n\n1\n2\n\n\n\n# prop 是单向数据流\n\n利用 prop 可以实现 父组件传送数据到子组件。但是不可以反过来，这样防止子组件意外变更父组件的状态，导致应用的数据流向不明。因为，每当父组件发生变更，子组件的所有 prop 都会刷新为最新的值，如果子组件内部改变 prop 的值。\n\n注意，javascript 对象和数组是通过引用传入的，所以对于一个数组或者对象的 prop 来说，子组件中更改变更这个对象可能会影响到父组件 ⚠️。\n\n常见的可能会修改 prop 的情况：\n\n * 父组件传送 初始值 给子组件使用，子组件希望这个初始值能够作为一个变量数据修改。此时可以将这个初始值定义到 data property（定义一个新的 data 变量）。\n\n * 子组件接收到来自父组件的原始数据，子组件需要对这个原始数据转换。最好使用这个数据定义一个计算属性。\n\n\n# prop 的类型验证\n\nprop 的类型 type 可以是下列原生构造函数中的一个：\n\n * string\n * number\n * boolean\n * array\n * object\n * date\n * function\n * symbol\n\ntype 可以是一个自定义构造 has 农户，并且通过 insanceof 检查确认这个类型。\n\n🌰 例子：\n\nfunction person (firstname, lastname) {\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\n\n1\n2\n3\n4\n\n\nvue.component('blog-post', {\n  props: {\n    author: person\n  }\n})\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌕 Vue 脚手架案例",frontmatter:{title:"🌕 Vue 脚手架案例",date:"2022-04-01T20:49:11.000Z",permalink:"/pages/fce04e/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 脚手架"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/100.%20%F0%9F%8C%95%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/100. 🌕 Vue 组件编程案例.md",key:"v-7a68118b",path:"/pages/fce04e/",headers:[{level:2,title:"🌰 TodoList 基础框架",slug:"🌰-todolist-基础框架",normalizedTitle:"🌰 todolist 基础框架",charIndex:30},{level:3,title:"实现静态组件",slug:"实现静态组件",normalizedTitle:"实现静态组件",charIndex:51},{level:3,title:"展示动态数据",slug:"展示动态数据",normalizedTitle:"展示动态数据",charIndex:178},{level:3,title:"初始化列表",slug:"初始化列表",normalizedTitle:"初始化列表",charIndex:292},{level:3,title:"添加项目功能",slug:"添加项目功能",normalizedTitle:"添加项目功能",charIndex:992},{level:3,title:"勾选状态功能",slug:"勾选状态功能",normalizedTitle:"勾选状态功能",charIndex:3571},{level:3,title:"删除项目功能",slug:"删除项目功能",normalizedTitle:"删除项目功能",charIndex:4528},{level:3,title:"底部统计与清除已完成项目功能",slug:"底部统计与清除已完成项目功能",normalizedTitle:"底部统计与清除已完成项目功能",charIndex:4995},{level:3,title:"TodoList 案例总结",slug:"todolist-案例总结",normalizedTitle:"todolist 案例总结",charIndex:6573},{level:2,title:"🌰 TodoList 案例完善",slug:"🌰-todolist-案例完善",normalizedTitle:"🌰 todolist 案例完善",charIndex:7047},{level:3,title:"使用浏览器本地存储",slug:"使用浏览器本地存储",normalizedTitle:"使用浏览器本地存储",charIndex:7068},{level:3,title:"使用自定义事件",slug:"使用自定义事件",normalizedTitle:"使用自定义事件",charIndex:7741},{level:3,title:"使用全局事件总线",slug:"使用全局事件总线",normalizedTitle:"使用全局事件总线",charIndex:9030},{level:3,title:"使用消息订阅与发布",slug:"使用消息订阅与发布",normalizedTitle:"使用消息订阅与发布",charIndex:9814},{level:3,title:"编辑项目功能",slug:"编辑项目功能",normalizedTitle:"编辑项目功能",charIndex:10788},{level:3,title:"添加动画与过渡效果",slug:"添加动画与过渡效果",normalizedTitle:"添加动画与过渡效果",charIndex:13079}],headersStr:"🌰 TodoList 基础框架 实现静态组件 展示动态数据 初始化列表 添加项目功能 勾选状态功能 删除项目功能 底部统计与清除已完成项目功能 TodoList 案例总结 🌰 TodoList 案例完善 使用浏览器本地存储 使用自定义事件 使用全局事件总线 使用消息订阅与发布 编辑项目功能 添加动画与过渡效果",content:'> 🔗 回顾组件化编程的流程：Vue 组件化编程\n\n\n# 🌰 TodoList 基础框架\n\n\n# 实现静态组件\n\n拆分组件，按照局部功能或者位置划分：\n\n * TodoHeader.vue\n\n * TodoList.vue\n\n * TodoItem.vue\n\n * TodoFooter.vue\n\n完成 TodoList 的静态页面效果。\n\n\n\n\n# 展示动态数据\n\nTodoList 的项目数据的展示：\n\n * 一整个列表可以是一个数组；\n * 每个项目可以是一个对象，包括项目的编号、名称、状态。\n\n数据保存在哪个位置的组件？\n\n * List 组件存储项目的数组。\n\n\n# 初始化列表\n\n * 使用 TodoList 组件展示 Todo 项目，所以可以在 TodoList 中存放相关的数据：\n\ndata() {\n  return {\n    todos: [\n      {id: \'001\', title: \'吃饭\', done: true},\n      {id: \'002\', title: \'学习\', done: false},\n      {id: \'003\', title: \'睡觉\', done: true},\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后在 <Template> 中使用 v-for 循环：\n\n<template>\n  <ul class="todo-main">\n    <TodoItem v-for="todo in todos" :key="todo.id" :todoObj="todo"/>\n  </ul>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n使用 :todoObj 传送 todo 对象数据到 TodoItem 。\n\n * 同时 TodoItem 接收 TodoList 中配置的数据：\n\nprops: [\'todoObj\']\n\n\n1\n\n\n<template>\n  <li>\n    <input type="checkbox" :checked="todoObj.done">\n    <span>{{ todoObj.title }}</span>\n  </li>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用 :checked 动态根据数据发生变化。\n\n\n# 添加项目功能\n\n在 TodoHeader 中，输入框中使用 @keyup.enter 绑定按下回车键的事件为方法 add() ：\n\n<input type="text" placeholder="请输入你的任务名称，按回车键确认" @keyup.enter="add"/>\n\n\n1\n\n\n将用户输入的数据包装为一个 todo 对象（使用 nanoid 库生成一个随机的 id ）\n\nadd(e) {\n  const todo = {\n    id: nanoid(), title: e.target.value, done: false\n  }\n  // console.log(todo)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n由于 TodoHeader 与 TodoList 的关系是平行（兄弟）关系，迄今为止，所以在此先使用最初级的方法，将共同的数据 todos 放在共同的组件 App 中：\n\n\n\n点击查看\n * 首先将 todos 转移到 TodoHeader ：\n\nexport default {\n  name: "App",\n  components: {TodoHeader, TodoList, TodoFooter},\n  data() {\n    return {\n      todos: [\n        {id: \'001\', title: \'吃饭\', done: true},\n        {id: \'002\', title: \'学习\', done: false},\n        {id: \'003\', title: \'睡觉\', done: true},\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n使用 :todos=‘todos’ 传送：\n\n<template>\n  <div id="root">\n    <div class="todo-container">\n      <div class="todo-wrap">\n        <TodoHeader/>\n        <TodoList :todos="todos"/>\n        <TodoFooter/>\n      </div>\n    </div>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在 TodoList 中使用 props 接收：\n\nprops:[\'todos\']\n\n\n1\n\n\n<template>\n  <ul class="todo-main">\n    <TodoItem v-for="todo in todos" :key="todo.id" :todoObj="todo"/>\n  </ul>\n</template>\n\n\n1\n2\n3\n4\n5\n\n * 在 App 中写一个准备要传送到 TodoHeader 中要使用的方法：\n\n methods: {\n  addTodo(todo){\n    this.todos.unshift(todo);\n  }\n\n\n1\n2\n3\n4\n\n\n<TodoHeader :addTodo="addTodo"/>\n\n\n1\n\n\n参数 todo 表示要接收来自 TodoHeader 的 todo 对象，在 TodoHeader 中使用 props 接收这个方法，并且调用这个方法，传入输入的 todo 内容：\n\nexport default {\n  name: "TodoHeader",\n  props: [\'addTodo\'],\n  methods: {\n    add(e) {\n      const todo = {\n        id: nanoid(), title: e.target.value, done: false\n      \n      this.addTodo(todo)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 随着在 App 的数据 todos 发生变化，模版中的内容会重新解析，此时 TodoList 收到的 todos 也会随之变化，此时 TodoList 中的模版也会重新解析，这样就实现了增加 todo 项目的功能。\n * 继续完善 TodoHeader 中的细节，给输入的内容是否为空进行判断，并且输入后将输入框清空，为了不操作原生 DOM 元素，把 title 数据进行绑定：\n\n\n\n点击查看\n\n<input type="text" placeholder="请输入你的任务名称，按回车键确认" v-model="title" @keyup.enter="add"/>\n\n\n1\n\n\nexport default {\n  name: "TodoHeader",\n  props: [\'addTodo\'],\n  data() {\n    return {\n      title: \'\'\n    }\n  },\n  methods: {\n    add(e) {\n      // 校验数据\n      if (!this.title.trim()) return alert(\'输入的todo不能为空！\')\n      // 将数据包装为todo对象\n      const todo = {\n        id: nanoid(), title: e.target.value, done: false\n      }\n      // 通知App组件区添加一个todo对象\n      this.addTodo(todo)\n      this.title = \'\' // 请求输入框\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意\n\n注意： App 组件传送的方法 addTodo 与 TodoHeader 中的 methods 命名为 add 必须不能重名。因为 data 、 methods 、 props 的数据届在 vc 实例对象中。\n\n\n# 勾选状态功能\n\n最初始的做法：\n\n点击查看\n\n由于根本上，要操作 todo 对象的组件应该是 App 组件，所以要在 App 中编写方法 checkTodo ，\n\ncheckTodo(id) {\n  this.todos.forEach((todo) => {\n    if (todo.id === id) todo.done = !todo.done\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n\n并且，要获取到勾选的是哪一个项，就在哪一个项中调用此方法。组件的关系是 App > TodoList > TodoItem ，所以 App 要传送此方法给 TodoItem 组件使用，就要一层一层传。\n\n先传给 TodoList ，然后通过 TodoList 传给 TodoItem ， TodoItem 通过 props 接收使用，在 TodoItem 中编写方法获取当前操作的 todo 项目的 id ， 可以使用 @click 或者 @change （更方便），\n\n<input type="checkbox" :checked="todoObj.done" @change="handleCheck(todoObj.id)">\n\n\n1\n\n\nprops: [\'todoObj\', \'checkTodo\'], // 声明接收todo对象\nmethods: {\n  handleCheck(id){\n    // 通知App组件将对应的todo对象的done值取反\n    this.checkTodo(id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n上面 input 标签要实现动态更改 todo 项目的状态，可以想到将两个 :checked 和 @change 结合，使用 v-model 绑定 done 。\n\n<input type="checkbox" v-model="todo.done">\n\n\n1\n\n\n但是此时，在 TodoItem 中修改的值，是来自 props 获取的值，而 Vue 中原则上是不能修改 props 的值，但 Vue 只能监测浅层次的修改，这里修改的是对象里的值， Vue 无法检测得到，虽然可以实现功能，但是为了避免后期对象存储出问题，不建议如此实现。\n\n\n# 删除项目功能\n\n删除功能的实现，重中之重是在要实现删除功能的地方，获取到要删除的项目的 id ：\n\n * 在删除按钮处 TodoItem 组件中，获得 todo.id ，并且添加询问是否删除的判断：\n\n<button class="btn btn-danger" @click="handleDelete(todoObj.id)">删除</button>\n\n\n1\n\n\nhandleDelete(id) {\n  if (confirm("是否删除本todo项目")){\n    this.deleteTodo(id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 App 组件中编写实际删除的方法方法 deleteTodo :\n\ndeleteTodo(id) {\n  this.todos = this.todos.filter((todo) => todo.id !== id)\n}\n\n\n1\n2\n3\n\n\n与要实现勾选状态的功能相同，要将 App 组件中的方法传送给 todoitem ，要通过中间的 TodoList 。\n\n\n# 底部统计与清除已完成项目功能\n\n要统计已完成以及全部的个数：\n\n * 需要 App 组件将 todos 传递给 TodoFooter 组件， TodoFooter 组件使用 props 接收：\n\n<TodoFooter :todos="todos"/>\n\n\n1\n\n\n * 由于要计算已完成的项目的个数，因此可以使用 computed 计算属性：\n   \n   这里可以使用数组的方法 reduce 条件统计函数：\n\ncomputed: {\n  doneTotal() {\n    return this.todos.reduce((pre, todo) => pre + (todo.done ? 1 : 0), 0)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n * 完成细节部分：\n   \n   使代码更加规范，将统计项目的全部个数的数据也加入计算属性：\n\n<span>已完成 {{ doneTotal }} / 全部 {{ total }}  </span>\n\n\n1\n\n\ntotal() {\n  return this.todos.length\n}\n\n\n1\n2\n3\n\n * 展示当前是否全选或者全部未选，这时也使用计算属性，计算完成的数量是否与总数量相等的布尔值，同时注意当前所有项目数量是否大于 0 的情况：\n\nisAll() {\n  return this.doneTotal === this.total && this.total > 0\n}\n\n\n1\n2\n3\n\n * 完成勾选全选或者全不选的功能（全部完成或者全部未完成），此时涉及修改 todos 中的数据，所以在 App 组件中添加方法 checkAllTodo ，参数是 TodoFooter 中获取到的全选或者全不选的布尔值赋值给所有的 todo 项目：\n\ncheckAllTodo(done){\n  this.todos.forEach(todo=>{\n    todo.done = done\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n * 继续完善细节，由于在全选或者全不选框中涉及数据展示（展示当前是否有全选）与数据交互（全选或者全不选的功能），所以此时可以考虑使用 v-model ，这时 v-model 中可以绑定的数据是 isAll ，这是不能再使用简化版的计算属性，需要添加 getter 和 setter 方法，并且此时 set 方法获取的布尔值正是勾选框此时的 checked 值（不再需要获取原生 DOM 值）：\n\nisAll: {\n  get() {\n    return this.doneTotal === this.total && this.total > 0\n  },\n  set(checked) {\n    this.checkAllTodo(value)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（从中可以看出计算属性的用处）\n\n * 完成「清楚已完成任务」按钮功能，绑定一个方法 clearAll ，调用来自 App 组件的方法 clearAllTodo ：\n\n（ App 组件中）：\n\nclearAllTodo() {\n  this.todos = this.todos.filter((todo) => !todo.done)\n}\n\n\n1\n2\n3\n\n\n（ TodoFooter 组件中）：\n\n<button class="btn btn-danger" @click="clearAll">清除已完成任务</button>\n\n\n1\n\n\nclearAll() {\n  if (confirm("是否删除所有已完成的todo项目？")) {\n    this.clearAllTodo()\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# TodoList 案例总结\n\n * Vue 组件化编程流程：\n   \n   * 拆分静态组件： 组件按照功能划分，注意组件的命名；\n   \n   * 实现动态的组件（动态的数据）：\n     \n     * ❓ 数据的类型、名称；\n     * ❓ 数据保存在哪个组件；\n   \n   * 考虑好数据的存放位置，数据是一个组件在用还是多个组件在用：\n     \n     * 一个组件使用：放在组件自身；\n     * 多个组件使用：放在共同的父组件上（状态提升）；\n   \n   * 实现交互：从绑定事件监听开始；\n\n * 运用 props 配置实现组件间通信：\n   \n   * 父组件 ==> 子组件 间通信；\n   * 子组件 ==> 父组件 间通信（要求父先给子一个函数，通过传参获取）；\n\n * ⚠️ 使用 v-model 时要注意， v-model 绑定的值不能是 props 传过来的值（不能修改）。\n   \n   ⚠️ 若 props 传送过来的数值类型是对象，使用 v-model 修改对象中的属性 Vue 不会报错。\n\n\n# 🌰 TodoList 案例完善\n\n\n# 使用浏览器本地存储\n\n🔗 🪐 Vue 浏览器本地存储\n\n要使用浏览器本地存储，就要监测 todos 数据的增删改查的情况，这时可以使用 watch 监视，此时简写版默认监视只是监视对象的第一层；只有开启深度监视才能监视到修改对象中的数据。\n\n * 使用深度监视写入到本地存储：\n   \n   watch: {\n     todos: {\n       deep: true,\n       handler(value) {\n         localStorage.setItem(\'todos\', JSON.stringify(value))\n       }\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   > 只要操作的数据是 todos ，则参数 value 就是最新的 todos 数据，这时将最新的数据存储即可。\n\n * 为了读取存储在浏览器中的数据，在初始化中的 data(){} 配置项中读取：\n   \n   data() {\n       return {\n         todos: JSON.parse(localStorage.getItem(\'todos\')) || []\n       }\n   },\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   注意要考虑到浏览器中没有保存任何数据的情况，此时 Vue 读取到 null 后，后续进行读取的一系列的操作会报错；\n\n\n# 使用自定义事件\n\n🔗 💫 Vue 组件自定义事件\n\n在 TodoHeader 组件添加以及 TodoFooter 删除 todo 项目时，涉及到子组件向父组件通信，此时可以考虑通过使用自定义事件实现。\n\n * 在 App 组件中，给 TodoHeader 绑定自定义事件 addTodo ，事件回调为 addTodo ：\n\n<TodoHeader @addTodo="addTodo"/>\n\n\n1\n\n\nmethods: {\n    addTodo(todo) {\n      this.todos.unshift(todo);\n    },\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 TodoHeader 组件中，触发自定义事件 addTodo ：\n\nmethods: {\n  add(e) {\n    // 校验数据\n    if (!this.title.trim()) return alert(\'输入的todo项目不能为空！\')\n    // 将数据包装为todo对象\n    const todo = {\n      id: nanoid(), title: e.target.value, done: false\n    }\n    // 通知App组件区添加一个todo对象\n    this.$emit(\'addTodo\', todo)\n    this.title = \'\' // 请求输入框\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n * 在 App 组件中，给 TodoFooter 绑定自定义事件 checkAllTodo 、 clearAllTodo ，事件回调为 checkAllTodo 、 clearAllTodo ：\n\n<TodoFooter :todos="todos" @checkAllTodo="checkAllTodo" @clearAllTodo="clearAllTodo"/>\n\n\n1\n\n\n在 TodoFooter 组件中，触发自定义事件 checkAllTodo 、 clearAllTodo ：\n\ncomputed: {\n  isAll: {\n      get() {\n        return this.doneTotal === this.total && this.total > 0\n      },\n      set(checked) {\n        this.$("checkAllTodo", checked)\n      }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nmethods: {\n  clearAll() {\n      if (confirm("是否删除所有已完成的todo项目？")) {\n        this.$emit("clearAllTodo")\n      }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用全局事件总线\n\n在 TodoList 案例中，适合于全局事件总线的是组件 TodoItem 与 App 之间的通信。\n\n * 首先在入口文件 main.js 安装全局事件总线。\n\nnew Vue({\n    el: \'#app\',\n    render: h => h(app),\n    beforeCreate() {\n        Vue.prototype.$bus = this\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 不再使用 TodoList 作为中间组件通信。\n * 在要接收数据的 App 组件中绑定自定义事件，并且在 beforeDestroy 中解绑：\n\nmounted() {\n  this.$bus.$on(\'checkTodo\', this.checkTodo)\n  this.$bus.$on(\'deleteTodo\', this.deleteTodo)\n},\nbeforeDestroy() {\n  this.$bus.$off(\'checkTodo\')\n  this.$bus.$off(\'deleteTodo\')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 在要发送数据的 TodoItem 中，触发该自定义事件：\n\nmethods: {\n  handleCheck(id) {\n    // 通知App组件将对应的todo对象的值取反\n    this.$bus.$emit(\'checkTodo\', id)\n  },\n  handleDelete(id) {\n    if (confirm("是否删除选择的todo项目？")) {\n      this.$bus.$emit(\'deleteTodo\', id)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 使用消息订阅与发布\n\n（其实消息的订阅与发布与全局事件总线相似，更加推荐直接使用在 Vue 中自带的全局事件总线）\n\n以 App 组件与 TodoItem 组件之间的通信：\n\n * 首先在 App 组件引入 pubsub-js ，\n\n在 mounted 中订阅消息：\n\nmounted() {\n  this.checkPubId = pubsub.subscribe(\'checkTodo\', this.checkTodo)\n  this.deletePubId = pubsub.subscribe(\'deleteTodo\', this.deleteTodo)\n}\n\n\n1\n2\n3\n4\n\n\n在 methods 中编写回调函数：\n\nmethods: {\n  \tdeleteTodo(_,id) {\n      this.todos = this.todos.filter((todo) => todo.id !== id)\n  }, \n    checkAllTodo(_,done) {\n      this.todos.forEach(todo => {\n        todo.done = done\n      })\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 这里的回调函数里应该第一个参数要为订阅的消息名称，为了不出现定义了参数而没有使用的情况而导致报错，这里可以使用 _ 占位。\n\n在 beforeDestroy 中取消订阅：\n\nbeforeDestroy() {\n  pubsub.unsubscribe(this.checkPubId)\n  pubsub.unsubscribe(this.deletePubId)\n}\n\n\n1\n2\n3\n4\n\n * 在 TodoItem 发布消息：\n\nmethods: {\n  handleCheck(id) {\n    pubsub.publish(\'checkTodo\', id)\n  },\n  handleDelete(id) {\n    if (confirm("是否删除选择的todo项目？")) {\n      pubsub.publish(\'deleteTodo\', id)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 编辑项目功能\n\n要实现编辑功能，点击编辑按钮之后， todo 项目的标题变为输入框，要确认编辑则回车确认。\n\n * 既然要确认 todo 项是否处于编辑状态，所以每点一次编辑按钮就要在每个对象中添加一个新的属性 isEdit ，而添加属性不能直接添加，否则 Vue 不能监测到更新，模版不能重新渲染，所以要用 $set 添加属性。\n\nhandleEdit(todo) {\n  if (Object.prototype.hasOwnProperty.call(todo, \'isEdit\')) {\n    todo.isEdit = true\n  } else {\n    this.$set(todo, \'isEdit\', true)\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同时加入判断当前对象是否已经有了 isEdit ，以免在下一次点击编辑时重复设置，已有 isEdit 直接修改即可。\n\n> 在原视频中，使用的方法是 todo.hasOwnProperty(‘isEdit’) 。在新的 ESLint 语法中，这种方法被禁止，对象不能直接调用这个方法。🔗 no-prototype-builtins - Rules - ESLint 中文 所以利用原型对象调用。\n\n * 在模版中，要使原标题与输入框不同时显示，并且点击编辑按钮只显示输入框，简单实用 v-show 通过属性 isEdit 判断：\n\n<span v-show="!todoObj.isEdit">{{ todoObj.title }}</span>\n<input type="text"\n       v-show="todoObj.isEdit"\n       :value="todoObj.title">\n\n\n1\n2\n3\n4\n\n * 要实现应用修改后的项目标题，可以在输入框失去焦点时提交新的项目标题，使用 @Blur 绑定一个方法 handleBlur 处理提交功能：\n\n<input type="text"\n       v-show="todoObj.isEdit"\n       :value="todoObj.title"\n       @blur="handleBlur(todoObj, $event)">\n\n\n1\n2\n3\n4\n\n\nhandleBlur(todo, e) {\n  todo.isEdit = false\n  if (!e.target.value.trim()) return alert(\'输入的修改值不能为空！\')\n  this.$bus.$emit(\'updateTodo\', todo.id, e.target.value)\n}\n\n\n1\n2\n3\n4\n5\n\n>  * 注意不能直接使用 todo.title 提交，因为此时输入框的值并没有绑定 todo.title （而不能使用 v-model ，因为不能直接修改 props 传来的值）。所以要使用调用原生 DOM 事件获取。\n>  * 要将提交的数据应用到原来的 todo 对象当中，使用全局事件总线，这里先触发了 updateTodo 这个事件，然后传入 id 和修改值。\n\n * 在 App 组件中，绑定 updateTodo 这个事件接收修改值：\n\nmethods:{\n  updateTodo(id, title) {\n    this.todos.forEach((todo) => {\n      if (todo.id === id) todo.title = title\n    })\n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nmounted() {\n  this.$bus.$on(\'updateTodo\', this.updateTodo)\n},\nbeforeDestroy(){\n  this.$bus.$off(\'updateTodo\')\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 继续添加细节，实现在添加按钮后，焦点会自动在输入框里的功能。\n\n首先使用 ref 标识这个输入框：\n\n<input type="text"\n       v-show="todoObj.isEdit"\n       :value="todoObj.title"\n       @blur="handleBlur(todoObj, $event)"\n       ref="inputTitle">\n\n\n1\n2\n3\n4\n5\n\n\n在处理点击编辑按钮后的方法中添加获取焦点代码：\n\nhandleEdit(todo) {\n  if (Object.prototype.hasOwnProperty.call(todo, \'isEdit\')) {\n    todo.isEdit = true\n  } else {\n    this.$set(todo, \'isEdit\', true)\n  }\n  this.$nextTick(function (){\n    this.$refs.inputTitle.focus()\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 注意直接在判断完后直接 this.$refs.inputTitle.focus() 是无效的，因为此时在运行完判断修改 isEdit 的值或者添加 isEdit 属性之后，Vue 不会重新解析模版。\n> \n> 使用 this.$nextTick 会在 DOM 节点更新完毕之后执行指定的回调函数。\n\n\n# 添加动画与过渡效果\n\n给添加 todo 项目和删除 todo 项目时，进入与退出时的动画效果。\n\n第一种方法， 使用 <transition> 标签给每个项目单独添加动画：\n\n * 在 TodoItem 中，使用 <transition> 标签给整个 todo 项目列表的标签 <li> 包裹起来：\n\n<transition name="todo" appear>\n  <li ...>\n</transition>\n\n\n1\n2\n3\n\n * 以使用第三方库 animate.js 为例，先在组件内引入库，然后配置 name 、 enter-active-class 、 leave-active-class ：\n\n<transition appear\n            name="animate__animated animate__bounce"\n            enter-active-class="animate__fadeInRight"\n            leave-active-class="animate__fadeOutRight"\n>\n  <li ...>\n</transition>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n第二种方法，在 TodoList 组件中的引入 TodoItem 的标签部分，使用 <transition-group> ，因为这里使用 v-for 同时每个项目的有一个唯一的 key 符合条件：\n\n引入 animate.js 库后：\n\n<transition-group appear\n            name="animate__animated animate__bounce"\n            enter-active-class="animate__fadeInRight"\n            leave-active-class="animate__fadeOutRight"\n>\n  <TodoItem v-for="todo in todos" :key="todo.id" :todoObj="todo"/>\n</transition-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'> 🔗 回顾组件化编程的流程：vue 组件化编程\n\n\n# 🌰 todolist 基础框架\n\n\n# 实现静态组件\n\n拆分组件，按照局部功能或者位置划分：\n\n * todoheader.vue\n\n * todolist.vue\n\n * todoitem.vue\n\n * todofooter.vue\n\n完成 todolist 的静态页面效果。\n\n\n\n\n# 展示动态数据\n\ntodolist 的项目数据的展示：\n\n * 一整个列表可以是一个数组；\n * 每个项目可以是一个对象，包括项目的编号、名称、状态。\n\n数据保存在哪个位置的组件？\n\n * list 组件存储项目的数组。\n\n\n# 初始化列表\n\n * 使用 todolist 组件展示 todo 项目，所以可以在 todolist 中存放相关的数据：\n\ndata() {\n  return {\n    todos: [\n      {id: \'001\', title: \'吃饭\', done: true},\n      {id: \'002\', title: \'学习\', done: false},\n      {id: \'003\', title: \'睡觉\', done: true},\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后在 <template> 中使用 v-for 循环：\n\n<template>\n  <ul class="todo-main">\n    <todoitem v-for="todo in todos" :key="todo.id" :todoobj="todo"/>\n  </ul>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n使用 :todoobj 传送 todo 对象数据到 todoitem 。\n\n * 同时 todoitem 接收 todolist 中配置的数据：\n\nprops: [\'todoobj\']\n\n\n1\n\n\n<template>\n  <li>\n    <input type="checkbox" :checked="todoobj.done">\n    <span>{{ todoobj.title }}</span>\n  </li>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用 :checked 动态根据数据发生变化。\n\n\n# 添加项目功能\n\n在 todoheader 中，输入框中使用 @keyup.enter 绑定按下回车键的事件为方法 add() ：\n\n<input type="text" placeholder="请输入你的任务名称，按回车键确认" @keyup.enter="add"/>\n\n\n1\n\n\n将用户输入的数据包装为一个 todo 对象（使用 nanoid 库生成一个随机的 id ）\n\nadd(e) {\n  const todo = {\n    id: nanoid(), title: e.target.value, done: false\n  }\n  // console.log(todo)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n由于 todoheader 与 todolist 的关系是平行（兄弟）关系，迄今为止，所以在此先使用最初级的方法，将共同的数据 todos 放在共同的组件 app 中：\n\n\n\n点击查看\n * 首先将 todos 转移到 todoheader ：\n\nexport default {\n  name: "app",\n  components: {todoheader, todolist, todofooter},\n  data() {\n    return {\n      todos: [\n        {id: \'001\', title: \'吃饭\', done: true},\n        {id: \'002\', title: \'学习\', done: false},\n        {id: \'003\', title: \'睡觉\', done: true},\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n使用 :todos=‘todos’ 传送：\n\n<template>\n  <div id="root">\n    <div class="todo-container">\n      <div class="todo-wrap">\n        <todoheader/>\n        <todolist :todos="todos"/>\n        <todofooter/>\n      </div>\n    </div>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在 todolist 中使用 props 接收：\n\nprops:[\'todos\']\n\n\n1\n\n\n<template>\n  <ul class="todo-main">\n    <todoitem v-for="todo in todos" :key="todo.id" :todoobj="todo"/>\n  </ul>\n</template>\n\n\n1\n2\n3\n4\n5\n\n * 在 app 中写一个准备要传送到 todoheader 中要使用的方法：\n\n methods: {\n  addtodo(todo){\n    this.todos.unshift(todo);\n  }\n\n\n1\n2\n3\n4\n\n\n<todoheader :addtodo="addtodo"/>\n\n\n1\n\n\n参数 todo 表示要接收来自 todoheader 的 todo 对象，在 todoheader 中使用 props 接收这个方法，并且调用这个方法，传入输入的 todo 内容：\n\nexport default {\n  name: "todoheader",\n  props: [\'addtodo\'],\n  methods: {\n    add(e) {\n      const todo = {\n        id: nanoid(), title: e.target.value, done: false\n      \n      this.addtodo(todo)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 随着在 app 的数据 todos 发生变化，模版中的内容会重新解析，此时 todolist 收到的 todos 也会随之变化，此时 todolist 中的模版也会重新解析，这样就实现了增加 todo 项目的功能。\n * 继续完善 todoheader 中的细节，给输入的内容是否为空进行判断，并且输入后将输入框清空，为了不操作原生 dom 元素，把 title 数据进行绑定：\n\n\n\n点击查看\n\n<input type="text" placeholder="请输入你的任务名称，按回车键确认" v-model="title" @keyup.enter="add"/>\n\n\n1\n\n\nexport default {\n  name: "todoheader",\n  props: [\'addtodo\'],\n  data() {\n    return {\n      title: \'\'\n    }\n  },\n  methods: {\n    add(e) {\n      // 校验数据\n      if (!this.title.trim()) return alert(\'输入的todo不能为空！\')\n      // 将数据包装为todo对象\n      const todo = {\n        id: nanoid(), title: e.target.value, done: false\n      }\n      // 通知app组件区添加一个todo对象\n      this.addtodo(todo)\n      this.title = \'\' // 请求输入框\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意\n\n注意： app 组件传送的方法 addtodo 与 todoheader 中的 methods 命名为 add 必须不能重名。因为 data 、 methods 、 props 的数据届在 vc 实例对象中。\n\n\n# 勾选状态功能\n\n最初始的做法：\n\n点击查看\n\n由于根本上，要操作 todo 对象的组件应该是 app 组件，所以要在 app 中编写方法 checktodo ，\n\nchecktodo(id) {\n  this.todos.foreach((todo) => {\n    if (todo.id === id) todo.done = !todo.done\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n\n并且，要获取到勾选的是哪一个项，就在哪一个项中调用此方法。组件的关系是 app > todolist > todoitem ，所以 app 要传送此方法给 todoitem 组件使用，就要一层一层传。\n\n先传给 todolist ，然后通过 todolist 传给 todoitem ， todoitem 通过 props 接收使用，在 todoitem 中编写方法获取当前操作的 todo 项目的 id ， 可以使用 @click 或者 @change （更方便），\n\n<input type="checkbox" :checked="todoobj.done" @change="handlecheck(todoobj.id)">\n\n\n1\n\n\nprops: [\'todoobj\', \'checktodo\'], // 声明接收todo对象\nmethods: {\n  handlecheck(id){\n    // 通知app组件将对应的todo对象的done值取反\n    this.checktodo(id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n上面 input 标签要实现动态更改 todo 项目的状态，可以想到将两个 :checked 和 @change 结合，使用 v-model 绑定 done 。\n\n<input type="checkbox" v-model="todo.done">\n\n\n1\n\n\n但是此时，在 todoitem 中修改的值，是来自 props 获取的值，而 vue 中原则上是不能修改 props 的值，但 vue 只能监测浅层次的修改，这里修改的是对象里的值， vue 无法检测得到，虽然可以实现功能，但是为了避免后期对象存储出问题，不建议如此实现。\n\n\n# 删除项目功能\n\n删除功能的实现，重中之重是在要实现删除功能的地方，获取到要删除的项目的 id ：\n\n * 在删除按钮处 todoitem 组件中，获得 todo.id ，并且添加询问是否删除的判断：\n\n<button class="btn btn-danger" @click="handledelete(todoobj.id)">删除</button>\n\n\n1\n\n\nhandledelete(id) {\n  if (confirm("是否删除本todo项目")){\n    this.deletetodo(id)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 app 组件中编写实际删除的方法方法 deletetodo :\n\ndeletetodo(id) {\n  this.todos = this.todos.filter((todo) => todo.id !== id)\n}\n\n\n1\n2\n3\n\n\n与要实现勾选状态的功能相同，要将 app 组件中的方法传送给 todoitem ，要通过中间的 todolist 。\n\n\n# 底部统计与清除已完成项目功能\n\n要统计已完成以及全部的个数：\n\n * 需要 app 组件将 todos 传递给 todofooter 组件， todofooter 组件使用 props 接收：\n\n<todofooter :todos="todos"/>\n\n\n1\n\n\n * 由于要计算已完成的项目的个数，因此可以使用 computed 计算属性：\n   \n   这里可以使用数组的方法 reduce 条件统计函数：\n\ncomputed: {\n  donetotal() {\n    return this.todos.reduce((pre, todo) => pre + (todo.done ? 1 : 0), 0)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n * 完成细节部分：\n   \n   使代码更加规范，将统计项目的全部个数的数据也加入计算属性：\n\n<span>已完成 {{ donetotal }} / 全部 {{ total }}  </span>\n\n\n1\n\n\ntotal() {\n  return this.todos.length\n}\n\n\n1\n2\n3\n\n * 展示当前是否全选或者全部未选，这时也使用计算属性，计算完成的数量是否与总数量相等的布尔值，同时注意当前所有项目数量是否大于 0 的情况：\n\nisall() {\n  return this.donetotal === this.total && this.total > 0\n}\n\n\n1\n2\n3\n\n * 完成勾选全选或者全不选的功能（全部完成或者全部未完成），此时涉及修改 todos 中的数据，所以在 app 组件中添加方法 checkalltodo ，参数是 todofooter 中获取到的全选或者全不选的布尔值赋值给所有的 todo 项目：\n\ncheckalltodo(done){\n  this.todos.foreach(todo=>{\n    todo.done = done\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n * 继续完善细节，由于在全选或者全不选框中涉及数据展示（展示当前是否有全选）与数据交互（全选或者全不选的功能），所以此时可以考虑使用 v-model ，这时 v-model 中可以绑定的数据是 isall ，这是不能再使用简化版的计算属性，需要添加 getter 和 setter 方法，并且此时 set 方法获取的布尔值正是勾选框此时的 checked 值（不再需要获取原生 dom 值）：\n\nisall: {\n  get() {\n    return this.donetotal === this.total && this.total > 0\n  },\n  set(checked) {\n    this.checkalltodo(value)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（从中可以看出计算属性的用处）\n\n * 完成「清楚已完成任务」按钮功能，绑定一个方法 clearall ，调用来自 app 组件的方法 clearalltodo ：\n\n（ app 组件中）：\n\nclearalltodo() {\n  this.todos = this.todos.filter((todo) => !todo.done)\n}\n\n\n1\n2\n3\n\n\n（ todofooter 组件中）：\n\n<button class="btn btn-danger" @click="clearall">清除已完成任务</button>\n\n\n1\n\n\nclearall() {\n  if (confirm("是否删除所有已完成的todo项目？")) {\n    this.clearalltodo()\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# todolist 案例总结\n\n * vue 组件化编程流程：\n   \n   * 拆分静态组件： 组件按照功能划分，注意组件的命名；\n   \n   * 实现动态的组件（动态的数据）：\n     \n     * ❓ 数据的类型、名称；\n     * ❓ 数据保存在哪个组件；\n   \n   * 考虑好数据的存放位置，数据是一个组件在用还是多个组件在用：\n     \n     * 一个组件使用：放在组件自身；\n     * 多个组件使用：放在共同的父组件上（状态提升）；\n   \n   * 实现交互：从绑定事件监听开始；\n\n * 运用 props 配置实现组件间通信：\n   \n   * 父组件 ==> 子组件 间通信；\n   * 子组件 ==> 父组件 间通信（要求父先给子一个函数，通过传参获取）；\n\n * ⚠️ 使用 v-model 时要注意， v-model 绑定的值不能是 props 传过来的值（不能修改）。\n   \n   ⚠️ 若 props 传送过来的数值类型是对象，使用 v-model 修改对象中的属性 vue 不会报错。\n\n\n# 🌰 todolist 案例完善\n\n\n# 使用浏览器本地存储\n\n🔗 🪐 vue 浏览器本地存储\n\n要使用浏览器本地存储，就要监测 todos 数据的增删改查的情况，这时可以使用 watch 监视，此时简写版默认监视只是监视对象的第一层；只有开启深度监视才能监视到修改对象中的数据。\n\n * 使用深度监视写入到本地存储：\n   \n   watch: {\n     todos: {\n       deep: true,\n       handler(value) {\n         localstorage.setitem(\'todos\', json.stringify(value))\n       }\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   > 只要操作的数据是 todos ，则参数 value 就是最新的 todos 数据，这时将最新的数据存储即可。\n\n * 为了读取存储在浏览器中的数据，在初始化中的 data(){} 配置项中读取：\n   \n   data() {\n       return {\n         todos: json.parse(localstorage.getitem(\'todos\')) || []\n       }\n   },\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   注意要考虑到浏览器中没有保存任何数据的情况，此时 vue 读取到 null 后，后续进行读取的一系列的操作会报错；\n\n\n# 使用自定义事件\n\n🔗 💫 vue 组件自定义事件\n\n在 todoheader 组件添加以及 todofooter 删除 todo 项目时，涉及到子组件向父组件通信，此时可以考虑通过使用自定义事件实现。\n\n * 在 app 组件中，给 todoheader 绑定自定义事件 addtodo ，事件回调为 addtodo ：\n\n<todoheader @addtodo="addtodo"/>\n\n\n1\n\n\nmethods: {\n    addtodo(todo) {\n      this.todos.unshift(todo);\n    },\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 todoheader 组件中，触发自定义事件 addtodo ：\n\nmethods: {\n  add(e) {\n    // 校验数据\n    if (!this.title.trim()) return alert(\'输入的todo项目不能为空！\')\n    // 将数据包装为todo对象\n    const todo = {\n      id: nanoid(), title: e.target.value, done: false\n    }\n    // 通知app组件区添加一个todo对象\n    this.$emit(\'addtodo\', todo)\n    this.title = \'\' // 请求输入框\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n * 在 app 组件中，给 todofooter 绑定自定义事件 checkalltodo 、 clearalltodo ，事件回调为 checkalltodo 、 clearalltodo ：\n\n<todofooter :todos="todos" @checkalltodo="checkalltodo" @clearalltodo="clearalltodo"/>\n\n\n1\n\n\n在 todofooter 组件中，触发自定义事件 checkalltodo 、 clearalltodo ：\n\ncomputed: {\n  isall: {\n      get() {\n        return this.donetotal === this.total && this.total > 0\n      },\n      set(checked) {\n        this.$("checkalltodo", checked)\n      }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nmethods: {\n  clearall() {\n      if (confirm("是否删除所有已完成的todo项目？")) {\n        this.$emit("clearalltodo")\n      }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用全局事件总线\n\n在 todolist 案例中，适合于全局事件总线的是组件 todoitem 与 app 之间的通信。\n\n * 首先在入口文件 main.js 安装全局事件总线。\n\nnew vue({\n    el: \'#app\',\n    render: h => h(app),\n    beforecreate() {\n        vue.prototype.$bus = this\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 不再使用 todolist 作为中间组件通信。\n * 在要接收数据的 app 组件中绑定自定义事件，并且在 beforedestroy 中解绑：\n\nmounted() {\n  this.$bus.$on(\'checktodo\', this.checktodo)\n  this.$bus.$on(\'deletetodo\', this.deletetodo)\n},\nbeforedestroy() {\n  this.$bus.$off(\'checktodo\')\n  this.$bus.$off(\'deletetodo\')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 在要发送数据的 todoitem 中，触发该自定义事件：\n\nmethods: {\n  handlecheck(id) {\n    // 通知app组件将对应的todo对象的值取反\n    this.$bus.$emit(\'checktodo\', id)\n  },\n  handledelete(id) {\n    if (confirm("是否删除选择的todo项目？")) {\n      this.$bus.$emit(\'deletetodo\', id)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 使用消息订阅与发布\n\n（其实消息的订阅与发布与全局事件总线相似，更加推荐直接使用在 vue 中自带的全局事件总线）\n\n以 app 组件与 todoitem 组件之间的通信：\n\n * 首先在 app 组件引入 pubsub-js ，\n\n在 mounted 中订阅消息：\n\nmounted() {\n  this.checkpubid = pubsub.subscribe(\'checktodo\', this.checktodo)\n  this.deletepubid = pubsub.subscribe(\'deletetodo\', this.deletetodo)\n}\n\n\n1\n2\n3\n4\n\n\n在 methods 中编写回调函数：\n\nmethods: {\n  \tdeletetodo(_,id) {\n      this.todos = this.todos.filter((todo) => todo.id !== id)\n  }, \n    checkalltodo(_,done) {\n      this.todos.foreach(todo => {\n        todo.done = done\n      })\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 这里的回调函数里应该第一个参数要为订阅的消息名称，为了不出现定义了参数而没有使用的情况而导致报错，这里可以使用 _ 占位。\n\n在 beforedestroy 中取消订阅：\n\nbeforedestroy() {\n  pubsub.unsubscribe(this.checkpubid)\n  pubsub.unsubscribe(this.deletepubid)\n}\n\n\n1\n2\n3\n4\n\n * 在 todoitem 发布消息：\n\nmethods: {\n  handlecheck(id) {\n    pubsub.publish(\'checktodo\', id)\n  },\n  handledelete(id) {\n    if (confirm("是否删除选择的todo项目？")) {\n      pubsub.publish(\'deletetodo\', id)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 编辑项目功能\n\n要实现编辑功能，点击编辑按钮之后， todo 项目的标题变为输入框，要确认编辑则回车确认。\n\n * 既然要确认 todo 项是否处于编辑状态，所以每点一次编辑按钮就要在每个对象中添加一个新的属性 isedit ，而添加属性不能直接添加，否则 vue 不能监测到更新，模版不能重新渲染，所以要用 $set 添加属性。\n\nhandleedit(todo) {\n  if (object.prototype.hasownproperty.call(todo, \'isedit\')) {\n    todo.isedit = true\n  } else {\n    this.$set(todo, \'isedit\', true)\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同时加入判断当前对象是否已经有了 isedit ，以免在下一次点击编辑时重复设置，已有 isedit 直接修改即可。\n\n> 在原视频中，使用的方法是 todo.hasownproperty(‘isedit’) 。在新的 eslint 语法中，这种方法被禁止，对象不能直接调用这个方法。🔗 no-prototype-builtins - rules - eslint 中文 所以利用原型对象调用。\n\n * 在模版中，要使原标题与输入框不同时显示，并且点击编辑按钮只显示输入框，简单实用 v-show 通过属性 isedit 判断：\n\n<span v-show="!todoobj.isedit">{{ todoobj.title }}</span>\n<input type="text"\n       v-show="todoobj.isedit"\n       :value="todoobj.title">\n\n\n1\n2\n3\n4\n\n * 要实现应用修改后的项目标题，可以在输入框失去焦点时提交新的项目标题，使用 @blur 绑定一个方法 handleblur 处理提交功能：\n\n<input type="text"\n       v-show="todoobj.isedit"\n       :value="todoobj.title"\n       @blur="handleblur(todoobj, $event)">\n\n\n1\n2\n3\n4\n\n\nhandleblur(todo, e) {\n  todo.isedit = false\n  if (!e.target.value.trim()) return alert(\'输入的修改值不能为空！\')\n  this.$bus.$emit(\'updatetodo\', todo.id, e.target.value)\n}\n\n\n1\n2\n3\n4\n5\n\n>  * 注意不能直接使用 todo.title 提交，因为此时输入框的值并没有绑定 todo.title （而不能使用 v-model ，因为不能直接修改 props 传来的值）。所以要使用调用原生 dom 事件获取。\n>  * 要将提交的数据应用到原来的 todo 对象当中，使用全局事件总线，这里先触发了 updatetodo 这个事件，然后传入 id 和修改值。\n\n * 在 app 组件中，绑定 updatetodo 这个事件接收修改值：\n\nmethods:{\n  updatetodo(id, title) {\n    this.todos.foreach((todo) => {\n      if (todo.id === id) todo.title = title\n    })\n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nmounted() {\n  this.$bus.$on(\'updatetodo\', this.updatetodo)\n},\nbeforedestroy(){\n  this.$bus.$off(\'updatetodo\')\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 继续添加细节，实现在添加按钮后，焦点会自动在输入框里的功能。\n\n首先使用 ref 标识这个输入框：\n\n<input type="text"\n       v-show="todoobj.isedit"\n       :value="todoobj.title"\n       @blur="handleblur(todoobj, $event)"\n       ref="inputtitle">\n\n\n1\n2\n3\n4\n5\n\n\n在处理点击编辑按钮后的方法中添加获取焦点代码：\n\nhandleedit(todo) {\n  if (object.prototype.hasownproperty.call(todo, \'isedit\')) {\n    todo.isedit = true\n  } else {\n    this.$set(todo, \'isedit\', true)\n  }\n  this.$nexttick(function (){\n    this.$refs.inputtitle.focus()\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 注意直接在判断完后直接 this.$refs.inputtitle.focus() 是无效的，因为此时在运行完判断修改 isedit 的值或者添加 isedit 属性之后，vue 不会重新解析模版。\n> \n> 使用 this.$nexttick 会在 dom 节点更新完毕之后执行指定的回调函数。\n\n\n# 添加动画与过渡效果\n\n给添加 todo 项目和删除 todo 项目时，进入与退出时的动画效果。\n\n第一种方法， 使用 <transition> 标签给每个项目单独添加动画：\n\n * 在 todoitem 中，使用 <transition> 标签给整个 todo 项目列表的标签 <li> 包裹起来：\n\n<transition name="todo" appear>\n  <li ...>\n</transition>\n\n\n1\n2\n3\n\n * 以使用第三方库 animate.js 为例，先在组件内引入库，然后配置 name 、 enter-active-class 、 leave-active-class ：\n\n<transition appear\n            name="animate__animated animate__bounce"\n            enter-active-class="animate__fadeinright"\n            leave-active-class="animate__fadeoutright"\n>\n  <li ...>\n</transition>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n第二种方法，在 todolist 组件中的引入 todoitem 的标签部分，使用 <transition-group> ，因为这里使用 v-for 同时每个项目的有一个唯一的 key 符合条件：\n\n引入 animate.js 库后：\n\n<transition-group appear\n            name="animate__animated animate__bounce"\n            enter-active-class="animate__fadeinright"\n            leave-active-class="animate__fadeoutright"\n>\n  <todoitem v-for="todo in todos" :key="todo.id" :todoobj="todo"/>\n</transition-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🪐 Vue 浏览器本地存储",frontmatter:{title:"🪐 Vue 浏览器本地存储",date:"2022-03-11T16:17:25.000Z",permalink:"/pages/8e154e/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 组件化编程"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/101.%20%F0%9F%AA%90%20Vue%20%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/101. 🪐 Vue 浏览器本地存储.md",key:"v-cd4c36e6",path:"/pages/8e154e/",headersStr:null,content:"浏览器的本地存储：是 JavaScript 原生 DOM 中提供的一个存储信息到浏览器存储中或者会话中的一个功能方法。\n\n * 存储内容大小一般支持 5 MB 左右（不同浏览器可能还不一样）\n\n * 浏览器端通过 window.sessionStorage 浏览器会话存储和 window.localStorage 本地存储属性来实现本地存储机制。\n\n * 相关 API：\n   \n   1. setItem('key', 'value'); 写入存储：该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新（覆盖）其对应的值。\n      \n      > 写入对象时，要使用 JSON.stringify(value) 将对象转化为字符串才能添加到存储中。\n   \n   2. getItem('person'); 读取存储：该方法接受一个键名作为参数，返回键名对应的值。\n      \n      > 读取存储的数据为对象字符串时，要获取字符串中的对象，要使用 JSON.parse(value) ，才能将读取的数据获取为对象。\n   \n   3. removeItem('key'); 删除存储：该方法接受一个键名作为参数，并把该键名从存储中删除。\n   \n   4. clear() ：该方法会清空存储中的所有数据。\n\n⚠️ 备注：\n\n * . SessionStorage 存储的内容会随着浏览器窗口关闭而消失（与服务器回话 Session 要区别）。\n * LocalStorage 存储的内容需要手动清除才会消失（清除浏览器缓存）。\n * getItem(xxx) 如果对应的 value 获取不到，那么 getItem 的返回值是 null 。（ JSON.parse(null) 获取对象值获取不到的结果依然是 null 。）",normalizedContent:"浏览器的本地存储：是 javascript 原生 dom 中提供的一个存储信息到浏览器存储中或者会话中的一个功能方法。\n\n * 存储内容大小一般支持 5 mb 左右（不同浏览器可能还不一样）\n\n * 浏览器端通过 window.sessionstorage 浏览器会话存储和 window.localstorage 本地存储属性来实现本地存储机制。\n\n * 相关 api：\n   \n   1. setitem('key', 'value'); 写入存储：该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新（覆盖）其对应的值。\n      \n      > 写入对象时，要使用 json.stringify(value) 将对象转化为字符串才能添加到存储中。\n   \n   2. getitem('person'); 读取存储：该方法接受一个键名作为参数，返回键名对应的值。\n      \n      > 读取存储的数据为对象字符串时，要获取字符串中的对象，要使用 json.parse(value) ，才能将读取的数据获取为对象。\n   \n   3. removeitem('key'); 删除存储：该方法接受一个键名作为参数，并把该键名从存储中删除。\n   \n   4. clear() ：该方法会清空存储中的所有数据。\n\n⚠️ 备注：\n\n * . sessionstorage 存储的内容会随着浏览器窗口关闭而消失（与服务器回话 session 要区别）。\n * localstorage 存储的内容需要手动清除才会消失（清除浏览器缓存）。\n * getitem(xxx) 如果对应的 value 获取不到，那么 getitem 的返回值是 null 。（ json.parse(null) 获取对象值获取不到的结果依然是 null 。）",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"💫 Vue 自定义事件",frontmatter:{title:"💫 Vue 自定义事件",date:"2022-03-11T16:25:03.000Z",permalink:"/pages/19709c/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 组件化编程"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/15.%20%F0%9F%92%AB%20Vue%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/15. 💫 Vue 自定义事件.md",key:"v-22193641",path:"/pages/19709c/",headers:[{level:2,title:"事件的命名",slug:"事件的命名",normalizedTitle:"事件的命名",charIndex:4308}],headersStr:"事件的命名",content:"自定义事件是区别于 Vue 中的内置事件的事件，内置事件一般是提供给 HTML DOM 使用，自定义事件一般提供给组件使用的。\n\n而当子组件需要与父组件通信，需要使用到 自定义事件。\n\n🌰 例子 / 父组件包含控制当前组件字体大小的数据，子组件中有想要控制字体大小的按钮，可以使用自定义事件，在子组件中触发父组件中的自定义事件：\n\n父组件中：\n\n<div id=\"blog-posts-events-demo\">\n  <div :style=\"{ fontSize: postFontSize + 'em' }\">\n    <blog-post\n      v-for=\"post in posts\"\n      v-bind:key=\"post.id\"\n      v-bind:post=\"post\"\n      v-on:enlarge-text=\"postFontSize += 0.1\"\n    ></blog-post>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nnew Vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [/* ... */],\n    postFontSize: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n子组件的按钮：\n\nVue.component('blog-post', {\n  props: ['post'],\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ post.title }}</h3>\n      <button v-on:click=\"$emit('enlarge-text')\">\n        Enlarge text\n      </button>\n      <div v-html=\"post.content\"></div>\n    </div>\n  `\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n自定义事件：\n\n * 适用于组件的通信： 子组件 传送到 父组件。\n\n * 使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（事件回调在父组件中）；\n\n * 绑定自定义事件（如在父组件）：\n   \n   * 方法一：在父组件中： <Demo @get=“test” /> 或者 <Demo v-on:get=\"test\" /> （ Demo 为子组件名，给该实例对象 vc 绑定 了某事件）\n   \n   * 方式二：在父组件中通过 ref 写法（灵活性强，可以使用等待修饰等。）\n   \n   * ⚠️： 两种方法都可以加上事件的修饰符（如 once 触发一次就不再触发了）；\n     \n     ⚠️⚠️： 通过 $refs 方法绑定自定义事件时，回调函数中要么配置在 methods 中，要么使用箭头函数，否则 this 的指向会有问题（要在模板中使用数据，只有在 data 、 props 、 computed 中获取数据，所以可以现在 data 中定义数据变量，然后在回调函数中使用 this 赋值）。\n\n * 触发自定义事件（在子组件）：（原则：给谁绑定的事件就在谁触发（自己绑定事件只能自己触发）） this.$emit(‘get’, 数据) ，数据为可以为多个数据参数。\n\n * 解绑自定义事件（在子组件）：\n   \n   * this.$off(‘get’) 解绑指定事件；\n   * this.$off([‘get’, ‘demo’]) 或者 this.$off() （解绑所有） 解绑多个事件。\n   \n   （上述的 get 均为自定义事件名， test 为父组件中接受数据的方法（回调函数））\n\n * 除了对于 HTML 上的 DOM，在组件上也可以绑定原生的 DOM 事件，但是需要使用 native 修饰符；\n\n> 在 Vue 的生命周期中的 this.$destroy 也会导致组件中的自定义事件失效，原生的事件不受影响。\n\n提示\n\n在 Vue 的开发者工具中查看自定义事件：\n\n\n\n🌰 自定义事件例子：\n\n点击查看\n * 在父组件 App 中，通过 ref 写法绑定自定义事件：\n\n<Student ref=\"student\"/>\n\n\n1\n\n\nmounted() {\n    this.$refs.student.$on('get', this.getStudentName) // 绑定自定义事件\n    // this.$refs.student.$once('get', this.getStudentName) // 触发一次就不再触发的自定义事件\n\n\n1\n2\n3\n\n * 绑定的事件方法 getStudentName ：\n\nmethods: {\n  getStudentName(studentName, ...params) {\n      console.log('studentName:', studentName, params)\n      this.studentName = studentName // 此处的this为App组件实例\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 此处 …params 是 ES6 用法，表示可以传入多个参数。\n\n * 在子组件 Student 中，触发事件：\n\n首先将触发事件的事件绑定在一个按钮上，以便测试：\n\n<button @click=\"sendStudentName\">把学生名给App</button>\n\n\n1\n\n\n然后在 sendStudentName 中触发：\n\nmethods:{\n  sendStudentName() {\n      // 触发Student组件实例身上的get事件\n      this.$emit('get', this.name, 1, 2, 3)\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 以上步骤便完成了子组件 Student 与父组件 App 之间的通信。\n\n----------------------------------------\n\n * 解绑自定义事件，在哪里触发在哪里解绑：\n\nunbind(){\n  // 解绑一个事件\n  this.$off('get')\n\n  // 解绑多个自定义事件\n  // this.$off(['get', 'demoEvent'])\n\n  // 解绑所有自定义事件\n  // this.$off()\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 销毁实例，导致自定义事件失效：\n\ndeath(){\n  this.$destroy() // 销毁了当前的Student组件的实例，销毁后所有的Student实例的自定义事件全都不奏效\n}\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n * 在入口文件 main.js 中销毁整个 vm 实例，导致自定义事件失效：\n\nmounted(){\n    setTimeout(()=>{\n        this.$destroy()\n    }, 3000)\n}\n\n\n1\n2\n3\n4\n5\n\n\n（编写了一个定时器测试，在 3 秒后自定义事件失效）\n\n🌰 绑定自定义事件的多种方法以及 this 的指向：\n\n * this 指向当前绑定自定义事件的组件：\n\n第一种：\n\nmounted() {\n  this.$refs.student.$on('get', this.getStudentName) // 绑定自定义事件\n}\n\n\n1\n2\n3\n\n\nmethods: {\n  getStudentName(studentName, ...params) {\n  \tconsole.log('studentName:', studentName, params)\n  \tthis.studentName = studentName // 此处的this为App组件实例\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 Vue 中的 methods 中编写方法， this 会指向当前的组件。\n\n第二种，使用箭头函数：\n\nmounted() {\n  this.$refs.student.$on('get', (studentName, ...params)=>{\n      console.log('studentName:', studentName, params)\n      this.studentName = studentName // 此处的this为App实例\n    \t// 注：箭头函数没有自己的this会向外找this，此处向外为mounted()\n      console.log(this)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * this 指向触发自定义事件的组件：\n\nmounted() {\n  his.$refs.student.$on('get', function(studentName, ...params) {\n      console.log('studentName:', studentName, params)\n      this.studentName = studentName // 此处的this为Student组件实例（谁触发自定义事件this指向谁）\n      console.log(this)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 在组件中绑定原生 DOM 事件的例子：\n\n * 在 App 组件中：\n\n<Student ref=\"student\" @click.native=\"show\"/>\n\n\n1\n\n\n> 在组件中使用绑定事件，不添加 .native 组件会默认会自定义事件，形如 <Student @get=\"getStudentName\"/> 。\n\nmethods: {\n  show() {\n      alert('you clicked Student component')\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 事件的命名\n\n不同于 组件与 Prop，事件命名不存在任何的 大小写转换，所以触发的事件名必须要完全匹配监听这个事件所用的名称。因为在 HTML 标签中的特性又会自动转换大小写（驼峰命名无效），导致驼峰命名的事件不可能它被监听到。所以始终建议使用 kebab-case 分隔命名。\n\n🌰 例子：\n\nthis.$emit(\"my-event\")\n\n\n1\n\n\n<my-component v-on:my-event=\"doSomething\"></my-component>\n\n\n1\n",normalizedContent:"自定义事件是区别于 vue 中的内置事件的事件，内置事件一般是提供给 html dom 使用，自定义事件一般提供给组件使用的。\n\n而当子组件需要与父组件通信，需要使用到 自定义事件。\n\n🌰 例子 / 父组件包含控制当前组件字体大小的数据，子组件中有想要控制字体大小的按钮，可以使用自定义事件，在子组件中触发父组件中的自定义事件：\n\n父组件中：\n\n<div id=\"blog-posts-events-demo\">\n  <div :style=\"{ fontsize: postfontsize + 'em' }\">\n    <blog-post\n      v-for=\"post in posts\"\n      v-bind:key=\"post.id\"\n      v-bind:post=\"post\"\n      v-on:enlarge-text=\"postfontsize += 0.1\"\n    ></blog-post>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nnew vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [/* ... */],\n    postfontsize: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n子组件的按钮：\n\nvue.component('blog-post', {\n  props: ['post'],\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ post.title }}</h3>\n      <button v-on:click=\"$emit('enlarge-text')\">\n        enlarge text\n      </button>\n      <div v-html=\"post.content\"></div>\n    </div>\n  `\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n自定义事件：\n\n * 适用于组件的通信： 子组件 传送到 父组件。\n\n * 使用场景：a 是父组件，b 是子组件，b 想给 a 传数据，那么就要在 a 中给 b 绑定自定义事件（事件回调在父组件中）；\n\n * 绑定自定义事件（如在父组件）：\n   \n   * 方法一：在父组件中： <demo @get=“test” /> 或者 <demo v-on:get=\"test\" /> （ demo 为子组件名，给该实例对象 vc 绑定 了某事件）\n   \n   * 方式二：在父组件中通过 ref 写法（灵活性强，可以使用等待修饰等。）\n   \n   * ⚠️： 两种方法都可以加上事件的修饰符（如 once 触发一次就不再触发了）；\n     \n     ⚠️⚠️： 通过 $refs 方法绑定自定义事件时，回调函数中要么配置在 methods 中，要么使用箭头函数，否则 this 的指向会有问题（要在模板中使用数据，只有在 data 、 props 、 computed 中获取数据，所以可以现在 data 中定义数据变量，然后在回调函数中使用 this 赋值）。\n\n * 触发自定义事件（在子组件）：（原则：给谁绑定的事件就在谁触发（自己绑定事件只能自己触发）） this.$emit(‘get’, 数据) ，数据为可以为多个数据参数。\n\n * 解绑自定义事件（在子组件）：\n   \n   * this.$off(‘get’) 解绑指定事件；\n   * this.$off([‘get’, ‘demo’]) 或者 this.$off() （解绑所有） 解绑多个事件。\n   \n   （上述的 get 均为自定义事件名， test 为父组件中接受数据的方法（回调函数））\n\n * 除了对于 html 上的 dom，在组件上也可以绑定原生的 dom 事件，但是需要使用 native 修饰符；\n\n> 在 vue 的生命周期中的 this.$destroy 也会导致组件中的自定义事件失效，原生的事件不受影响。\n\n提示\n\n在 vue 的开发者工具中查看自定义事件：\n\n\n\n🌰 自定义事件例子：\n\n点击查看\n * 在父组件 app 中，通过 ref 写法绑定自定义事件：\n\n<student ref=\"student\"/>\n\n\n1\n\n\nmounted() {\n    this.$refs.student.$on('get', this.getstudentname) // 绑定自定义事件\n    // this.$refs.student.$once('get', this.getstudentname) // 触发一次就不再触发的自定义事件\n\n\n1\n2\n3\n\n * 绑定的事件方法 getstudentname ：\n\nmethods: {\n  getstudentname(studentname, ...params) {\n      console.log('studentname:', studentname, params)\n      this.studentname = studentname // 此处的this为app组件实例\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 此处 …params 是 es6 用法，表示可以传入多个参数。\n\n * 在子组件 student 中，触发事件：\n\n首先将触发事件的事件绑定在一个按钮上，以便测试：\n\n<button @click=\"sendstudentname\">把学生名给app</button>\n\n\n1\n\n\n然后在 sendstudentname 中触发：\n\nmethods:{\n  sendstudentname() {\n      // 触发student组件实例身上的get事件\n      this.$emit('get', this.name, 1, 2, 3)\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 以上步骤便完成了子组件 student 与父组件 app 之间的通信。\n\n----------------------------------------\n\n * 解绑自定义事件，在哪里触发在哪里解绑：\n\nunbind(){\n  // 解绑一个事件\n  this.$off('get')\n\n  // 解绑多个自定义事件\n  // this.$off(['get', 'demoevent'])\n\n  // 解绑所有自定义事件\n  // this.$off()\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 销毁实例，导致自定义事件失效：\n\ndeath(){\n  this.$destroy() // 销毁了当前的student组件的实例，销毁后所有的student实例的自定义事件全都不奏效\n}\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n * 在入口文件 main.js 中销毁整个 vm 实例，导致自定义事件失效：\n\nmounted(){\n    settimeout(()=>{\n        this.$destroy()\n    }, 3000)\n}\n\n\n1\n2\n3\n4\n5\n\n\n（编写了一个定时器测试，在 3 秒后自定义事件失效）\n\n🌰 绑定自定义事件的多种方法以及 this 的指向：\n\n * this 指向当前绑定自定义事件的组件：\n\n第一种：\n\nmounted() {\n  this.$refs.student.$on('get', this.getstudentname) // 绑定自定义事件\n}\n\n\n1\n2\n3\n\n\nmethods: {\n  getstudentname(studentname, ...params) {\n  \tconsole.log('studentname:', studentname, params)\n  \tthis.studentname = studentname // 此处的this为app组件实例\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 vue 中的 methods 中编写方法， this 会指向当前的组件。\n\n第二种，使用箭头函数：\n\nmounted() {\n  this.$refs.student.$on('get', (studentname, ...params)=>{\n      console.log('studentname:', studentname, params)\n      this.studentname = studentname // 此处的this为app实例\n    \t// 注：箭头函数没有自己的this会向外找this，此处向外为mounted()\n      console.log(this)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * this 指向触发自定义事件的组件：\n\nmounted() {\n  his.$refs.student.$on('get', function(studentname, ...params) {\n      console.log('studentname:', studentname, params)\n      this.studentname = studentname // 此处的this为student组件实例（谁触发自定义事件this指向谁）\n      console.log(this)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 在组件中绑定原生 dom 事件的例子：\n\n * 在 app 组件中：\n\n<student ref=\"student\" @click.native=\"show\"/>\n\n\n1\n\n\n> 在组件中使用绑定事件，不添加 .native 组件会默认会自定义事件，形如 <student @get=\"getstudentname\"/> 。\n\nmethods: {\n  show() {\n      alert('you clicked student component')\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 事件的命名\n\n不同于 组件与 prop，事件命名不存在任何的 大小写转换，所以触发的事件名必须要完全匹配监听这个事件所用的名称。因为在 html 标签中的特性又会自动转换大小写（驼峰命名无效），导致驼峰命名的事件不可能它被监听到。所以始终建议使用 kebab-case 分隔命名。\n\n🌰 例子：\n\nthis.$emit(\"my-event\")\n\n\n1\n\n\n<my-component v-on:my-event=\"dosomething\"></my-component>\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"✨ Vue Slot 插槽",frontmatter:{title:"✨ Vue Slot 插槽",date:"2022-06-29T23:57:17.000Z",permalink:"/pages/914583/",categories:["🏃 前端核心框架","⛈ Vue 组件编程"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/20.%20%E2%9C%A8%20Vue%20Slot%20%E6%8F%92%E6%A7%BD%20.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/20. ✨ Vue Slot 插槽 .md",key:"v-7e207d18",path:"/pages/914583/",headers:[{level:2,title:"slot 插槽",slug:"slot-插槽",normalizedTitle:"slot 插槽",charIndex:2}],headersStr:"slot 插槽",content:'# slot 插槽\n\n * 插槽是一种可以让父组件在子组件的指定位置插入一个 HTML 结构的方式，也是一种组件之间的通信方法，适用于父组件向子组件传输。\n * 分三种插槽：默认插槽、具名插槽、作用域插槽。\n\n🌰 插槽的使用例子：（实现如下图的分类目录）\n\n\n\n在主组件 App 组件中存储数据，分类 Category 组件展示数据。\n\n🌰 **默认插槽的使用例子**：\t\n\n\n * 在父组件 App 中：\n\n<div class="container">\n  <Category :listData="films" title="电影">\n    <video controls src="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"/>\n  </Category>\n  <Category title="游戏">\n    <ul>\n      <li v-for="(g,index) in games" :key="index">{{ g }}</li>\n    </ul>\n  </Category>\n  <Category :listData="cats" title="猫咪">\n    <img src="http://placekitten.com/500/300" alt="">\n  </Category>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 在 Category 组件中：\n\n<template>\n  <div class="category">\n    <h3>{{ title }}分类</h3>\n    <slot>当没有传递具体结构时的默认值</slot>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 **具名插槽的使用例子**：具名插槽给 `slot` 标签添加 `name` 属性用于标识不同的 `slot` 标签。\n\n\n实现如下图的效果，可以使用两个插槽实现，此时需要区分两个插槽。\n\n\n\n * 在父组件 App 中：\n\n<template>\n  <div class="container">\n    <Category :listData="films" title="电影">\n      <video slot="center" controls src="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"/>\n      <template v-slot:footer>\n        <div class="foot">\n          <a href="#">经典电影</a>\n          <a href="#">热门电影</a>\n          <a href="#">推荐电影</a>\n        </div>\n        <h4>欢迎观看</h4>\n      </template>\n    </Category>\n    <Category title="游戏">\n      <ul slot="center">\n        <li v-for="(g,index) in games" :key="index">{{ g }}</li>\n      </ul>\n      <div class="foot" slot="footer">\n        <a slot="footer" href="#">单机游戏</a>\n        <a slot="footer" href="#">网络游戏</a>\n      </div>\n    </Category>\n    <Category :listData="cats" title="猫咪">\n      <img slot="center" src="http://placekitten.com/500/300" alt="">\n      <a slot="footer" href="#">更多猫咪</a>\n    </Category>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 在 Category 组件中：\n\n<template>\n  <div class="category">\n    <h3>{{ title }}分类</h3>\n    \x3c!--<ul>\n       <li v-for="(item, index) in listData" :key="index">{{ item }}</li>\n    </ul>--\x3e\n    <slot name="center">当没有传递具体结构时的默认值</slot>\n    <slot name="footer">当没有传递具体结构时的默认值</slot>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 作用域插槽例子：\n当数据在组件的自身，但根据数据生成的结构不在该组件而在父组件决定。（如下例子，当 games 数据在 Category 组件中，但是使用数据便利出来的结构由 App 组件决定）\n\n * 在 App 组件中：\n\n决定的结构不一样，但是使用的数据一样：\n\n<template>\n  <div class="container">\n    <Category title="游戏">\n      <template scope="data">\n        <ul>\n          <li v-for="(g,index) in data.games" :key="index">{{ g }}</li>\n        </ul>\n      </template>\n    </Category>\n\n    <Category title="游戏">\n      <template scope="{games, msg}">\n        <ol>\n          <li style="color:red" v-for="(g,index) in games" :key="index">{{ g }}</li>\n        </ol>\n        <h4>{{ msg }}</h4>\n      </template>\n    </Category>\n\n    <Category title="游戏">\n      <template slot-scope="{games}">\n        <h4 v-for="(g,index) in games" :key="index">{{ g }}</h4>\n      </template>\n    </Category>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 使用 slot-scope 标签可以支持结构赋值，（虽然使用 scope 也可以实现，但已被 slot-scope 取代这种写法）\n\n * 在 Category 组件中：\n\n<template>\n  <div class="category">\n    <h3>{{ title }}分类</h3>\n    <slot :games="games" msg="hello">当没有传递具体结构时的默认值</slot>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# slot 插槽\n\n * 插槽是一种可以让父组件在子组件的指定位置插入一个 html 结构的方式，也是一种组件之间的通信方法，适用于父组件向子组件传输。\n * 分三种插槽：默认插槽、具名插槽、作用域插槽。\n\n🌰 插槽的使用例子：（实现如下图的分类目录）\n\n\n\n在主组件 app 组件中存储数据，分类 category 组件展示数据。\n\n🌰 **默认插槽的使用例子**：\t\n\n\n * 在父组件 app 中：\n\n<div class="container">\n  <category :listdata="films" title="电影">\n    <video controls src="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"/>\n  </category>\n  <category title="游戏">\n    <ul>\n      <li v-for="(g,index) in games" :key="index">{{ g }}</li>\n    </ul>\n  </category>\n  <category :listdata="cats" title="猫咪">\n    <img src="http://placekitten.com/500/300" alt="">\n  </category>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 在 category 组件中：\n\n<template>\n  <div class="category">\n    <h3>{{ title }}分类</h3>\n    <slot>当没有传递具体结构时的默认值</slot>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 **具名插槽的使用例子**：具名插槽给 `slot` 标签添加 `name` 属性用于标识不同的 `slot` 标签。\n\n\n实现如下图的效果，可以使用两个插槽实现，此时需要区分两个插槽。\n\n\n\n * 在父组件 app 中：\n\n<template>\n  <div class="container">\n    <category :listdata="films" title="电影">\n      <video slot="center" controls src="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"/>\n      <template v-slot:footer>\n        <div class="foot">\n          <a href="#">经典电影</a>\n          <a href="#">热门电影</a>\n          <a href="#">推荐电影</a>\n        </div>\n        <h4>欢迎观看</h4>\n      </template>\n    </category>\n    <category title="游戏">\n      <ul slot="center">\n        <li v-for="(g,index) in games" :key="index">{{ g }}</li>\n      </ul>\n      <div class="foot" slot="footer">\n        <a slot="footer" href="#">单机游戏</a>\n        <a slot="footer" href="#">网络游戏</a>\n      </div>\n    </category>\n    <category :listdata="cats" title="猫咪">\n      <img slot="center" src="http://placekitten.com/500/300" alt="">\n      <a slot="footer" href="#">更多猫咪</a>\n    </category>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 在 category 组件中：\n\n<template>\n  <div class="category">\n    <h3>{{ title }}分类</h3>\n    \x3c!--<ul>\n       <li v-for="(item, index) in listdata" :key="index">{{ item }}</li>\n    </ul>--\x3e\n    <slot name="center">当没有传递具体结构时的默认值</slot>\n    <slot name="footer">当没有传递具体结构时的默认值</slot>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 作用域插槽例子：\n当数据在组件的自身，但根据数据生成的结构不在该组件而在父组件决定。（如下例子，当 games 数据在 category 组件中，但是使用数据便利出来的结构由 app 组件决定）\n\n * 在 app 组件中：\n\n决定的结构不一样，但是使用的数据一样：\n\n<template>\n  <div class="container">\n    <category title="游戏">\n      <template scope="data">\n        <ul>\n          <li v-for="(g,index) in data.games" :key="index">{{ g }}</li>\n        </ul>\n      </template>\n    </category>\n\n    <category title="游戏">\n      <template scope="{games, msg}">\n        <ol>\n          <li style="color:red" v-for="(g,index) in games" :key="index">{{ g }}</li>\n        </ol>\n        <h4>{{ msg }}</h4>\n      </template>\n    </category>\n\n    <category title="游戏">\n      <template slot-scope="{games}">\n        <h4 v-for="(g,index) in games" :key="index">{{ g }}</h4>\n      </template>\n    </category>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 使用 slot-scope 标签可以支持结构赋值，（虽然使用 scope 也可以实现，但已被 slot-scope 取代这种写法）\n\n * 在 category 组件中：\n\n<template>\n  <div class="category">\n    <h3>{{ title }}分类</h3>\n    <slot :games="games" msg="hello">当没有传递具体结构时的默认值</slot>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⭐️ Vue 动态组件与异步组件",frontmatter:{title:"⭐️ Vue 动态组件与异步组件",date:"2022-07-01T19:55:02.000Z",permalink:"/pages/432c01/",categories:["🏃 前端核心框架","⛈ Vue 组件编程"],tags:[null]},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/30.%20%E2%AD%90%EF%B8%8F%20Vue%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/30. ⭐️ Vue 动态组件与异步组件.md",key:"v-3547f7f4",path:"/pages/432c01/",headersStr:null,content:"🌰 例子：",normalizedContent:"🌰 例子：",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"☀️ Vue 全局事件总线",frontmatter:{title:"☀️ Vue 全局事件总线",date:"2022-04-02T23:02:17.000Z",permalink:"/pages/2a073b/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 脚手架"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/41.%20%E2%98%80%EF%B8%8F%20Vue%20%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/41. ☀️ Vue 全局事件总线.md",key:"v-6321bba8",path:"/pages/2a073b/",headersStr:null,content:"全局事件总线 GlobalEventBus：一种组件间通信的方式，适用于任意组件间通信。（这不是 Vue 中的 API，是利用现有的功能组合）\n\n> 要实现这个能给任意组件通信的总线中间件，必须要实现两个条件：\n> \n>  * 所有的组件都能看见它。\n>  * 必须要保证它能够调用 $on 、 $off 、 $emit 。\n> \n> 要保证实现前述的第一个条件，可以考虑要使 vc 组件实例原型对象中能够找到。所以可以利用前述的一个重要关系：组件实例原型与 Vue 实例原型的关系。\n> \n> 要保证实现第二个条件，利用生命周期 beforeCreate ，在原型中赋值为组件实例对象。一般写为 Vue.prototrype.$bus = this （ this 为当前创建的 vm ） 。\n\n * 使用全局事件总线：（在入口文件 main.js 的 beforeCreate ）安装全局事件总线：\n   \n   new Vue({\n   \t......\n   \tbeforeCreate() {\n   \t\tVue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm\n   \t},\n       ......\n   }) \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   * 使用事件总线：\n     \n     * 接收数据：A 组件想要接收数据，就在 A 组件中给 $bus 绑定自定义事件，事件的回调留在 A 组件自身（谁绑定事件，回调在谁身上）：\n       \n       methods() {\n         demo(data) { ... }\n       },\n       ...\n       , mounted() {\n         this.$bus.on('xxx', this.demo) // 向全局事件总线绑定自定义事件 xxx\n       }\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       \n     \n     * 提供数据（谁提供数据谁就触发事件）：\n       \n       this.$bus.$emit('xxx', 数据)\n       \n       \n       1\n       \n     \n     * ⚠️ 最好在接收完数据之后，在 beforeDestory 中用 $off 去解绑当前组件所用到的事件：\n       \n       beforeDestroy() {\n           this.$bus.$off('xxx')\n       },\n       \n       \n       1\n       2\n       3\n       \n\n>  * 绑定在 $bus 中的自定义事件命名可能会有冲突，所以要注意不要使用已经定义的自定义事件的命名；并且最好不占用这个自定义事件，使用完后就（在绑定处）解绑该自定义事件。\n>  * 为什么在 beforeDestory 中销毁？组件不使用后销毁后，有可能在 vc 实例中的自定义事件没有被销毁！\n\n🌰 实现全局事件总线例子：\n\n * 首先在入口文件安装全局事件总线。\n * 现在在 School 组件中想要接收来自 Student 组件的数据，所以在 School 组件中绑定自定义事件 hello ，并将回调写在 School 组件中：（下面使用箭头函数）\n\nmounted() {\n  this.$bus.$on('hello', (data) => {\n    console.log('School receiving StudentName: ', data)\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 Student 组件想要提供数据，则在 Student 中触发该自定义事件 hello ，并且传递数据到参数中。\n\n<button @click=\"sendStudentName\">把学生名给School组件</button>\n\n\n1\n\n\nmethods: {\n  sendStudentName() {\n    this.$bus.$emit('hello', this.name)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 School 组件接受完数据，解绑该自定义事件：\n\n beforeDestroy() {\n  this.$bus.$off('hello')\n}\n\n\n1\n2\n3\n",normalizedContent:"全局事件总线 globaleventbus：一种组件间通信的方式，适用于任意组件间通信。（这不是 vue 中的 api，是利用现有的功能组合）\n\n> 要实现这个能给任意组件通信的总线中间件，必须要实现两个条件：\n> \n>  * 所有的组件都能看见它。\n>  * 必须要保证它能够调用 $on 、 $off 、 $emit 。\n> \n> 要保证实现前述的第一个条件，可以考虑要使 vc 组件实例原型对象中能够找到。所以可以利用前述的一个重要关系：组件实例原型与 vue 实例原型的关系。\n> \n> 要保证实现第二个条件，利用生命周期 beforecreate ，在原型中赋值为组件实例对象。一般写为 vue.prototrype.$bus = this （ this 为当前创建的 vm ） 。\n\n * 使用全局事件总线：（在入口文件 main.js 的 beforecreate ）安装全局事件总线：\n   \n   new vue({\n   \t......\n   \tbeforecreate() {\n   \t\tvue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm\n   \t},\n       ......\n   }) \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   * 使用事件总线：\n     \n     * 接收数据：a 组件想要接收数据，就在 a 组件中给 $bus 绑定自定义事件，事件的回调留在 a 组件自身（谁绑定事件，回调在谁身上）：\n       \n       methods() {\n         demo(data) { ... }\n       },\n       ...\n       , mounted() {\n         this.$bus.on('xxx', this.demo) // 向全局事件总线绑定自定义事件 xxx\n       }\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       \n     \n     * 提供数据（谁提供数据谁就触发事件）：\n       \n       this.$bus.$emit('xxx', 数据)\n       \n       \n       1\n       \n     \n     * ⚠️ 最好在接收完数据之后，在 beforedestory 中用 $off 去解绑当前组件所用到的事件：\n       \n       beforedestroy() {\n           this.$bus.$off('xxx')\n       },\n       \n       \n       1\n       2\n       3\n       \n\n>  * 绑定在 $bus 中的自定义事件命名可能会有冲突，所以要注意不要使用已经定义的自定义事件的命名；并且最好不占用这个自定义事件，使用完后就（在绑定处）解绑该自定义事件。\n>  * 为什么在 beforedestory 中销毁？组件不使用后销毁后，有可能在 vc 实例中的自定义事件没有被销毁！\n\n🌰 实现全局事件总线例子：\n\n * 首先在入口文件安装全局事件总线。\n * 现在在 school 组件中想要接收来自 student 组件的数据，所以在 school 组件中绑定自定义事件 hello ，并将回调写在 school 组件中：（下面使用箭头函数）\n\nmounted() {\n  this.$bus.$on('hello', (data) => {\n    console.log('school receiving studentname: ', data)\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 student 组件想要提供数据，则在 student 中触发该自定义事件 hello ，并且传递数据到参数中。\n\n<button @click=\"sendstudentname\">把学生名给school组件</button>\n\n\n1\n\n\nmethods: {\n  sendstudentname() {\n    this.$bus.$emit('hello', this.name)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n * 在 school 组件接受完数据，解绑该自定义事件：\n\n beforedestroy() {\n  this.$bus.$off('hello')\n}\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"⚡️ Vue 消息订阅与发布",frontmatter:{title:"⚡️ Vue 消息订阅与发布",date:"2022-03-11T16:27:24.000Z",permalink:"/pages/e784e6/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 组件化编程"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/43.%20%E2%9A%A1%EF%B8%8F%20Vue%20%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/43. ⚡️ Vue 消息订阅与发布.md",key:"v-d6281a1a",path:"/pages/e784e6/",headersStr:null,content:"订阅与发布：一种组件间通信的方式，适用于任意组件之间通信，包含以下操作：\n\n * 订阅消息：（谁需要谁绑定）对应绑定事件监听；\n * 发布消息：（谁提供数据谁发布）分发事件；\n * 取消消息订阅：解绑事件监听；\n\n * 使用方式：\n   \n   * 在项目中安装第三方库 pubsubJS\n     \n     $ npm i pubsub-js\n     \n     \n     1\n     \n     \n     > 🔗 相关链接： PubSubJS 在线文档\n   \n   * 在入口文件中引入 pubsub：\n     \n     import pubsub from 'pubsub-js'\n     \n     \n     1\n     \n   \n   * 接收数据： A 组件想接受数据，则在 A 组件中订阅消息，订阅的回调留在 A 组件自身。\n     \n     methods(){\n       demo(data){......}\n     }\n     ......\n     mounted() {\n       this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * 提供数据（发布消息，触发订阅的回调函数调用）：\n     \n     pubsub.publish('xxx', 数据)\n     \n     \n     1\n     \n   \n   * 最好在接收完数据之后，在 beforeDestroy 钩子中用 pubsub.unsubscribe 取消订阅。\n\n🌰 实现消息订阅与发布例子：\n\n（与全局事件总线中 Student 组件将数据发送给 School 类似）\n\n * 需要数据的组件为 School 组件，所以该组件订阅消息：\n   \n   在 School 组件中引入 pubsub-js ：\n\nimport pubsub from 'pubsub-js'\n\n\n1\n\n\n订阅消息：\n\nmounted() {\n  /*this.pubid = pubsub.subscribe('hello', function (msgName, data) {\n      console.log('有人发布hello消息，hello消息的回调执行了', msgName)\n      console.log(this) // undefined\n    })*/\n    this.pubid = pubsub.subscribe('hello',\n                                 )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注意回调函数中的第一个参数为消息名，第二个参数才是接收的数据。\n\n注意\n\n注意此时的 this 指向问题，与自定义事件中的回调函数类似，使用 function 会导致 this 为 undefined 。此时可以使用在 method 编写回调函数或者使用箭头函数。\n\n * 在接收完信息后，最好在 beforeDestroy 中取消订阅该消息：\n\nbeforeDestroy() {\n  // this.$bus.$off('hello')\n  pubsub.unsubscribe(this.pubid)\n}\n\n\n1\n2\n3\n4\n\n\n> 与自定义事件中解绑事件不一样，要取消订阅不能使用事件名，可以使用在订阅消息以后返回的 pubid 标识该订阅消息。\n\n * 提供数据的组件 Student 组件发布消息：\n   \n   在 Student 组件中引入 pubsub-js （同上）；\n   \n   发布消息：\n\n<button @click=\"sendStudentName\">将StudentName发送给School</button>\n\n\n1\n\n\nmethods:{\n  sendStudentName(){\n    // this.$bus.$emit('hello', this.name)\n    pubsub.publish('hello', this.name)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n提示\n\n消息的订阅与发布在 Vue 中其实不常用，常用的是在 Vue 中有与此模型相似的全局事件总线。\n\n同时，在 Vue 的开发者工具的事件中能监测到使用的自定义事件，而无法监测来自第三方库的消息订阅与发布。",normalizedContent:"订阅与发布：一种组件间通信的方式，适用于任意组件之间通信，包含以下操作：\n\n * 订阅消息：（谁需要谁绑定）对应绑定事件监听；\n * 发布消息：（谁提供数据谁发布）分发事件；\n * 取消消息订阅：解绑事件监听；\n\n * 使用方式：\n   \n   * 在项目中安装第三方库 pubsubjs\n     \n     $ npm i pubsub-js\n     \n     \n     1\n     \n     \n     > 🔗 相关链接： pubsubjs 在线文档\n   \n   * 在入口文件中引入 pubsub：\n     \n     import pubsub from 'pubsub-js'\n     \n     \n     1\n     \n   \n   * 接收数据： a 组件想接受数据，则在 a 组件中订阅消息，订阅的回调留在 a 组件自身。\n     \n     methods(){\n       demo(data){......}\n     }\n     ......\n     mounted() {\n       this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * 提供数据（发布消息，触发订阅的回调函数调用）：\n     \n     pubsub.publish('xxx', 数据)\n     \n     \n     1\n     \n   \n   * 最好在接收完数据之后，在 beforedestroy 钩子中用 pubsub.unsubscribe 取消订阅。\n\n🌰 实现消息订阅与发布例子：\n\n（与全局事件总线中 student 组件将数据发送给 school 类似）\n\n * 需要数据的组件为 school 组件，所以该组件订阅消息：\n   \n   在 school 组件中引入 pubsub-js ：\n\nimport pubsub from 'pubsub-js'\n\n\n1\n\n\n订阅消息：\n\nmounted() {\n  /*this.pubid = pubsub.subscribe('hello', function (msgname, data) {\n      console.log('有人发布hello消息，hello消息的回调执行了', msgname)\n      console.log(this) // undefined\n    })*/\n    this.pubid = pubsub.subscribe('hello',\n                                 )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注意回调函数中的第一个参数为消息名，第二个参数才是接收的数据。\n\n注意\n\n注意此时的 this 指向问题，与自定义事件中的回调函数类似，使用 function 会导致 this 为 undefined 。此时可以使用在 method 编写回调函数或者使用箭头函数。\n\n * 在接收完信息后，最好在 beforedestroy 中取消订阅该消息：\n\nbeforedestroy() {\n  // this.$bus.$off('hello')\n  pubsub.unsubscribe(this.pubid)\n}\n\n\n1\n2\n3\n4\n\n\n> 与自定义事件中解绑事件不一样，要取消订阅不能使用事件名，可以使用在订阅消息以后返回的 pubid 标识该订阅消息。\n\n * 提供数据的组件 student 组件发布消息：\n   \n   在 student 组件中引入 pubsub-js （同上）；\n   \n   发布消息：\n\n<button @click=\"sendstudentname\">将studentname发送给school</button>\n\n\n1\n\n\nmethods:{\n  sendstudentname(){\n    // this.$bus.$emit('hello', this.name)\n    pubsub.publish('hello', this.name)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n提示\n\n消息的订阅与发布在 vue 中其实不常用，常用的是在 vue 中有与此模型相似的全局事件总线。\n\n同时，在 vue 的开发者工具的事件中能监测到使用的自定义事件，而无法监测来自第三方库的消息订阅与发布。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌙 Vue 动画与过渡",frontmatter:{title:"🌙 Vue 动画与过渡",date:"2022-03-11T16:38:36.000Z",permalink:"/pages/5a0c40/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 组件化编程"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/50.%20%F0%9F%8C%99%20Vue%20%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BF%87%E6%B8%A1.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/50. 🌙 Vue 动画与过渡.md",key:"v-69d10f5e",path:"/pages/5a0c40/",headers:[{level:3,title:"动画效果",slug:"动画效果",normalizedTitle:"动画效果",charIndex:425},{level:3,title:"过渡效果",slug:"过渡效果",normalizedTitle:"过渡效果",charIndex:1604},{level:3,title:"多个元素实现同样的过渡动画效果",slug:"多个元素实现同样的过渡动画效果",normalizedTitle:"多个元素实现同样的过渡动画效果",charIndex:2152},{level:3,title:"集成第三方动画",slug:"集成第三方动画",normalizedTitle:"集成第三方动画",charIndex:2899}],headersStr:"动画效果 过渡效果 多个元素实现同样的过渡动画效果 集成第三方动画",content:'Vue 封装的基于 CSS 的过渡与动画：\n\n * 作用：在插入、更新或者移除 DOM 元素时，在合适的时候给元素的样式添加类名。\n\n\n\n🔗 相关链接：官方文档 Transition | Vue.js (vuejs.org)\n\n * 用法：（在 CSS 准备好以下的样式）\n   * 元素进入的样式：\n     * v-enter ：进入的起点\n     * v-enter-to ：进入的终点\n     * v-enter-active ：进入过程中\n   * 元素离开的样式：\n     * v-leave ：离开的起点\n     * v-leave-to ：离开的终点\n     * v-leave-active ：离开过程中\n   * 使用 <transition> 标签包裹要应用过渡或者动画的元素，并且配置 name 属性；要对多个元素应用过渡或者动画，则使用 <transition-group> ，并且要指定 key 值。\n\n\n# 动画效果\n\n🌰 例子：\n\n实现如下图示的例子：\n\n * 不用考虑写两次进入和离开的动画，只要写一次进入的动画，然后将进入的动画倒放即可。\n\n * 给动画创建一个关键帧 @keyframes ，添加动画样式：\n\n.v-enter-active {\n  animation: test 1s;\n}\n\n.v-leave-active {\n  animation: test 1s reverse;\n}\n\n@keyframes test {\n  from {\n    transform: translateX(-100%);\n  }\n  to {\n    transform: translateX(0px);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 利用 Vue 实现动画样式的根据目前的 isShow 自动变化，想让谁有动画效果，谁就用 <transition> 标签：\n\n<div>\n  <button @click="isShow = !isShow">显示/隐藏</button>\n  <transition>\n    <h1 v-show="isShow" class="come">Hello Vue</h1>\n  </transition>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 命名问题：\n> \n> 当给 <transition> 一个 name 属性：\n> \n> <transition name="show">\n>   <h1 v-show="isShow">Hello Vue</h1>\n> </transition>\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> Vue 过渡样式要随之修改为：\n> \n> .show-enter-active {\n>   animation: test 1s;\n> }\n> \n> .show-leave-active {\n>   animation: test 1s reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> name 用于标识某个动画样式，以免重复或者无法匹配。\n\n * 追加细节，在开启页面时就有动画，在 <transition> 标签中使用 appear 属性即可。（有两种用法：直接 appear 或者 :apear=‘true’ ）\n\n<transition name="show" appear>\n  <h1 v-show="isShow">Hello Vue</h1>\n</transition>\n\n\n1\n2\n3\n\n\n> 注意 <transition> 标签最后不会被解析到模版中的一个标签，Vue 通过这个标签给它匹配动画样式。\n\n\n# 过渡效果\n\n实现上述例子的另一种方法：\n\n * 在动画样式中，设置进入的起点、终点，离开的起点、终点的样式：\n\n/*进入的起点，离开的终点*/\n.show-enter, .show-leave-to{\n  transform: translateX(-100%);\n}\n\n/*进入的终点，离开的起点*/\n.show-enter-to, .show-leave{\n  transform: translateX(0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 要实现动画，可以在 h1 中添加动画，或者另外写一个激活动画：\n\nh1{\n  background-color: lightskyblue;\n  transition: 0.5s linear;\n}\n\n\n1\n2\n3\n4\n\n\n或者\n\n.show-enter-active, .show-leave-active{\n\ttransition: 0.5s linear;\n}\n\n\n1\n2\n3\n\n * 观察开发者工具可以看到，Vue 一般实现动画会在样式中放入三个动画样式，例如离开动画： .show-leave-active 、 .show-leave-to 、 .show-leave （起点一般动画速度太快而难以观察）。\n\n\n# 多个元素实现同样的过渡动画效果\n\n * 注意：一般 <transition> 标签只能应用于一个单独的标签元素。如果有多个元素就要使用 <transition-group> ，并且里面的每一个元素都要有一个唯一的 key 值（真实列表借助 v-for 实现）：\n\n<transition-group name="show" appear>\n  <h1 v-show="isShow" key="1">Hello</h1>\n  <h1 v-show="isShow" key="2">Vue</h1>\n</transition-group>\n\n\n1\n2\n3\n4\n\n\n> 如果不用 <transition-group> 而使用一个 <div> 包裹两个元素，也可实现大致的效果。但是此时如果想要实现两个互斥的元素不同时出现，就不能单纯使用一个 <div> 包裹，只能通过 <transition-group> 实现。\n> \n> <transition name="show" appear>\n>   <div v-show="isShow">\n>     <h1>Hello</h1>\n>     <h1>Vue</h1>>\n>   </div>\n> </transition>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> \n> \n> <transition-group name="show" appear>\n>   <h1 v-show="isShow" key="1">Hello</h1>\n>   <h1 v-show="!isShow" key="2">Vue</h1>\n> </transition-group>\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n\n# 集成第三方动画\n\n🔗 以 animate.css 为例：\n\n * animate.css - npm (npmjs.com)\n * Animate.css | A cross-browser library of CSS animations.\n\n使用例子：\n\n * 安装并引入 animate.css\n\n$ npm install animate.css --save\n\n\n1\n\n\nimport \'animate.css\'\n\n\n1\n\n * 将 <transition> 相关的标签的 name 属性设置为 animate 相关值，如下\n\n<transition-group \n\tname="animate__animated animate__bounce" \n\tappear>\n  <h1 v-show="isShow" key="1">Hello</h1>\n  <h1 v-show="!isShow" key="2">Vue</h1>\n</transition-group>\n\n\n1\n2\n3\n4\n5\n6\n\n * 加入动画（在官网上选择复制相关的类名称）：\n\n<transition-group appear\n                  name="animate__animated animate__bounce"\n                  enter-active-class="animate__slideInUp"\n                  leave-active-class="animate__slideOutUp"\n>\n  <h1 v-show="isShow" key="1">Hello</h1>\n  <h1 v-show="!isShow" key="2">Vue</h1>\n</transition-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'vue 封装的基于 css 的过渡与动画：\n\n * 作用：在插入、更新或者移除 dom 元素时，在合适的时候给元素的样式添加类名。\n\n\n\n🔗 相关链接：官方文档 transition | vue.js (vuejs.org)\n\n * 用法：（在 css 准备好以下的样式）\n   * 元素进入的样式：\n     * v-enter ：进入的起点\n     * v-enter-to ：进入的终点\n     * v-enter-active ：进入过程中\n   * 元素离开的样式：\n     * v-leave ：离开的起点\n     * v-leave-to ：离开的终点\n     * v-leave-active ：离开过程中\n   * 使用 <transition> 标签包裹要应用过渡或者动画的元素，并且配置 name 属性；要对多个元素应用过渡或者动画，则使用 <transition-group> ，并且要指定 key 值。\n\n\n# 动画效果\n\n🌰 例子：\n\n实现如下图示的例子：\n\n * 不用考虑写两次进入和离开的动画，只要写一次进入的动画，然后将进入的动画倒放即可。\n\n * 给动画创建一个关键帧 @keyframes ，添加动画样式：\n\n.v-enter-active {\n  animation: test 1s;\n}\n\n.v-leave-active {\n  animation: test 1s reverse;\n}\n\n@keyframes test {\n  from {\n    transform: translatex(-100%);\n  }\n  to {\n    transform: translatex(0px);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 利用 vue 实现动画样式的根据目前的 isshow 自动变化，想让谁有动画效果，谁就用 <transition> 标签：\n\n<div>\n  <button @click="isshow = !isshow">显示/隐藏</button>\n  <transition>\n    <h1 v-show="isshow" class="come">hello vue</h1>\n  </transition>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 命名问题：\n> \n> 当给 <transition> 一个 name 属性：\n> \n> <transition name="show">\n>   <h1 v-show="isshow">hello vue</h1>\n> </transition>\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> vue 过渡样式要随之修改为：\n> \n> .show-enter-active {\n>   animation: test 1s;\n> }\n> \n> .show-leave-active {\n>   animation: test 1s reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> name 用于标识某个动画样式，以免重复或者无法匹配。\n\n * 追加细节，在开启页面时就有动画，在 <transition> 标签中使用 appear 属性即可。（有两种用法：直接 appear 或者 :apear=‘true’ ）\n\n<transition name="show" appear>\n  <h1 v-show="isshow">hello vue</h1>\n</transition>\n\n\n1\n2\n3\n\n\n> 注意 <transition> 标签最后不会被解析到模版中的一个标签，vue 通过这个标签给它匹配动画样式。\n\n\n# 过渡效果\n\n实现上述例子的另一种方法：\n\n * 在动画样式中，设置进入的起点、终点，离开的起点、终点的样式：\n\n/*进入的起点，离开的终点*/\n.show-enter, .show-leave-to{\n  transform: translatex(-100%);\n}\n\n/*进入的终点，离开的起点*/\n.show-enter-to, .show-leave{\n  transform: translatex(0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 要实现动画，可以在 h1 中添加动画，或者另外写一个激活动画：\n\nh1{\n  background-color: lightskyblue;\n  transition: 0.5s linear;\n}\n\n\n1\n2\n3\n4\n\n\n或者\n\n.show-enter-active, .show-leave-active{\n\ttransition: 0.5s linear;\n}\n\n\n1\n2\n3\n\n * 观察开发者工具可以看到，vue 一般实现动画会在样式中放入三个动画样式，例如离开动画： .show-leave-active 、 .show-leave-to 、 .show-leave （起点一般动画速度太快而难以观察）。\n\n\n# 多个元素实现同样的过渡动画效果\n\n * 注意：一般 <transition> 标签只能应用于一个单独的标签元素。如果有多个元素就要使用 <transition-group> ，并且里面的每一个元素都要有一个唯一的 key 值（真实列表借助 v-for 实现）：\n\n<transition-group name="show" appear>\n  <h1 v-show="isshow" key="1">hello</h1>\n  <h1 v-show="isshow" key="2">vue</h1>\n</transition-group>\n\n\n1\n2\n3\n4\n\n\n> 如果不用 <transition-group> 而使用一个 <div> 包裹两个元素，也可实现大致的效果。但是此时如果想要实现两个互斥的元素不同时出现，就不能单纯使用一个 <div> 包裹，只能通过 <transition-group> 实现。\n> \n> <transition name="show" appear>\n>   <div v-show="isshow">\n>     <h1>hello</h1>\n>     <h1>vue</h1>>\n>   </div>\n> </transition>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> \n> \n> <transition-group name="show" appear>\n>   <h1 v-show="isshow" key="1">hello</h1>\n>   <h1 v-show="!isshow" key="2">vue</h1>\n> </transition-group>\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n\n# 集成第三方动画\n\n🔗 以 animate.css 为例：\n\n * animate.css - npm (npmjs.com)\n * animate.css | a cross-browser library of css animations.\n\n使用例子：\n\n * 安装并引入 animate.css\n\n$ npm install animate.css --save\n\n\n1\n\n\nimport \'animate.css\'\n\n\n1\n\n * 将 <transition> 相关的标签的 name 属性设置为 animate 相关值，如下\n\n<transition-group \n\tname="animate__animated animate__bounce" \n\tappear>\n  <h1 v-show="isshow" key="1">hello</h1>\n  <h1 v-show="!isshow" key="2">vue</h1>\n</transition-group>\n\n\n1\n2\n3\n4\n5\n6\n\n * 加入动画（在官网上选择复制相关的类名称）：\n\n<transition-group appear\n                  name="animate__animated animate__bounce"\n                  enter-active-class="animate__slideinup"\n                  leave-active-class="animate__slideoutup"\n>\n  <h1 v-show="isshow" key="1">hello</h1>\n  <h1 v-show="!isshow" key="2">vue</h1>\n</transition-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌩 Vuex 状态管理",frontmatter:{title:"🌩 Vuex 状态管理",date:"2022-04-06T14:17:24.000Z",permalink:"/pages/def0ac/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 脚手架"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/70.%20%F0%9F%8C%A9%20Vuex%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/70. 🌩 Vuex 状态管理.md",key:"v-0cc0fa08",path:"/pages/def0ac/",headers:[{level:2,title:"Vuex 的理解",slug:"vuex-的理解",normalizedTitle:"vuex 的理解",charIndex:2},{level:2,title:"Vuex 原理",slug:"vuex-原理",normalizedTitle:"vuex 原理",charIndex:461},{level:2,title:"Vuex 的使用",slug:"vuex-的使用",normalizedTitle:"vuex 的使用",charIndex:880},{level:3,title:"Vuex 的开发环境",slug:"vuex-的开发环境",normalizedTitle:"vuex 的开发环境",charIndex:893},{level:3,title:"Vuex 的基本使用",slug:"vuex-的基本使用",normalizedTitle:"vuex 的基本使用",charIndex:1801},{level:3,title:"getters 的使用",slug:"getters-的使用",normalizedTitle:"getters 的使用",charIndex:2941},{level:3,title:"四个 map 方法的使用",slug:"四个-map-方法的使用",normalizedTitle:"四个 map 方法的使用",charIndex:3305},{level:2,title:"Vuex 的使用案例",slug:"vuex-的使用案例",normalizedTitle:"vuex 的使用案例",charIndex:5674},{level:3,title:"🌰 使用 Vuex 实现求和案例",slug:"🌰-使用-vuex-实现求和案例",normalizedTitle:"🌰 使用 vuex 实现求和案例",charIndex:5689},{level:3,title:"🌰 多组件共享数据",slug:"🌰-多组件共享数据",normalizedTitle:"🌰 多组件共享数据",charIndex:7146},{level:2,title:"Vuex 的模块化编码",slug:"vuex-的模块化编码",normalizedTitle:"vuex 的模块化编码",charIndex:7278}],headersStr:"Vuex 的理解 Vuex 原理 Vuex 的使用 Vuex 的开发环境 Vuex 的基本使用 getters 的使用 四个 map 方法的使用 Vuex 的使用案例 🌰 使用 Vuex 实现求和案例 🌰 多组件共享数据 Vuex 的模块化编码",content:"# Vuex 的理解\n\n * Vuex 的概念： 专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 Vue 应用中的多个组件的共享状态进行集中式的管理（读 / 写操作），也是组件之间通信的一种方式，并且适用于任意组件间的通信。\n\n> 🔗 相关链接：\n> \n>  * GitHub：vuejs/vuex: 🗃️ Centralized State Management for Vue.js. (github.com)\n>  * 官方文档：What is Vuex? | Vuex (vuejs.org)\n\n----------------------------------------\n\n>  * 使用全局事件总线实现多组件共享数据：不只是读、还要写的操作时，就显得有点繁杂。\n> \n>  * 使用 Vuex 多组件共享数据：读写可以在双向操作。\n\n * 什么时候使用 Vuex ：共享一个状态。\n   * 多个组件依赖与同一个状态。\n   * 来自不同的组件的行为需要变更同一个状态。\n\n\n# Vuex 原理\n\n\n\n * Vuex 三个重要组成部分：\n   \n   * Actions：动作行为。\n   * Mutations：加工维护。\n   * State：状态（数据） ，数据交给 State 保管，可以包含许多数据关键词。\n\n * 可以在图中了解 Vuex 的工作流程。\n   \n   * 三个组成部分可以看成是三个对象中存储数据。\n   \n   * Actions 与后端接口相关，当组件进行的动作的数据需要通过 AJAX 请求获取，即不知道动作的数据。实际上，当组件知道进行的动作和数据，Vue 会直接 Commit 到 Mutations，即 Actions 可以省略。\n   \n   * Mutations 是实际加工状态的地方。\n   \n   * Vuex 基于 store 工作。例如， store.dispatch 、 store.commit 、 store.mutate ，在任意组件中都能调用。\n\n\n# Vuex 的使用\n\n\n# Vuex 的开发环境\n\n * 安装 Vuex 3：\n\n$ npm i vuex@3\n\n\n1\n\n\n提示\n\n在 2022 年 2 月 7 日，Vue 3 成为了默认的版本（即执行 npm i vue 安装的版本是 Vue 3），Vuex 也更新到了 Vuex 4 版本，而 Vue 4 只能在 Vue 3 中运行（所以执行 npm i vuex 安装的是 Vuex 4）。所以，在目前基于 Vue 2 版本的学习，我们要安装可以基于 Vue 2 运行的 Vuex 3。\n\n * 创建 Vuex 的操作文件 src/store/index.js ：\n\n//引入Vue核心库\nimport Vue from 'vue'\n//引入Vuex\nimport Vuex from 'vuex'\n//应用Vuex插件\nVue.use(Vuex)\n\n//准备actions对象——响应组件中用户的动作\nconst actions = {}\n//准备mutations对象——修改state中的数据\nconst mutations = {}\n//准备state对象——保存具体的数据\nconst state = {}\n\n//创建并暴露store\nexport default new Vuex.Store({\n\tactions,\n\tmutations,\n\tstate\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n提示\n\n注意：由于 store 的引入不能晚于引入插件 Vuex ，所以现在操作文件中引入 Vue 并且引入插件 Vuex ，然后在入口文件就直接引入 store 配置项即可。\n\n * 在入口文件 main.js 中创建 vm 实例时传入 store 配置项：\n\n......\n//引入store\nimport store from './store'\n......\n\n//创建vm\nnew Vue({\n\tel:'#app',\n\trender: h => h(App),\n\tstore\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Vuex 的基本使用\n\n * 在 store 操作文件 index.js 中初始化数据，配置 actions 和 mutations 的方法：\n\n// 响应组件中的动作\nconst actions = {\n\tadd(context,value){\n\t\tcontext.commit('ADD',value)\n\t},\n}\n\n// 执行动作的实际操作\nconst mutations = {\n\tADD(state,value){\n\t\tstate.sum += value\n\t}\n}\n\n//初始化数据\nconst state = {\n   sum:0\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n提示\n\n * actions 中定义的方法有两个参数：\n   \n   * context ：上下文相关的内容，一般提供给动作中的方法中所用到的内容。（可以看作是 store 的部分内容）\n     \n     注意：包括 dispatch ：可以用来在方法中调取在 actions 中的其他方法。实际开发中没有像例子那么简单的业务逻辑，甚至如此简单的业务逻辑可以在组件中直接完成，但是一旦有繁杂的业务逻辑此时 actions 的作用就显现出来，并且可以在 actions 中定义多个方法包含多种业务逻辑提供其中一个方法使用 dispatch 调取。\n   \n   * value ：组件传递给 Vuex 要进行操作的数据。在 actions 中可对此进行判断等业务逻辑。\n\n * mutations 中定义的方法有两个参数：\n   \n   * state ：提供用来读取 state 中的数据（状态）。\n   * value ：组件传递给 Vuex 要进行操作的数据。\n\n * 在 mutations 中的方法名命名一般为大写与 actions 中的方法进行区分。并且在 mutations 中一般直接操作数据，而不再过多进行判断等业务逻辑（一般放在 actions 中进行）。\n\n * 在组件中使用 Vuex ：\n   \n   * 组件中读取 Vuex 中的数据： $store.state.sum （在模版中）\n   \n   * 组件中操作 Vuex 中的数据：通过 dispatch ： $store.dispatch('method', value) 或者 commit ： $store.commit(‘method’, value) 。\n     \n     注意：若在该操作没有网络请求或者其他业务逻辑，组件可以越过 actions 的 dispatch ，直接使用 mutations 中 commit 。\n\n\n# getters 的使用\n\n * 概念：当在 state 中的数据需要经过（复杂）加工之后使用，可以使用 getters 加工。（在组件中的计算属性 computed 只能提供在目前组件中使用，不能共享给其他组件复用）\n\n * 在 store 操作文件 index.js 中追加配置 getters ，注意要追加到暴露项中：\n\nconst getters = {\n\tbigSum(state){\n\t\treturn state.sum * 10\n\t}\n}\n\n//创建并暴露store\nexport default new Vuex.Store({\n\t......\n\tgetters\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 在组件中读取加工后的数据： $store.getters.bigSum 。\n\n\n# 四个 map 方法的使用\n\n当初始化的数据较多，在组件中的模版语法使用过长的代码语句获取在 Vuex 的数据不太好，所以可以使用计算属性 computed 获取。\n\n🌰 例子：使用计算属性获取 Vuex 中的数据：\n\n点击查看\n\ncomputed: {\n  sum() {\n    return this.$store.state.sum\n  },\n  school() {\n    return this.$store.state.school\n  },\n  subject() {\n    return this.$store.state.subject\n  },\n  bigSum() {\n    return this.$store.getters.bigSum\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以看出在计算属性中有相同部分的代码，都是从 state 或者 getter 中获取数据，所以 Vuex 提供了生成 state 或者 getters 计算属性的方法 mapState 和 mapGetters 。\n\n * mapState 方法：可以映射 state 的数据为计算属性：\n\ncomputed: {\n    //借助mapState生成计算属性：sum、school、subject（对象写法）\n     ...mapState({sum:'sum',school:'school',subject:'subject'}),\n         \n    //借助mapState生成计算属性：sum、school、subject（数组写法）\n    ...mapState(['sum','school','subject']),\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * mapGetters 方法：可以映射 getters 的数据为计算属性：\n\ncomputed: {\n    //借助mapGetters生成计算属性：bigSum（对象写法）\n    ...mapGetters({bigSum:'bigSum'}),\n\n    //借助mapGetters生成计算属性：bigSum（数组写法）\n    ...mapGetters(['bigSum'])\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 使用原始方法与 Vuex 中的 actions 对话：\n\n点击查看\n\nmethods: {\n  increment() {\n    this.$store.commit('ADD', this.n)\n  },\n  decrement() {\n    this.$store.commit('SUB', this.n)\n  },\n  incrementOdd() {\n    this.$store.dispatch('addOdd', this.n)\n  },\n  incrementWait() {\n    this.$store.dispatch('addWait', this.n)\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n与上面两个 map 方法类似，Vuex 提供了帮助生成 actions 和 mutations 对话的方法 mapActions 和 mapMutations 。\n\n * mapActions 方法：用于帮助生成与 actions 对话的方法，包含 $store.dispatch(xxx) 的函数：\n\nmethods:{\n  //靠mapActions生成：incrementOdd、incrementWait（对象形式） \n  ...mapActions({incrementOdd: 'addOdd', incrementWait: 'addWait'}),\n    \n  //靠mapActions生成：incrementOdd、incrementWait（数组形式）\n  ...mapActions(['addOdd', 'addWait'])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * mapMutations ：用于帮助生成与 mutations 对话的方法，包含 $store.commit(xxx) 的函数：\n\nmethods:{\n  //靠mapActions生成：increment、decrement（对象形式）\n  ...mapMutations({increment: 'ADD', decrement: 'SUB'}), \n   \n  //靠mapMutations生成：JIA、JIAN（对象形式）\n  ...mapMutations(['ADD','SUB'])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n使用数组法生成，要求事件名与在 actions 或者 mutations 中的方法名称相同，即在模板中要使用在 actions 或者 mutations 中的方法名称。\n\n注意\n\n此时 mapActions 与 mapMutations 帮我们生成的对象方法相当于：\n\nincrement(value) {\n  this.$store.commit('ADD', value)\n}\n\n\n1\n2\n3\n\n\n说明要传递参数到 actions 或者 mutations 中的方法中，需要在模版中绑定事件时就传递好参数，否则参数是事件对象，例如： <button @click=\"increment(n)\">+</button> 。\n\n提示\n\n真实依靠计算属性获取与使用 map 获取在 Vue 开发者工具中的区别：\n\n\n\n\n# Vuex 的使用案例\n\n\n# 🌰 使用 Vuex 实现求和案例\n\n在 store 操作文件 index.js 中：\n\n * 初始化数据，准备用于操作的数据 state ：\n\nconst state = {\n    sum: 0 // 当前求和的结果\n}\n\n\n1\n2\n3\n\n * 准备用于响应组件中的动作 actions ：\n\nconst actions = {\n    add(context, value) {\n        context.commit('ADD', value)\n    },\n    sub(context, value) {\n        context.commit('SUB', value)\n    },\n    addOdd(context, value) {\n        if (context.state.sum % 2) {\n            context.commit('ADD', value) \n        }\n    },\n    addWait(context, value) {\n        setTimeout(() => {\n            context.commit('ADD', value) \n        }, 500)\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 准备操作（加工）数据（状态）的 mutations ：\n\nconst mutations = {\n    ADD(state, value) {\n        state.sum += value\n    },\n    SUB(state, value) {\n        state.sum -= value\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在组件中使用 Vuex ：\n\n * 读取 Vuex 中的数据：\n\n<h1>当前的求和为： {{$store.state.sum}}</h1>\n\n\n1\n\n * 操作 Vuex 中的数据：\n\nmethods: {\n  increment() {\n    this.$store.dispatch('add', this.n)\n  },\n  decrement() {\n    this.$store.dispatch('sub', this.n)\n  },\n  incrementOdd() {\n    this.$store.dispatch('addOdd', this.n)\n  },\n  incrementWait() {\n    this.$store.dispatch('addWait', this.n)\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注： n 为定义用来选择递增的数字。\n\n提示\n\n对上述改进，可以看出在 actions 中的 add 和 sub 方法并没有其他的业务逻辑，所以在组件中可以直接使用 commit 直接越过 actioins ：\n\nmethods: {\n  increment() {\n      this.$store.commit('ADD', this.n)\n  },\n  decrement() {\n    this.$store.commit('SUB', this.n)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 🌰 多组件共享数据\n\n除了第一个例子的 Count 组件以外，新加一个组件 Person ，使用 Vuex 共享两个组件都可以使用的数据。\n\n详细步骤不赘述，其实不同组件获取 Vuex 中的数据都可可以使用普通方法或者 map 方法，从而实现共享数据。\n\n\n# Vuex 的模块化编码\n\n * 当多个组件同时使用 Vuex 实现共享数据并且操作数据时，此时的 store 文件其实「不堪重负」，在 actions 和 mutations 中的方法繁杂起来，不同组件操作不同的方法，造成编码混乱和版本管理困难。\n\n * 使用模块化编码的目的：让代码更好维护，让多种数据分类更加明确。\n\n🌰 将上述的 Vuex 例子进行模块化编码，\n\n * 修改 Vuex store.js ，分割为如下文件：\n   \n   * countOptions.js\n   \n   * personOptions.js\n\nexport default {\n  namespaced:true,//开启命名空间\n  state:{ ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 注意：开启命名空间才能在组件中使用如 countOptions 的命名。\n\n然后在 store.js 暴露时，使用 modules 包含以上的模块：\n\nexport default new Vuex.Store({\n    modules: {\n        countOptions,\n        personOptions\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n * 在组件中，使用模块化编码后：\n\n读取 state 数据：\n\n//方式一：自己直接读取\nthis.$store.state.personOptions.personlist\n\n//方式二：借助mapState读取：\n...mapState('countOptions',['sum','school','subject']),\n\n\n1\n2\n3\n4\n5\n\n\n读取 getters 数据：\n\n//方式一：自己直接读取\nthis.$store.getters['personOptions/firstPersonName']\n\n//方式二：借助mapGetters读取：\n...mapGetters('countOptions',['bigSum'])\n\n\n1\n2\n3\n4\n5\n\n\n> 注意： $store.getters 与 state 不同。\n\n调用 dispatch ：\n\n//方式一：自己直接dispatch\nthis.$store.dispatch('personAbout/addPersonWang',person)\n\n//方式二：借助mapActions：\n...mapActions('countOptions',{incrementOdd:'addOdd',incrementWait:'addWait'})\n\n\n1\n2\n3\n4\n5\n\n\n调用 commit ：\n\n//方式一：自己直接commit\nthis.$store.commit('personOptions/ADD_PERSON',person)\n\n//方式二：借助mapMutations：\n...mapMutations('countOptions',{increment:'ADD',decrement:'SUB'}),\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# vuex 的理解\n\n * vuex 的概念： 专门在 vue 中实现集中式状态（数据）管理的一个 vue 插件，对 vue 应用中的多个组件的共享状态进行集中式的管理（读 / 写操作），也是组件之间通信的一种方式，并且适用于任意组件间的通信。\n\n> 🔗 相关链接：\n> \n>  * github：vuejs/vuex: 🗃️ centralized state management for vue.js. (github.com)\n>  * 官方文档：what is vuex? | vuex (vuejs.org)\n\n----------------------------------------\n\n>  * 使用全局事件总线实现多组件共享数据：不只是读、还要写的操作时，就显得有点繁杂。\n> \n>  * 使用 vuex 多组件共享数据：读写可以在双向操作。\n\n * 什么时候使用 vuex ：共享一个状态。\n   * 多个组件依赖与同一个状态。\n   * 来自不同的组件的行为需要变更同一个状态。\n\n\n# vuex 原理\n\n\n\n * vuex 三个重要组成部分：\n   \n   * actions：动作行为。\n   * mutations：加工维护。\n   * state：状态（数据） ，数据交给 state 保管，可以包含许多数据关键词。\n\n * 可以在图中了解 vuex 的工作流程。\n   \n   * 三个组成部分可以看成是三个对象中存储数据。\n   \n   * actions 与后端接口相关，当组件进行的动作的数据需要通过 ajax 请求获取，即不知道动作的数据。实际上，当组件知道进行的动作和数据，vue 会直接 commit 到 mutations，即 actions 可以省略。\n   \n   * mutations 是实际加工状态的地方。\n   \n   * vuex 基于 store 工作。例如， store.dispatch 、 store.commit 、 store.mutate ，在任意组件中都能调用。\n\n\n# vuex 的使用\n\n\n# vuex 的开发环境\n\n * 安装 vuex 3：\n\n$ npm i vuex@3\n\n\n1\n\n\n提示\n\n在 2022 年 2 月 7 日，vue 3 成为了默认的版本（即执行 npm i vue 安装的版本是 vue 3），vuex 也更新到了 vuex 4 版本，而 vue 4 只能在 vue 3 中运行（所以执行 npm i vuex 安装的是 vuex 4）。所以，在目前基于 vue 2 版本的学习，我们要安装可以基于 vue 2 运行的 vuex 3。\n\n * 创建 vuex 的操作文件 src/store/index.js ：\n\n//引入vue核心库\nimport vue from 'vue'\n//引入vuex\nimport vuex from 'vuex'\n//应用vuex插件\nvue.use(vuex)\n\n//准备actions对象——响应组件中用户的动作\nconst actions = {}\n//准备mutations对象——修改state中的数据\nconst mutations = {}\n//准备state对象——保存具体的数据\nconst state = {}\n\n//创建并暴露store\nexport default new vuex.store({\n\tactions,\n\tmutations,\n\tstate\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n提示\n\n注意：由于 store 的引入不能晚于引入插件 vuex ，所以现在操作文件中引入 vue 并且引入插件 vuex ，然后在入口文件就直接引入 store 配置项即可。\n\n * 在入口文件 main.js 中创建 vm 实例时传入 store 配置项：\n\n......\n//引入store\nimport store from './store'\n......\n\n//创建vm\nnew vue({\n\tel:'#app',\n\trender: h => h(app),\n\tstore\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# vuex 的基本使用\n\n * 在 store 操作文件 index.js 中初始化数据，配置 actions 和 mutations 的方法：\n\n// 响应组件中的动作\nconst actions = {\n\tadd(context,value){\n\t\tcontext.commit('add',value)\n\t},\n}\n\n// 执行动作的实际操作\nconst mutations = {\n\tadd(state,value){\n\t\tstate.sum += value\n\t}\n}\n\n//初始化数据\nconst state = {\n   sum:0\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n提示\n\n * actions 中定义的方法有两个参数：\n   \n   * context ：上下文相关的内容，一般提供给动作中的方法中所用到的内容。（可以看作是 store 的部分内容）\n     \n     注意：包括 dispatch ：可以用来在方法中调取在 actions 中的其他方法。实际开发中没有像例子那么简单的业务逻辑，甚至如此简单的业务逻辑可以在组件中直接完成，但是一旦有繁杂的业务逻辑此时 actions 的作用就显现出来，并且可以在 actions 中定义多个方法包含多种业务逻辑提供其中一个方法使用 dispatch 调取。\n   \n   * value ：组件传递给 vuex 要进行操作的数据。在 actions 中可对此进行判断等业务逻辑。\n\n * mutations 中定义的方法有两个参数：\n   \n   * state ：提供用来读取 state 中的数据（状态）。\n   * value ：组件传递给 vuex 要进行操作的数据。\n\n * 在 mutations 中的方法名命名一般为大写与 actions 中的方法进行区分。并且在 mutations 中一般直接操作数据，而不再过多进行判断等业务逻辑（一般放在 actions 中进行）。\n\n * 在组件中使用 vuex ：\n   \n   * 组件中读取 vuex 中的数据： $store.state.sum （在模版中）\n   \n   * 组件中操作 vuex 中的数据：通过 dispatch ： $store.dispatch('method', value) 或者 commit ： $store.commit(‘method’, value) 。\n     \n     注意：若在该操作没有网络请求或者其他业务逻辑，组件可以越过 actions 的 dispatch ，直接使用 mutations 中 commit 。\n\n\n# getters 的使用\n\n * 概念：当在 state 中的数据需要经过（复杂）加工之后使用，可以使用 getters 加工。（在组件中的计算属性 computed 只能提供在目前组件中使用，不能共享给其他组件复用）\n\n * 在 store 操作文件 index.js 中追加配置 getters ，注意要追加到暴露项中：\n\nconst getters = {\n\tbigsum(state){\n\t\treturn state.sum * 10\n\t}\n}\n\n//创建并暴露store\nexport default new vuex.store({\n\t......\n\tgetters\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 在组件中读取加工后的数据： $store.getters.bigsum 。\n\n\n# 四个 map 方法的使用\n\n当初始化的数据较多，在组件中的模版语法使用过长的代码语句获取在 vuex 的数据不太好，所以可以使用计算属性 computed 获取。\n\n🌰 例子：使用计算属性获取 vuex 中的数据：\n\n点击查看\n\ncomputed: {\n  sum() {\n    return this.$store.state.sum\n  },\n  school() {\n    return this.$store.state.school\n  },\n  subject() {\n    return this.$store.state.subject\n  },\n  bigsum() {\n    return this.$store.getters.bigsum\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以看出在计算属性中有相同部分的代码，都是从 state 或者 getter 中获取数据，所以 vuex 提供了生成 state 或者 getters 计算属性的方法 mapstate 和 mapgetters 。\n\n * mapstate 方法：可以映射 state 的数据为计算属性：\n\ncomputed: {\n    //借助mapstate生成计算属性：sum、school、subject（对象写法）\n     ...mapstate({sum:'sum',school:'school',subject:'subject'}),\n         \n    //借助mapstate生成计算属性：sum、school、subject（数组写法）\n    ...mapstate(['sum','school','subject']),\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * mapgetters 方法：可以映射 getters 的数据为计算属性：\n\ncomputed: {\n    //借助mapgetters生成计算属性：bigsum（对象写法）\n    ...mapgetters({bigsum:'bigsum'}),\n\n    //借助mapgetters生成计算属性：bigsum（数组写法）\n    ...mapgetters(['bigsum'])\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n🌰 使用原始方法与 vuex 中的 actions 对话：\n\n点击查看\n\nmethods: {\n  increment() {\n    this.$store.commit('add', this.n)\n  },\n  decrement() {\n    this.$store.commit('sub', this.n)\n  },\n  incrementodd() {\n    this.$store.dispatch('addodd', this.n)\n  },\n  incrementwait() {\n    this.$store.dispatch('addwait', this.n)\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n与上面两个 map 方法类似，vuex 提供了帮助生成 actions 和 mutations 对话的方法 mapactions 和 mapmutations 。\n\n * mapactions 方法：用于帮助生成与 actions 对话的方法，包含 $store.dispatch(xxx) 的函数：\n\nmethods:{\n  //靠mapactions生成：incrementodd、incrementwait（对象形式） \n  ...mapactions({incrementodd: 'addodd', incrementwait: 'addwait'}),\n    \n  //靠mapactions生成：incrementodd、incrementwait（数组形式）\n  ...mapactions(['addodd', 'addwait'])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * mapmutations ：用于帮助生成与 mutations 对话的方法，包含 $store.commit(xxx) 的函数：\n\nmethods:{\n  //靠mapactions生成：increment、decrement（对象形式）\n  ...mapmutations({increment: 'add', decrement: 'sub'}), \n   \n  //靠mapmutations生成：jia、jian（对象形式）\n  ...mapmutations(['add','sub'])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n使用数组法生成，要求事件名与在 actions 或者 mutations 中的方法名称相同，即在模板中要使用在 actions 或者 mutations 中的方法名称。\n\n注意\n\n此时 mapactions 与 mapmutations 帮我们生成的对象方法相当于：\n\nincrement(value) {\n  this.$store.commit('add', value)\n}\n\n\n1\n2\n3\n\n\n说明要传递参数到 actions 或者 mutations 中的方法中，需要在模版中绑定事件时就传递好参数，否则参数是事件对象，例如： <button @click=\"increment(n)\">+</button> 。\n\n提示\n\n真实依靠计算属性获取与使用 map 获取在 vue 开发者工具中的区别：\n\n\n\n\n# vuex 的使用案例\n\n\n# 🌰 使用 vuex 实现求和案例\n\n在 store 操作文件 index.js 中：\n\n * 初始化数据，准备用于操作的数据 state ：\n\nconst state = {\n    sum: 0 // 当前求和的结果\n}\n\n\n1\n2\n3\n\n * 准备用于响应组件中的动作 actions ：\n\nconst actions = {\n    add(context, value) {\n        context.commit('add', value)\n    },\n    sub(context, value) {\n        context.commit('sub', value)\n    },\n    addodd(context, value) {\n        if (context.state.sum % 2) {\n            context.commit('add', value) \n        }\n    },\n    addwait(context, value) {\n        settimeout(() => {\n            context.commit('add', value) \n        }, 500)\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 准备操作（加工）数据（状态）的 mutations ：\n\nconst mutations = {\n    add(state, value) {\n        state.sum += value\n    },\n    sub(state, value) {\n        state.sum -= value\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在组件中使用 vuex ：\n\n * 读取 vuex 中的数据：\n\n<h1>当前的求和为： {{$store.state.sum}}</h1>\n\n\n1\n\n * 操作 vuex 中的数据：\n\nmethods: {\n  increment() {\n    this.$store.dispatch('add', this.n)\n  },\n  decrement() {\n    this.$store.dispatch('sub', this.n)\n  },\n  incrementodd() {\n    this.$store.dispatch('addodd', this.n)\n  },\n  incrementwait() {\n    this.$store.dispatch('addwait', this.n)\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注： n 为定义用来选择递增的数字。\n\n提示\n\n对上述改进，可以看出在 actions 中的 add 和 sub 方法并没有其他的业务逻辑，所以在组件中可以直接使用 commit 直接越过 actioins ：\n\nmethods: {\n  increment() {\n      this.$store.commit('add', this.n)\n  },\n  decrement() {\n    this.$store.commit('sub', this.n)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 🌰 多组件共享数据\n\n除了第一个例子的 count 组件以外，新加一个组件 person ，使用 vuex 共享两个组件都可以使用的数据。\n\n详细步骤不赘述，其实不同组件获取 vuex 中的数据都可可以使用普通方法或者 map 方法，从而实现共享数据。\n\n\n# vuex 的模块化编码\n\n * 当多个组件同时使用 vuex 实现共享数据并且操作数据时，此时的 store 文件其实「不堪重负」，在 actions 和 mutations 中的方法繁杂起来，不同组件操作不同的方法，造成编码混乱和版本管理困难。\n\n * 使用模块化编码的目的：让代码更好维护，让多种数据分类更加明确。\n\n🌰 将上述的 vuex 例子进行模块化编码，\n\n * 修改 vuex store.js ，分割为如下文件：\n   \n   * countoptions.js\n   \n   * personoptions.js\n\nexport default {\n  namespaced:true,//开启命名空间\n  state:{ ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 注意：开启命名空间才能在组件中使用如 countoptions 的命名。\n\n然后在 store.js 暴露时，使用 modules 包含以上的模块：\n\nexport default new vuex.store({\n    modules: {\n        countoptions,\n        personoptions\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n * 在组件中，使用模块化编码后：\n\n读取 state 数据：\n\n//方式一：自己直接读取\nthis.$store.state.personoptions.personlist\n\n//方式二：借助mapstate读取：\n...mapstate('countoptions',['sum','school','subject']),\n\n\n1\n2\n3\n4\n5\n\n\n读取 getters 数据：\n\n//方式一：自己直接读取\nthis.$store.getters['personoptions/firstpersonname']\n\n//方式二：借助mapgetters读取：\n...mapgetters('countoptions',['bigsum'])\n\n\n1\n2\n3\n4\n5\n\n\n> 注意： $store.getters 与 state 不同。\n\n调用 dispatch ：\n\n//方式一：自己直接dispatch\nthis.$store.dispatch('personabout/addpersonwang',person)\n\n//方式二：借助mapactions：\n...mapactions('countoptions',{incrementodd:'addodd',incrementwait:'addwait'})\n\n\n1\n2\n3\n4\n5\n\n\n调用 commit ：\n\n//方式一：自己直接commit\nthis.$store.commit('personoptions/add_person',person)\n\n//方式二：借助mapmutations：\n...mapmutations('countoptions',{increment:'add',decrement:'sub'}),\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🛒 Vue 中的 AJAX",frontmatter:{title:"🛒 Vue 中的 AJAX",date:"2022-03-12T23:31:28.000Z",permalink:"/pages/b2106c/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 组件化编程"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/60.%20%F0%9F%9B%92%20Vue%20%E4%B8%AD%E7%9A%84%20AJAX.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/60. 🛒 Vue 中的 AJAX.md",key:"v-a5c47462",path:"/pages/b2106c/",headers:[{level:3,title:"解决开发环境 AJAX 跨域问题",slug:"解决开发环境-ajax-跨域问题",normalizedTitle:"解决开发环境 ajax 跨域问题",charIndex:2},{level:3,title:"借助 Vue-CLI 配置代理服务器",slug:"借助-vue-cli-配置代理服务器",normalizedTitle:"借助 vue-cli 配置代理服务器",charIndex:2025},{level:2,title:"配置代理案例（搜索案例）",slug:"配置代理案例-搜索案例",normalizedTitle:"配置代理案例（搜索案例）",charIndex:3425},{level:2,title:"Vue-resource",slug:"vue-resource",normalizedTitle:"vue-resource",charIndex:5161}],headersStr:"解决开发环境 AJAX 跨域问题 借助 Vue-CLI 配置代理服务器 配置代理案例（搜索案例） Vue-resource",content:"# 解决开发环境 AJAX 跨域问题\n\n引入问题：\n\n * 使用 node 配置两个模拟的服务器：\n\n点击查看\n * server1.js\n\nconst express = require('express')\nconst app = express()\n\napp.use((request,response,next)=>{\n   console.log('有人请求服务器1了');\n   // console.log('请求来自于',request.get('Host'));\n   // console.log('请求的地址',request.url);\n   next()\n})\n\napp.get('/students',(request,response)=>{\n   const students = [\n      {id:'001',name:'tom',age:18},\n      {id:'002',name:'jerry',age:19},\n      {id:'003',name:'tony',age:120},\n   ]\n   response.send(students)\n})\n\napp.listen(5050,(err)=>{\n   if(!err) console.log('服务器1启动成功了,请求学生信息地址为：http://localhost:5050/students');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * server2.js\n\nconst express = require('express')\nconst app = express()\n\napp.use((request,response,next)=>{\n   console.log('有人请求服务器2了');\n   next()\n})\n\napp.get('/cars',(request,response)=>{\n   const cars = [\n      {id:'001',name:'奔驰',price:199},\n      {id:'002',name:'马自达',price:109},\n      {id:'003',name:'捷达',price:120},\n   ]\n   response.send(cars)\n})\n\napp.listen(5051,(err)=>{\n   if(!err) console.log('服务器2启动成功了,请求汽车信息地址为：http://localhost:5051/cars');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 在 Vue 组件使用 axios 请求服务器：\n\n首先引入 axios ：\n\nimport axios from 'axios'\n\n\n1\n\n\n然后编写想服务器请求信息的方法：\n\ngetStudentInfo(){\n  axios.get('http://localhost:5050/students').then(\n      response => {\n        console.log('请求成功了', response.data)\n      },\n      error => {\n        console.log('请求失败', error)\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n运行后，此时出现跨域问题：\n\n * 没有遵循同源策略（协议名、主机名、端口号要一致）（由于 Vue 组件基于 http://localhost:8080 运行，而服务器基于 http://localhost:5050 ）\n\n * 虽然引起了跨域但是请求有成功发送。发送请求后，服务器也收到了请求，并且返回了响应，但是浏览器发现了跨域问题导致报错。\n\n\n\n一般有三种解决的方法：\n\n * cors ：服务器响应请求时携带特殊的相应头。（真正意义上解决跨域，但是响应头不能轻易携带）\n * jsonp ：巧妙借助 script 的 src 属性在引入外部资源时不受同源策略实现。但是在真正开发中，得在前端使用特殊方法，后端同时配合；并且只能对 get 请求有效。\n * 配置代理服务器：本身也是服务器，与前台所处的位置（意思是端口）一致，要发送请求时，代理服务器作为中介帮助前台发送请求到服务器 ，服务器返回的请求也通过代理服务器作为中介返回给前台。利用服务器与服务器之间的通信不使用 ajax 而使用 http 请求这一点。\n   * 后端 nginx 开启代理服务器。\n   * 借助 vue-cli 开启代理服务器。\n\n\n# 借助 Vue-CLI 配置代理服务器\n\n🔗 devServer-proxy ：Configuration Reference | Vue CLI (vuejs.org)\n\n第一种方法：\n\n * 在 vue.js.config 配置文件中配置 devServer ：\n\n// 开启代理服务器\ndevServer: {\n    proxy: 'http://localhost:5050'\n}\n\n\n1\n2\n3\n4\n\n * 修改原来请求的路径的端口为代理服务器的端口，并且注意请求的路径要明确：\n\ngetStudentInfo(){\n  axios.get('http://localhost:8080/students').then(\n      response => {\n        console.log('请求成功了', response.data)\n      },\n      error => {\n        console.log('请求失败', error)\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 运行后，请求成功并获得了响应的数据。\n\n提示\n\n使用上述方法配置代理服务器有两个缺陷：\n\n * 优先匹配前端资源：代理服务器并不是将所有的请求都会转发到服务器，当代理服务器中已经存在的资源（在 public 目录下，只要请求路径同名），则不会向服务器请求资源。\n * 通过在 vue.config.js 中的 devServer 中不可以配置多个代理服务器。\n\n第二种方法：\n\n * 在 vue.config.js 配置文件中配置 devServer ：\n\ndevServer: {\n    proxy: {\n        '/server1': { // 请求前缀，请求地址例子：http://localhost:8080/server1/students\n            target: 'http://localhost:5050', // 代理目标服务器的基础历经\n            pathRewrite: {'^/server1': ''}, // 重写路径，匹配以 /server1开头的请求路径\n            ws: true, // 用于支持websocket\n            changeOrigin: true // 用于控制请求头中的host值 例子 false为8080，true为5050\n        },\n        '/server2': { // 请求前缀，请求地址例子：http://localhost:8080/server2/cars\n            target: 'http://localhost:5051', \n            pathRewrite: {'^/server2': ''}, \n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n解决了再方法一中的缺点：\n\n * 可以配置多个服务器\n * 请求时加上前缀，解决了当代理服务器可能有重复命名的文件导致请求不能转发到服务器的问题。\n\n但是使用该方法配置略烦琐，并且请求资源时必须要添加前缀。\n\n\n# 配置代理案例（搜索案例）\n\n * 按照组件化编程，划分好组件，实现页面效果：\n\n\n\n * 在搜索组件中完成请求搜索：\n\n🔗 GitHub 提供的用户搜索接口：\n\nhttps://api.github.com/search/users?q=userName\n\n\n1\n\n\n在搜索输入框中使用 v-model 绑定输入的关键词，搜索按钮绑定搜索事件方法：\n\n<div>\n  <input type=\"text\" placeholder=\"enter the name you search\" v-model=\"keyword\"/>\n  <button @click=\"searchUsers\">Search</button>\n</div>\n\n\n1\n2\n3\n4\n\n\n使用 axios 发送请求：\n\ndata() {\n  return {\n    keyword: ''\n  }\n}, methods: {\n  searchUsers() {\n    axios.get(`https://api.github.com/search/users?q=${this.keyword}`).then(\n        response => {\n          console.log('请求成功', response.data)\n        },\n        error => {\n          console.log('请求出错', error.massage)\n        }\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n>  * 要在请求链接中插入表达式，要使用 `` 符号。\n>  * 不用考虑跨域问题，因为 Github 后端已经解决了 CORS 引起的跨域问题（添加特殊的响应头）。 同时 incomplete_results 意思是仅展示部分结果， 搜索结果保存在 items 中。\n>  * 注意不能过于频繁请求接口，否则会被误认为攻击然后被封锁 IP。\n\n * 通过全局事件总线在 Search 组件和 List 组件之间的通信。\n\n在 List 组件中绑定自定义事件：\n\nmounted() {\n  this.$bus.$on('getUserResults', (users) => {\n    console.log('List received data,', users)\n    this.users = users\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 Search 组件中触发，并传入数据：\n\nsearchUsers() {\n  axios.get(`https://api.github.com/search/users?q=${this.keyword}`).then(\n      response => {\n        console.log('请求成功', response.data.items)\n        this.$bus.$emit('getUserResults', response.data.items)\n      },\n      error => {\n        console.log('请求出错', error.massage)\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将获取到的数据应用到模版，使用 v-for 循环：\n\n<div class=\"row\">\n  <div class=\"card\" v-for=\"user in users\" :key=\"user.login\">\n    <a :href=\"user.html_url\" target=\"_blank\">\n      <img :src=\"user.avatar_url\" style='width: 100px'/>\n    </a>\n    <p class=\"card-text\">{{ user.login }}</p>\n  </div>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Vue-resource\n\n * 安装 vue-resource ：\n\n$ npm i vue-resource\n\n\n1\n\n * 在入口文件 main.js 引入：\n\n// 引入 vue-resource\nimport VueResource from 'vue-resource'\n\n// 使用插件\nVue.use(VueResource)\n\n\n1\n2\n3\n4\n5\n\n\n🌰 使用的方法与 axios 类似：\n\nsearchUsers() {\n  this.$bus.$emit('updateListData', {isFirst: false, isLoading: true, errMsg: '', users: []})\n  this.$http.get(`https://api.github.com/search/users?q=${this.keyword}`).then(\n      response => {\n        console.log('请求成功', response.data.items)\n        this.$bus.$emit('updateListData', {isLoading: false, errMsg: '', users: response.data.items})\n      },\n      error => {\n        console.log('请求出错', error.message)\n        this.$bus.$emit('updateListData', {isLoading: false, errMsg: error.message, users: []})\n\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n一般在 Vue 的早期版本较多使用来实现异步加载，Vue 2.0 版本后，一般推荐使用 axios 实现 AJAX 请求。\n\n🔗 Vue.js Ajax (vue-resource) | 菜鸟教程 (runoob.com)",normalizedContent:"# 解决开发环境 ajax 跨域问题\n\n引入问题：\n\n * 使用 node 配置两个模拟的服务器：\n\n点击查看\n * server1.js\n\nconst express = require('express')\nconst app = express()\n\napp.use((request,response,next)=>{\n   console.log('有人请求服务器1了');\n   // console.log('请求来自于',request.get('host'));\n   // console.log('请求的地址',request.url);\n   next()\n})\n\napp.get('/students',(request,response)=>{\n   const students = [\n      {id:'001',name:'tom',age:18},\n      {id:'002',name:'jerry',age:19},\n      {id:'003',name:'tony',age:120},\n   ]\n   response.send(students)\n})\n\napp.listen(5050,(err)=>{\n   if(!err) console.log('服务器1启动成功了,请求学生信息地址为：http://localhost:5050/students');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * server2.js\n\nconst express = require('express')\nconst app = express()\n\napp.use((request,response,next)=>{\n   console.log('有人请求服务器2了');\n   next()\n})\n\napp.get('/cars',(request,response)=>{\n   const cars = [\n      {id:'001',name:'奔驰',price:199},\n      {id:'002',name:'马自达',price:109},\n      {id:'003',name:'捷达',price:120},\n   ]\n   response.send(cars)\n})\n\napp.listen(5051,(err)=>{\n   if(!err) console.log('服务器2启动成功了,请求汽车信息地址为：http://localhost:5051/cars');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 在 vue 组件使用 axios 请求服务器：\n\n首先引入 axios ：\n\nimport axios from 'axios'\n\n\n1\n\n\n然后编写想服务器请求信息的方法：\n\ngetstudentinfo(){\n  axios.get('http://localhost:5050/students').then(\n      response => {\n        console.log('请求成功了', response.data)\n      },\n      error => {\n        console.log('请求失败', error)\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n运行后，此时出现跨域问题：\n\n * 没有遵循同源策略（协议名、主机名、端口号要一致）（由于 vue 组件基于 http://localhost:8080 运行，而服务器基于 http://localhost:5050 ）\n\n * 虽然引起了跨域但是请求有成功发送。发送请求后，服务器也收到了请求，并且返回了响应，但是浏览器发现了跨域问题导致报错。\n\n\n\n一般有三种解决的方法：\n\n * cors ：服务器响应请求时携带特殊的相应头。（真正意义上解决跨域，但是响应头不能轻易携带）\n * jsonp ：巧妙借助 script 的 src 属性在引入外部资源时不受同源策略实现。但是在真正开发中，得在前端使用特殊方法，后端同时配合；并且只能对 get 请求有效。\n * 配置代理服务器：本身也是服务器，与前台所处的位置（意思是端口）一致，要发送请求时，代理服务器作为中介帮助前台发送请求到服务器 ，服务器返回的请求也通过代理服务器作为中介返回给前台。利用服务器与服务器之间的通信不使用 ajax 而使用 http 请求这一点。\n   * 后端 nginx 开启代理服务器。\n   * 借助 vue-cli 开启代理服务器。\n\n\n# 借助 vue-cli 配置代理服务器\n\n🔗 devserver-proxy ：configuration reference | vue cli (vuejs.org)\n\n第一种方法：\n\n * 在 vue.js.config 配置文件中配置 devserver ：\n\n// 开启代理服务器\ndevserver: {\n    proxy: 'http://localhost:5050'\n}\n\n\n1\n2\n3\n4\n\n * 修改原来请求的路径的端口为代理服务器的端口，并且注意请求的路径要明确：\n\ngetstudentinfo(){\n  axios.get('http://localhost:8080/students').then(\n      response => {\n        console.log('请求成功了', response.data)\n      },\n      error => {\n        console.log('请求失败', error)\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 运行后，请求成功并获得了响应的数据。\n\n提示\n\n使用上述方法配置代理服务器有两个缺陷：\n\n * 优先匹配前端资源：代理服务器并不是将所有的请求都会转发到服务器，当代理服务器中已经存在的资源（在 public 目录下，只要请求路径同名），则不会向服务器请求资源。\n * 通过在 vue.config.js 中的 devserver 中不可以配置多个代理服务器。\n\n第二种方法：\n\n * 在 vue.config.js 配置文件中配置 devserver ：\n\ndevserver: {\n    proxy: {\n        '/server1': { // 请求前缀，请求地址例子：http://localhost:8080/server1/students\n            target: 'http://localhost:5050', // 代理目标服务器的基础历经\n            pathrewrite: {'^/server1': ''}, // 重写路径，匹配以 /server1开头的请求路径\n            ws: true, // 用于支持websocket\n            changeorigin: true // 用于控制请求头中的host值 例子 false为8080，true为5050\n        },\n        '/server2': { // 请求前缀，请求地址例子：http://localhost:8080/server2/cars\n            target: 'http://localhost:5051', \n            pathrewrite: {'^/server2': ''}, \n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n解决了再方法一中的缺点：\n\n * 可以配置多个服务器\n * 请求时加上前缀，解决了当代理服务器可能有重复命名的文件导致请求不能转发到服务器的问题。\n\n但是使用该方法配置略烦琐，并且请求资源时必须要添加前缀。\n\n\n# 配置代理案例（搜索案例）\n\n * 按照组件化编程，划分好组件，实现页面效果：\n\n\n\n * 在搜索组件中完成请求搜索：\n\n🔗 github 提供的用户搜索接口：\n\nhttps://api.github.com/search/users?q=username\n\n\n1\n\n\n在搜索输入框中使用 v-model 绑定输入的关键词，搜索按钮绑定搜索事件方法：\n\n<div>\n  <input type=\"text\" placeholder=\"enter the name you search\" v-model=\"keyword\"/>\n  <button @click=\"searchusers\">search</button>\n</div>\n\n\n1\n2\n3\n4\n\n\n使用 axios 发送请求：\n\ndata() {\n  return {\n    keyword: ''\n  }\n}, methods: {\n  searchusers() {\n    axios.get(`https://api.github.com/search/users?q=${this.keyword}`).then(\n        response => {\n          console.log('请求成功', response.data)\n        },\n        error => {\n          console.log('请求出错', error.massage)\n        }\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n>  * 要在请求链接中插入表达式，要使用 `` 符号。\n>  * 不用考虑跨域问题，因为 github 后端已经解决了 cors 引起的跨域问题（添加特殊的响应头）。 同时 incomplete_results 意思是仅展示部分结果， 搜索结果保存在 items 中。\n>  * 注意不能过于频繁请求接口，否则会被误认为攻击然后被封锁 ip。\n\n * 通过全局事件总线在 search 组件和 list 组件之间的通信。\n\n在 list 组件中绑定自定义事件：\n\nmounted() {\n  this.$bus.$on('getuserresults', (users) => {\n    console.log('list received data,', users)\n    this.users = users\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 search 组件中触发，并传入数据：\n\nsearchusers() {\n  axios.get(`https://api.github.com/search/users?q=${this.keyword}`).then(\n      response => {\n        console.log('请求成功', response.data.items)\n        this.$bus.$emit('getuserresults', response.data.items)\n      },\n      error => {\n        console.log('请求出错', error.massage)\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将获取到的数据应用到模版，使用 v-for 循环：\n\n<div class=\"row\">\n  <div class=\"card\" v-for=\"user in users\" :key=\"user.login\">\n    <a :href=\"user.html_url\" target=\"_blank\">\n      <img :src=\"user.avatar_url\" style='width: 100px'/>\n    </a>\n    <p class=\"card-text\">{{ user.login }}</p>\n  </div>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# vue-resource\n\n * 安装 vue-resource ：\n\n$ npm i vue-resource\n\n\n1\n\n * 在入口文件 main.js 引入：\n\n// 引入 vue-resource\nimport vueresource from 'vue-resource'\n\n// 使用插件\nvue.use(vueresource)\n\n\n1\n2\n3\n4\n5\n\n\n🌰 使用的方法与 axios 类似：\n\nsearchusers() {\n  this.$bus.$emit('updatelistdata', {isfirst: false, isloading: true, errmsg: '', users: []})\n  this.$http.get(`https://api.github.com/search/users?q=${this.keyword}`).then(\n      response => {\n        console.log('请求成功', response.data.items)\n        this.$bus.$emit('updatelistdata', {isloading: false, errmsg: '', users: response.data.items})\n      },\n      error => {\n        console.log('请求出错', error.message)\n        this.$bus.$emit('updatelistdata', {isloading: false, errmsg: error.message, users: []})\n\n      }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n一般在 vue 的早期版本较多使用来实现异步加载，vue 2.0 版本后，一般推荐使用 axios 实现 ajax 请求。\n\n🔗 vue.js ajax (vue-resource) | 菜鸟教程 (runoob.com)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"☔️ Vue Router 路由",frontmatter:{title:"☔️ Vue Router 路由",date:"2022-04-07T23:45:48.000Z",permalink:"/pages/c2ae57/",categories:["📚 前端笔记","🏃 核心部分","⛈ Vue 脚手架"],tags:["Vue"],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/11.%20%E2%9B%88%20Vue%20%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/90.%20%E2%98%94%EF%B8%8F%20Vue%20Router%20%E8%B7%AF%E7%94%B1.html",relativePath:"105. 🏃 前端核心框架/11. ⛈ Vue 组件编程/90. ☔️ Vue Router 路由.md",key:"v-e0c0e444",path:"/pages/c2ae57/",headers:[{level:2,title:"路由的基本使用",slug:"路由的基本使用",normalizedTitle:"路由的基本使用",charIndex:488},{level:3,title:"简单的路由案例",slug:"简单的路由案例",normalizedTitle:"简单的路由案例",charIndex:1225},{level:3,title:"路由使用的几个注意点",slug:"路由使用的几个注意点",normalizedTitle:"路由使用的几个注意点",charIndex:1933},{level:2,title:"多级路由（嵌套路由）",slug:"多级路由-嵌套路由",normalizedTitle:"多级路由（嵌套路由）",charIndex:2217},{level:3,title:"嵌套路由案例",slug:"嵌套路由案例",normalizedTitle:"嵌套路由案例",charIndex:2232},{level:2,title:"路由的更多配置",slug:"路由的更多配置",normalizedTitle:"路由的更多配置",charIndex:3148},{level:3,title:"路由传参",slug:"路由传参",normalizedTitle:"路由传参",charIndex:3160},{level:4,title:"query 传参",slug:"query-传参",normalizedTitle:"query 传参",charIndex:3168},{level:4,title:"params 传参",slug:"params-传参",normalizedTitle:"params 传参",charIndex:3941},{level:3,title:"命名路由",slug:"命名路由",normalizedTitle:"命名路由",charIndex:4991},{level:3,title:"props 配置",slug:"props-配置",normalizedTitle:"props 配置",charIndex:5524},{level:3,title:"replace 属性",slug:"replace-属性",normalizedTitle:"replace 属性",charIndex:6448},{level:3,title:"编程式路由导航",slug:"编程式路由导航",normalizedTitle:"编程式路由导航",charIndex:6725},{level:3,title:"缓存路由组件",slug:"缓存路由组件",normalizedTitle:"缓存路由组件",charIndex:7523},{level:3,title:"路由生命周期钩子",slug:"路由生命周期钩子",normalizedTitle:"路由生命周期钩子",charIndex:7765},{level:3,title:"路由守卫",slug:"路由守卫",normalizedTitle:"路由守卫",charIndex:8176},{level:2,title:"路由器的两种工作模式",slug:"路由器的两种工作模式",normalizedTitle:"路由器的两种工作模式",charIndex:9735}],headersStr:"路由的基本使用 简单的路由案例 路由使用的几个注意点 多级路由（嵌套路由） 嵌套路由案例 路由的更多配置 路由传参 query 传参 params 传参 命名路由 props 配置 replace 属性 编程式路由导航 缓存路由组件 路由生命周期钩子 路由守卫 路由器的两种工作模式",content:"应用理解：要实现 SPA（Single Page Web Application） 单页面网页应用（整个应用只有一个完整的页面），在导航去点击导航链接切换不同的内容展示，但页面不会整体刷新，只会做页面的局部刷新，数据需要 AJAX 请求获取。路由器监测地址路径发生变化，按照路由规则引导到相应的内容。\n\n * 路由与路由器的理解：\n   \n   * 一个路由（Route）就是一组映射关系（ key-value 对应关系， key 是路径， value 是 function 或者 component 。）\n   * 多个路由需要路由器（Router） 进行管理。\n\n * 路由的分类：\n   \n   * 前端路由： value 为 component ，用于展示页面内容。工作过程：当浏览器路径改变时，对应的组件就会显示在页面。 所以要使用路由的前提是，展示的不同内容区分为不同的组件。\n   \n   * 后端路由： value 为 function ，用于处理客户端提交的请求。工作过程：服务器收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据。\n\n\n# 路由的基本使用\n\n * 安装 vue-router ：\n\n$ npm i vue-router@3\n\n\n1\n\n\n> 2022 年 2 月 7 日以后， vue-router 的默认版本为 vue-router 4，并且 vue-router 4 只能在 Vue 3 下运行。所以，在基于 Vue 2 的学习中可以安装 vue-router 3。\n\n * 编写路由文件 src/router/index.js ：\n\n// 该文件专门用于创建整个应用的路由器\n// 引入VueRouter\nimport VueRouter from \"vue-router\"\n// 引入路由组件\n\n// 创建并暴露一个路由器\nexport default new VueRouter({\n    routes: [\n        {\n        \tpath: '',\n        \tcomponent: ,\n        } \n    ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 在入口文件 main.js 中引入 router ，应用插件：\n\n...\n// 引入VueRouter\nimport VueRouter from \"vue-router\"\n// 引入路由器\nimport router from './router'\n\n...\n\n// 应用插件\nVue.use(VueRouter)\n\nnew Vue({\n    el: '#app',\n    render: h => h(app),\n    router: router\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 简单的路由案例\n\n\n\n * 在 App 组件中，实现导航栏的切换：使用 router-link 标签，可以实现类似 <a> 标签的页面跳转功能。\n\n<div class=\"list-group\">\n  \x3c!--原始HTML中使用a标签实现页面的跳转--\x3e\n  \x3c!-- <a class=\"list-group-item\" href=\"./about.html\">About</a>\n       <a class=\"list-group-item active\" href=\"./home.html\">Home</a>--\x3e\n  \x3c!--Vue中借助router-link标签实现类似a标签的路由切换--\x3e\n  <router-link class=\"list-group-item\" active-class=\"active\" to=\"/about\">about</router-link>\n  <router-link class=\"list-group-item\" active-class=\"active\" to=\"/home\">home</router-link>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 样式同样使用 class 属性配置相应的样式，并且高亮样式可以使用 active-class 配置。\n\n * 在指定位置展示指定的路由组件内容：使用 <router-view> 标签。\n\n<div class=\"panel-body\">\n  \x3c!--制定组件的呈现位置--\x3e\n  <router-view></router-view>\n</div>\n\n\n1\n2\n3\n4\n\n\n\n# 路由使用的几个注意点\n\n * 路由组件（通过路由展示页面的内容）通常存放在 pages 文件夹，一般组件（普通通过标签引入组件的内容）通常存放在 components 文件夹。\n\n * 当切换路由组件时，「被隐藏」（被切走）的路由组件，默认是被销毁的，需要的时候才会去挂载。\n\n> 两个路由组件的组件实例都有 $route ，但是里面的路由内容只与目前的路由组件相关；另外都有同一个 $router 。\n\n * 每个组件都有自己的 $route 属性，存储自己的路由信息。\n * 整个应用只有一个 $router ，可以通过组件的 $router 属性获取。\n\n\n# 多级路由（嵌套路由）\n\n\n# 嵌套路由案例\n\n\n\n在 Home 组件中实现内容由不同的组件呈现，此时可以使用嵌套路由。\n\n * 配置路由规则，使用 children 配置项配置嵌套路由：\n\nroutes: [\n    {\n        path: '/about',\n        component: About\n    },\n    {\n        path: '/home',\n        component: Home,\n        children: [\n            {\n                path: 'message',\n                component: Message\n            },\n            {\n                path: 'news',\n                component: News\n            },\n        ]\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意\n\n与一级路由的路径写法不同，在多级路由中的 path 路径配置项中，不必再在路径前面添加 / ，因为 children 下的配置默认为上一级路由的子级路由。\n\n * 在组件中同样适用 router-link 完成路由跳转，注意 to 属性的路径要写完整的路径，否则无法匹配。\n\n<ul class=\"nav nav-tabs\">\n  <li>\n    <router-link class=\"list-group-item\" active-class=\"active\" to=\"/home/news\">News</router-link>\n  </li>\n  <li>\n    <router-link class=\"list-group-item\" active-class=\"active\" to=\"/home/message\">Message</router-link>\n  </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 路由的更多配置\n\n\n# 路由传参\n\n# query 传参\n\n通过 router-link 给目标组件传递参数时可以使用 query 传递。\n\n🌰 使用 query 传递参数的例子：\n\n * 传递参数：\n\n<li v-for=\"message in messageList\" :key=\"message.id\">\n  \x3c!--跳转路由并且携带query参数，to的字符串写法--\x3e\n  \x3c!--<router-link :to=\"`/home/message/detail?id=${message.id}&title=${message.title}`\"> {{ message.title }}</router-link>--\x3e\n\n  \x3c!--跳转路由并且携带query参数，to的对象写法--\x3e\n  <router-link :to=\"{\n    path: '/home/message/detail',\n    query: {\n      id: message.id,\n      title: message.title\n    }\n  }\"> {{ message.title }}</router-link>\n</li>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> router-link 标签中的 to 有两种写法，字符串形式（由于要传入参数所以要使用 `` 符号包裹 ）过于繁琐可以使用对象形式（注意要使用对象形式，必须使字符串内为表达式，所以属性名为 :to ），传递到目标组件的 $route 中。\n\n * 接收参数：\n\n<ul>\n  <li>消息编号 {{ $route.query.id }}</li>\n  <li>消息标题 {{ $route.query.title }}</li>\n</ul>\n\n\n1\n2\n3\n4\n\n\n# params 传参\n\n通过 router-link 传递参数的不同于 query 的写法（字符串形式）的另一种传递参数方法。使用方法：要现在路由配置文件中声明传递的参数在路径中的格式，然后才能在路由路径中匹配出对应的参数（或者直接使用对象指定名称传递）。一般直接用于简化字符串形式。\n\n🌰：使用 params 传递参数的例子：\n\n * 配置路由文件的 Detail 相关的路由：\n\n... \n{\n    path: 'message', // 子级路由不用斜杠\n    component: Message,\n    children: [\n        {\n            name: 'detail',\n            path: 'detail/:id/:title',\n            component: Detail\n        }\n    ]\n},\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 传递参数：\n\n<li v-for=\"message in messageList\" :key=\"message.id\">\n  \x3c!--跳转路由并且携带params参数，to的字符串写法--\x3e\n  <router-link :to=\"`/home/message/detail/${message.id}/${message.title}`\"> {{ message.title }}</router-link>\n\n  \x3c!--跳转路由并且携带params参数，to的对象写法--\x3e\n  <router-link :to=\"{\n    name: 'detail',\n    params:{\n      id: message.id,\n      title: message.title\n    }\n  }\"> {{ message.title }}\n  </router-link>\n</li>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 使用 params 传递参数时， to 的对象写法一定要使用 name 配置项，不能使用 path 配置项。\n\n * 接收参数：\n\n<ul>\n  <li>消息编号 {{ $route.params.id }}</li>\n  <li>消息标题 {{ $route.params.title }}</li>\n</ul>\n\n\n1\n2\n3\n4\n\n\n\n# 命名路由\n\n将路由语义化的配置 name ，可以简化跳转的路径，注意只能使用对象形式的 name 配置命名，不能用于简化形式（字符串），简化形式默认值给的是 path 配置。\n\n🌰 ：使用命名路由的例子：\n\n * 在路由配置文件中，给相关的路由命名：\n\nroutes: [\n    {\n        name: 'about',\n        path: '/about',\n        component: About\n    },\n    {\n        name: 'home',\n        path: '/home',\n        component: Home,\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 在组件中使用 router-link 配置 :to 属性时：\n\n<router-link class=\"list-group-item\" active-class=\"active\" :to=\"{ name: 'About' }\">about</router-link>\n\n\n1\n\n\n> 一般用于路由路径较长的情况。例如上述例子路由路径较短可以直接使用字符串形式的路由路径即可。\n\n\n# props 配置\n\n前面使用 params 或者 query 传递参数在接收参数时，都是直接在模版中使用 $route 直接读取。 props 配置可以让路由组件更加方便地接收到参数。\n\n🌰 使用 props 传递参数时：\n\n * 在路由配置文件中在要接收参数的组件路由配置 props ，有三种写法：\n\n...\n{\n    name: 'detail',\n    path: 'detail/:id/:title',\n    component: Detail,\n\n    // 1 props中值为对象，该对象中的所有key-value都会以props传给Detail组件中的$route.props\n    // props: {a: 1, b: hello}\n\n    // 2 值为布尔值，若布尔值为真就会把路由组件收到的所有params参数，以props的形式传送给Detail组件（只能适用params传参）\n    // props: true\n\n    // 3 props值为函数，该对象中的所有key-value都会以props传给Detail组件\n    props($route) {\n        return {\n            id: $route.params.id,\n            title: $route.params.title\n        }\n    }\n   /*props({query: id,title}) {\n        return { id, title }\n    }*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 传递参数时可以使用 query 或者 params 配置。\n * 接收参数时，先使用 props 接收，然后再在模版中简化使用。\n\nprops: ['id', 'title']\n\n\n1\n\n\n<ul>\n  <li>消息编号 {{ id }}</li>\n  <li>消息标题 {{ title }}</li>\n</ul>\n\n\n1\n2\n3\n4\n\n\n\n# replace 属性\n\n作用：控制路由跳转时操作浏览器历史记录的模式。\n\n> 浏览器的历史记录有两种写入方式：\n> \n>  * push ：追加历史记录；\n>  * replace ：替换当前记录，前面的记录不会受到影响。\n> \n> 路由跳转时默认为 push 方式。\n\n使用：在 <router-link> 中添加 replace 属性，修改浏览器的历史记录写入方式。\n\n<router-link replace .......>News</router-link>\n\n\n1\n\n\n> :replace=“true” 简写为 replace 。\n\n\n# 编程式路由导航\n\n作用：不借助 <router-link> 实现路由的跳转，让路由跳转更加灵活。（当最终样式不为 <a> 标签，为其他的标签样式或者存在其他功能）主要使用 $router 中的 API。\n\n🌰 使用 $router 实现 push 、 replace 、 back 、 forward 跳转的例子：\n\n * 在组件中，跳转并且传递参数，替换掉之前使用的 router-link 标签。\n\nmethods: {\n  pushShow(message) {\n    this.$router.push({\n      name: 'detail',\n      params:{\n        id: message.id,\n        title: message.title\n      }\n    })\n  },\n  replaceShow(message) {\n    this.$router.replace({\n      name: 'detail',\n      params:{\n        id: message.id,\n        title: message.title\n      }\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 使用两个按钮实现页面的前进和后退，或者前进或者后退指定的步数。\n\nmethods: {\n  back() {\n    this.$router.back()\n  },\n  forward() {\n    this.$router.forward()\n  },\n  go(){\n    this.$router.go(-2) // 参数为步数\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 缓存路由组件\n\n作用：让不展示的路由组件保持挂载，不被销毁。\n\n使用：使用 <keep alive> 包裹要保留的路由视图。属性 include 指定要保留的组件名称。\n\n<keep-alive include=\"News\">\n  <router-view/>\n</keep-alive>\n\n\n1\n2\n3\n\n\n<keep-alive :include=\"['News','Message']\">\n  <router-view/>\n</keep-alive>\n\n\n1\n2\n3\n\n\n\n# 路由生命周期钩子\n\n 1. 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n 2. 具体名字：\n    1. activated 路由组件被激活时触发。\n    2. deactivated 路由组件失活时触发。\n\n🌰 例子：\n\nactivated() {\n  console.log('News组件被激活')\n  this.timer = setInterval(() => {\n    // console.log('@')\n    this.opacity -= 0.01\n    if (this.opacity <= 0) this.opacity = 1\n  }, 16)\n},\ndeactivated() {\n  console.log('News组件失活了')\n  clearInterval(this.timer)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 路由守卫\n\n 1. 作用：对路由进行权限控制。\n 2. 分类：全局守卫、独享守卫、组件内守卫。\n\n🌰 全局守卫的例子：\n\n * 全局前置守卫：初始化执行、每次路由切换前执行：\n\nrouter.beforeEach((to, from, next) => {\n  console.log('@', to, from)\n  if(to.meta.isAuth) {\n    if (localStorage.getItem('name') === 'simon') {\n      next()\n    } else {\n      alert('没有权限')\n      }\n  } else {\n    next()\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 在要使用权限判断的组件路由配置中添加新的配置 meta 存储相关的属性，如 isAuth ，当 isAuth 为 true 时表示需要进行权限判断：\n\n{\n    name: 'Message',\n    path: 'message',\n    component: Message,\n    meta: {isAuth: true, title:'消息'},\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 后置路由守卫：初始化执行、每次路由切换之后执行：\n\nrouter.afterEach((to, from) => {\n    console.log('afterEach',to, from)\n    // 借助后置路由守卫修改网页标题，如果使用前置守卫编码重复\n    document.title = to.meta.title || 'Vue Guard DEMO'\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 注意：后置路由守卫不会有 next 。\n\n🌰 独享守卫例子：\n\n独享路由只有在切换目标路由的之前执行，即只能配置 beforeEnter ：\n\n * 给 News 组件配置 beforeEnter ：\n\n{\n    name: 'News',\n    path: 'news',\n    component: News,\n    meta: {isAuth: true, title: '新闻'},\n    beforeEnter: (to, from, next) => {\n        if (to.meta.isAuth) {\n            if (localStorage.getItem('name') === 'simon') {\n                next()\n            } else {\n                alert('没有权限')\n            }\n        } else {\n            next()\n        }\n    }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n🌰 组件内守卫：\n\n>  * 是通过路由规则切换路由或者进入路由时触发的。\n>  * 要与前置路由与后置路由区分，这是发生在前置路由之后，以及后置路由之前，在组件内部处理的守卫逻辑，并且不离开当前组件不会调用 beforeRouteLeave 。\n\n// 通过路由规则，进入该组件时被调用\nbeforeRouteEnter(to, from, next) {\n  // ...\n},\n// 通过路由规则，离开该组件时被调用\nbeforeRouteLeave(to, from, next) {\n\t// ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 路由器的两种工作模式\n\n关于 Hash 值：\n\n * 是 URL 地址从 # 开始以及其后面的内容。\n\n * Hash 值不会包含在 HTTP 请求中，即 Hash 值不会做为路径的一部分发送给服务器。\n\n路由器有两种工作模式，默认是 Hash 模式：\n\n * Hash 模式：\n   \n   * URL 地址总是会带着 # 。\n   * 地址分享时可能会标记为不合法。\n   * 浏览器兼容性较好。\n\n * history 模式：\n   \n   * URL 地址与 Hash 模式相比不带有 # 。\n   \n   * 浏览器兼容性与 Hash 模式相比相比略差。\n   \n   * 应用部署上线时需要后端人员支持，要解决刷新页面时服务端找不到资源的问题。\n     \n     > 🔗 相关链接：connect-history-api-fallback - npm (npmjs.com) Middleware to proxy requests through a specified index page, useful for Single Page Applications that utilise the HTML5 History API.\n\n🌰 修改路由器的工作模式的例子：\n\n * 在路由器配置文件中，添加 mode 配置：\n\nconst router = new VueRouter({\n    mode: 'history',\n    routes: ...\n})\n\n\n1\n2\n3\n4\n",normalizedContent:"应用理解：要实现 spa（single page web application） 单页面网页应用（整个应用只有一个完整的页面），在导航去点击导航链接切换不同的内容展示，但页面不会整体刷新，只会做页面的局部刷新，数据需要 ajax 请求获取。路由器监测地址路径发生变化，按照路由规则引导到相应的内容。\n\n * 路由与路由器的理解：\n   \n   * 一个路由（route）就是一组映射关系（ key-value 对应关系， key 是路径， value 是 function 或者 component 。）\n   * 多个路由需要路由器（router） 进行管理。\n\n * 路由的分类：\n   \n   * 前端路由： value 为 component ，用于展示页面内容。工作过程：当浏览器路径改变时，对应的组件就会显示在页面。 所以要使用路由的前提是，展示的不同内容区分为不同的组件。\n   \n   * 后端路由： value 为 function ，用于处理客户端提交的请求。工作过程：服务器收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据。\n\n\n# 路由的基本使用\n\n * 安装 vue-router ：\n\n$ npm i vue-router@3\n\n\n1\n\n\n> 2022 年 2 月 7 日以后， vue-router 的默认版本为 vue-router 4，并且 vue-router 4 只能在 vue 3 下运行。所以，在基于 vue 2 的学习中可以安装 vue-router 3。\n\n * 编写路由文件 src/router/index.js ：\n\n// 该文件专门用于创建整个应用的路由器\n// 引入vuerouter\nimport vuerouter from \"vue-router\"\n// 引入路由组件\n\n// 创建并暴露一个路由器\nexport default new vuerouter({\n    routes: [\n        {\n        \tpath: '',\n        \tcomponent: ,\n        } \n    ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 在入口文件 main.js 中引入 router ，应用插件：\n\n...\n// 引入vuerouter\nimport vuerouter from \"vue-router\"\n// 引入路由器\nimport router from './router'\n\n...\n\n// 应用插件\nvue.use(vuerouter)\n\nnew vue({\n    el: '#app',\n    render: h => h(app),\n    router: router\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 简单的路由案例\n\n\n\n * 在 app 组件中，实现导航栏的切换：使用 router-link 标签，可以实现类似 <a> 标签的页面跳转功能。\n\n<div class=\"list-group\">\n  \x3c!--原始html中使用a标签实现页面的跳转--\x3e\n  \x3c!-- <a class=\"list-group-item\" href=\"./about.html\">about</a>\n       <a class=\"list-group-item active\" href=\"./home.html\">home</a>--\x3e\n  \x3c!--vue中借助router-link标签实现类似a标签的路由切换--\x3e\n  <router-link class=\"list-group-item\" active-class=\"active\" to=\"/about\">about</router-link>\n  <router-link class=\"list-group-item\" active-class=\"active\" to=\"/home\">home</router-link>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 样式同样使用 class 属性配置相应的样式，并且高亮样式可以使用 active-class 配置。\n\n * 在指定位置展示指定的路由组件内容：使用 <router-view> 标签。\n\n<div class=\"panel-body\">\n  \x3c!--制定组件的呈现位置--\x3e\n  <router-view></router-view>\n</div>\n\n\n1\n2\n3\n4\n\n\n\n# 路由使用的几个注意点\n\n * 路由组件（通过路由展示页面的内容）通常存放在 pages 文件夹，一般组件（普通通过标签引入组件的内容）通常存放在 components 文件夹。\n\n * 当切换路由组件时，「被隐藏」（被切走）的路由组件，默认是被销毁的，需要的时候才会去挂载。\n\n> 两个路由组件的组件实例都有 $route ，但是里面的路由内容只与目前的路由组件相关；另外都有同一个 $router 。\n\n * 每个组件都有自己的 $route 属性，存储自己的路由信息。\n * 整个应用只有一个 $router ，可以通过组件的 $router 属性获取。\n\n\n# 多级路由（嵌套路由）\n\n\n# 嵌套路由案例\n\n\n\n在 home 组件中实现内容由不同的组件呈现，此时可以使用嵌套路由。\n\n * 配置路由规则，使用 children 配置项配置嵌套路由：\n\nroutes: [\n    {\n        path: '/about',\n        component: about\n    },\n    {\n        path: '/home',\n        component: home,\n        children: [\n            {\n                path: 'message',\n                component: message\n            },\n            {\n                path: 'news',\n                component: news\n            },\n        ]\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意\n\n与一级路由的路径写法不同，在多级路由中的 path 路径配置项中，不必再在路径前面添加 / ，因为 children 下的配置默认为上一级路由的子级路由。\n\n * 在组件中同样适用 router-link 完成路由跳转，注意 to 属性的路径要写完整的路径，否则无法匹配。\n\n<ul class=\"nav nav-tabs\">\n  <li>\n    <router-link class=\"list-group-item\" active-class=\"active\" to=\"/home/news\">news</router-link>\n  </li>\n  <li>\n    <router-link class=\"list-group-item\" active-class=\"active\" to=\"/home/message\">message</router-link>\n  </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 路由的更多配置\n\n\n# 路由传参\n\n# query 传参\n\n通过 router-link 给目标组件传递参数时可以使用 query 传递。\n\n🌰 使用 query 传递参数的例子：\n\n * 传递参数：\n\n<li v-for=\"message in messagelist\" :key=\"message.id\">\n  \x3c!--跳转路由并且携带query参数，to的字符串写法--\x3e\n  \x3c!--<router-link :to=\"`/home/message/detail?id=${message.id}&title=${message.title}`\"> {{ message.title }}</router-link>--\x3e\n\n  \x3c!--跳转路由并且携带query参数，to的对象写法--\x3e\n  <router-link :to=\"{\n    path: '/home/message/detail',\n    query: {\n      id: message.id,\n      title: message.title\n    }\n  }\"> {{ message.title }}</router-link>\n</li>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> router-link 标签中的 to 有两种写法，字符串形式（由于要传入参数所以要使用 `` 符号包裹 ）过于繁琐可以使用对象形式（注意要使用对象形式，必须使字符串内为表达式，所以属性名为 :to ），传递到目标组件的 $route 中。\n\n * 接收参数：\n\n<ul>\n  <li>消息编号 {{ $route.query.id }}</li>\n  <li>消息标题 {{ $route.query.title }}</li>\n</ul>\n\n\n1\n2\n3\n4\n\n\n# params 传参\n\n通过 router-link 传递参数的不同于 query 的写法（字符串形式）的另一种传递参数方法。使用方法：要现在路由配置文件中声明传递的参数在路径中的格式，然后才能在路由路径中匹配出对应的参数（或者直接使用对象指定名称传递）。一般直接用于简化字符串形式。\n\n🌰：使用 params 传递参数的例子：\n\n * 配置路由文件的 detail 相关的路由：\n\n... \n{\n    path: 'message', // 子级路由不用斜杠\n    component: message,\n    children: [\n        {\n            name: 'detail',\n            path: 'detail/:id/:title',\n            component: detail\n        }\n    ]\n},\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 传递参数：\n\n<li v-for=\"message in messagelist\" :key=\"message.id\">\n  \x3c!--跳转路由并且携带params参数，to的字符串写法--\x3e\n  <router-link :to=\"`/home/message/detail/${message.id}/${message.title}`\"> {{ message.title }}</router-link>\n\n  \x3c!--跳转路由并且携带params参数，to的对象写法--\x3e\n  <router-link :to=\"{\n    name: 'detail',\n    params:{\n      id: message.id,\n      title: message.title\n    }\n  }\"> {{ message.title }}\n  </router-link>\n</li>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 使用 params 传递参数时， to 的对象写法一定要使用 name 配置项，不能使用 path 配置项。\n\n * 接收参数：\n\n<ul>\n  <li>消息编号 {{ $route.params.id }}</li>\n  <li>消息标题 {{ $route.params.title }}</li>\n</ul>\n\n\n1\n2\n3\n4\n\n\n\n# 命名路由\n\n将路由语义化的配置 name ，可以简化跳转的路径，注意只能使用对象形式的 name 配置命名，不能用于简化形式（字符串），简化形式默认值给的是 path 配置。\n\n🌰 ：使用命名路由的例子：\n\n * 在路由配置文件中，给相关的路由命名：\n\nroutes: [\n    {\n        name: 'about',\n        path: '/about',\n        component: about\n    },\n    {\n        name: 'home',\n        path: '/home',\n        component: home,\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 在组件中使用 router-link 配置 :to 属性时：\n\n<router-link class=\"list-group-item\" active-class=\"active\" :to=\"{ name: 'about' }\">about</router-link>\n\n\n1\n\n\n> 一般用于路由路径较长的情况。例如上述例子路由路径较短可以直接使用字符串形式的路由路径即可。\n\n\n# props 配置\n\n前面使用 params 或者 query 传递参数在接收参数时，都是直接在模版中使用 $route 直接读取。 props 配置可以让路由组件更加方便地接收到参数。\n\n🌰 使用 props 传递参数时：\n\n * 在路由配置文件中在要接收参数的组件路由配置 props ，有三种写法：\n\n...\n{\n    name: 'detail',\n    path: 'detail/:id/:title',\n    component: detail,\n\n    // 1 props中值为对象，该对象中的所有key-value都会以props传给detail组件中的$route.props\n    // props: {a: 1, b: hello}\n\n    // 2 值为布尔值，若布尔值为真就会把路由组件收到的所有params参数，以props的形式传送给detail组件（只能适用params传参）\n    // props: true\n\n    // 3 props值为函数，该对象中的所有key-value都会以props传给detail组件\n    props($route) {\n        return {\n            id: $route.params.id,\n            title: $route.params.title\n        }\n    }\n   /*props({query: id,title}) {\n        return { id, title }\n    }*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 传递参数时可以使用 query 或者 params 配置。\n * 接收参数时，先使用 props 接收，然后再在模版中简化使用。\n\nprops: ['id', 'title']\n\n\n1\n\n\n<ul>\n  <li>消息编号 {{ id }}</li>\n  <li>消息标题 {{ title }}</li>\n</ul>\n\n\n1\n2\n3\n4\n\n\n\n# replace 属性\n\n作用：控制路由跳转时操作浏览器历史记录的模式。\n\n> 浏览器的历史记录有两种写入方式：\n> \n>  * push ：追加历史记录；\n>  * replace ：替换当前记录，前面的记录不会受到影响。\n> \n> 路由跳转时默认为 push 方式。\n\n使用：在 <router-link> 中添加 replace 属性，修改浏览器的历史记录写入方式。\n\n<router-link replace .......>news</router-link>\n\n\n1\n\n\n> :replace=“true” 简写为 replace 。\n\n\n# 编程式路由导航\n\n作用：不借助 <router-link> 实现路由的跳转，让路由跳转更加灵活。（当最终样式不为 <a> 标签，为其他的标签样式或者存在其他功能）主要使用 $router 中的 api。\n\n🌰 使用 $router 实现 push 、 replace 、 back 、 forward 跳转的例子：\n\n * 在组件中，跳转并且传递参数，替换掉之前使用的 router-link 标签。\n\nmethods: {\n  pushshow(message) {\n    this.$router.push({\n      name: 'detail',\n      params:{\n        id: message.id,\n        title: message.title\n      }\n    })\n  },\n  replaceshow(message) {\n    this.$router.replace({\n      name: 'detail',\n      params:{\n        id: message.id,\n        title: message.title\n      }\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 使用两个按钮实现页面的前进和后退，或者前进或者后退指定的步数。\n\nmethods: {\n  back() {\n    this.$router.back()\n  },\n  forward() {\n    this.$router.forward()\n  },\n  go(){\n    this.$router.go(-2) // 参数为步数\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 缓存路由组件\n\n作用：让不展示的路由组件保持挂载，不被销毁。\n\n使用：使用 <keep alive> 包裹要保留的路由视图。属性 include 指定要保留的组件名称。\n\n<keep-alive include=\"news\">\n  <router-view/>\n</keep-alive>\n\n\n1\n2\n3\n\n\n<keep-alive :include=\"['news','message']\">\n  <router-view/>\n</keep-alive>\n\n\n1\n2\n3\n\n\n\n# 路由生命周期钩子\n\n 1. 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n 2. 具体名字：\n    1. activated 路由组件被激活时触发。\n    2. deactivated 路由组件失活时触发。\n\n🌰 例子：\n\nactivated() {\n  console.log('news组件被激活')\n  this.timer = setinterval(() => {\n    // console.log('@')\n    this.opacity -= 0.01\n    if (this.opacity <= 0) this.opacity = 1\n  }, 16)\n},\ndeactivated() {\n  console.log('news组件失活了')\n  clearinterval(this.timer)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 路由守卫\n\n 1. 作用：对路由进行权限控制。\n 2. 分类：全局守卫、独享守卫、组件内守卫。\n\n🌰 全局守卫的例子：\n\n * 全局前置守卫：初始化执行、每次路由切换前执行：\n\nrouter.beforeeach((to, from, next) => {\n  console.log('@', to, from)\n  if(to.meta.isauth) {\n    if (localstorage.getitem('name') === 'simon') {\n      next()\n    } else {\n      alert('没有权限')\n      }\n  } else {\n    next()\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 在要使用权限判断的组件路由配置中添加新的配置 meta 存储相关的属性，如 isauth ，当 isauth 为 true 时表示需要进行权限判断：\n\n{\n    name: 'message',\n    path: 'message',\n    component: message,\n    meta: {isauth: true, title:'消息'},\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 后置路由守卫：初始化执行、每次路由切换之后执行：\n\nrouter.aftereach((to, from) => {\n    console.log('aftereach',to, from)\n    // 借助后置路由守卫修改网页标题，如果使用前置守卫编码重复\n    document.title = to.meta.title || 'vue guard demo'\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 注意：后置路由守卫不会有 next 。\n\n🌰 独享守卫例子：\n\n独享路由只有在切换目标路由的之前执行，即只能配置 beforeenter ：\n\n * 给 news 组件配置 beforeenter ：\n\n{\n    name: 'news',\n    path: 'news',\n    component: news,\n    meta: {isauth: true, title: '新闻'},\n    beforeenter: (to, from, next) => {\n        if (to.meta.isauth) {\n            if (localstorage.getitem('name') === 'simon') {\n                next()\n            } else {\n                alert('没有权限')\n            }\n        } else {\n            next()\n        }\n    }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n🌰 组件内守卫：\n\n>  * 是通过路由规则切换路由或者进入路由时触发的。\n>  * 要与前置路由与后置路由区分，这是发生在前置路由之后，以及后置路由之前，在组件内部处理的守卫逻辑，并且不离开当前组件不会调用 beforerouteleave 。\n\n// 通过路由规则，进入该组件时被调用\nbeforerouteenter(to, from, next) {\n  // ...\n},\n// 通过路由规则，离开该组件时被调用\nbeforerouteleave(to, from, next) {\n\t// ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 路由器的两种工作模式\n\n关于 hash 值：\n\n * 是 url 地址从 # 开始以及其后面的内容。\n\n * hash 值不会包含在 http 请求中，即 hash 值不会做为路径的一部分发送给服务器。\n\n路由器有两种工作模式，默认是 hash 模式：\n\n * hash 模式：\n   \n   * url 地址总是会带着 # 。\n   * 地址分享时可能会标记为不合法。\n   * 浏览器兼容性较好。\n\n * history 模式：\n   \n   * url 地址与 hash 模式相比不带有 # 。\n   \n   * 浏览器兼容性与 hash 模式相比相比略差。\n   \n   * 应用部署上线时需要后端人员支持，要解决刷新页面时服务端找不到资源的问题。\n     \n     > 🔗 相关链接：connect-history-api-fallback - npm (npmjs.com) middleware to proxy requests through a specified index page, useful for single page applications that utilise the html5 history api.\n\n🌰 修改路由器的工作模式的例子：\n\n * 在路由器配置文件中，添加 mode 配置：\n\nconst router = new vuerouter({\n    mode: 'history',\n    routes: ...\n})\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"☂️ Vue 3 上手",frontmatter:{title:"☂️ Vue 3 上手",date:"2022-04-10T10:04:24.000Z",permalink:"/pages/c8dfe0/",categories:["📚 前端笔记","🏃 核心框架","🌨 Vue 3"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/15.%20%F0%9F%8C%A8%20Vue%203%20%E7%BB%84%E5%90%88%E5%BC%8F%20API/01.%20%E2%98%82%EF%B8%8F%20Vue%203%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE.html",relativePath:"105. 🏃 前端核心框架/15. 🌨 Vue 3 组合式 API/01. ☂️ Vue 3 创建项目.md",key:"v-accee9b2",path:"/pages/c8dfe0/",headers:[{level:3,title:"新的特性",slug:"新的特性",normalizedTitle:"新的特性",charIndex:2},{level:2,title:"Vue 3 的安装",slug:"vue-3-的安装",normalizedTitle:"vue 3 的安装",charIndex:58},{level:3,title:"使用 Vue-CLI 创建 Vue 3 项目",slug:"使用-vue-cli-创建-vue-3-项目",normalizedTitle:"使用 vue-cli 创建 vue 3 项目",charIndex:72},{level:3,title:"使用 Vite 创建 Vue 3 项目",slug:"使用-vite-创建-vue-3-项目",normalizedTitle:"使用 vite 创建 vue 3 项目",charIndex:197},{level:2,title:"Vue 3 项目结构分析",slug:"vue-3-项目结构分析",normalizedTitle:"vue 3 项目结构分析",charIndex:353}],headersStr:"新的特性 Vue 3 的安装 使用 Vue-CLI 创建 Vue 3 项目 使用 Vite 创建 Vue 3 项目 Vue 3 项目结构分析",content:"# 新的特性\n\n * Composition API （组合 API）\n * 新的内置组件\n * 其他特性\n\n\n# Vue 3 的安装\n\n\n# 使用 Vue-CLI 创建 Vue 3 项目\n\n * 确保 Vue 的版本在 4.5.10 以上\n\n$ vue -V\n\n\n1\n\n * 创建 Vue 3 的 CLI 项目：\n\n$ vue create vue3-cli-test\n\n\n1\n\n\n\n\n\n# 使用 Vite 创建 Vue 3 项目\n\n🔗 参照链接：Home | Vite 中文网 (vitejs.cn)\n\n$ npm init vite-app vue3-vite-test\n$ cd vue3-vite-test\n$ npm install\n$ npm run dev\n\n\n1\n2\n3\n4\n\n\n\n# Vue 3 项目结构分析\n\nmain.js\n\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n\n\n1\n2\n3\n4\n\n * 在 Vue 3 引入的不再是 Vue 构造函数，引入的是一个名为 createApp 的工厂函数。\n\n>  * Vue 2 时期创建 Vue 实例对象：\n> \n> const app = createApp(App) // 创建实例对象app（类似于Vue 2中的vm，但是app比vm更轻量）\n> app.mount('#app')\n> \n> \n> 1\n> 2\n\n----------------------------------------\n\n * 在 Vue 3 中组件模版结构可以没有根标签包裹。",normalizedContent:"# 新的特性\n\n * composition api （组合 api）\n * 新的内置组件\n * 其他特性\n\n\n# vue 3 的安装\n\n\n# 使用 vue-cli 创建 vue 3 项目\n\n * 确保 vue 的版本在 4.5.10 以上\n\n$ vue -v\n\n\n1\n\n * 创建 vue 3 的 cli 项目：\n\n$ vue create vue3-cli-test\n\n\n1\n\n\n\n\n\n# 使用 vite 创建 vue 3 项目\n\n🔗 参照链接：home | vite 中文网 (vitejs.cn)\n\n$ npm init vite-app vue3-vite-test\n$ cd vue3-vite-test\n$ npm install\n$ npm run dev\n\n\n1\n2\n3\n4\n\n\n\n# vue 3 项目结构分析\n\nmain.js\n\nimport { createapp } from 'vue'\nimport app from './app.vue'\n\ncreateapp(app).mount('#app')\n\n\n1\n2\n3\n4\n\n * 在 vue 3 引入的不再是 vue 构造函数，引入的是一个名为 createapp 的工厂函数。\n\n>  * vue 2 时期创建 vue 实例对象：\n> \n> const app = createapp(app) // 创建实例对象app（类似于vue 2中的vm，但是app比vm更轻量）\n> app.mount('#app')\n> \n> \n> 1\n> 2\n\n----------------------------------------\n\n * 在 vue 3 中组件模版结构可以没有根标签包裹。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧊 Vue 3 的组合 API 编程",frontmatter:{title:"🧊 Vue 3 的组合 API 编程",date:"2022-04-10T12:42:10.000Z",permalink:"/pages/0768ce/",categories:["📚 前端笔记","🏃 核心框架","🌨 Vue 3"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/15.%20%F0%9F%8C%A8%20Vue%203%20%E7%BB%84%E5%90%88%E5%BC%8F%20API/02.%20%F0%9F%A7%8A%20Vue%203%20%E7%9A%84%E7%BB%84%E5%90%88%20API%20%E7%BC%96%E7%A8%8B.html",relativePath:"105. 🏃 前端核心框架/15. 🌨 Vue 3 组合式 API/02. 🧊 Vue 3 的组合 API 编程.md",key:"v-4645f627",path:"/pages/0768ce/",headers:[{level:2,title:"常用 API",slug:"常用-api",normalizedTitle:"常用 api",charIndex:2},{level:3,title:"setup",slug:"setup",normalizedTitle:"setup",charIndex:13},{level:3,title:"ref 函数",slug:"ref-函数",normalizedTitle:"ref 函数",charIndex:878},{level:3,title:"reactive 函数",slug:"reactive-函数",normalizedTitle:"reactive 函数",charIndex:1333},{level:3,title:"对比 ref 与 reactive 函数",slug:"对比-ref-与-reactive-函数",normalizedTitle:"对比 ref 与 reactive 函数",charIndex:1625},{level:3,title:"setup 的注意点",slug:"setup-的注意点",normalizedTitle:"setup 的注意点",charIndex:2008},{level:3,title:"响应式原理",slug:"响应式原理",normalizedTitle:"响应式原理",charIndex:2380},{level:4,title:"Vue 2 中的响应式",slug:"vue-2-中的响应式",normalizedTitle:"vue 2 中的响应式",charIndex:2389},{level:4,title:"Vue3 的响应式",slug:"vue3-的响应式",normalizedTitle:"vue3 的响应式",charIndex:2781},{level:3,title:"计算属性 computed 函数",slug:"计算属性-computed-函数",normalizedTitle:"计算属性 computed 函数",charIndex:3467},{level:3,title:"数据监视 watch 函数",slug:"数据监视-watch-函数",normalizedTitle:"数据监视 watch 函数",charIndex:4200},{level:3,title:"watchEffect 函数",slug:"watcheffect-函数",normalizedTitle:"watcheffect 函数",charIndex:5796},{level:3,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:6199},{level:3,title:"自定义 hook 函数",slug:"自定义-hook-函数",normalizedTitle:"自定义 hook 函数",charIndex:6650},{level:3,title:"toRef 函数",slug:"toref-函数",normalizedTitle:"toref 函数",charIndex:7644},{level:2,title:"其他 API",slug:"其他-api",normalizedTitle:"其他 api",charIndex:8032},{level:3,title:"shallowReactive 原始 shallowRef 函数",slug:"shallowreactive-原始-shallowref-函数",normalizedTitle:"shallowreactive 原始 shallowref 函数",charIndex:8043},{level:3,title:"readonly 与 shallowReadonly 函数",slug:"readonly-与-shallowreadonly-函数",normalizedTitle:"readonly 与 shallowreadonly 函数",charIndex:8384},{level:3,title:"toRaw 与 markRaw 函数",slug:"toraw-与-markraw-函数",normalizedTitle:"toraw 与 markraw 函数",charIndex:8587},{level:3,title:"customRef",slug:"customref",normalizedTitle:"customref",charIndex:8835},{level:3,title:"provide 与 inject",slug:"provide-与-inject",normalizedTitle:"provide 与 inject",charIndex:9600},{level:3,title:"响应式数据判断",slug:"响应式数据判断",normalizedTitle:"响应式数据判断",charIndex:9993},{level:2,title:"Composition API 的优势",slug:"composition-api-的优势",normalizedTitle:"composition api 的优势",charIndex:10240},{level:3,title:"Options API 存在的问题",slug:"options-api-存在的问题",normalizedTitle:"options api 存在的问题",charIndex:10264},{level:3,title:"Composition API 的优势",slug:"composition-api-的优势-2",normalizedTitle:"composition api 的优势",charIndex:10240}],headersStr:"常用 API setup ref 函数 reactive 函数 对比 ref 与 reactive 函数 setup 的注意点 响应式原理 Vue 2 中的响应式 Vue3 的响应式 计算属性 computed 函数 数据监视 watch 函数 watchEffect 函数 生命周期 自定义 hook 函数 toRef 函数 其他 API shallowReactive 原始 shallowRef 函数 readonly 与 shallowReadonly 函数 toRaw 与 markRaw 函数 customRef provide 与 inject 响应式数据判断 Composition API 的优势 Options API 存在的问题 Composition API 的优势",content:"# 常用 API\n\n\n# setup\n\n * setup 是 Vue 3 中的新的一个配置项，值为一个函数。\n   \n   是所有 Composition 组合 API 「表演的舞台」。\n\n * 组件中所有到的：数据、方法，都要配置在 setup 中。\n\n * setup 函数中的两种返回值：\n   \n   * ⭐️ 若最后返回一个对象，则对象中的属性、方法，在模版中可以直接使用。\n   * 若返回一个渲染函数，则可以返回自定义的渲染内容（了解）。\n\n🌰 例子：在 setup 中返回一个对象：\n\nsetup() {\n  // 数据\n  let name = 'Simon'\n  let age = '3'\n\n  // 方法\n  function sayHello() {\n    alert(`hello, this is ${name}, age:${age}`)\n  }\n\n  return {\n    name,\n    age,\n    sayHello\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * ⚠️ 注意：\n   1. 尽量不要与 Vue 2.x 中的配置混用：\n      * Vue 2.x 的配置（ data 、 methods 、 computed … ）中可以访问到 setup 中的属性、方法。\n      * 但是在 setup 配置中不能访问 Vue 2.x 的配置（ data 、 methods 、 computed … ）。\n      * 当 setup 中的属性、方法与 Vue 2.x 的配置有重名时，以 setup 优先。\n   2. setup 不能是一个 async 函数，因为返回值不再是 return 对象，而是一个被 async 包裹的对象，而是 promise ，此时模版无法使用 return 中的属性（后期可以返回一个 Promise 的实例，但是需要 Suspense 和异步组件的配合 🔗 Suspense 组件）\n\n\n# ref 函数\n\n>  * 在之前使用的 ref ，作用是给原生的 DOM 标签添加标识，替代 id 的作用。\n>  * 在上述 setup 的例子中定义的数据不是一个响应式的数据，发生变化 Vue 无法监测。\n\n * ref 函数作用：定义一个响应式的数据。\n\n * 语法： const xxx = ref(initValue)\n   \n   * 创建一个 ReflImpl ： reference + implement 包含响应式数据的引用 ref 对象（引用实现对象）。\n   * 在 JS 中操作数据： xxx.value\n   * 在模版中读取数据：直接 {{ xxx }} （自动解析 ReflImpl 的 value 值）\n\n * 注意：\n   \n   * 参数可以接收的数据有：基本数据类型、对象类型。\n   * 基本类型的数据：响应式依然是直接靠 Object.defineProperty() 的 get 与 set （数据劫持）完成的。\n   * 对象类型的数据：借助 Vue 3 中的 reactive 函数。\n\n\n# reactive 函数\n\n * reactive 函数的作用：定义一个对象类型的响应式数据。（对于基本数据类型只能使用 ref ，基本数据类型放在对象中再使用 reactive 函数即可 ）\n\n * 语法： const 代理对象 = reactive(源对象) ，参数接收一个对象（或数组），返回一个代理对象（ Proxy 的实例对象，代理 Proxy 对象）\n\n * 使用 reactive 函数定义的响应式数据是「深层次的」。\n\n * reactive 函数内部基于 ES6 的 Proxy 函数实现，通过代理对象操作源对象的内部数据。\n\n\n# 对比 ref 与 reactive 函数\n\n * 从定义数据类型角度对比：\n   \n   * ref 用来定义基本数据类型。\n   * reactive 用来定义对象（包括数组）类型。\n   \n   reactive 可以用来定义基本数据类型，封装在一个 data 对象中即可。\n\n * 从原理角度对比：\n   \n   * ref 通过 Object.defineProperty() 的 get 与 set 来实现响应式（数据劫持）。\n   * reactive 通过使用 Proxy （数据劫持）与 Reflect （操作源对象内部的数据）结合实现响应式。\n\n * 从实用角度对比：\n   \n   * ref 定义的数据，操作数据需要使用 .value 读取，在模版中可以直接读取。\n   * reactive 定义的数据，操作和读取数据可以直接读取。\n\n\n# setup 的注意点\n\n * setup 执行的时机：\n   \n   * 在 beforeCreate 之前执行一次， this 是 undefined 。\n\n * setup 的参数：\n   \n   * props ：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\n   * context ：上下文对象，包含以下内容：\n     * attrs ： 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性，相当于 this.$attrs 。\n     * slots ：收到的插槽内容，相当于 this.$slots 。\n     * emit ：分发自定义事件的函数，相当于 this.$emit 。注意，自定义事件在要触发的组件中，与 props 相同，使用 emits 先声明，否则会警告。\n\n\n# 响应式原理\n\n# Vue 2 中的响应式\n\n * 实现原理（对于对象类型和数组类型的数据）：\n   \n   * 对象类型：通过 Object.defineProperty() 对属性的读取、修改进行拦截（数据劫持）。\n   \n   * 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n     \n     Object.defineProperty(data, 'count', {\n         get () {}, \n         set () {}\n     })\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * 存在问题：（可以通过 Vue.set （ this.$set ） 解决）\n   \n   * 新增属性、删除属性，界面不会更新。\n   * 直接通过下标修改数组，界面不会自动更新。\n\n# Vue3 的响应式\n\n * 实现原理:\n   * 通过 Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。\n   * 通过 Reflect（反射）：映射对源对象的属性进行操作。\n\nnew Proxy(data, {\n\t// 拦截读取属性值\n    get (target, prop) {\n    \treturn Reflect.get(target, prop)\n    },\n    // 拦截设置属性值或添加新属性\n    set (target, prop, value) {\n    \treturn Reflect.set(target, prop, value)\n    },\n    // 拦截删除属性\n    deleteProperty (target, prop) {\n    \treturn Reflect.deleteProperty(target, prop)\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 🔗 相关链接 MDN：\n> \n>  * Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n> \n>  * Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\n\n\n# 计算属性 computed 函数\n\nVue 3 中的计算属性 computed 函数的使用方法与 Vue 2 中的 computed 一致，在 Vue 3 中计算属性放入了 setup 中。可以将定义在 setup 中的数据设置为计算属性。\n\n🌰 计算属性的简写形式：\n\nsetup() {\n  // 数据属性\n  let person = reactive({\n    firstName: 'Simon',\n    lastName: 'Luo',\n  })\n\n  // 计算属性\n  person.fullName = computed(() => {\n    return person.firstName + '-' + person.lastName\n  })\n\n  return {\n    person,\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n>  * 上述简写的形式若将计算后的属性修改会提示警告，因为简写的计算属性是只读的。\n\n🌰 计算属性的完整形式（包括 get() 和 set() ）：\n\nperson.fullName = computed({\n  get() {\n    return person.firstName + '-' + person.lastName\n  },\n  set(value) {\n    const nameArr = value.split('-')\n    person.firstName = nameArr[0]\n    person.lastName = nameArr[1]\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 数据监视 watch 函数\n\n与 computed 函数类似， watch 函数放在 setup 中使用，并且与 Vue 2 时的数据监视 watch 配置用法相同。\n\n但是 Vue 3 中的数据监视，对于不同的使用情况有不同的结果：\n\n * 监视普通的 ref 定义的一个响应式数据：\n\nwatch(sum, (newValue, oldValue)=>{\n  console.log('newValue', newValue)\n  console.log('oldValue', oldValue)\n}, {immediate: true})\n\n\n1\n2\n3\n4\n\n * 监视普通的 ref 定义的多个响应式数据：\n\nwatch([sum, msg], (newValue, oldValue)=>{\n  console.log('newValue', newValue)\n  console.log('oldValue', oldValue)\n})\n\n\n1\n2\n3\n4\n\n\n> 监视使用 ref 定义的数据可以完整获取 newValue 、 oldValue 。\n\n注意\n\n对于 ref 定义的响应式数据的一个注意点： ref 定义的普通数据的监视不能使用 .value ，不用使用 .value 是因为 ref 定义的数据生成引用对象， .value 直接获取的是数据。\n\n而对于使用 ref 定义的响应式数据为一个对象时，此时 .value 的值为借用 reative 生成的 Proxy 对象，这时并不能监视到该层次的变化。可以使用加上 .value 或者开启深度监视解决。\n\n * 监视 reactive 定义的响应式数据（以对象为例）：\n\nwatch(person, (newValue, oldValue) => {\n  console.log('oldValue', oldValue) // 依旧是newValue\n  console.log('newValue', newValue)\n}, {deep: false})\n\n\n1\n2\n3\n4\n\n\n注意\n\n * 监视使用 reactive 定义的响应式数据不能获取 oldValue ；\n\n * 监视使用 reactive 定义的响应式数据，会强制开启深度监视（对于此事监视完整的一个对象而言）。\n\n * 监视 reactive 定义的响应式数据的某一个属性或者某些属性，第一个参数需要为一个函数的返回值或者对象，监测多个属性需要使用数组包裹。\n\nwatch(() => person.age, (newValue, oldValue) => {\n  console.log('newValue', newValue)\n}, {immediate: true, deep: false})\n\n\n1\n2\n3\n\n\nwatch([() => person.age, () => person.name], (newValue, oldValue) => {\n  console.log('newValue', newValue)\n}, {deep: false})\n\n\n1\n2\n3\n\n\n注意\n\n * 当监视的为 reactive 定义的响应式数据的某一个属性为一个对象时，并且其中有需要深度监视的属性，此时需要开启深度监视。\n\nwatch(() => person.job, (newValue, oldValue) => {\n  console.log('oldValue', oldValue)\n  console.log('newValue', newValue)\n}, {deep: true})\n\n\n1\n2\n3\n4\n\n\n> 由于监视的是 reactive 定义的对象中的某个属性，所以 deep 配置有效\n\n\n# watchEffect 函数\n\n * 在 watch 函数中：既要指明监视的属性，也要指明监视的回调。\n * 在 watchEffect 函数中：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n * 与 computed 函数相似，在 computed 函数中注重计算出来的值（回调函数的返回值），所以必须要返回一个值；但是 watchEffect 注重的是过程（回调函数的函数体），所以不用写返回值。\n\n🌰 watchEffect 函数的使用例子：\n\nwatchEffect(()=>{\n  const x1 = sum.value\n  const x2 = person.age\n  console.log('watchEffect回调执行')\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 只要 watchEffect 指定的回调函数中用到的数据发生变化，则直接重新执行回调。\n\n\n# 生命周期\n\n\n\n * Vue 3 中可以继续使用 Vue 2 中的生命周期钩子，但有有两个被更名：\n   * beforeDestroy 改名为 beforeUnmount\n   * destroyed 改名为 unmounted\n * Vue 3 也提供了 Composition API 形式的生命周期钩子，与 Vue 2 中钩子对应关系如下：\n   * beforeCreate ===> setup()\n   * created =======> setup()\n   * beforeMount ===> onBeforeMount\n   * mounted =======> onMounted\n   * beforeUpdate ===> onBeforeUpdate\n   * updated =======> onUpdated\n   * beforeUnmount ==> onBeforeUnmount\n   * unmounted =====> onUnmounted\n\n\n# 自定义 hook 函数\n\n自定义 hook 函数本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。\n\n * 类似于 Vue2 中的 mixin。\n\n * 自定义 hook 的优势：复用代码，让 setup 中的逻辑更清楚易懂。\n\n🌰 例子：\n\n * 在 src 目录下创建新的目录 hook 存储 hook 函数，创建文件 usePoint 为例（一般命名开头为 use ）：\n\n// 实现获取鼠标坐标\nimport {onBeforeUnmount, onMounted, reactive} from \"vue\";\n\nexport default function () {\n    // 实现的数据\n    let point = reactive({\n        x: 0,\n        y: 0\n    })\n\n    // 实现的方法\n    function savePoint(event) {\n        point.x = event.pageX\n        point.y = event.pageY\n        console.log(event.pageX, event.pageY)\n    }\n\n    // 实现的相关钩子\n    onMounted(() => {\n        window.addEventListener('click', savePoint)\n    })\n\n    onBeforeUnmount(() => {\n        window.removeEventListener('click', savePoint)\n    })\n\n    return point\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 在要使用这个 hook 函数的组件，引入当作函数并使用：\n\nimport usePoint from \"../hooks/usePoint\";\n\n\n1\n\n\nsetup() {\n  let point = usePoint()\n\n  return {\n    point\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# toRef 函数\n\n * toRef 函数创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。\n * 语法： const name = toRef(person,'name') / toRefs(person)\n * 应用：要将响应式对象中的某个属性单独提供给外部使用时。\n\n> 与 ref 函数不同， ref 函数会重新创建新的引用 RefImpl 对象； toRef 创建的是引用原来的 RefImpl 对象。\n\n🌰：使用 toRefs() 批量处理 setup 中的某个对象：\n\nsetup(){\n\tlet person = reactive({\n\t\tname: 'Simon',\n    age: 3\n\t})\n  \n  return {\n \t \t...toRefs(person)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 其他 API\n\n\n# shallowReactive 原始 shallowRef 函数\n\n * 浅层响应式数据的定义：\n   \n   * shallowReactive ：只处理对象最外层属性的响应式（浅响应式）。\n   \n   * shallowRef ：只处理基本数据类型的响应式，不进行对象的响应式处理（对于使用这个函数定义的对象，不会借用 reactive 处理对象为 Proxy 对象）。\n\n * 应用场景：\n   \n   * 如果只有一个对象数据，由多层对象结构（结构较深层），但只需要实现外层属性的变化，使用 shallowReactive 函数定义。\n   * 如果只有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换，使用 shallowRef 函数定义。\n\n\n# readonly 与 shallowReadonly 函数\n\n * 只读属性相关的 API ：（* 对于定义的响应式数据有效）\n   * readonly ：让一个响应式数据变为只读的（深只读）；\n   * shallowReadonly ：让一个响应式数据变为只读（浅只读）；\n * 应用场景：不希望响应式数据被修改时。（当收到来自另一个组件定义的响应式数据，在现组件不希望引入的数据被修改时）\n\n\n# toRaw 与 markRaw 函数\n\n生成与标记为原始普通数据：\n\n * toRaw ：\n   * 作用：将一个由 reactive （只能是）定义的响应式对象转为普通对象（原始）。\n   * 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作不会引起页面的变化。\n * markRaw ：\n   * 用于某些数据 ** 不应该被赋值时自动设置为响应式数据的，** 例如复杂的第三方库数据。\n   * 当渲染具有不可变数据源的大列表时，跳过响应式转换会提高渲染性能。\n\n\n# customRef\n\n * 作用：创建一个自定义 ref ，并且对其依赖项跟踪和更新触发进行显示控制。\n\n🌰 实现防抖效果（延迟显示）：\n\n点击查看\n\n// 自定义一个ref\nfunction myRef(value, delay) {\n  let timer\n  // console.log('myRef', value)\n  return customRef((track, trigger) => {\n    return {\n      // 类似计算属性get/set\n      get() {\n        console.log(`read from myRef, value: ${value}`)\n        track() // 通知Vue追踪value的变化（告诉Vue）\n        return value\n      },\n      set(newValue) {\n        console.log(`modify in myRef, after Modified Value: ${newValue}`)\n        clearTimeout(timer)\n        timer = setTimeout(() => {\n          value = newValue\n          trigger() // 通知Vue重新解析模版\n        }, delay)\n      },\n    }\n  })\n}\n\nlet keyword = myRef('hello', 500) // 使用自定义ref\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# provide 与 inject\n\n * 作用： 实现 **（祖与后代）跨级组件之间 ** 的通信。\n * 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据。\n\n🌰 例子：\n\n * 在祖组件中的 setup 中 provide ：\n\nsetup(){\n\t......\n    let car = reactive({name:'奔驰',price:'40万'})\n    provide('car',car)\n    ......\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 在后代组件中使用 inject 获取：\n\nsetup(props,context){\n\t......\n    const car = inject('car')\n    return {car}\n\t......\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 响应式数据判断\n\n当数据逐渐增多或者获取从它处来的数据，未知该数据的响应式类型（是否为响应式），需要进行该数据的判断，使用下列函数判断：\n\n * isRef ：检查目标数据是否为 ref 创建的引用对象；\n * isReactive ：检查目标数据是否由 reactive 创建的响应式代理；\n * isReadonly ：检查目标数据是否为由 readonly 创建的只读代理；\n * isProxy ：检查一个对象是否由 reactive 或者 readonly 方法创建的代理。\n\n\n# Composition API 的优势\n\n\n# Options API 存在的问题\n\n\n\n提示\n\n使用传统 Options API （配置式 API）中，新增或者修改一个需求，就需要分别在 data 、 methods 、 computed 里修改 。\n\n\n# Composition API 的优势\n\n\n\n\n\n提示\n\n⭐️ 在 Composition API （基于函数组合 API）中，可以整合在一块组织代码、函数（配合自定义钩子函数使用），让相关功能的代码更加有序的组织在一起。",normalizedContent:"# 常用 api\n\n\n# setup\n\n * setup 是 vue 3 中的新的一个配置项，值为一个函数。\n   \n   是所有 composition 组合 api 「表演的舞台」。\n\n * 组件中所有到的：数据、方法，都要配置在 setup 中。\n\n * setup 函数中的两种返回值：\n   \n   * ⭐️ 若最后返回一个对象，则对象中的属性、方法，在模版中可以直接使用。\n   * 若返回一个渲染函数，则可以返回自定义的渲染内容（了解）。\n\n🌰 例子：在 setup 中返回一个对象：\n\nsetup() {\n  // 数据\n  let name = 'simon'\n  let age = '3'\n\n  // 方法\n  function sayhello() {\n    alert(`hello, this is ${name}, age:${age}`)\n  }\n\n  return {\n    name,\n    age,\n    sayhello\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * ⚠️ 注意：\n   1. 尽量不要与 vue 2.x 中的配置混用：\n      * vue 2.x 的配置（ data 、 methods 、 computed … ）中可以访问到 setup 中的属性、方法。\n      * 但是在 setup 配置中不能访问 vue 2.x 的配置（ data 、 methods 、 computed … ）。\n      * 当 setup 中的属性、方法与 vue 2.x 的配置有重名时，以 setup 优先。\n   2. setup 不能是一个 async 函数，因为返回值不再是 return 对象，而是一个被 async 包裹的对象，而是 promise ，此时模版无法使用 return 中的属性（后期可以返回一个 promise 的实例，但是需要 suspense 和异步组件的配合 🔗 suspense 组件）\n\n\n# ref 函数\n\n>  * 在之前使用的 ref ，作用是给原生的 dom 标签添加标识，替代 id 的作用。\n>  * 在上述 setup 的例子中定义的数据不是一个响应式的数据，发生变化 vue 无法监测。\n\n * ref 函数作用：定义一个响应式的数据。\n\n * 语法： const xxx = ref(initvalue)\n   \n   * 创建一个 reflimpl ： reference + implement 包含响应式数据的引用 ref 对象（引用实现对象）。\n   * 在 js 中操作数据： xxx.value\n   * 在模版中读取数据：直接 {{ xxx }} （自动解析 reflimpl 的 value 值）\n\n * 注意：\n   \n   * 参数可以接收的数据有：基本数据类型、对象类型。\n   * 基本类型的数据：响应式依然是直接靠 object.defineproperty() 的 get 与 set （数据劫持）完成的。\n   * 对象类型的数据：借助 vue 3 中的 reactive 函数。\n\n\n# reactive 函数\n\n * reactive 函数的作用：定义一个对象类型的响应式数据。（对于基本数据类型只能使用 ref ，基本数据类型放在对象中再使用 reactive 函数即可 ）\n\n * 语法： const 代理对象 = reactive(源对象) ，参数接收一个对象（或数组），返回一个代理对象（ proxy 的实例对象，代理 proxy 对象）\n\n * 使用 reactive 函数定义的响应式数据是「深层次的」。\n\n * reactive 函数内部基于 es6 的 proxy 函数实现，通过代理对象操作源对象的内部数据。\n\n\n# 对比 ref 与 reactive 函数\n\n * 从定义数据类型角度对比：\n   \n   * ref 用来定义基本数据类型。\n   * reactive 用来定义对象（包括数组）类型。\n   \n   reactive 可以用来定义基本数据类型，封装在一个 data 对象中即可。\n\n * 从原理角度对比：\n   \n   * ref 通过 object.defineproperty() 的 get 与 set 来实现响应式（数据劫持）。\n   * reactive 通过使用 proxy （数据劫持）与 reflect （操作源对象内部的数据）结合实现响应式。\n\n * 从实用角度对比：\n   \n   * ref 定义的数据，操作数据需要使用 .value 读取，在模版中可以直接读取。\n   * reactive 定义的数据，操作和读取数据可以直接读取。\n\n\n# setup 的注意点\n\n * setup 执行的时机：\n   \n   * 在 beforecreate 之前执行一次， this 是 undefined 。\n\n * setup 的参数：\n   \n   * props ：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\n   * context ：上下文对象，包含以下内容：\n     * attrs ： 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性，相当于 this.$attrs 。\n     * slots ：收到的插槽内容，相当于 this.$slots 。\n     * emit ：分发自定义事件的函数，相当于 this.$emit 。注意，自定义事件在要触发的组件中，与 props 相同，使用 emits 先声明，否则会警告。\n\n\n# 响应式原理\n\n# vue 2 中的响应式\n\n * 实现原理（对于对象类型和数组类型的数据）：\n   \n   * 对象类型：通过 object.defineproperty() 对属性的读取、修改进行拦截（数据劫持）。\n   \n   * 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n     \n     object.defineproperty(data, 'count', {\n         get () {}, \n         set () {}\n     })\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * 存在问题：（可以通过 vue.set （ this.$set ） 解决）\n   \n   * 新增属性、删除属性，界面不会更新。\n   * 直接通过下标修改数组，界面不会自动更新。\n\n# vue3 的响应式\n\n * 实现原理:\n   * 通过 proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。\n   * 通过 reflect（反射）：映射对源对象的属性进行操作。\n\nnew proxy(data, {\n\t// 拦截读取属性值\n    get (target, prop) {\n    \treturn reflect.get(target, prop)\n    },\n    // 拦截设置属性值或添加新属性\n    set (target, prop, value) {\n    \treturn reflect.set(target, prop, value)\n    },\n    // 拦截删除属性\n    deleteproperty (target, prop) {\n    \treturn reflect.deleteproperty(target, prop)\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 🔗 相关链接 mdn：\n> \n>  * proxy：https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/proxy\n> \n>  * reflect：https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/reflect\n\n\n# 计算属性 computed 函数\n\nvue 3 中的计算属性 computed 函数的使用方法与 vue 2 中的 computed 一致，在 vue 3 中计算属性放入了 setup 中。可以将定义在 setup 中的数据设置为计算属性。\n\n🌰 计算属性的简写形式：\n\nsetup() {\n  // 数据属性\n  let person = reactive({\n    firstname: 'simon',\n    lastname: 'luo',\n  })\n\n  // 计算属性\n  person.fullname = computed(() => {\n    return person.firstname + '-' + person.lastname\n  })\n\n  return {\n    person,\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n>  * 上述简写的形式若将计算后的属性修改会提示警告，因为简写的计算属性是只读的。\n\n🌰 计算属性的完整形式（包括 get() 和 set() ）：\n\nperson.fullname = computed({\n  get() {\n    return person.firstname + '-' + person.lastname\n  },\n  set(value) {\n    const namearr = value.split('-')\n    person.firstname = namearr[0]\n    person.lastname = namearr[1]\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 数据监视 watch 函数\n\n与 computed 函数类似， watch 函数放在 setup 中使用，并且与 vue 2 时的数据监视 watch 配置用法相同。\n\n但是 vue 3 中的数据监视，对于不同的使用情况有不同的结果：\n\n * 监视普通的 ref 定义的一个响应式数据：\n\nwatch(sum, (newvalue, oldvalue)=>{\n  console.log('newvalue', newvalue)\n  console.log('oldvalue', oldvalue)\n}, {immediate: true})\n\n\n1\n2\n3\n4\n\n * 监视普通的 ref 定义的多个响应式数据：\n\nwatch([sum, msg], (newvalue, oldvalue)=>{\n  console.log('newvalue', newvalue)\n  console.log('oldvalue', oldvalue)\n})\n\n\n1\n2\n3\n4\n\n\n> 监视使用 ref 定义的数据可以完整获取 newvalue 、 oldvalue 。\n\n注意\n\n对于 ref 定义的响应式数据的一个注意点： ref 定义的普通数据的监视不能使用 .value ，不用使用 .value 是因为 ref 定义的数据生成引用对象， .value 直接获取的是数据。\n\n而对于使用 ref 定义的响应式数据为一个对象时，此时 .value 的值为借用 reative 生成的 proxy 对象，这时并不能监视到该层次的变化。可以使用加上 .value 或者开启深度监视解决。\n\n * 监视 reactive 定义的响应式数据（以对象为例）：\n\nwatch(person, (newvalue, oldvalue) => {\n  console.log('oldvalue', oldvalue) // 依旧是newvalue\n  console.log('newvalue', newvalue)\n}, {deep: false})\n\n\n1\n2\n3\n4\n\n\n注意\n\n * 监视使用 reactive 定义的响应式数据不能获取 oldvalue ；\n\n * 监视使用 reactive 定义的响应式数据，会强制开启深度监视（对于此事监视完整的一个对象而言）。\n\n * 监视 reactive 定义的响应式数据的某一个属性或者某些属性，第一个参数需要为一个函数的返回值或者对象，监测多个属性需要使用数组包裹。\n\nwatch(() => person.age, (newvalue, oldvalue) => {\n  console.log('newvalue', newvalue)\n}, {immediate: true, deep: false})\n\n\n1\n2\n3\n\n\nwatch([() => person.age, () => person.name], (newvalue, oldvalue) => {\n  console.log('newvalue', newvalue)\n}, {deep: false})\n\n\n1\n2\n3\n\n\n注意\n\n * 当监视的为 reactive 定义的响应式数据的某一个属性为一个对象时，并且其中有需要深度监视的属性，此时需要开启深度监视。\n\nwatch(() => person.job, (newvalue, oldvalue) => {\n  console.log('oldvalue', oldvalue)\n  console.log('newvalue', newvalue)\n}, {deep: true})\n\n\n1\n2\n3\n4\n\n\n> 由于监视的是 reactive 定义的对象中的某个属性，所以 deep 配置有效\n\n\n# watcheffect 函数\n\n * 在 watch 函数中：既要指明监视的属性，也要指明监视的回调。\n * 在 watcheffect 函数中：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n * 与 computed 函数相似，在 computed 函数中注重计算出来的值（回调函数的返回值），所以必须要返回一个值；但是 watcheffect 注重的是过程（回调函数的函数体），所以不用写返回值。\n\n🌰 watcheffect 函数的使用例子：\n\nwatcheffect(()=>{\n  const x1 = sum.value\n  const x2 = person.age\n  console.log('watcheffect回调执行')\n})\n\n\n1\n2\n3\n4\n5\n\n\n> 只要 watcheffect 指定的回调函数中用到的数据发生变化，则直接重新执行回调。\n\n\n# 生命周期\n\n\n\n * vue 3 中可以继续使用 vue 2 中的生命周期钩子，但有有两个被更名：\n   * beforedestroy 改名为 beforeunmount\n   * destroyed 改名为 unmounted\n * vue 3 也提供了 composition api 形式的生命周期钩子，与 vue 2 中钩子对应关系如下：\n   * beforecreate ===> setup()\n   * created =======> setup()\n   * beforemount ===> onbeforemount\n   * mounted =======> onmounted\n   * beforeupdate ===> onbeforeupdate\n   * updated =======> onupdated\n   * beforeunmount ==> onbeforeunmount\n   * unmounted =====> onunmounted\n\n\n# 自定义 hook 函数\n\n自定义 hook 函数本质是一个函数，把 setup 函数中使用的 composition api 进行了封装。\n\n * 类似于 vue2 中的 mixin。\n\n * 自定义 hook 的优势：复用代码，让 setup 中的逻辑更清楚易懂。\n\n🌰 例子：\n\n * 在 src 目录下创建新的目录 hook 存储 hook 函数，创建文件 usepoint 为例（一般命名开头为 use ）：\n\n// 实现获取鼠标坐标\nimport {onbeforeunmount, onmounted, reactive} from \"vue\";\n\nexport default function () {\n    // 实现的数据\n    let point = reactive({\n        x: 0,\n        y: 0\n    })\n\n    // 实现的方法\n    function savepoint(event) {\n        point.x = event.pagex\n        point.y = event.pagey\n        console.log(event.pagex, event.pagey)\n    }\n\n    // 实现的相关钩子\n    onmounted(() => {\n        window.addeventlistener('click', savepoint)\n    })\n\n    onbeforeunmount(() => {\n        window.removeeventlistener('click', savepoint)\n    })\n\n    return point\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 在要使用这个 hook 函数的组件，引入当作函数并使用：\n\nimport usepoint from \"../hooks/usepoint\";\n\n\n1\n\n\nsetup() {\n  let point = usepoint()\n\n  return {\n    point\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# toref 函数\n\n * toref 函数创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。\n * 语法： const name = toref(person,'name') / torefs(person)\n * 应用：要将响应式对象中的某个属性单独提供给外部使用时。\n\n> 与 ref 函数不同， ref 函数会重新创建新的引用 refimpl 对象； toref 创建的是引用原来的 refimpl 对象。\n\n🌰：使用 torefs() 批量处理 setup 中的某个对象：\n\nsetup(){\n\tlet person = reactive({\n\t\tname: 'simon',\n    age: 3\n\t})\n  \n  return {\n \t \t...torefs(person)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 其他 api\n\n\n# shallowreactive 原始 shallowref 函数\n\n * 浅层响应式数据的定义：\n   \n   * shallowreactive ：只处理对象最外层属性的响应式（浅响应式）。\n   \n   * shallowref ：只处理基本数据类型的响应式，不进行对象的响应式处理（对于使用这个函数定义的对象，不会借用 reactive 处理对象为 proxy 对象）。\n\n * 应用场景：\n   \n   * 如果只有一个对象数据，由多层对象结构（结构较深层），但只需要实现外层属性的变化，使用 shallowreactive 函数定义。\n   * 如果只有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换，使用 shallowref 函数定义。\n\n\n# readonly 与 shallowreadonly 函数\n\n * 只读属性相关的 api ：（* 对于定义的响应式数据有效）\n   * readonly ：让一个响应式数据变为只读的（深只读）；\n   * shallowreadonly ：让一个响应式数据变为只读（浅只读）；\n * 应用场景：不希望响应式数据被修改时。（当收到来自另一个组件定义的响应式数据，在现组件不希望引入的数据被修改时）\n\n\n# toraw 与 markraw 函数\n\n生成与标记为原始普通数据：\n\n * toraw ：\n   * 作用：将一个由 reactive （只能是）定义的响应式对象转为普通对象（原始）。\n   * 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作不会引起页面的变化。\n * markraw ：\n   * 用于某些数据 ** 不应该被赋值时自动设置为响应式数据的，** 例如复杂的第三方库数据。\n   * 当渲染具有不可变数据源的大列表时，跳过响应式转换会提高渲染性能。\n\n\n# customref\n\n * 作用：创建一个自定义 ref ，并且对其依赖项跟踪和更新触发进行显示控制。\n\n🌰 实现防抖效果（延迟显示）：\n\n点击查看\n\n// 自定义一个ref\nfunction myref(value, delay) {\n  let timer\n  // console.log('myref', value)\n  return customref((track, trigger) => {\n    return {\n      // 类似计算属性get/set\n      get() {\n        console.log(`read from myref, value: ${value}`)\n        track() // 通知vue追踪value的变化（告诉vue）\n        return value\n      },\n      set(newvalue) {\n        console.log(`modify in myref, after modified value: ${newvalue}`)\n        cleartimeout(timer)\n        timer = settimeout(() => {\n          value = newvalue\n          trigger() // 通知vue重新解析模版\n        }, delay)\n      },\n    }\n  })\n}\n\nlet keyword = myref('hello', 500) // 使用自定义ref\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# provide 与 inject\n\n * 作用： 实现 **（祖与后代）跨级组件之间 ** 的通信。\n * 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据。\n\n🌰 例子：\n\n * 在祖组件中的 setup 中 provide ：\n\nsetup(){\n\t......\n    let car = reactive({name:'奔驰',price:'40万'})\n    provide('car',car)\n    ......\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 在后代组件中使用 inject 获取：\n\nsetup(props,context){\n\t......\n    const car = inject('car')\n    return {car}\n\t......\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 响应式数据判断\n\n当数据逐渐增多或者获取从它处来的数据，未知该数据的响应式类型（是否为响应式），需要进行该数据的判断，使用下列函数判断：\n\n * isref ：检查目标数据是否为 ref 创建的引用对象；\n * isreactive ：检查目标数据是否由 reactive 创建的响应式代理；\n * isreadonly ：检查目标数据是否为由 readonly 创建的只读代理；\n * isproxy ：检查一个对象是否由 reactive 或者 readonly 方法创建的代理。\n\n\n# composition api 的优势\n\n\n# options api 存在的问题\n\n\n\n提示\n\n使用传统 options api （配置式 api）中，新增或者修改一个需求，就需要分别在 data 、 methods 、 computed 里修改 。\n\n\n# composition api 的优势\n\n\n\n\n\n提示\n\n⭐️ 在 composition api （基于函数组合 api）中，可以整合在一块组织代码、函数（配合自定义钩子函数使用），让相关功能的代码更加有序的组织在一起。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌊 Vue 3 其他更新",frontmatter:{title:"🌊 Vue 3 其他更新",date:"2022-04-14T13:10:12.000Z",permalink:"/pages/f33531/",categories:["📚 前端笔记","🏃 核心框架","🌨 Vue 3"],tags:[null],author:{name:"Simon",link:"https://github.com/simon1uo"}},regularPath:"/105.%20%F0%9F%8F%83%20%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/15.%20%F0%9F%8C%A8%20Vue%203%20%E7%BB%84%E5%90%88%E5%BC%8F%20API/03.%20%F0%9F%8C%8A%20Vue%203%20%E5%85%B6%E4%BB%96%E6%9B%B4%E6%96%B0.html",relativePath:"105. 🏃 前端核心框架/15. 🌨 Vue 3 组合式 API/03. 🌊 Vue 3 其他更新.md",key:"v-22c566d9",path:"/pages/f33531/",headers:[{level:2,title:"Vue 3 新增组件功能",slug:"vue-3-新增组件功能",normalizedTitle:"vue 3 新增组件功能",charIndex:2},{level:3,title:"Fragment",slug:"fragment",normalizedTitle:"fragment",charIndex:19},{level:3,title:"Teleport",slug:"teleport",normalizedTitle:"teleport",charIndex:145},{level:3,title:"Suspense",slug:"suspense",normalizedTitle:"suspense",charIndex:428},{level:2,title:"Vue 3 其他更新",slug:"vue-3-其他更新",normalizedTitle:"vue 3 其他更新",charIndex:1091},{level:3,title:"全局 API 转移",slug:"全局-api-转移",normalizedTitle:"全局 api 转移",charIndex:1106},{level:3,title:"其他改变",slug:"其他改变",normalizedTitle:"其他改变",charIndex:1957}],headersStr:"Vue 3 新增组件功能 Fragment Teleport Suspense Vue 3 其他更新 全局 API 转移 其他改变",content:'# Vue 3 新增组件功能\n\n\n# Fragment\n\n>  * 在 Vue2 中：组件必须有一个根标签\n>  * 在 Vue3 中： 组件可以没有根标签，内部会将多个标签包含在一个 Fragment 虚拟元素中。\n\n使用 Fragment 的好处：减少标签层级，减少内存占用。\n\n\n# Teleport\n\n * 将组件 HTML 结构移动到指定位置。\n\n<teleport to="移动位置">\n\n\t<div v-if="isShow" class="mask">\n\t\t<div class="dialog">\n\t\t\t<h3>我是一个弹窗</h3>\n\t\t\t<button @click="isShow = false">关闭弹窗</button>\n\t\t</div>\n\t</div>\n</teleport>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> to 中的参数可以是 HTML 标签，例如 body ， @test ， .test 。\n\n\n# Suspense\n\n> 在 Vue 中组件模版渲染时，默认一个组件引入一个组件是一起渲染模版出来的（静态引入，容易引发当引入的组件有问题，当前组件加载连带出错变慢加载）。当异步引入组件时，模版分别渲染。\n\n * 作用：等待异步组件时渲染一些额外内容（ef 插槽），让应用有更好的用户体验。\n\n * 使用步骤：\n   \n   * 异步引入组件：\n     \n     import {defineAsyncComponent} from "vue";\n     const Child = defineAsyncComponent(() => import(\'./components/Child\')) // 动态（异步）引入\n     \n     \n     1\n     2\n     \n   \n   * 使用 Suspend 标签包裹两个插槽模版， default 和 fallback ：\n     \n     <Suspense>\n       <template v-slot:default>\n         <Child/>\n       </template>\n       <template v-slot:fallback>\n         <h3>加载中...</h3>\n       </template>\n     </Suspense>\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     \n\n\n# Vue 3 其他更新\n\n\n# 全局 API 转移\n\n * Vue 2.x 有许多全局 API 和配置。\n   \n   * 🌰 例如：注册全局组件、注册全局指令等。\n     \n     //注册全局组件\n     Vue.component(\'MyButton\', {\n       data: () => ({\n         count: 0\n       }),\n       template: \'<button @click="count++">Clicked {{ count }} times.</button>\'\n     })\n     \n     //注册全局指令\n     Vue.directive(\'focus\', {\n       inserted: el => el.focus()\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n\n * Vue3.0 中对这些 API 做出了调整：\n   \n   * 将全局的 API 调整到应用实例（ app ）上：\n\n2.X 全局 API（ VUE ）          3.X 实例 API ( APP )\nVue.config.xxxx            app.config.xxxx\nVue.config.productionTip   移除\nVue.component              app.component\nVue.directive              app.directive\nVue.mixin                  app.mixin\nVue.use                    app.use\nVue.prototype              app.config.globalProperties\n\n\n# 其他改变\n\n 1. 对于 data 配置项应该始终被声明为一个函数（不能为对象）。\n\n 2. 动画与过渡相关的类名称更改：\n    \n    Vue 2.x 写法：\n    \n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n    }\n    .v-leave,\n    .v-enter-to {\n      opacity: 1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    \n    Vue 3.x 写法：\n    \n    .v-enter-from,\n    .v-leave-to {\n      opacity: 0;\n    }\n    \n    .v-leave-from,\n    .v-enter-to {\n      opacity: 1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 3. 移除了 keyCode （兼容性较差）作为 v-on 的修饰符，同时也不再支持 config.keyCodes （按键编码相关）\n\n 4. 移除了 v-on.native 修饰符（组件绑定自定义事件），修改为以下写法：（不声明的自定义事件即为原生 DOM 事件）\n    \n    父组件中绑定事件\n    \n    <my-component\n      v-on:close="handleComponentEvent"\n      v-on:click="handleNativeClickEvent"\n    />\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    子组件中声明自定义事件\n    \n    <script>\n      export default {\n        emits: [\'close\']\n      }\n    <\/script>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. 移除了过滤器 filter ：\n\n提示\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。',normalizedContent:'# vue 3 新增组件功能\n\n\n# fragment\n\n>  * 在 vue2 中：组件必须有一个根标签\n>  * 在 vue3 中： 组件可以没有根标签，内部会将多个标签包含在一个 fragment 虚拟元素中。\n\n使用 fragment 的好处：减少标签层级，减少内存占用。\n\n\n# teleport\n\n * 将组件 html 结构移动到指定位置。\n\n<teleport to="移动位置">\n\n\t<div v-if="isshow" class="mask">\n\t\t<div class="dialog">\n\t\t\t<h3>我是一个弹窗</h3>\n\t\t\t<button @click="isshow = false">关闭弹窗</button>\n\t\t</div>\n\t</div>\n</teleport>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> to 中的参数可以是 html 标签，例如 body ， @test ， .test 。\n\n\n# suspense\n\n> 在 vue 中组件模版渲染时，默认一个组件引入一个组件是一起渲染模版出来的（静态引入，容易引发当引入的组件有问题，当前组件加载连带出错变慢加载）。当异步引入组件时，模版分别渲染。\n\n * 作用：等待异步组件时渲染一些额外内容（ef 插槽），让应用有更好的用户体验。\n\n * 使用步骤：\n   \n   * 异步引入组件：\n     \n     import {defineasynccomponent} from "vue";\n     const child = defineasynccomponent(() => import(\'./components/child\')) // 动态（异步）引入\n     \n     \n     1\n     2\n     \n   \n   * 使用 suspend 标签包裹两个插槽模版， default 和 fallback ：\n     \n     <suspense>\n       <template v-slot:default>\n         <child/>\n       </template>\n       <template v-slot:fallback>\n         <h3>加载中...</h3>\n       </template>\n     </suspense>\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     \n\n\n# vue 3 其他更新\n\n\n# 全局 api 转移\n\n * vue 2.x 有许多全局 api 和配置。\n   \n   * 🌰 例如：注册全局组件、注册全局指令等。\n     \n     //注册全局组件\n     vue.component(\'mybutton\', {\n       data: () => ({\n         count: 0\n       }),\n       template: \'<button @click="count++">clicked {{ count }} times.</button>\'\n     })\n     \n     //注册全局指令\n     vue.directive(\'focus\', {\n       inserted: el => el.focus()\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n\n * vue3.0 中对这些 api 做出了调整：\n   \n   * 将全局的 api 调整到应用实例（ app ）上：\n\n2.x 全局 api（ vue ）          3.x 实例 api ( app )\nvue.config.xxxx            app.config.xxxx\nvue.config.productiontip   移除\nvue.component              app.component\nvue.directive              app.directive\nvue.mixin                  app.mixin\nvue.use                    app.use\nvue.prototype              app.config.globalproperties\n\n\n# 其他改变\n\n 1. 对于 data 配置项应该始终被声明为一个函数（不能为对象）。\n\n 2. 动画与过渡相关的类名称更改：\n    \n    vue 2.x 写法：\n    \n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n    }\n    .v-leave,\n    .v-enter-to {\n      opacity: 1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    \n    vue 3.x 写法：\n    \n    .v-enter-from,\n    .v-leave-to {\n      opacity: 0;\n    }\n    \n    .v-leave-from,\n    .v-enter-to {\n      opacity: 1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 3. 移除了 keycode （兼容性较差）作为 v-on 的修饰符，同时也不再支持 config.keycodes （按键编码相关）\n\n 4. 移除了 v-on.native 修饰符（组件绑定自定义事件），修改为以下写法：（不声明的自定义事件即为原生 dom 事件）\n    \n    父组件中绑定事件\n    \n    <my-component\n      v-on:close="handlecomponentevent"\n      v-on:click="handlenativeclickevent"\n    />\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    子组件中声明自定义事件\n    \n    <script>\n      export default {\n        emits: [\'close\']\n      }\n    <\/script>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. 移除了过滤器 filter ：\n\n提示\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 javascript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"💡 面试常见问题收集",frontmatter:{title:"💡 面试常见问题收集",date:"2022-07-01T23:38:45.000Z",permalink:"/pages/a2e141/",categories:["🪞 前端面试题收集","⛳️ 准备工作"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/01.%20%E2%9B%B3%EF%B8%8F%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/02.%20%F0%9F%92%A1%20%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86.html",relativePath:"200. 🪞 前端面试题收集/01. ⛳️ 准备工作/02. 💡 面试常见问题收集.md",key:"v-54b9b1f0",path:"/pages/a2e141/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🧳 面试项目经验",frontmatter:{title:"🧳 面试项目经验",date:"2022-07-01T23:38:20.000Z",permalink:"/pages/fc5676/",categories:["🪞 前端面试题收集","⛳️ 准备工作"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/01.%20%E2%9B%B3%EF%B8%8F%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/03.%20%F0%9F%A7%B3%20%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C.html",relativePath:"200. 🪞 前端面试题收集/01. ⛳️ 准备工作/03. 🧳 面试项目经验.md",key:"v-79db4046",path:"/pages/fc5676/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 HTTP 与 HTTPS",frontmatter:{title:"🍎 HTTP 与 HTTPS",date:"2022-06-06T11:42:22.000Z",permalink:"/pages/f9fc1b/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20HTTP%20%E4%B8%8E%20HTTPS%20.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/01. 🍎 HTTP 与 HTTPS .md",key:"v-3437b616",path:"/pages/f9fc1b/",headers:[{level:2,title:"HTTP / HTTPS基本概念",slug:"http-https基本概念",normalizedTitle:"http / https 基本概念",charIndex:111},{level:2,title:"HTTP / HTTPS 区别",slug:"http-https-区别",normalizedTitle:"http / https 区别",charIndex:656},{level:2,title:"HTTPS 的工作原理 / 流程",slug:"https-的工作原理-流程",normalizedTitle:"https 的工作原理 / 流程",charIndex:911},{level:2,title:"HTTPS 更加安全",slug:"https-更加安全",normalizedTitle:"https 更加安全",charIndex:1214},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1850}],headersStr:"HTTP / HTTPS基本概念 HTTP / HTTPS 区别 HTTPS 的工作原理 / 流程 HTTPS 更加安全 参考",content:"> 相关问题：\n> \n>  * 什么是 HTTP / HTTPS？\n>  * HTTP 与 HTTPS 的区别？\n>  * 为什么说 HTTPS 比 HTTP 安全？\n>  * HTTPS 协议的优点 / 缺点？\n\n\n# HTTP / HTTPS 基本概念\n\n * HTTP ：是互联网最为广泛应用的 超文本传输协议，是客户端和服务器端 请求和应答 的标准（TCP），用于从 WWW 服务器传呼文本到本地浏览器的传输协议。HTTP 以明文方式发送内容，不提供任何方式的数据加密。\n   \n   > 特点：\n   > \n   >  * 支持 客户端 / 服务器 模式。\n   >  * 简单快速。客户向服务器发送请求只需要传送 请求方法和路径。这使得 Web 服务器规模小，通信快；\n   >  * 灵活。HTTP 允许传输任意类型的数据对象，通过请求头的 Content-Type 标记；\n   >  * 无连接。每次连接只处理一个请求。服务器处理完客户的请求并受到客户的应答后，即断开连接。以节省传输时间；\n   >  * 无状态。HTTP 协议无法根据当前的状态进行本次的请求处理。\n\n * HTTPS：HTTP 协议加入 SSL 层，提高 HTTP 协议的安全性。通过 SSL 证书验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n   \n   SSL 协议位于 TCP / IP 协议与各种应用协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信。\n\n\n# HTTP / HTTPS 区别\n\n * HTTP 传输的数据未经加密处理，是明文传输信息的超文本传输协议；HTTPS 是具有安全性的 SSL 加密传输协议。\n * HTTP 与 HTTPS 使用不同的连接的方式。HTTP 协议的端口为 80；HTTPS 协议的端口为 443。\n * HTTP 协议是无状态的连接；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输和身份认证的网络协议，相比于 HTTP 协议更加安全。但是 HTTPS 需要设计加密以及多次握手，性能不如 HTTP；\n\n\n# HTTPS 的工作原理 / 流程\n\n客户端使用 HTTPS 协议方式与 Web 服务器通信时的步骤：\n\n * 客户端使用 HTTPS 的 URL 访问服务器，要求 Web 服务器建立 SSL 连接；\n * Web 服务器接收到来自客户端的请求之后，会将网站的证书（包含公钥）传输给客户端；\n * 客户端和 Web 服务器开始协商 SSL 连接的安全等级（加密等级）；\n * 客户端浏览器通过双方协商一致的安全等级，建立 会话密钥，然后通过 公钥 加密 会话密钥，并传送给网站；\n * Web 服务器通过自己的 私钥 解密出 会话密钥；\n * Web 服务器通过 会话密钥 加密与客户端之间的通信；\n\n\n# HTTPS 更加安全\n\nHTTP 通信过程中存在问题（风险）：\n\n * 使用明文通信（不加密）。（内容容易被窃听）\n * 不验证通信方身份。（身份容易被伪装）\n\nSSL 层通过以下手段解决，保障通信安全：\n\n * 对称加密：保证 加密和解密 使用的密钥是同一个。 解决通信过程的机密性。\n\n * 非对称加密：存在公钥和私钥用来加密和解密；公钥加密后只能用私钥解密；私钥加密后只能用公钥解密。实现密钥协商。\n\n * 混合加密：HTTPS 采用对称加密和非对称加密混合，保证了密钥安全；保证了密钥交换的问题；\n   \n   发送密文的一方使用对方的公钥进行加密处理「对称的密钥」，然后对方用自己的私钥解密拿到「对称的密钥」，这样确保了交换的密钥是安全的情况下，使用对称加密方式进行通信。\n\n * 摘要算法：验证信息的完整性。\n   \n   是一种特殊的压缩算法，把任意长度的数据压缩成固定的长度和独一无二的摘要字符串（给数据生成指纹）。摘要算法确保了数字摘要与原文是完全一致的，只要在原文后加上摘要就能保证信息的完整性。\n\n * 数字签名：身份验证。\n   \n   使用私钥加密，公钥解密。签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。\n\n * CA 证书验证机构：保证了认证服务器的公开密钥的是真实有效的数字证书认证机构；服务器的公开密钥是值得信赖的。\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * 什么是 http / https？\n>  * http 与 https 的区别？\n>  * 为什么说 https 比 http 安全？\n>  * https 协议的优点 / 缺点？\n\n\n# http / https 基本概念\n\n * http ：是互联网最为广泛应用的 超文本传输协议，是客户端和服务器端 请求和应答 的标准（tcp），用于从 www 服务器传呼文本到本地浏览器的传输协议。http 以明文方式发送内容，不提供任何方式的数据加密。\n   \n   > 特点：\n   > \n   >  * 支持 客户端 / 服务器 模式。\n   >  * 简单快速。客户向服务器发送请求只需要传送 请求方法和路径。这使得 web 服务器规模小，通信快；\n   >  * 灵活。http 允许传输任意类型的数据对象，通过请求头的 content-type 标记；\n   >  * 无连接。每次连接只处理一个请求。服务器处理完客户的请求并受到客户的应答后，即断开连接。以节省传输时间；\n   >  * 无状态。http 协议无法根据当前的状态进行本次的请求处理。\n\n * https：http 协议加入 ssl 层，提高 http 协议的安全性。通过 ssl 证书验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n   \n   ssl 协议位于 tcp / ip 协议与各种应用协议之间，浏览器和服务器在使用 ssl 建立连接时需要选择一组恰当的加密算法来实现安全通信。\n\n\n# http / https 区别\n\n * http 传输的数据未经加密处理，是明文传输信息的超文本传输协议；https 是具有安全性的 ssl 加密传输协议。\n * http 与 https 使用不同的连接的方式。http 协议的端口为 80；https 协议的端口为 443。\n * http 协议是无状态的连接；https 协议是由 ssl + http 协议构建的可进行加密传输和身份认证的网络协议，相比于 http 协议更加安全。但是 https 需要设计加密以及多次握手，性能不如 http；\n\n\n# https 的工作原理 / 流程\n\n客户端使用 https 协议方式与 web 服务器通信时的步骤：\n\n * 客户端使用 https 的 url 访问服务器，要求 web 服务器建立 ssl 连接；\n * web 服务器接收到来自客户端的请求之后，会将网站的证书（包含公钥）传输给客户端；\n * 客户端和 web 服务器开始协商 ssl 连接的安全等级（加密等级）；\n * 客户端浏览器通过双方协商一致的安全等级，建立 会话密钥，然后通过 公钥 加密 会话密钥，并传送给网站；\n * web 服务器通过自己的 私钥 解密出 会话密钥；\n * web 服务器通过 会话密钥 加密与客户端之间的通信；\n\n\n# https 更加安全\n\nhttp 通信过程中存在问题（风险）：\n\n * 使用明文通信（不加密）。（内容容易被窃听）\n * 不验证通信方身份。（身份容易被伪装）\n\nssl 层通过以下手段解决，保障通信安全：\n\n * 对称加密：保证 加密和解密 使用的密钥是同一个。 解决通信过程的机密性。\n\n * 非对称加密：存在公钥和私钥用来加密和解密；公钥加密后只能用私钥解密；私钥加密后只能用公钥解密。实现密钥协商。\n\n * 混合加密：https 采用对称加密和非对称加密混合，保证了密钥安全；保证了密钥交换的问题；\n   \n   发送密文的一方使用对方的公钥进行加密处理「对称的密钥」，然后对方用自己的私钥解密拿到「对称的密钥」，这样确保了交换的密钥是安全的情况下，使用对称加密方式进行通信。\n\n * 摘要算法：验证信息的完整性。\n   \n   是一种特殊的压缩算法，把任意长度的数据压缩成固定的长度和独一无二的摘要字符串（给数据生成指纹）。摘要算法确保了数字摘要与原文是完全一致的，只要在原文后加上摘要就能保证信息的完整性。\n\n * 数字签名：身份验证。\n   \n   使用私钥加密，公钥解密。签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。\n\n * ca 证书验证机构：保证了认证服务器的公开密钥的是真实有效的数字证书认证机构；服务器的公开密钥是值得信赖的。\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 HTTP 常见的请求头",frontmatter:{title:"🍏 HTTP 常见的请求头",date:"2022-06-06T15:14:24.000Z",permalink:"/pages/1fc4db/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8F%20HTTP%20%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/02. 🍏 HTTP 常见的请求头.md",key:"v-26fbe376",path:"/pages/1fc4db/",headers:[{level:2,title:"HTTP header 概念",slug:"http-header-概念",normalizedTitle:"http header 概念",charIndex:36},{level:2,title:"常见的 header 字段",slug:"常见的-header-字段",normalizedTitle:"常见的 header 字段",charIndex:172},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:923}],headersStr:"HTTP header 概念 常见的 header 字段 参考",content:"> 相关问题：\n> \n>  * HTTP 常见的请求头有哪些？\n\n\n# HTTP header 概念\n\nHTTP header（头部字段），指在 HTTP 超文本传输协议的 请求和响应消息中的 消息头部分。定义了超文本传输协议事务中的 操作参数。\n\nHTTP 头部字段可以根据需要定义，因此 请求头、响应头内容都可能是非标准的头字段。\n\n\n# 常见的 header 字段\n\n * Accept ：能够接受的响应内容类型。\n   \n   🌰 ： Accept: text/plain\n\n * Accpet-Charset ：能够接受的字符集\n\n * Accept-Encoding ：能够接受的编码方式列表\n\n * Accept-Language ：能够接受的自然语言列表\n\n * Authorization ：用于超文本传输协议的认证的认证信息。\n   \n   🌰 ： Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n\n * Cache-Control ：指定本次请求 / 响应链中所有的缓存机制都必须准手的指令。\n\n * Connection ：浏览器想要优先使用的连接类型。\n\n * Cookie ：服务器通过 Set- Cookie 发送的一个超文本传输协议 Cookie。\n\n * Content-Length ：以 八位字节数组 （8 位的字节）表示的请求体的长度。\n\n * Content-Type ：请求体的多媒体类型。\n   \n   🌰 ： Content-Type: application/x-www-form-urlencoded\n\n * Date ：发送消息的日期和时间。\n\n * Except ：表明客户端要求服务器做出特定的行为。\n\n * Host ：服务器的域名 (用于虚拟主机)，以及服务器所监听的传输控制协议端口号。\n\n * User-Agent ：浏览器的浏览器身份标识字符串。\n\n * Origin ：跨源请求的共享的来源。\n   \n   🌰 ： Origin: http://www.example-social-network.com\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * http 常见的请求头有哪些？\n\n\n# http header 概念\n\nhttp header（头部字段），指在 http 超文本传输协议的 请求和响应消息中的 消息头部分。定义了超文本传输协议事务中的 操作参数。\n\nhttp 头部字段可以根据需要定义，因此 请求头、响应头内容都可能是非标准的头字段。\n\n\n# 常见的 header 字段\n\n * accept ：能够接受的响应内容类型。\n   \n   🌰 ： accept: text/plain\n\n * accpet-charset ：能够接受的字符集\n\n * accept-encoding ：能够接受的编码方式列表\n\n * accept-language ：能够接受的自然语言列表\n\n * authorization ：用于超文本传输协议的认证的认证信息。\n   \n   🌰 ： authorization: basic qwxhzgrpbjpvcgvuihnlc2ftzq==\n\n * cache-control ：指定本次请求 / 响应链中所有的缓存机制都必须准手的指令。\n\n * connection ：浏览器想要优先使用的连接类型。\n\n * cookie ：服务器通过 set- cookie 发送的一个超文本传输协议 cookie。\n\n * content-length ：以 八位字节数组 （8 位的字节）表示的请求体的长度。\n\n * content-type ：请求体的多媒体类型。\n   \n   🌰 ： content-type: application/x-www-form-urlencoded\n\n * date ：发送消息的日期和时间。\n\n * except ：表明客户端要求服务器做出特定的行为。\n\n * host ：服务器的域名 (用于虚拟主机)，以及服务器所监听的传输控制协议端口号。\n\n * user-agent ：浏览器的浏览器身份标识字符串。\n\n * origin ：跨源请求的共享的来源。\n   \n   🌰 ： origin: http://www.example-social-network.com\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 HTTP 常见的状态码",frontmatter:{title:"🍎 HTTP 常见的状态码",date:"2022-06-06T15:16:14.000Z",permalink:"/pages/6caede/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/04.%20%F0%9F%8D%8E%20HTTP%20%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/04. 🍎 HTTP 常见的状态码.md",key:"v-81be5d5c",path:"/pages/6caede/",headers:[{level:2,title:"HTTP 状态码的概念",slug:"http-状态码的概念",normalizedTitle:"http 状态码的概念",charIndex:74},{level:2,title:"1**",slug:"_1",normalizedTitle:"1**",charIndex:189},{level:2,title:"2**",slug:"_2",normalizedTitle:"2**",charIndex:202},{level:2,title:"3**",slug:"_3",normalizedTitle:"3**",charIndex:215},{level:2,title:"4**",slug:"_4",normalizedTitle:"4**",charIndex:230},{level:2,title:"5**",slug:"_5",normalizedTitle:"5**",charIndex:246},{level:2,title:"常用应用场景",slug:"常用应用场景",normalizedTitle:"常用应用场景",charIndex:978},{level:2,title:"相关问题",slug:"相关问题",normalizedTitle:"相关问题",charIndex:2},{level:3,title:"301 与 302 的区别",slug:"_301-与-302-的区别",normalizedTitle:"301 与 302 的区别",charIndex:1410},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1732}],headersStr:"HTTP 状态码的概念 1** 2** 3** 4** 5** 常用应用场景 相关问题 301 与 302 的区别 参考",content:"> 相关问题：\n> \n>  * HTTP 常见的状态码有哪些？\n>  * HTTP 状态码的种类？\n>  * HTTP 状态码的应用场景？\n\n\n# HTTP 状态码的概念\n\nHTTP 状态码，用于表示网页服务器超文本传输协议响应状态的 3 位数字代码。作用是 服务器告诉客户端当前请求的响应状态，通过状态码能判断和分析服务器的运行状态。\n\n状态码由第一位开头数字分类：\n\n * 1** 表示消息；\n * 2** 表示成功；\n * 3** ：表示重定向；\n * 4** ：表示请求错误；\n * 5** ：表示服务器错误；\n\n\n# 1**\n\n请求已被接收，需要继续处理。一般是 临时相应，只包状态行和某些可选的响应头信息，并且以空行结束。\n\n常见的 1** 的状态码有：\n\n * 100 ：客户端继续发送请求。临时相应，用于通知客户端发送的部分请求已经被服务器接收，且未被拒绝，客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个相应。服务器必须在请求完成之后向客户端发送一个最终响应。\n * 101 ：服务器根据客户端的请求切换协议。例如 WebSocket 或者 HTTP 2 的 shengji。\n\n\n# 2**\n\n代表 请求已经被服务器成功接收、理解。\n\n常见的 2** 的状态码有：\n\n * 200 ：\n * 201 ：\n * 202 ：\n * 203\n * 204\n * 205\n * 206\n\n\n# 3**\n\n代表要完成请求，需要进一步的操作，用来重定向。\n\n常见的 3** 的状态码有：\n\n * 300 ：\n\n\n# 4**\n\n代表 客户端可能发生了错误，妨碍了服务器端的处理。\n\n常见的 4** 的状态码有：\n\n * 400 错误请求：服务器不理解请求的语法；\n * 401 未授权：请求要求身份认证；\n * 403 禁止：服务器拒绝响应请求；\n * 404 未找到：服务器找不到请求的网页；\n * 405 方法禁用：禁用请求中指定的方法；\n * 406 不接受：无法使用请求的内容特性响应请求的网页；\n * 407 需要代理授权：与 401 相似，指定请求者应当授权使用代理；\n * 408 请求超时：服务器等待请求发生超时。\n\n\n# 5**\n\n代表 服务器无法完成明显的请求，服务器在处理请求时有错误或者异常状态发生。\n\n\n# 常用应用场景\n\n * 100 ：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输。\n * 206 ：一般用作断点续传，或者是视频文件等大文件的加载。\n * 301 ：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时就使用 301 重定向到新的域名。\n * 302 ：临时重定向不会缓存，常用于未登录的用户访问用户中心重定向到登录页面。\n * 304 ：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分。\n * 400 ：请求参数有误，请求无法被服务器识别。\n * 403 ：客户端禁止访问该站或者资源。内网 / 外网资源。\n * 404 ：服务器找不到资源。\n * 503 ：服务器停机维护时。\n * 504 ：网关超时。\n\n\n# 相关问题\n\n\n# 301 与 302 的区别\n\n * 301 Moved Permanently 表示被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n\n * 302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。\n   \n   字面上的区别就是 301 是永久重定向，而 302 是临时重定向。\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * http 常见的状态码有哪些？\n>  * http 状态码的种类？\n>  * http 状态码的应用场景？\n\n\n# http 状态码的概念\n\nhttp 状态码，用于表示网页服务器超文本传输协议响应状态的 3 位数字代码。作用是 服务器告诉客户端当前请求的响应状态，通过状态码能判断和分析服务器的运行状态。\n\n状态码由第一位开头数字分类：\n\n * 1** 表示消息；\n * 2** 表示成功；\n * 3** ：表示重定向；\n * 4** ：表示请求错误；\n * 5** ：表示服务器错误；\n\n\n# 1**\n\n请求已被接收，需要继续处理。一般是 临时相应，只包状态行和某些可选的响应头信息，并且以空行结束。\n\n常见的 1** 的状态码有：\n\n * 100 ：客户端继续发送请求。临时相应，用于通知客户端发送的部分请求已经被服务器接收，且未被拒绝，客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个相应。服务器必须在请求完成之后向客户端发送一个最终响应。\n * 101 ：服务器根据客户端的请求切换协议。例如 websocket 或者 http 2 的 shengji。\n\n\n# 2**\n\n代表 请求已经被服务器成功接收、理解。\n\n常见的 2** 的状态码有：\n\n * 200 ：\n * 201 ：\n * 202 ：\n * 203\n * 204\n * 205\n * 206\n\n\n# 3**\n\n代表要完成请求，需要进一步的操作，用来重定向。\n\n常见的 3** 的状态码有：\n\n * 300 ：\n\n\n# 4**\n\n代表 客户端可能发生了错误，妨碍了服务器端的处理。\n\n常见的 4** 的状态码有：\n\n * 400 错误请求：服务器不理解请求的语法；\n * 401 未授权：请求要求身份认证；\n * 403 禁止：服务器拒绝响应请求；\n * 404 未找到：服务器找不到请求的网页；\n * 405 方法禁用：禁用请求中指定的方法；\n * 406 不接受：无法使用请求的内容特性响应请求的网页；\n * 407 需要代理授权：与 401 相似，指定请求者应当授权使用代理；\n * 408 请求超时：服务器等待请求发生超时。\n\n\n# 5**\n\n代表 服务器无法完成明显的请求，服务器在处理请求时有错误或者异常状态发生。\n\n\n# 常用应用场景\n\n * 100 ：客户端在发送 post 数据给服务器前，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 数据，如果处理，则 post 上传数据。常用于 post 大数据传输。\n * 206 ：一般用作断点续传，或者是视频文件等大文件的加载。\n * 301 ：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时就使用 301 重定向到新的域名。\n * 302 ：临时重定向不会缓存，常用于未登录的用户访问用户中心重定向到登录页面。\n * 304 ：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分。\n * 400 ：请求参数有误，请求无法被服务器识别。\n * 403 ：客户端禁止访问该站或者资源。内网 / 外网资源。\n * 404 ：服务器找不到资源。\n * 503 ：服务器停机维护时。\n * 504 ：网关超时。\n\n\n# 相关问题\n\n\n# 301 与 302 的区别\n\n * 301 moved permanently 表示被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 uri 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n\n * 302 found 请求的资源现在临时从不同的 uri 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 cache-control 或 expires 中进行了指定的情况下，这个响应才是可缓存的。\n   \n   字面上的区别就是 301 是永久重定向，而 302 是临时重定向。\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 HTTP 1.0/1.1/2.0 的区别",frontmatter:{title:"🍏 HTTP 1.0/1.1/2.0 的区别",date:"2022-06-06T15:15:24.000Z",permalink:"/pages/f53072/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8F%20HTTP%201.0%201.1%202.0%20%E5%8C%BA%E5%88%AB.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/03. 🍏 HTTP 1.0 1.1 2.0 区别.md",key:"v-0fab340e",path:"/pages/f53072/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:404}],headersStr:"参考",content:"> 相关问题：\n> \n>  * HTTP 的 1.0 / 1.1 / 2.0 分别有什么特点？分别有什么区别？\n\n * HTTP 1.0：\n   \n   * 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接。\n\n * HTTP 1.1：\n   \n   * 引入 持久连接。TCP 连接默认不关闭，可以被多个请求服用。\n   * 在同一个 TCP 连接中，客户端可以发送多个请求。\n   * 所有数据通信 按序进行，服务器只有处理完一个请求，才会接着处理下一个请求。\n   * 新增一些请求方法、请求头、响应头。\n\n * HTTP 2.0:\n   \n   * 采用了 二进制格式 而非 文本格式；\n   * 完全 多路复用。只需要一个连接就可以实现并行。\n   * 使用报头压缩，降低开销。\n   * 引入服务器推送。语序服务端推送资源给客户端。适合加载静态资源。\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * http 的 1.0 / 1.1 / 2.0 分别有什么特点？分别有什么区别？\n\n * http 1.0：\n   \n   * 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 tcp 连接。\n\n * http 1.1：\n   \n   * 引入 持久连接。tcp 连接默认不关闭，可以被多个请求服用。\n   * 在同一个 tcp 连接中，客户端可以发送多个请求。\n   * 所有数据通信 按序进行，服务器只有处理完一个请求，才会接着处理下一个请求。\n   * 新增一些请求方法、请求头、响应头。\n\n * http 2.0:\n   \n   * 采用了 二进制格式 而非 文本格式；\n   * 完全 多路复用。只需要一个连接就可以实现并行。\n   * 使用报头压缩，降低开销。\n   * 引入服务器推送。语序服务端推送资源给客户端。适合加载静态资源。\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 TCP 与 UDP 的区别",frontmatter:{title:"🍏 TCP 与 UDP 的区别",date:"2022-06-06T12:31:58.000Z",permalink:"/pages/58170b/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8F%20TCP%20%E4%B8%8E%20UDP%20%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/10. 🍏 TCP 与 UDP 的区别.md",key:"v-17a3e06a",path:"/pages/58170b/",headers:[{level:2,title:"TCP 与 UDP 的区别",slug:"tcp-与-udp-的区别",normalizedTitle:"tcp 与 udp 的区别",charIndex:21},{level:2,title:"TCP",slug:"tcp",normalizedTitle:"tcp",charIndex:21},{level:2,title:"UDP",slug:"udp",normalizedTitle:"udp",charIndex:27},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1540}],headersStr:"TCP 与 UDP 的区别 TCP UDP 参考",content:"> 相关问题：\n> \n>  * 请说一下 TCP 与 UDP 的区别？\n>  * 分别说一下对 TCP 与 UDP 的理解？\n\n\n# TCP 与 UDP 的区别\n\n * TCP 是 面向连接的；UDP 是 无连接的，发送数据之前不需要先建立连接；\n * TCP 提供 可靠服务，通过 TCP 连接传输的数据无差错、不丢失、不重复且按序到达，适合带来大量数据的交换；UDP 尽最大努力交付，不保证可靠交付；\n * TCP 面向字节流；UDP 面向报文，网络出现拥塞不会使得发送速率降低（因此会出现丢包，在实时的应用比如电话、视频会议中）；\n * TCP 只能是 一对一的；UDP 支持 一对一、一对多；\n * TCP 的首部较大，为 20 字节；UDP 只有 8 字节；\n\n对比：\n\n       TCP                UDP\n可靠性    可靠                 不可靠\n连接性    面向连接               无连接\n报文     面向字节流              面向报文\n效率     传输效率低              传输效率高\n双工性    全双工                一对一、一对多、多对一、多对多\n流量控制   滑动窗口               - 🈚️\n拥塞控制   慢开始、拥塞避免、快重传、快恢复   - 🈚️\n\n应用场景：\n\n * TCP：适用于对效率要求低、准确性高的要求有可靠连接的场景：\n   * 电子邮件 / SMTP 协议\n   * 远程终端接入 / TELNET 协议\n   * 万维网 / WWW 协议\n   * 文件传输 / FTP 协议\n * UDP：适用于对于效率要求高、准确性要求低的场景：\n   * 域名转换 / DNS 协议\n   * 文件传输 / TFTP 协议\n   * 网络管理 / SNMP\n   * 远程文件管理 / NFS\n\n\n# TCP\n\nTCP （Transmission Control Protocol） 传输控制协议，是一种可靠的、面向字节流的通信协议，将应用层交下来的数据看成是 无结构的字节流。\n\n> 看成是流水形式，发送方 TCP 会将数据放入蓄水池（缓冲区），等到可以发送的时候就发送，不能发送就等着，TCP 会根据当前网络的拥塞状态来确定每个报文段的大小；\n\nTCP 的报文首部有 20 个字节，额外开销大。\n\nTCP 特点：\n\n * 充分实现数据传输时的各种控制功能。可以进行丢包的重发控制；对次序乱掉的分包进行顺序控制（UDP 中无）\n\n * 是面向有连接的协议。只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n\n根据 TCP 这些特点，在 IP 这种无连接的网络上也能实现高可靠性的通信。\n\n\n# UDP\n\nUDP （User Datagram Protocol） 用户数据包协议，简单面向数据报的通信协议，对应用层交下来的报文，不合并、不拆分，只才其上面加上首部后就交给下面的网络层。\n\n> 无论应用层交给 UDP 多长的报文，都会统统发送，一次发送一个报文；接收方接收到后直接去除首部，交给上面的应用层就完成任务。\n\nUDP 的报文头部包括 4 个字段，每个字段占用 2 个字节，标题短、开销小。\n\nUDP 特点：\n\n * 不提供复杂的控制机制，面向 IP 提供 无连接的通信服务；\n   * 传输途中出现丢包，UDP 不负责重发；\n   * 包的到达顺序乱序，UDP 不会纠正；\n * 收到数据的那一刻，立刻按照原样发送到网络上，即使网络出现拥塞。UDP 没有流量控制等避免网络拥塞的行为。\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * 请说一下 tcp 与 udp 的区别？\n>  * 分别说一下对 tcp 与 udp 的理解？\n\n\n# tcp 与 udp 的区别\n\n * tcp 是 面向连接的；udp 是 无连接的，发送数据之前不需要先建立连接；\n * tcp 提供 可靠服务，通过 tcp 连接传输的数据无差错、不丢失、不重复且按序到达，适合带来大量数据的交换；udp 尽最大努力交付，不保证可靠交付；\n * tcp 面向字节流；udp 面向报文，网络出现拥塞不会使得发送速率降低（因此会出现丢包，在实时的应用比如电话、视频会议中）；\n * tcp 只能是 一对一的；udp 支持 一对一、一对多；\n * tcp 的首部较大，为 20 字节；udp 只有 8 字节；\n\n对比：\n\n       tcp                udp\n可靠性    可靠                 不可靠\n连接性    面向连接               无连接\n报文     面向字节流              面向报文\n效率     传输效率低              传输效率高\n双工性    全双工                一对一、一对多、多对一、多对多\n流量控制   滑动窗口               - 🈚️\n拥塞控制   慢开始、拥塞避免、快重传、快恢复   - 🈚️\n\n应用场景：\n\n * tcp：适用于对效率要求低、准确性高的要求有可靠连接的场景：\n   * 电子邮件 / smtp 协议\n   * 远程终端接入 / telnet 协议\n   * 万维网 / www 协议\n   * 文件传输 / ftp 协议\n * udp：适用于对于效率要求高、准确性要求低的场景：\n   * 域名转换 / dns 协议\n   * 文件传输 / tftp 协议\n   * 网络管理 / snmp\n   * 远程文件管理 / nfs\n\n\n# tcp\n\ntcp （transmission control protocol） 传输控制协议，是一种可靠的、面向字节流的通信协议，将应用层交下来的数据看成是 无结构的字节流。\n\n> 看成是流水形式，发送方 tcp 会将数据放入蓄水池（缓冲区），等到可以发送的时候就发送，不能发送就等着，tcp 会根据当前网络的拥塞状态来确定每个报文段的大小；\n\ntcp 的报文首部有 20 个字节，额外开销大。\n\ntcp 特点：\n\n * 充分实现数据传输时的各种控制功能。可以进行丢包的重发控制；对次序乱掉的分包进行顺序控制（udp 中无）\n\n * 是面向有连接的协议。只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n\n根据 tcp 这些特点，在 ip 这种无连接的网络上也能实现高可靠性的通信。\n\n\n# udp\n\nudp （user datagram protocol） 用户数据包协议，简单面向数据报的通信协议，对应用层交下来的报文，不合并、不拆分，只才其上面加上首部后就交给下面的网络层。\n\n> 无论应用层交给 udp 多长的报文，都会统统发送，一次发送一个报文；接收方接收到后直接去除首部，交给上面的应用层就完成任务。\n\nudp 的报文头部包括 4 个字段，每个字段占用 2 个字节，标题短、开销小。\n\nudp 特点：\n\n * 不提供复杂的控制机制，面向 ip 提供 无连接的通信服务；\n   * 传输途中出现丢包，udp 不负责重发；\n   * 包的到达顺序乱序，udp 不会纠正；\n * 收到数据的那一刻，立刻按照原样发送到网络上，即使网络出现拥塞。udp 没有流量控制等避免网络拥塞的行为。\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 HTTP 请求方法",frontmatter:{title:"🍎 HTTP 请求方法",date:"2022-06-06T17:27:06.000Z",permalink:"/pages/9506f5/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/05.%20%F0%9F%8D%8E%20HTTP%20%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/05. 🍎 HTTP 请求方法.md",key:"v-24edffca",path:"/pages/9506f5/",headers:[{level:2,title:"请求方法 GET 与 POST 的区别",slug:"请求方法-get-与-post-的区别",normalizedTitle:"请求方法 get 与 post 的区别",charIndex:24},{level:3,title:"GET / POST",slug:"get-post",normalizedTitle:"get / post",charIndex:95},{level:3,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:41},{level:2,title:"HTTP 支持的请求方法",slug:"http-支持的请求方法",normalizedTitle:"http 支持的请求方法",charIndex:925},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1014}],headersStr:"请求方法 GET 与 POST 的区别 GET / POST 区别 HTTP 支持的请求方法 参考",content:"> 相关问题：\n> \n>  * 说说 HTTP 请求方法 GET 与 POST 的区别？\n>  * HTTP 常见的请求方法有哪些？\n\n\n# 请求方法 GET 与 POST 的区别\n\n\n# GET / POST\n\n是 HTTP 协议中的 发送请求的方法。\n\n * GET 方法请求一个指定资源的表示形式，应该只被用于获取数据。\n * POST 方法用于将实体提交到指定的资源，通常导致服务器上的状态变化或者副作用。\n\n本质上都是 TCP 连接。\n\n\n# 区别\n\n * 请求数据 / 参数的位置：GET 的参数通过 URL 传递；POST 通过 Request Body 传递。\n   \n   > 这只是一个约定，没有受到 HTTP 的特别规范。实际上可以在 POST 请求的 URL 中写入参数，或者 GET 的 Request Body 请求体中提交参数。\n\n * 请求数据 / 参数是否安全：GET 的请求参数直接暴露在 URL 中，不能传递敏感信息；GE T 的请求参数会完整保留在浏览器的历史中。\n   \n   > 实际上，HTTP 使用明文传输，使用 POST 请求同样不安全。只有 HTTPS 才能加密安全。\n\n * 请求数据 / 参数类型 / 编码方式：GET 请求只接受 ASCII 字符；POST 请求没有限制。 GET 只能进行 URL 编码；POST 支持多种编码方式。\n\n * 数据长度限制：GET 在 URL 传送参数时受到浏览器或者服务器的限制（URL 的长度）；POST 请求无。\n   \n   > 实际上，HTTP 协议并没有限制 URL 和 Request Body 的长度。对 URL 的长度限制大多是浏览器和服务器的原因。\n\n * 缓存：GET 请求会被浏览器主动 Cache；POST 请求不会，除非手动设置。GET 在浏览器会退时无害，POST 会重新提交请求。\n\n * 数据包：GET 请求，浏览器会一同发送 HTTP header 和 data，服务器响应 200 并返回数据；POST 请求，浏览器回先发送 header，服务器响应 100 ，浏览器再发送 data ，所以数据包发送了两次。\n\n\n# HTTP 支持的请求方法\n\n * GET\n * POST\n * HEAD\n * OPTIONS\n * PUT\n * DELETE\n * TRACE\n * CONNECT\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * 说说 http 请求方法 get 与 post 的区别？\n>  * http 常见的请求方法有哪些？\n\n\n# 请求方法 get 与 post 的区别\n\n\n# get / post\n\n是 http 协议中的 发送请求的方法。\n\n * get 方法请求一个指定资源的表示形式，应该只被用于获取数据。\n * post 方法用于将实体提交到指定的资源，通常导致服务器上的状态变化或者副作用。\n\n本质上都是 tcp 连接。\n\n\n# 区别\n\n * 请求数据 / 参数的位置：get 的参数通过 url 传递；post 通过 request body 传递。\n   \n   > 这只是一个约定，没有受到 http 的特别规范。实际上可以在 post 请求的 url 中写入参数，或者 get 的 request body 请求体中提交参数。\n\n * 请求数据 / 参数是否安全：get 的请求参数直接暴露在 url 中，不能传递敏感信息；ge t 的请求参数会完整保留在浏览器的历史中。\n   \n   > 实际上，http 使用明文传输，使用 post 请求同样不安全。只有 https 才能加密安全。\n\n * 请求数据 / 参数类型 / 编码方式：get 请求只接受 ascii 字符；post 请求没有限制。 get 只能进行 url 编码；post 支持多种编码方式。\n\n * 数据长度限制：get 在 url 传送参数时受到浏览器或者服务器的限制（url 的长度）；post 请求无。\n   \n   > 实际上，http 协议并没有限制 url 和 request body 的长度。对 url 的长度限制大多是浏览器和服务器的原因。\n\n * 缓存：get 请求会被浏览器主动 cache；post 请求不会，除非手动设置。get 在浏览器会退时无害，post 会重新提交请求。\n\n * 数据包：get 请求，浏览器会一同发送 http header 和 data，服务器响应 200 并返回数据；post 请求，浏览器回先发送 header，服务器响应 100 ，浏览器再发送 data ，所以数据包发送了两次。\n\n\n# http 支持的请求方法\n\n * get\n * post\n * head\n * options\n * put\n * delete\n * trace\n * connect\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 TCP 的三次握手与四次挥手",frontmatter:{title:"🍏 TCP 的三次握手与四次挥手",date:"2022-06-06T19:51:37.000Z",permalink:"/pages/6d9faf/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/11.%20%F0%9F%8D%8F%20TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/11. 🍏 TCP 的三次握手与四次挥手.md",key:"v-6c1f0267",path:"/pages/6d9faf/",headers:[{level:2,title:"三次握手",slug:"三次握手",normalizedTitle:"三次握手",charIndex:29},{level:2,title:"四次挥手",slug:"四次挥手",normalizedTitle:"四次挥手",charIndex:34},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1327}],headersStr:"三次握手 四次挥手 参考",content:"> 相关问题：\n> \n>  * 说说为什么需要 TCP 的三次握手与四次挥手？\n\n\n# 三次握手\n\nTCP 连接的三次握手过程：\n\n * 第一次握手：客户端给服务器发送一个 SYN 报文，指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SENT 状态；\n   \n   > 作用：客户发送网络包、服务器能够接收。这样服务端可以得出：客户端的发送能力和服务端的接收能力正常。\n\n * 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认 客户端的 SYN ，将客户端的 ISN + 1 作为 ACK 的值，此时服务器处于 SYN_RCVD 状态；\n   \n   > 作用：服务端发送包，客户端收到了。这样客户端可以得出：服务端的接收、发送能力，客户端的接收、发送能力正常。不过此时服务端不能确定客户端的接受能力是否正常。\n\n * 第三次握手： 客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN + 1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时双方建立起了连接。\n   \n   > 作用：客户端发送包，服务端接收到了。服务端最终得出客户端的接受能力正常。最后客户端和服务端的接收和发送能力都正常。\n\n三次握手后确认双方的接收和发送能力正常，可以正常通信。\n\n>  * 为什么不是二次握手。两次握手时，发送端可以确定自己发送的信息对方能够接收，并且确定对方发送的包自己能收到，但是接收端只能确定发送端的发送能力，无法确定自己发的包对方是否后能收到。并且两次握手，客户端可能因为网络阻塞等原因发送多个请求报文，延时到达的请求又会和服务器建立连接，浪费服务器的资源。\n\n\n# 四次挥手\n\nTCP 连接四次挥手结束连接的过程：\n\n * 第一次挥手：客户端发送一个 FIN 报文，报文中指定一个序列号，此时客户端处于 FIN_WAIT 的状态，停止发送数据，等待服务端的确认。\n\n * 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表示服务端已经收到了客户端的报文，此时服务器处于 CLOSE_WAIT 状态。\n\n * 第三次挥手：服务端也想断开连接，就和客户端的第一次挥手一样，发给客户端一个 FIN，并且在报文中指定一个序列号，此时服务端处于 FIN_WAIT 状态。\n\n * 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，并且把服务端的序列号值 + 1 作为 ACK 报文的序列号，此时客户端处于 TIME_WAIT 状态。需要过一段时间以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。服务端收到 ACK 报文之后，就处于关闭连接 CLOSED 状态了。\n\n四次挥手的原因：服务端收到客户端的 FIN 报文之后，并不会立即关闭连接，而是先发送一个 ACK 包告诉客户端收到关闭连接的通知，只有当服务器的所有报文发送完毕之后，才会发送 FIN 报文断开连接，因此需要四次握手。\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * 说说为什么需要 tcp 的三次握手与四次挥手？\n\n\n# 三次握手\n\ntcp 连接的三次握手过程：\n\n * 第一次握手：客户端给服务器发送一个 syn 报文，指明客户端的初始化序列号 isn，此时客户端处于 syn_sent 状态；\n   \n   > 作用：客户发送网络包、服务器能够接收。这样服务端可以得出：客户端的发送能力和服务端的接收能力正常。\n\n * 第二次握手：服务器收到客户端的 syn 报文之后，会以自己的 syn 报文作为应答，为了确认 客户端的 syn ，将客户端的 isn + 1 作为 ack 的值，此时服务器处于 syn_rcvd 状态；\n   \n   > 作用：服务端发送包，客户端收到了。这样客户端可以得出：服务端的接收、发送能力，客户端的接收、发送能力正常。不过此时服务端不能确定客户端的接受能力是否正常。\n\n * 第三次握手： 客户端收到 syn 报文之后，会发送一个 ack 报文，值为服务器的 isn + 1。此时客户端处于 established 状态。服务器收到 ack 报文之后，也处于 established 状态，此时双方建立起了连接。\n   \n   > 作用：客户端发送包，服务端接收到了。服务端最终得出客户端的接受能力正常。最后客户端和服务端的接收和发送能力都正常。\n\n三次握手后确认双方的接收和发送能力正常，可以正常通信。\n\n>  * 为什么不是二次握手。两次握手时，发送端可以确定自己发送的信息对方能够接收，并且确定对方发送的包自己能收到，但是接收端只能确定发送端的发送能力，无法确定自己发的包对方是否后能收到。并且两次握手，客户端可能因为网络阻塞等原因发送多个请求报文，延时到达的请求又会和服务器建立连接，浪费服务器的资源。\n\n\n# 四次挥手\n\ntcp 连接四次挥手结束连接的过程：\n\n * 第一次挥手：客户端发送一个 fin 报文，报文中指定一个序列号，此时客户端处于 fin_wait 的状态，停止发送数据，等待服务端的确认。\n\n * 第二次挥手：服务端收到 fin 之后，会发送 ack 报文，且把客户端的序列号值 + 1 作为 ack 报文的序列号值，表示服务端已经收到了客户端的报文，此时服务器处于 close_wait 状态。\n\n * 第三次挥手：服务端也想断开连接，就和客户端的第一次挥手一样，发给客户端一个 fin，并且在报文中指定一个序列号，此时服务端处于 fin_wait 状态。\n\n * 第四次挥手：客户端收到 fin 之后，一样发送一个 ack 报文作为应答，并且把服务端的序列号值 + 1 作为 ack 报文的序列号，此时客户端处于 time_wait 状态。需要过一段时间以确保服务端收到自己的 ack 报文之后才会进入 closed 状态。服务端收到 ack 报文之后，就处于关闭连接 closed 状态了。\n\n四次挥手的原因：服务端收到客户端的 fin 报文之后，并不会立即关闭连接，而是先发送一个 ack 包告诉客户端收到关闭连接的通知，只有当服务器的所有报文发送完毕之后，才会发送 fin 报文断开连接，因此需要四次握手。\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 TCP/IP 协议",frontmatter:{title:"🍏 TCP/IP 协议",date:"2022-06-06T21:27:30.000Z",permalink:"/pages/d329d0/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/12.%20%F0%9F%8D%8F%20TCPIP%20%E5%8D%8F%E8%AE%AE.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/12. 🍏 TCPIP 协议.md",key:"v-4a1b1da4",path:"/pages/d329d0/",headers:[{level:2,title:"TCP/IP 的概念",slug:"tcp-ip-的概念",normalizedTitle:"tcp/ip 的概念",charIndex:36},{level:2,title:"TCP/IP 划分层次",slug:"tcp-ip-划分层次",normalizedTitle:"tcp/ip 划分层次",charIndex:308},{level:3,title:"五层体系",slug:"五层体系",normalizedTitle:"五层体系",charIndex:335},{level:3,title:"四层体系",slug:"四层体系",normalizedTitle:"四层体系",charIndex:343},{level:2,title:"OSI 参考模型",slug:"osi-参考模型",normalizedTitle:"osi 参考模型",charIndex:508},{level:2,title:"TCP/IP 与 OSI 参考模型对比",slug:"tcp-ip-与-osi-参考模型对比",normalizedTitle:"tcp/ip 与 osi 参考模型对比",charIndex:2705},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:512}],headersStr:"TCP/IP 的概念 TCP/IP 划分层次 五层体系 四层体系 OSI 参考模型 TCP/IP 与 OSI 参考模型对比 参考",content:"> 相关问题：\n> \n>  * 如何理解 TCP/IP 协议？\n\n\n# TCP/IP 的概念\n\n是 传输控制协议 / 网际协议。指能够在多个网络之间实现信息传输的协议簇。\n\n * TCP 传输控制协议： 面向连接的、可靠的、基于字节流的传输层通信协议；\n * IP 网际协议：用于封包交换数据网络的协议；\n\nTCP / IP 不仅仅是指 TCP 和 IP 两个协议，而是指由 FTP、SMTP、TCP、UDP、IP 等协议构成的协议簇。仅仅因为 TCP 协议与 IP 协议最具代表性，所以统称为 TCP/IP 协议簇（TCP/IP Protocol Suite or TCP/IP Protocols） 。\n\n\n# TCP/IP 划分层次\n\nTCP/IP 协议簇划分了 五层体系 或者 四层体系：\n\n * 五层体系协议结构：综合 OSI 和 TCP/IP 的优点，包括应用层、传输层、网络层、数据链路层和物理层。\n   \n   五层体系只是为了介绍计算机网络原理。实际应用是 TCP/IP 四层体系结构。\n\n * 四层体系结构：包括应用层、传输层、网络层、网络接口层。\n\n\n# 五层体系\n\n应用层：TCP/IP 将 OSI 参考模型中的会话层、表示层、应用层的功能合并到一个应用层中实现，通过不同的应用层协议为不同的应用提供服务。（例如： FTP、TELNENT、DNS、SMTP）\n\n传输层：对应 OSI 参考模型的传输层。为上层实体提供源端到对端主机的通信功能。定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP）。\n\n网络层：负责为分组网络中的不同主机提供通信服务，并且通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或者用户数据封装成分组和包进行传送。\n\n数据链路层：在两个相邻节点传输数据时，将网络层交下来的 IP 数据包组装成帧，在两个相邻节点之间的链路上传送帧。\n\n物理层：保证数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。\n\n\n# 四层体系\n\n应用层：\n\n * 功能：负责一切与应用程序相关的功能。\n\n * 相关协议：FTP、HTTP、DNS、SMTP、NFS\n\n传输层：\n\n * 单位：报文段；\n\n * 功能：负责提供可靠的传输服务，对应 OSI 参考模型的第四层。\n\n * 相关协议：TCP、UDP\n\n网络层（网络互联层）：\n\n * 单位：数据报；\n\n * 功能：负责网络间的寻址数据传输，对应 OSI 参考模型的第三层。\n\n * 相关协议：IP、ICMP、 ARP、 RARP\n\n网络接口层：\n\n * 单位：帧；\n\n * 功能：负责实际数据的传输，对应 OSI 参考模型的下两层。\n\n * 相关协议： HDLC、 PPP、 SLIP\n\n\n# OSI 参考模型\n\nOSI （Open System Interconnect） 模型为 开放式通信系统互联参考模型，是国际标准化组织提出的 计算机在世界范围内互联为网络的 标准框架。\n\n将计算机网络体系结构分为 7 层，每一层都有各自的功能和协议，并且完成与相邻层的接口通信，互不打扰。\n\n应用层：定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如，DNS 域名系统、HTTP 协议、电子邮件协议 SMTP 协议等。\n\n * 作用：通过应用程序间的交互完成特定的网络应用。\n * 数据单元：报文。\n\n表示层：提供的服务包括 数据压缩、数据加密、数据描述；使应用程序不必担心在各台计算机中表示和存储的内部格式存在差异。\n\n * 作用：使通信的应用程序能够解释交换数据的含义。为上层应用层提供服务，向下接收来自会话层的服务。\n\n会话层：提供了数据交换的定界和同步功能，包括建立检查点和恢复方案的方法。\n\n * 作用：负责建立、管理、终止表示层实体之间的通信会话。\n\n传输层：向高层屏蔽下层数据通信的细节。是计算机通信体系结构中关键的一层。\n\n * 作用：为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其它一些关键传输问题。\n\n网络层：\n\n * 两台计算机之间传送数据时，通信链路往往不止一条，传输的信息可能经过很多通信子网。\n\n * 作用：选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把传输层产生的报文或者用户数据封装成分组或包，向下传输到数据链路层。\n   \n   使用无连接的 IP 网际协议（Internet Protocol） 和许多路由协议。所以网络层也称 IP 层。\n\n数据链路层：\n\n * 也叫链路层，在网络层和物理层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这时需要使用专门的链路层协议。\n\n * 作用：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据组装成帧，在两个相邻节点间的链路上传送帧。\n   \n   * 每一组数据帧包含 报头 head 和 数据 data 两部分：\n     \n     head 标明数据发送者、接受者、数据类型，例如 MAC 地址；\n     \n     data 存储了计算机之间交互的数据。\n   \n   通过控制信息可以知道帧的起止比特位置，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单丢弃这个帧，以免继续占用网络资源。\n\n物理层：\n\n * 作用：实现计算机节点之间比特流的透明传送。\n   \n   主要任务是确定传输媒体接口的一些特性（机械特性、电气特性、功能特性、过程特性）。主要和硬件有关。\n\n----------------------------------------\n\n数据在各层中的传输过程：\n\n * 应用层中的报文传送到运输层。\n\n * 最简单的情况下，运输层收到报文并附上附加信息，该首部将被接收端的运输层接收。\n   \n   应用层和运输层首部信息构成运输层报文段，附加信息可能包括：允许接收端向上适当的应用程序交付报文的信息以及差错检查位的信息。该信息能让接收端判断报文中的比特是否在途中已被改变。\n\n * 运输层向网络层传递该报文段，网络层增加了如源头和目的端系统地址等网络层首部信息，生层网络层数据报。\n\n * 网络层数据报传递给数据链路层，在数据链路层中数据报添加发送端 MAC 地址和接收端 MAC 地址后，被封装成帧。\n\n * 在物理层中，数据帧被封装为比特流，然后通过传输介质传送到对端。\n\n * 对端通过一步步解开封装，获取到传送的数据。\n\n\n# TCP/IP 与 OSI 参考模型对比\n\n相同点：\n\n * 都采用了层次结构；\n * 都能提供面向连接和无连接的两种通信服务机制；\n\n不同点：\n\n * OSI 采用七层模型；TCP/IP 采用 四层或者五层 结构；\n * TCP/IP 没有对网络接口层进行细分；OSI 参考模型对服务和协议进行了明确的细分；\n * OSI 作为概念模型实现较为困难；TCP/IP 能够投入实际应用中；\n * TCP/IP 协议去掉表示层和会话层原因在于：表示层和会话层、应用成都是在应用程序中内部实现的，最终产出的是一个应用数据包，而应用程序之间是无法实现代码的抽象构想的，所以 OSI 参考模型的分层无法实现。\n\n\n# 参考",normalizedContent:"> 相关问题：\n> \n>  * 如何理解 tcp/ip 协议？\n\n\n# tcp/ip 的概念\n\n是 传输控制协议 / 网际协议。指能够在多个网络之间实现信息传输的协议簇。\n\n * tcp 传输控制协议： 面向连接的、可靠的、基于字节流的传输层通信协议；\n * ip 网际协议：用于封包交换数据网络的协议；\n\ntcp / ip 不仅仅是指 tcp 和 ip 两个协议，而是指由 ftp、smtp、tcp、udp、ip 等协议构成的协议簇。仅仅因为 tcp 协议与 ip 协议最具代表性，所以统称为 tcp/ip 协议簇（tcp/ip protocol suite or tcp/ip protocols） 。\n\n\n# tcp/ip 划分层次\n\ntcp/ip 协议簇划分了 五层体系 或者 四层体系：\n\n * 五层体系协议结构：综合 osi 和 tcp/ip 的优点，包括应用层、传输层、网络层、数据链路层和物理层。\n   \n   五层体系只是为了介绍计算机网络原理。实际应用是 tcp/ip 四层体系结构。\n\n * 四层体系结构：包括应用层、传输层、网络层、网络接口层。\n\n\n# 五层体系\n\n应用层：tcp/ip 将 osi 参考模型中的会话层、表示层、应用层的功能合并到一个应用层中实现，通过不同的应用层协议为不同的应用提供服务。（例如： ftp、telnent、dns、smtp）\n\n传输层：对应 osi 参考模型的传输层。为上层实体提供源端到对端主机的通信功能。定义了两个主要的协议：传输控制协议（tcp）和用户数据报协议（udp）。\n\n网络层：负责为分组网络中的不同主机提供通信服务，并且通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或者用户数据封装成分组和包进行传送。\n\n数据链路层：在两个相邻节点传输数据时，将网络层交下来的 ip 数据包组装成帧，在两个相邻节点之间的链路上传送帧。\n\n物理层：保证数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。\n\n\n# 四层体系\n\n应用层：\n\n * 功能：负责一切与应用程序相关的功能。\n\n * 相关协议：ftp、http、dns、smtp、nfs\n\n传输层：\n\n * 单位：报文段；\n\n * 功能：负责提供可靠的传输服务，对应 osi 参考模型的第四层。\n\n * 相关协议：tcp、udp\n\n网络层（网络互联层）：\n\n * 单位：数据报；\n\n * 功能：负责网络间的寻址数据传输，对应 osi 参考模型的第三层。\n\n * 相关协议：ip、icmp、 arp、 rarp\n\n网络接口层：\n\n * 单位：帧；\n\n * 功能：负责实际数据的传输，对应 osi 参考模型的下两层。\n\n * 相关协议： hdlc、 ppp、 slip\n\n\n# osi 参考模型\n\nosi （open system interconnect） 模型为 开放式通信系统互联参考模型，是国际标准化组织提出的 计算机在世界范围内互联为网络的 标准框架。\n\n将计算机网络体系结构分为 7 层，每一层都有各自的功能和协议，并且完成与相邻层的接口通信，互不打扰。\n\n应用层：定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如，dns 域名系统、http 协议、电子邮件协议 smtp 协议等。\n\n * 作用：通过应用程序间的交互完成特定的网络应用。\n * 数据单元：报文。\n\n表示层：提供的服务包括 数据压缩、数据加密、数据描述；使应用程序不必担心在各台计算机中表示和存储的内部格式存在差异。\n\n * 作用：使通信的应用程序能够解释交换数据的含义。为上层应用层提供服务，向下接收来自会话层的服务。\n\n会话层：提供了数据交换的定界和同步功能，包括建立检查点和恢复方案的方法。\n\n * 作用：负责建立、管理、终止表示层实体之间的通信会话。\n\n传输层：向高层屏蔽下层数据通信的细节。是计算机通信体系结构中关键的一层。\n\n * 作用：为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其它一些关键传输问题。\n\n网络层：\n\n * 两台计算机之间传送数据时，通信链路往往不止一条，传输的信息可能经过很多通信子网。\n\n * 作用：选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把传输层产生的报文或者用户数据封装成分组或包，向下传输到数据链路层。\n   \n   使用无连接的 ip 网际协议（internet protocol） 和许多路由协议。所以网络层也称 ip 层。\n\n数据链路层：\n\n * 也叫链路层，在网络层和物理层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这时需要使用专门的链路层协议。\n\n * 作用：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 ip 数据组装成帧，在两个相邻节点间的链路上传送帧。\n   \n   * 每一组数据帧包含 报头 head 和 数据 data 两部分：\n     \n     head 标明数据发送者、接受者、数据类型，例如 mac 地址；\n     \n     data 存储了计算机之间交互的数据。\n   \n   通过控制信息可以知道帧的起止比特位置，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单丢弃这个帧，以免继续占用网络资源。\n\n物理层：\n\n * 作用：实现计算机节点之间比特流的透明传送。\n   \n   主要任务是确定传输媒体接口的一些特性（机械特性、电气特性、功能特性、过程特性）。主要和硬件有关。\n\n----------------------------------------\n\n数据在各层中的传输过程：\n\n * 应用层中的报文传送到运输层。\n\n * 最简单的情况下，运输层收到报文并附上附加信息，该首部将被接收端的运输层接收。\n   \n   应用层和运输层首部信息构成运输层报文段，附加信息可能包括：允许接收端向上适当的应用程序交付报文的信息以及差错检查位的信息。该信息能让接收端判断报文中的比特是否在途中已被改变。\n\n * 运输层向网络层传递该报文段，网络层增加了如源头和目的端系统地址等网络层首部信息，生层网络层数据报。\n\n * 网络层数据报传递给数据链路层，在数据链路层中数据报添加发送端 mac 地址和接收端 mac 地址后，被封装成帧。\n\n * 在物理层中，数据帧被封装为比特流，然后通过传输介质传送到对端。\n\n * 对端通过一步步解开封装，获取到传送的数据。\n\n\n# tcp/ip 与 osi 参考模型对比\n\n相同点：\n\n * 都采用了层次结构；\n * 都能提供面向连接和无连接的两种通信服务机制；\n\n不同点：\n\n * osi 采用七层模型；tcp/ip 采用 四层或者五层 结构；\n * tcp/ip 没有对网络接口层进行细分；osi 参考模型对服务和协议进行了明确的细分；\n * osi 作为概念模型实现较为困难；tcp/ip 能够投入实际应用中；\n * tcp/ip 协议去掉表示层和会话层原因在于：表示层和会话层、应用成都是在应用程序中内部实现的，最终产出的是一个应用数据包，而应用程序之间是无法实现代码的抽象构想的，所以 osi 参考模型的分层无法实现。\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 WebSocket 相关",frontmatter:{title:"🍏 WebSocket 相关",date:"2022-06-06T15:16:36.000Z",permalink:"/pages/47ce67/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/30.%20%F0%9F%8D%8F%20WebSocket%20%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/30. 🍏 WebSocket 相关.md",key:"v-e1f5ee38",path:"/pages/47ce67/",headers:[{level:2,title:"WebSocket 的概念",slug:"websocket-的概念",normalizedTitle:"websocket 的概念",charIndex:62},{level:2,title:"WebSocket 特点",slug:"websocket-特点",normalizedTitle:"websocket 特点",charIndex:340}],headersStr:"WebSocket 的概念 WebSocket 特点",content:"> 相关问题：\n> \n>  * 说说你对 WebSocket 的理解？\n>  * WebSocket 的应用场景？\n\n\n# WebSocket 的概念\n\nWebSocket 是一种 网络传输协议，位于 OSI 模型中的应用层。可以在单个 TCP 连接上进行全双工通信，更好地节省服务器资源和带宽并达到 实时通信的效果。\n\n客户端和服务器只需要完成一次握手，就可以创建持久性的连接，并且进行双向的数据传输。\n\n> WebSocket 出现之前，实现实时 Web 应用的方式是 轮询：不停地向服务器发送 HTTP 请求，询问有无数据，有数据服务器就用响应报文回应。如果轮询频率较高，近似实现「实时通信」的效果。缺点很明显，反复发送无效查询请求耗费大量的带宽和 CPU 资源。\n\n\n# WebSocket 特点",normalizedContent:"> 相关问题：\n> \n>  * 说说你对 websocket 的理解？\n>  * websocket 的应用场景？\n\n\n# websocket 的概念\n\nwebsocket 是一种 网络传输协议，位于 osi 模型中的应用层。可以在单个 tcp 连接上进行全双工通信，更好地节省服务器资源和带宽并达到 实时通信的效果。\n\n客户端和服务器只需要完成一次握手，就可以创建持久性的连接，并且进行双向的数据传输。\n\n> websocket 出现之前，实现实时 web 应用的方式是 轮询：不停地向服务器发送 http 请求，询问有无数据，有数据服务器就用响应报文回应。如果轮询频率较高，近似实现「实时通信」的效果。缺点很明显，反复发送无效查询请求耗费大量的带宽和 cpu 资源。\n\n\n# websocket 特点",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 输入 URL 回车后发生的事情",frontmatter:{title:"🍎 输入 URL 回车后发生的事情",date:"2022-06-06T18:46:09.000Z",permalink:"/pages/606924/",categories:["🪞冲刺","🏙 HTTP 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/05.%20%F0%9F%8F%99%20HTTP%20%E7%9B%B8%E5%85%B3/40.%20%F0%9F%8D%8E%20%E8%BE%93%E5%85%A5%20URL%20%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85.html",relativePath:"200. 🪞 前端面试题收集/05. 🏙 HTTP 相关/40. 🍎 输入 URL 回车后发生的事情.md",key:"v-3b17764e",path:"/pages/606924/",headers:[{level:2,title:"简单分析",slug:"简单分析",normalizedTitle:"简单分析",charIndex:49},{level:2,title:"完整分析",slug:"完整分析",normalizedTitle:"完整分析",charIndex:141},{level:3,title:"URL 解析",slug:"url-解析",normalizedTitle:"url 解析",charIndex:77},{level:3,title:"DNS 查询",slug:"dns-查询",normalizedTitle:"dns 查询",charIndex:88},{level:3,title:"TCP 连接 / 发送 HTTP 请求",slug:"tcp-连接-发送-http-请求",normalizedTitle:"tcp 连接 / 发送 http 请求",charIndex:354},{level:3,title:"响应请求",slug:"响应请求",normalizedTitle:"响应请求",charIndex:122},{level:3,title:"页面渲染",slug:"页面渲染",normalizedTitle:"页面渲染",charIndex:131}],headersStr:"简单分析 完整分析 URL 解析 DNS 查询 TCP 连接 / 发送 HTTP 请求 响应请求 页面渲染",content:"> 相关问题：\n> \n>  * 说说在浏览器中输入 URL 后敲下回车之后，发生的事情？\n\n\n# 简单分析\n\n输入 URL 到回车后发生的行为：\n\n * URL 解析；\n * DNS 查询；\n * TCP 连接；\n * HTTP 请求；\n * 响应请求；\n * 页面渲染。\n\n\n# 完整分析\n\n\n# URL 解析\n\n首先判断输入的是一个 ** 合法的 URL ** 还是 搜索关键次，根据输入的内容进行对应的操作。\n\n * 根据 URL 找到这个 URL 域名的服务器 IP；为了寻找这个 IP，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录顺序为：浏览器缓存、系统缓存、路由器缓存。\n\n\n# DNS 查询\n\n在缓存中没有查找到则查询 DNS 服务器，最终查找获得服务器的 IP 地址。\n\n\n# TCP 连接 / 发送 HTTP 请求\n\n浏览器根据这个 IP 地址以及相应的端口号，构造一个 HTTP 请求，这个请求报文会包括这次请求的信息：请求方法、请求说明、请求附带的数据，并将这个 HTTP 请求封装在一个 TCP 包中。\n\n这个 TCP 包会依次经过 传输层、网络层、数据链路层、物理层到达服务器，服务器解析这个请求来做出响应。\n\n\n# 响应请求\n\n服务器接收到浏览器的请求后，就会进行逻辑操作，处理完成之后返回一个 HTTP 响应消息：包括响应行、响应头、响应正文。\n\n服务器响应之后，由于现在 HTTP 默认开始长连接 Keep-alive ，当前页面关闭之后，TCP 连接会经过四次挥手完成断开。\n\n\n# 页面渲染\n\n浏览器接收到服务器响应的资源后，首先会对资源进行解析：\n\n * 响应头解析：根据不同的响应头参数做出对应的处理，例如重定向、存储 Cookie、解压 gzip、缓存资源等。\n * 查看响应头的 Content-Type ：根据不同的资源类型采用不同的解析方式。\n\n页面渲染的过程：\n\n * 解析 HTML 文档，构建 DOM 树；\n   \n   > 浏览器接收到来自服务器的 HTML 文档之后，会遍历文档节点，生成 DOM 树，解析 CSS 文件 生成 CSS 规则树。\n\n * 解析 CSS ，生成 CSS 规则树；\n\n * 合并 DOM 树和 CSS 树，生成 render 树；\n\n * 布局 render 树（layout /reflow），负责各元素尺寸、位置的计算；\n\n * 绘制 render 树（paint），绘制页面像素信息；\n\n * 浏览器将各层的信息发送给 GPU，GPU 将各层合成，显示在屏幕上。",normalizedContent:"> 相关问题：\n> \n>  * 说说在浏览器中输入 url 后敲下回车之后，发生的事情？\n\n\n# 简单分析\n\n输入 url 到回车后发生的行为：\n\n * url 解析；\n * dns 查询；\n * tcp 连接；\n * http 请求；\n * 响应请求；\n * 页面渲染。\n\n\n# 完整分析\n\n\n# url 解析\n\n首先判断输入的是一个 ** 合法的 url ** 还是 搜索关键次，根据输入的内容进行对应的操作。\n\n * 根据 url 找到这个 url 域名的服务器 ip；为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录顺序为：浏览器缓存、系统缓存、路由器缓存。\n\n\n# dns 查询\n\n在缓存中没有查找到则查询 dns 服务器，最终查找获得服务器的 ip 地址。\n\n\n# tcp 连接 / 发送 http 请求\n\n浏览器根据这个 ip 地址以及相应的端口号，构造一个 http 请求，这个请求报文会包括这次请求的信息：请求方法、请求说明、请求附带的数据，并将这个 http 请求封装在一个 tcp 包中。\n\n这个 tcp 包会依次经过 传输层、网络层、数据链路层、物理层到达服务器，服务器解析这个请求来做出响应。\n\n\n# 响应请求\n\n服务器接收到浏览器的请求后，就会进行逻辑操作，处理完成之后返回一个 http 响应消息：包括响应行、响应头、响应正文。\n\n服务器响应之后，由于现在 http 默认开始长连接 keep-alive ，当前页面关闭之后，tcp 连接会经过四次挥手完成断开。\n\n\n# 页面渲染\n\n浏览器接收到服务器响应的资源后，首先会对资源进行解析：\n\n * 响应头解析：根据不同的响应头参数做出对应的处理，例如重定向、存储 cookie、解压 gzip、缓存资源等。\n * 查看响应头的 content-type ：根据不同的资源类型采用不同的解析方式。\n\n页面渲染的过程：\n\n * 解析 html 文档，构建 dom 树；\n   \n   > 浏览器接收到来自服务器的 html 文档之后，会遍历文档节点，生成 dom 树，解析 css 文件 生成 css 规则树。\n\n * 解析 css ，生成 css 规则树；\n\n * 合并 dom 树和 css 树，生成 render 树；\n\n * 布局 render 树（layout /reflow），负责各元素尺寸、位置的计算；\n\n * 绘制 render 树（paint），绘制页面像素信息；\n\n * 浏览器将各层的信息发送给 gpu，gpu 将各层合成，显示在屏幕上。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 HTML 语义化标签理解",frontmatter:{title:"🍏 HTML 语义化标签理解",date:"2022-06-07T17:32:04.000Z",permalink:"/pages/34b808/",categories:["🪞冲刺","🌆 HTML 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/06.%20%F0%9F%8C%86%20HTML%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8F%20HTML%20%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3.html",relativePath:"200. 🪞 前端面试题收集/06. 🌆 HTML 相关/01. 🍏 HTML 语义化标签理解.md",key:"v-32e2c4a0",path:"/pages/34b808/",headersStr:null,content:"语义化标签指 正确的标签包含了正确的内容、结构良好、便于阅读。\n\n比如 nav 标签为 导航条； article header footer 。",normalizedContent:"语义化标签指 正确的标签包含了正确的内容、结构良好、便于阅读。\n\n比如 nav 标签为 导航条； article header footer 。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 实现响应式设计的相关",frontmatter:{title:"🍎 实现响应式设计的相关",date:"2022-06-28T11:24:27.000Z",permalink:"/pages/28d421/",categories:["🪞 前端面试题收集","🌆 HTML 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/06.%20%F0%9F%8C%86%20HTML%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/06. 🌆 HTML 相关/02. 🍎 实现响应式设计的相关.md",key:"v-a173582a",path:"/pages/28d421/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:66},{level:2,title:"实现方式",slug:"实现方式",normalizedTitle:"实现方式",charIndex:231},{level:3,title:"媒体查询",slug:"媒体查询",normalizedTitle:"媒体查询",charIndex:251},{level:3,title:"百分比 %",slug:"百分比",normalizedTitle:"百分比 %",charIndex:1066},{level:3,title:"vw & vh",slug:"vw-vh",normalizedTitle:"vw &amp; vh",charIndex:null},{level:3,title:"rem",slug:"rem",normalizedTitle:"rem",charIndex:627},{level:3,title:"利用 CSS UI 框架",slug:"利用-css-ui-框架",normalizedTitle:"利用 css ui 框架",charIndex:2445},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2528},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1645}],headersStr:"概念 实现方式 媒体查询 百分比 % vw & vh rem 利用 CSS UI 框架 总结 参考",content:"> 相关问题：\n> \n>  * 什么是响应式设计？\n>  * 响应式设计的基本原理？\n>  * 如何实现响应式网页的设计。\n\n\n# 概念\n\n响应式网页设计是一种网络页面设计布局。页面的设计与开发根据 用户的行为以及设备环境（系统平台、屏幕尺寸、屏幕方向等）进行相应的响应和调整。\n\n响应式网站设计的特点：\n\n * 同时适配 PC 端和移动端的设备；\n * 标签导航在 PC 端与移动端有响应的样式；\n * 网络的布局根据视口的大小调整模块的大小和位置；\n\n\n# 实现方式\n\n响应式网页设计的原理是 通过媒体查询检测不同设备的屏幕尺寸。\n\n所以为了适配移动端的设备，页面的头部必须有 meta 声明 viewport ：\n\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, user-scalble=no\"\n\n\n1\n\n\n> 对应的 content 属性有：\n> \n>  * width=device-width ：自适应设备的宽度；\n>  * initial-scale ：缩放比例的初始化大小；\n>  * maximum-scale ：缩放比例的最大大小；\n>  * user-scaleble=no ：是否允许用户调整页面的缩放比例；\n\n实现响应式布局的方式：\n\n * 媒体查询；\n * CSS 单位：百分比 / vw & vh / rem\n\n\n# 媒体查询\n\nCSS3 中添加了更多的媒体查询。像 if 条件表达式，可以设置不同类型的媒体条件，并且根据不同的媒体条件，给出响应符合的媒体调用的样式表。\n\n通过媒体查询可以给不同分辨率的设备编写不同的样式实现响应式的布局。还可以根据不同分辨率的设备分配大小不同的资源。为小屏幕手机设置 @2x 图，为大屏幕手机设置 @3x 图。\n\n🌰 例子：\n\n@media screen and (max-width: 1920px) { ... }\n\n\n1\n\n\n> 针对屏幕最大宽度为 1920px （意味着 1920px 宽度大小以内的屏幕） 的屏幕设置样式。\n\n@media screen (min-width: 375px) and (max-width: 600px) {\n  body {\n    font-size: 18px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 当视口的宽度在 375px 与 600px 之间，字体的大小为 18px 。\n\n\n# 百分比 %\n\n使用 CSS 单位中的百分比 % 单位实现响应式的效果。例如，当浏览器的宽度和高度随着浏览器的可视窗口生改变时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的可视窗口的变化发生变化，从而达到响应式的效果。\n\n但是要注意：\n\n * height / width 属性的百分比依托于（相对于）父元素标签，其他的元素则不依赖于父元素。\n * 对于定位属性：子元素的 top / left / right / bottom 如果设置百分比的单位数值，那么相对于直接非 static 定位的父元素的高度。\n * 对于 padding 内边距：不论是垂直方向还是水平方向，对相对于直接父元素的 width 宽度，而与父元素的 height 无关。\n * 对于 margin 外边距：不论是垂直方向还是水平方向，都相对于直接父元素的 width 宽度。\n * border-radius ：相对于自身的宽度。常用场景，画一个圆或者实现圆形头像框。\n\n> 可以看到如果每个属性都使用百分比，会有不同的「相对」规则，会形成复杂的布局，所以不建议使用百分比的单位实现响应式。\n\n\n# vw & vh\n\nvw 表示相对于视图窗口的宽度， vh 表示相对于视图窗口高度。 任意层级元素，在使用 vw 单位的情况下， 1vw 都等于视图宽度的百分之一。\n\n> 参考 vw / vh 与百分比单位的区别\n\n\n# rem\n\nrem 是相对于根元素的字体尺寸 font-size 属性的。\n\n🌰 例子 / 根据不同的设备分辨率改变字体的尺寸：\n\n@media screen and (max-width: 414px) {\n  html {\n    font-size: 18px\n  }\n}\n\n@media screen and (max-width: 375px) {\n  html {\n    font-size: 16px\n  }\n}\n\n\n@media screen and (max-width: 320px) {\n  html {\n    font-size: 12px\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / 为了更加准确监听可视窗口的大小的变化，加入 JavaScript 脚本调整字体尺寸：\n\n<script>\nfunction init() {\n  // 获取屏幕宽度\n  let width = document.documentElement.clientWidth\n  // 设置根元素的字体大小。设置为宽度的十等分\n  document.documentElement.style.fontSize = width / 10 + 'px'\n}\n\n// 首次加载页面时，运行一次\ninit()\n// 为屏幕的变化大小事件添加事件监听\nwindow.addEventListener('orientationonchange', init)\n// 监听手机窗口的变化\nwindow.addEventListener('resize', init)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 利用 CSS UI 框架\n\n主流的 CSS UI 框架，例如 Bootstrap、 ElementUI、TailwindCSS 都有提供栅格布局实现响应式。\n\n\n# 总结\n\n响应式的设计通常会从以下的方面思考：\n\n * 使用弹性盒子包裹元素（包括图片、表格、视频）和媒体查询技术；\n * 使用百分比布局创建流式布局的弹性 UI，同时使用媒体查询限制元素的尺寸和内容变更范围；\n * 使用相对单位使得内容自适应调整；\n * 选择断点，针对不同的断点实现不同布局和内容的展示。\n\n响应式布局的优点：\n\n * 面对不同的分辨率设备的灵活性强；\n * 能够快捷解决多设备显示的是配问题；\n\n响应式布局的缺点：\n\n * 仅适用于布局信息、框架并不复杂的部门类型网站；\n * 兼容各种设备的工作量大，效率低；\n * 代码累赘，会出现隐藏无用的元素，加载时间长。\n * 一方面改变了网站原有的布局。\n\n\n# 参考\n\n * 面试官：什么是响应式设计？响应式设计的基本原理是什么？如何做？ | web 前端面试 - 面试官系列 (vue3js.cn)\n\n * Responsive design - Learn web development | MDN (mozilla.org)",normalizedContent:"> 相关问题：\n> \n>  * 什么是响应式设计？\n>  * 响应式设计的基本原理？\n>  * 如何实现响应式网页的设计。\n\n\n# 概念\n\n响应式网页设计是一种网络页面设计布局。页面的设计与开发根据 用户的行为以及设备环境（系统平台、屏幕尺寸、屏幕方向等）进行相应的响应和调整。\n\n响应式网站设计的特点：\n\n * 同时适配 pc 端和移动端的设备；\n * 标签导航在 pc 端与移动端有响应的样式；\n * 网络的布局根据视口的大小调整模块的大小和位置；\n\n\n# 实现方式\n\n响应式网页设计的原理是 通过媒体查询检测不同设备的屏幕尺寸。\n\n所以为了适配移动端的设备，页面的头部必须有 meta 声明 viewport ：\n\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, user-scalble=no\"\n\n\n1\n\n\n> 对应的 content 属性有：\n> \n>  * width=device-width ：自适应设备的宽度；\n>  * initial-scale ：缩放比例的初始化大小；\n>  * maximum-scale ：缩放比例的最大大小；\n>  * user-scaleble=no ：是否允许用户调整页面的缩放比例；\n\n实现响应式布局的方式：\n\n * 媒体查询；\n * css 单位：百分比 / vw & vh / rem\n\n\n# 媒体查询\n\ncss3 中添加了更多的媒体查询。像 if 条件表达式，可以设置不同类型的媒体条件，并且根据不同的媒体条件，给出响应符合的媒体调用的样式表。\n\n通过媒体查询可以给不同分辨率的设备编写不同的样式实现响应式的布局。还可以根据不同分辨率的设备分配大小不同的资源。为小屏幕手机设置 @2x 图，为大屏幕手机设置 @3x 图。\n\n🌰 例子：\n\n@media screen and (max-width: 1920px) { ... }\n\n\n1\n\n\n> 针对屏幕最大宽度为 1920px （意味着 1920px 宽度大小以内的屏幕） 的屏幕设置样式。\n\n@media screen (min-width: 375px) and (max-width: 600px) {\n  body {\n    font-size: 18px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 当视口的宽度在 375px 与 600px 之间，字体的大小为 18px 。\n\n\n# 百分比 %\n\n使用 css 单位中的百分比 % 单位实现响应式的效果。例如，当浏览器的宽度和高度随着浏览器的可视窗口生改变时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的可视窗口的变化发生变化，从而达到响应式的效果。\n\n但是要注意：\n\n * height / width 属性的百分比依托于（相对于）父元素标签，其他的元素则不依赖于父元素。\n * 对于定位属性：子元素的 top / left / right / bottom 如果设置百分比的单位数值，那么相对于直接非 static 定位的父元素的高度。\n * 对于 padding 内边距：不论是垂直方向还是水平方向，对相对于直接父元素的 width 宽度，而与父元素的 height 无关。\n * 对于 margin 外边距：不论是垂直方向还是水平方向，都相对于直接父元素的 width 宽度。\n * border-radius ：相对于自身的宽度。常用场景，画一个圆或者实现圆形头像框。\n\n> 可以看到如果每个属性都使用百分比，会有不同的「相对」规则，会形成复杂的布局，所以不建议使用百分比的单位实现响应式。\n\n\n# vw & vh\n\nvw 表示相对于视图窗口的宽度， vh 表示相对于视图窗口高度。 任意层级元素，在使用 vw 单位的情况下， 1vw 都等于视图宽度的百分之一。\n\n> 参考 vw / vh 与百分比单位的区别\n\n\n# rem\n\nrem 是相对于根元素的字体尺寸 font-size 属性的。\n\n🌰 例子 / 根据不同的设备分辨率改变字体的尺寸：\n\n@media screen and (max-width: 414px) {\n  html {\n    font-size: 18px\n  }\n}\n\n@media screen and (max-width: 375px) {\n  html {\n    font-size: 16px\n  }\n}\n\n\n@media screen and (max-width: 320px) {\n  html {\n    font-size: 12px\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / 为了更加准确监听可视窗口的大小的变化，加入 javascript 脚本调整字体尺寸：\n\n<script>\nfunction init() {\n  // 获取屏幕宽度\n  let width = document.documentelement.clientwidth\n  // 设置根元素的字体大小。设置为宽度的十等分\n  document.documentelement.style.fontsize = width / 10 + 'px'\n}\n\n// 首次加载页面时，运行一次\ninit()\n// 为屏幕的变化大小事件添加事件监听\nwindow.addeventlistener('orientationonchange', init)\n// 监听手机窗口的变化\nwindow.addeventlistener('resize', init)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 利用 css ui 框架\n\n主流的 css ui 框架，例如 bootstrap、 elementui、tailwindcss 都有提供栅格布局实现响应式。\n\n\n# 总结\n\n响应式的设计通常会从以下的方面思考：\n\n * 使用弹性盒子包裹元素（包括图片、表格、视频）和媒体查询技术；\n * 使用百分比布局创建流式布局的弹性 ui，同时使用媒体查询限制元素的尺寸和内容变更范围；\n * 使用相对单位使得内容自适应调整；\n * 选择断点，针对不同的断点实现不同布局和内容的展示。\n\n响应式布局的优点：\n\n * 面对不同的分辨率设备的灵活性强；\n * 能够快捷解决多设备显示的是配问题；\n\n响应式布局的缺点：\n\n * 仅适用于布局信息、框架并不复杂的部门类型网站；\n * 兼容各种设备的工作量大，效率低；\n * 代码累赘，会出现隐藏无用的元素，加载时间长。\n * 一方面改变了网站原有的布局。\n\n\n# 参考\n\n * 面试官：什么是响应式设计？响应式设计的基本原理是什么？如何做？ | web 前端面试 - 面试官系列 (vue3js.cn)\n\n * responsive design - learn web development | mdn (mozilla.org)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 CSS 的盒子模型相关",frontmatter:{title:"🍎 CSS 的盒子模型相关",date:"2022-06-07T13:34:37.000Z",permalink:"/pages/efa419/",categories:["🪞冲刺","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20CSS%20%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%20.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/01. 🍎 CSS 的盒子模型相关 .md",key:"v-3b0ec81b",path:"/pages/efa419/",headers:[{level:2,title:"盒子模型的概念",slug:"盒子模型的概念",normalizedTitle:"盒子模型的概念",charIndex:22},{level:3,title:"标准盒子模型",slug:"标准盒子模型",normalizedTitle:"标准盒子模型",charIndex:94},{level:3,title:"怪异盒子模型",slug:"怪异盒子模型",normalizedTitle:"怪异盒子模型",charIndex:374},{level:2,title:"box-sizing",slug:"box-sizing",normalizedTitle:"box-sizing",charIndex:724}],headersStr:"盒子模型的概念 标准盒子模型 怪异盒子模型 box-sizing",content:">  * 说一下对盒子模型的理解？\n\n\n# 盒子模型的概念\n\n对 HTML 文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型 ，将所有元素表示为一个矩形盒子。\n\n标准盒子模型由四个部分组成：margins（外边距）、borders（边框）、paddings（内边距）、实际内容。\n\n\n\n * content：实际内容，（文本或者图像）；\n * padding：内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的 background 属性影响。\n * border：边框，围绕元素内容的内边距的一条或者多条线，由粗细、样式、颜色三部分组成。\n * margin：外边距，在元素外常见额外的空白。\n\nCSS 盒子模型可以分成，默认情况下是 W3C 标准盒子模型：\n\n * W3C 标准盒子模型；\n * IE 怪异盒子模型。\n\n\n# 标准盒子模型\n\n盒子总宽度 = 元素宽度 width + 内边距 padding（左右）+ border 边框宽度 （左右）+ 外边距 margin （左右）；\n\n盒子总高度 = 元素高度 height + 内边距 padding （上下）+ border 边框宽度（上下） + 外边距 margin（上下）；\n\n> 所以，最终的实际盒子宽度和高度不等于 内容元素的 宽度和高度\n\n\n# 怪异盒子模型\n\n与 W3C 标准盒子模型不同，这里 width /height 包含了 内边距 padding 和边框 border 的长度。\n\n盒子总宽度 = width + 外边距 margin（左右）；\n\n盒子总高度 = height + 外边距 margin （上下）；\n\n\n# box-sizing\n\n定义浏览器引擎如何计算一个元素的 总宽度和总高度：\n\n{\n  box-sizing: content-box | border-box | inherit;\n}\n\n\n1\n2\n3\n\n * content-box ：（默认值），表示元素的 width / height 不包含 padding 、 border ，即 W3C 的标准盒子模型；\n * border-box ：表示元素的 width / height 包含 padding 和 border ，即 怪异盒子模型。\n * inherit ：从父元素继承 box-sizing 的值。",normalizedContent:">  * 说一下对盒子模型的理解？\n\n\n# 盒子模型的概念\n\n对 html 文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 css 基础框盒模型 ，将所有元素表示为一个矩形盒子。\n\n标准盒子模型由四个部分组成：margins（外边距）、borders（边框）、paddings（内边距）、实际内容。\n\n\n\n * content：实际内容，（文本或者图像）；\n * padding：内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的 background 属性影响。\n * border：边框，围绕元素内容的内边距的一条或者多条线，由粗细、样式、颜色三部分组成。\n * margin：外边距，在元素外常见额外的空白。\n\ncss 盒子模型可以分成，默认情况下是 w3c 标准盒子模型：\n\n * w3c 标准盒子模型；\n * ie 怪异盒子模型。\n\n\n# 标准盒子模型\n\n盒子总宽度 = 元素宽度 width + 内边距 padding（左右）+ border 边框宽度 （左右）+ 外边距 margin （左右）；\n\n盒子总高度 = 元素高度 height + 内边距 padding （上下）+ border 边框宽度（上下） + 外边距 margin（上下）；\n\n> 所以，最终的实际盒子宽度和高度不等于 内容元素的 宽度和高度\n\n\n# 怪异盒子模型\n\n与 w3c 标准盒子模型不同，这里 width /height 包含了 内边距 padding 和边框 border 的长度。\n\n盒子总宽度 = width + 外边距 margin（左右）；\n\n盒子总高度 = height + 外边距 margin （上下）；\n\n\n# box-sizing\n\n定义浏览器引擎如何计算一个元素的 总宽度和总高度：\n\n{\n  box-sizing: content-box | border-box | inherit;\n}\n\n\n1\n2\n3\n\n * content-box ：（默认值），表示元素的 width / height 不包含 padding 、 border ，即 w3c 的标准盒子模型；\n * border-box ：表示元素的 width / height 包含 padding 和 border ，即 怪异盒子模型。\n * inherit ：从父元素继承 box-sizing 的值。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 CSS 的选择器相关",frontmatter:{title:"🍎 CSS 的选择器相关",date:"2022-06-07T13:48:55.000Z",permalink:"/pages/10ff5a/",categories:["🪞冲刺","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20CSS%20%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/02. 🍎 CSS 的选择器相关.md",key:"v-7c5ca52a",path:"/pages/10ff5a/",headers:[{level:2,title:"CSS 选择器概念",slug:"css-选择器概念",normalizedTitle:"css 选择器概念",charIndex:60},{level:2,title:"选择器的优先级",slug:"选择器的优先级",normalizedTitle:"选择器的优先级",charIndex:1477},{level:2,title:"继承属性",slug:"继承属性",normalizedTitle:"继承属性",charIndex:1956}],headersStr:"CSS 选择器概念 选择器的优先级 继承属性",content:'>  * CSS 的选择器有哪些？\n>  * CSS 的选择器优先级为？\n>  * CSS 哪些属性可以继承？\n\n\n# CSS 选择器概念\n\nCSS 选择器是 CSS 规则的一部分，是元素和其他部分组合起来告诉浏览器哪个元素应当被选为应用规则中的 CSS 属性值的方式。\n\n选择器选择的元素为选择器对象。\n\n🌰 例子 / 对照例子：\n\n<div id="box">\n  <div class="one">\n    <p class="one_1"></p>\n    <p class="one_2"></p>\n  \t<p class="one_3"></p>\n  </div>\n  <div class="two">\n    \n  </div>\n  <div class="three">\n    \n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n常用的选择器有：\n\n * id 选择器： #box ，选择 id 为 box 的元素；\n\n * class 选择器： .one ，选择类名为 one 的 所有元素；\n\n * 标签选择器： div ，选择标签为 div 的 所有元素；\n\n * 后代选择器： #box div ，选择 id 为 box 内部的所有 idv 元素；\n\n * 子代选择器： .one > one_1 ，选择父元素为 .one 的所有 .one_1 子元素；\n\n * 相邻同胞选择器： .one + .two ，选择紧跟在 .one 之后的所有 .two 元素；\n\n * 群组选择器： (div, p) ，选择 div 和 p 的所有元素。\n\n * 伪类选择器：\n   \n   * link ： 未访问的连接：\n   * :visied ：选择已经访问过的连接 。\n   * :active ：活动的连接；\n   * :hover ：鼠标指针在元素上浮动；\n   * :focus ：选择具有焦点的元素；\n   * :first-child ：父元素的第一个子元素；\n\n * 伪元素选择器：\n   \n   * :first-letter ：用于选取指定选择器的首字母；\n   \n   * :first-line ：用于选取选择器的首行内容；\n   \n   * :bofore ：在选择器被选元素的内容后面插入内容；\n   \n   * :afrer ：在选择器被选元素的内容后面插入内容。\n\n * 属性选择器：\n   \n   * [attribute] ：选择带有 attribute 属性的元素；\n   * [attribute=valu] ：选择所有使用 attribute=value 的元素；\n   * [attribute~=value] ：选择 attribute 属性包含 value 的元素；\n   * [attribute|=value] ：选择 attribute 属性以 value 开头的元素；\n   * [attribute*=value] ：选择 attribute 属性值包含 value 的所有元素。\n   * [attribute^=value] ：选择 attribute 属性值开头为 value 的所有元素。\n   * [attribute$=value] ：选择 attribute 属性值结尾为 value 的所有元素。\n\n * CSS 新增的选择器：\n   \n   * 层次选择器\n   * 伪类选择器\n   * 属性选择器\n\n\n# 选择器的优先级\n\n由高到低顺序为：\n\n * 内联；\n * ID 选择器；\n * 类选择器；\n * 标签选择器；\n\n根据权重计算得出优先级（上面的顺序分别由 A、B、C、D 对应）：\n\n * 如果存在内联样式，A = 1 否则 A = 0；\n * B 的值为 ID 选择器 出现的次数；\n * C 的值等于 类选择器和属性选择器 出现的次数；\n * D 的值等于 标签选择器和伪元素 出现的总次数；\n\n> 🌰 例子：\n> \n> #nav-gloabl > ul > li > a.nav-link\n> \n> \n> 1\n> \n>  * 没有内联样式， A = 0；\n>  * ID 选择器出现了 1 次，B = 1；\n>  * 类选择器出现了 1 次， C = 1；\n>  * 标签选择器出现 3 次， D = 3 ；\n> \n> 该 （A，B，C，D）对应为 （0，1，1，3）\n\n优先级计算后，比较规则：\n\n * 从左到右依次进行比较，较大者优先级更高；\n * 如果想等，往右移比较；\n * 4 为全部相等，则后面会覆盖前面的样式（按照先后顺序）。\n\n\n# 继承属性\n\n指的是 给父元素设置的元素，后代元素会自动拥有这些属性。\n\n继承属性分为：\n\n * 字体系列属性：\n   * font\n   * font-family\n   * font-weight\n   * font-size\n   * font-style\n   * font-variant\n * 文本系列属性：\n   * text-indent\n   * text-align\n   * line-height\n   * word-spacing\n   * letter-spacing\n   * text-transform\n   * direction\n   * color\n * 元素可见性：\n   * visibility\n * 表格布局属性：\n   * caption-style\n   * border-collapse\n   * border-spacing\n   * empty-cells\n   * table-content\n * 列表属性：\n   * list-style-type\n   * list-style-position\n   * list-style\n * 引用：\n   * quotos\n * 光标属性：\n   * cursor\n\n特殊的继承：\n\n * a 标签的字体颜色不能被继承；\n * h1 ~ h7 的字体大小不能被继承；\n\n无继承的属性：\n\n * display\n * 文本属性：\n   * vertical-align\n   * text-decoration\n * 盒子模型的属性：宽度、高度、内外边距、边框等；\n * 定位属性：浮动、清除浮动、定位等；\n * 生成内容属性： content 、 counter-reset 、 counter-increment 等；\n * 轮廓样式属性；\n * 页面样式属性；',normalizedContent:'>  * css 的选择器有哪些？\n>  * css 的选择器优先级为？\n>  * css 哪些属性可以继承？\n\n\n# css 选择器概念\n\ncss 选择器是 css 规则的一部分，是元素和其他部分组合起来告诉浏览器哪个元素应当被选为应用规则中的 css 属性值的方式。\n\n选择器选择的元素为选择器对象。\n\n🌰 例子 / 对照例子：\n\n<div id="box">\n  <div class="one">\n    <p class="one_1"></p>\n    <p class="one_2"></p>\n  \t<p class="one_3"></p>\n  </div>\n  <div class="two">\n    \n  </div>\n  <div class="three">\n    \n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n常用的选择器有：\n\n * id 选择器： #box ，选择 id 为 box 的元素；\n\n * class 选择器： .one ，选择类名为 one 的 所有元素；\n\n * 标签选择器： div ，选择标签为 div 的 所有元素；\n\n * 后代选择器： #box div ，选择 id 为 box 内部的所有 idv 元素；\n\n * 子代选择器： .one > one_1 ，选择父元素为 .one 的所有 .one_1 子元素；\n\n * 相邻同胞选择器： .one + .two ，选择紧跟在 .one 之后的所有 .two 元素；\n\n * 群组选择器： (div, p) ，选择 div 和 p 的所有元素。\n\n * 伪类选择器：\n   \n   * link ： 未访问的连接：\n   * :visied ：选择已经访问过的连接 。\n   * :active ：活动的连接；\n   * :hover ：鼠标指针在元素上浮动；\n   * :focus ：选择具有焦点的元素；\n   * :first-child ：父元素的第一个子元素；\n\n * 伪元素选择器：\n   \n   * :first-letter ：用于选取指定选择器的首字母；\n   \n   * :first-line ：用于选取选择器的首行内容；\n   \n   * :bofore ：在选择器被选元素的内容后面插入内容；\n   \n   * :afrer ：在选择器被选元素的内容后面插入内容。\n\n * 属性选择器：\n   \n   * [attribute] ：选择带有 attribute 属性的元素；\n   * [attribute=valu] ：选择所有使用 attribute=value 的元素；\n   * [attribute~=value] ：选择 attribute 属性包含 value 的元素；\n   * [attribute|=value] ：选择 attribute 属性以 value 开头的元素；\n   * [attribute*=value] ：选择 attribute 属性值包含 value 的所有元素。\n   * [attribute^=value] ：选择 attribute 属性值开头为 value 的所有元素。\n   * [attribute$=value] ：选择 attribute 属性值结尾为 value 的所有元素。\n\n * css 新增的选择器：\n   \n   * 层次选择器\n   * 伪类选择器\n   * 属性选择器\n\n\n# 选择器的优先级\n\n由高到低顺序为：\n\n * 内联；\n * id 选择器；\n * 类选择器；\n * 标签选择器；\n\n根据权重计算得出优先级（上面的顺序分别由 a、b、c、d 对应）：\n\n * 如果存在内联样式，a = 1 否则 a = 0；\n * b 的值为 id 选择器 出现的次数；\n * c 的值等于 类选择器和属性选择器 出现的次数；\n * d 的值等于 标签选择器和伪元素 出现的总次数；\n\n> 🌰 例子：\n> \n> #nav-gloabl > ul > li > a.nav-link\n> \n> \n> 1\n> \n>  * 没有内联样式， a = 0；\n>  * id 选择器出现了 1 次，b = 1；\n>  * 类选择器出现了 1 次， c = 1；\n>  * 标签选择器出现 3 次， d = 3 ；\n> \n> 该 （a，b，c，d）对应为 （0，1，1，3）\n\n优先级计算后，比较规则：\n\n * 从左到右依次进行比较，较大者优先级更高；\n * 如果想等，往右移比较；\n * 4 为全部相等，则后面会覆盖前面的样式（按照先后顺序）。\n\n\n# 继承属性\n\n指的是 给父元素设置的元素，后代元素会自动拥有这些属性。\n\n继承属性分为：\n\n * 字体系列属性：\n   * font\n   * font-family\n   * font-weight\n   * font-size\n   * font-style\n   * font-variant\n * 文本系列属性：\n   * text-indent\n   * text-align\n   * line-height\n   * word-spacing\n   * letter-spacing\n   * text-transform\n   * direction\n   * color\n * 元素可见性：\n   * visibility\n * 表格布局属性：\n   * caption-style\n   * border-collapse\n   * border-spacing\n   * empty-cells\n   * table-content\n * 列表属性：\n   * list-style-type\n   * list-style-position\n   * list-style\n * 引用：\n   * quotos\n * 光标属性：\n   * cursor\n\n特殊的继承：\n\n * a 标签的字体颜色不能被继承；\n * h1 ~ h7 的字体大小不能被继承；\n\n无继承的属性：\n\n * display\n * 文本属性：\n   * vertical-align\n   * text-decoration\n * 盒子模型的属性：宽度、高度、内外边距、边框等；\n * 定位属性：浮动、清除浮动、定位等；\n * 生成内容属性： content 、 counter-reset 、 counter-increment 等；\n * 轮廓样式属性；\n * 页面样式属性；',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 CSS 的计量单位相关",frontmatter:{title:"🍎 CSS 的计量单位相关",date:"2022-06-07T14:40:14.000Z",permalink:"/pages/5fc469/",categories:["🪞冲刺","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20CSS%20%E7%9A%84%E8%AE%A1%E9%87%8F%E5%8D%95%E4%BD%8D%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/03. 🍎 CSS 的计量单位相关.md",key:"v-1d3b852d",path:"/pages/5fc469/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2},{level:3,title:"px",slug:"px",normalizedTitle:"px",charIndex:56},{level:3,title:"em",slug:"em",normalizedTitle:"em",charIndex:77},{level:3,title:"rem",slug:"rem",normalizedTitle:"rem",charIndex:86},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:677}],headersStr:"概念 px em rem 参考",content:"# 概念\n\nCSS 规范中，长度单位可以分为两种，绝对单位和相对单位。\n\n * 绝对长度单位：cm、mm、in、px、pt、pc；\n\n * 相对长度单位：em、ex、ch、rem、vw、vh、vmin、vmax、%；\n\n五个常用的单位是 px / em / rem / vh & vw / vmin & vmax\n\n\n# px\n\npx 表示像素。一个 px 单位是屏幕上的一个像素点，每个像素点的大小都相同的，所以像素是绝对长度单位，px 的大小与元素的其他属性没有关系；\n\n\n# em\n\nem 是相对于 当前对象内文本的字体尺寸 font-size 的 相对长度单位。如果行内文本的字体尺寸没有设置，则相对于浏览器的默认字体尺寸 16px；\n\n特点：\n\n * em 值不是固定的；\n * em 会继承父级元素的字体大小；\n\n\n# rem\n\n相对单位，相对的是 HTML 根元素字体尺寸 font-szie 的值。\n\n特点：\n\n * 集合相对大小与绝对大小的优点于一身。\n * 与 em 不同的是 rem 总是相对于根元素，而不像 em 使用级联的方式计算尺寸。\n\nvh / vw\n\n根据相对于视口（viewport）的大小计算。\n\n> 例如， 50 vh 为视口的一般高度； 50 vw 为视口的一般宽度；\n\n> 与 vh & vw 容易混淆的是单位是 % ，在 % 号中，有以下情况：\n> \n>  * 对于 position: absolute ，相对的是已经定位的父元素。\n>  * 对于 position: fixed ，相对的是视口。\n\n\n# 参考\n\n * 🥽 CSS 单位 | notebook (simon1uo.github.io) 相关的例子。",normalizedContent:"# 概念\n\ncss 规范中，长度单位可以分为两种，绝对单位和相对单位。\n\n * 绝对长度单位：cm、mm、in、px、pt、pc；\n\n * 相对长度单位：em、ex、ch、rem、vw、vh、vmin、vmax、%；\n\n五个常用的单位是 px / em / rem / vh & vw / vmin & vmax\n\n\n# px\n\npx 表示像素。一个 px 单位是屏幕上的一个像素点，每个像素点的大小都相同的，所以像素是绝对长度单位，px 的大小与元素的其他属性没有关系；\n\n\n# em\n\nem 是相对于 当前对象内文本的字体尺寸 font-size 的 相对长度单位。如果行内文本的字体尺寸没有设置，则相对于浏览器的默认字体尺寸 16px；\n\n特点：\n\n * em 值不是固定的；\n * em 会继承父级元素的字体大小；\n\n\n# rem\n\n相对单位，相对的是 html 根元素字体尺寸 font-szie 的值。\n\n特点：\n\n * 集合相对大小与绝对大小的优点于一身。\n * 与 em 不同的是 rem 总是相对于根元素，而不像 em 使用级联的方式计算尺寸。\n\nvh / vw\n\n根据相对于视口（viewport）的大小计算。\n\n> 例如， 50 vh 为视口的一般高度； 50 vw 为视口的一般宽度；\n\n> 与 vh & vw 容易混淆的是单位是 % ，在 % 号中，有以下情况：\n> \n>  * 对于 position: absolute ，相对的是已经定位的父元素。\n>  * 对于 position: fixed ，相对的是视口。\n\n\n# 参考\n\n * 🥽 css 单位 | notebook (simon1uo.github.io) 相关的例子。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 CSS 实现隐藏元素",frontmatter:{title:"🍏 CSS 实现隐藏元素",date:"2022-06-07T17:16:47.000Z",permalink:"/pages/9ca940/",categories:["🪞冲刺","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/04.%20%F0%9F%8D%8F%20CSS%20%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/04. 🍏 CSS 实现隐藏元素.md",key:"v-23710361",path:"/pages/9ca940/",headers:[{level:2,title:"实现方式",slug:"实现方式",normalizedTitle:"实现方式",charIndex:46},{level:3,title:"display:none",slug:"display-none",normalizedTitle:"display:none",charIndex:64},{level:3,title:"visibility:hidden",slug:"visibility-hidden",normalizedTitle:"visibility:hidden",charIndex:154},{level:3,title:"opacity:0",slug:"opacity-0",normalizedTitle:"opacity:0",charIndex:232},{level:3,title:"position:absolute",slug:"position-absolute",normalizedTitle:"position:absolute",charIndex:447},{level:3,title:"clip-path",slug:"clip-path",normalizedTitle:"clip-path",charIndex:581},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:787}],headersStr:"实现方式 display:none visibility:hidden opacity:0 position:absolute clip-path 参考",content:"> 相关问题：\n> \n>  * 在 CSS 中，有哪些方式可以实现隐藏页面的元素。\n\n\n# 实现方式\n\n有如下的方法：\n\n\n# display:none\n\n将元素的 display 属性设置为 none 。元素会在页面上彻底消失，不占用任何的空间（会导致浏览器重新排版渲染页面），无法响应点击事件。\n\n\n# visibility:hidden\n\n页面上隐藏元素（不会引发重排，但是会引发重绘），DOM 结果均会存在，会占用页面空间，但是无法响应点击事件。\n\n\n# opacity:0\n\n将元素的透明度设置为 0 （不会引发重排，但是会引发重绘），元素修改为不可见，会占用页面空间，可以响应点击事件。\n\n设置盒子模型属性\n\n不占据页面空间，无法响应点击事件。\n\n🌰 例子：\n\n.hidden {\n\twidth: 0;\n\theight: 0;\n\tpadding: 0;\n\tborder: 0;\n\tmargin: 0;\n\toverflow: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# position:absolute\n\n将元素移出可视区域，元素不可见，不影响页面布局。\n\n🌰 例子：\n\n.hidden {\n\tposition: absolute;\n\ttop: -9999px;\n\tleft: -9999px;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# clip-path\n\n通过裁剪的形式，元素不可见，占据页面空间，无法响应点击事件。\n\n🌰 例子：\n\n.hidden {\n\tclip-path: polygon(0px 0px, 0px 0px, 0px 0px, 0px 0px);\n}\n\n\n1\n2\n3\n\n\n总结：最常用的是 display: none 和 visibility: hidden 。其他元素只是巧妙地将元素隐藏，真正用途并非隐藏元素。\n\n\n# 参考\n\n * 面试官：css 中，有哪些方式可以隐藏页面元素？区别？| web 前端面试 - 面试官系列 (vue3js.cn)",normalizedContent:"> 相关问题：\n> \n>  * 在 css 中，有哪些方式可以实现隐藏页面的元素。\n\n\n# 实现方式\n\n有如下的方法：\n\n\n# display:none\n\n将元素的 display 属性设置为 none 。元素会在页面上彻底消失，不占用任何的空间（会导致浏览器重新排版渲染页面），无法响应点击事件。\n\n\n# visibility:hidden\n\n页面上隐藏元素（不会引发重排，但是会引发重绘），dom 结果均会存在，会占用页面空间，但是无法响应点击事件。\n\n\n# opacity:0\n\n将元素的透明度设置为 0 （不会引发重排，但是会引发重绘），元素修改为不可见，会占用页面空间，可以响应点击事件。\n\n设置盒子模型属性\n\n不占据页面空间，无法响应点击事件。\n\n🌰 例子：\n\n.hidden {\n\twidth: 0;\n\theight: 0;\n\tpadding: 0;\n\tborder: 0;\n\tmargin: 0;\n\toverflow: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# position:absolute\n\n将元素移出可视区域，元素不可见，不影响页面布局。\n\n🌰 例子：\n\n.hidden {\n\tposition: absolute;\n\ttop: -9999px;\n\tleft: -9999px;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# clip-path\n\n通过裁剪的形式，元素不可见，占据页面空间，无法响应点击事件。\n\n🌰 例子：\n\n.hidden {\n\tclip-path: polygon(0px 0px, 0px 0px, 0px 0px, 0px 0px);\n}\n\n\n1\n2\n3\n\n\n总结：最常用的是 display: none 和 visibility: hidden 。其他元素只是巧妙地将元素隐藏，真正用途并非隐藏元素。\n\n\n# 参考\n\n * 面试官：css 中，有哪些方式可以隐藏页面元素？区别？| web 前端面试 - 面试官系列 (vue3js.cn)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 CSS 实现元素居中",frontmatter:{title:"🍏 CSS 实现元素居中",date:"2022-06-27T23:37:01.000Z",permalink:"/pages/46067c/",categories:["🪞 前端面试题收集","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/05.%20%F0%9F%8D%8F%20CSS%20%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/05. 🍏 CSS 实现元素居中.md",key:"v-769e6dac",path:"/pages/46067c/",headers:[{level:2,title:"居中的几种方法",slug:"居中的几种方法",normalizedTitle:"居中的几种方法",charIndex:34},{level:3,title:"定位 + margin: auto",slug:"定位-margin-auto",normalizedTitle:"定位 + margin: auto",charIndex:46},{level:3,title:"定位 + margin: -value",slug:"定位-margin-value",normalizedTitle:"定位 + margin: -value",charIndex:287},{level:3,title:"定位 + transform",slug:"定位-transform",normalizedTitle:"定位 + transform",charIndex:532},{level:3,title:"table 布局",slug:"table-布局",normalizedTitle:"table 布局",charIndex:745},{level:3,title:"flex 布局",slug:"flex-布局",normalizedTitle:"flex 布局",charIndex:991},{level:3,title:"grid 布局",slug:"grid-布局",normalizedTitle:"grid 布局",charIndex:767}],headersStr:"居中的几种方法 定位 + margin: auto 定位 + margin: -value 定位 + transform table 布局 flex 布局 grid 布局",content:"> 相关问题：\n> \n>  * 实现元素居中的方式有哪些？\n\n\n# 居中的几种方法\n\n\n# 定位 + margin: auto\n\n🌰 例子：\n\nSee the Pen Untitled by simon1uo (@simon1uo) on CodePen.\n\n> 这里的父元素设置为相对定位，子元素设置为绝对定位，并且四个定位属性都设置为 0 。如果子元素没有设置宽高，则宽高会等于父元素。\n> \n> 如果子元素设置了宽高，那么显示为设置的宽高大小，但是实际上虚拟的子元素已经撑满了整个父元素，此时再设置 margin 为 auto 则可以实现水平和垂直居中了。\n\n\n# 定位 + margin: -value\n\n🌰 例子\n\nSee the Pen css-center-1 by simon1uo (@simon1uo) on CodePen.\n\n> 首先，子元素没有设置绝对定位时，会在父元素的左上角位置。当设置了 left / top 的偏移都为 50% ，此时子元素会在右下角的位置。此时再设置 margin-left / margin-top 的值为子元素的宽高的一半，将偏移的中心修改为元素的中点。此时即可以实现元素的水平居中和垂直居中。\n\n\n# 定位 + transform\n\n🌰 例子：\n\nSee the Pen css-center-2 by simon1uo (@simon1uo) on CodePen.\n\n> 与上面使用 margin-left / margin-top 的负值方法同理。 transform 的位移是相对于自己的，所以这里 -50% 是相对于自己的宽高计算，并且这里不需要知道自己元素的宽高，使用的场景比 margin 的负值广泛。\n\n\n# table 布局\n\n> 由于 flex 和 grid 布局的出现，较少使用 table 布局。\n\n🌰 例子：\n\nSee the Pen css-center-3 by simon1uo (@simon1uo) on CodePen.\n\n> 利用表格的 text-align 和 vertical-align 实现，这两个属性可以使行内元素水平垂直居中。注意 vertical-align 的居中属性值为 middle 。并且要将子元素设置为 inline-block 行内块元素。\n\n\n# flex 布局\n\n🌰 例子：\n\nSee the Pen css-center-4 by simon1uo (@simon1uo) on CodePen.\n\n\n# grid 布局\n\n🌰 例子：\n\nSee the Pen css-center-6-grid by simon1uo (@simon1uo) on CodePen.",normalizedContent:"> 相关问题：\n> \n>  * 实现元素居中的方式有哪些？\n\n\n# 居中的几种方法\n\n\n# 定位 + margin: auto\n\n🌰 例子：\n\nsee the pen untitled by simon1uo (@simon1uo) on codepen.\n\n> 这里的父元素设置为相对定位，子元素设置为绝对定位，并且四个定位属性都设置为 0 。如果子元素没有设置宽高，则宽高会等于父元素。\n> \n> 如果子元素设置了宽高，那么显示为设置的宽高大小，但是实际上虚拟的子元素已经撑满了整个父元素，此时再设置 margin 为 auto 则可以实现水平和垂直居中了。\n\n\n# 定位 + margin: -value\n\n🌰 例子\n\nsee the pen css-center-1 by simon1uo (@simon1uo) on codepen.\n\n> 首先，子元素没有设置绝对定位时，会在父元素的左上角位置。当设置了 left / top 的偏移都为 50% ，此时子元素会在右下角的位置。此时再设置 margin-left / margin-top 的值为子元素的宽高的一半，将偏移的中心修改为元素的中点。此时即可以实现元素的水平居中和垂直居中。\n\n\n# 定位 + transform\n\n🌰 例子：\n\nsee the pen css-center-2 by simon1uo (@simon1uo) on codepen.\n\n> 与上面使用 margin-left / margin-top 的负值方法同理。 transform 的位移是相对于自己的，所以这里 -50% 是相对于自己的宽高计算，并且这里不需要知道自己元素的宽高，使用的场景比 margin 的负值广泛。\n\n\n# table 布局\n\n> 由于 flex 和 grid 布局的出现，较少使用 table 布局。\n\n🌰 例子：\n\nsee the pen css-center-3 by simon1uo (@simon1uo) on codepen.\n\n> 利用表格的 text-align 和 vertical-align 实现，这两个属性可以使行内元素水平垂直居中。注意 vertical-align 的居中属性值为 middle 。并且要将子元素设置为 inline-block 行内块元素。\n\n\n# flex 布局\n\n🌰 例子：\n\nsee the pen css-center-4 by simon1uo (@simon1uo) on codepen.\n\n\n# grid 布局\n\n🌰 例子：\n\nsee the pen css-center-6-grid by simon1uo (@simon1uo) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 CSS BFC 相关",frontmatter:{title:"🍎 CSS BFC 相关",date:"2022-06-27T23:38:02.000Z",permalink:"/pages/0cd1d6/",categories:["🪞 前端面试题收集","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/06.%20%F0%9F%8D%8E%20CSS%20BFC%20%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/06. 🍎 CSS BFC 相关.md",key:"v-215e8422",path:"/pages/0cd1d6/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2},{level:3,title:"触发 BFC 的条件",slug:"触发-bfc-的条件",normalizedTitle:"触发 bfc 的条件",charIndex:356},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:577}],headersStr:"概念 触发 BFC 的条件 参考",content:"# 概念\n\n> 引子：当在页面布局的时候，常常可能出现 元素的高度小时；两栏布局没法自适应；两个元素的间距\n\nBFC （Block Formatting Context） ，块级格式化上下文，是页面中的一块渲染区域，并且有一套属于自己的渲染规则。规则如下：\n\n * 内部的盒子会在垂直方向上一个接一个放置；\n * 对于同一个 BFC 中的两个相邻的盒子的 margin 外边距会重叠，与方向无关。\n * 每个元素的左外边距与包含块的左边界相接触（从左到右），对于浮动元素也是如此。\n * BFC 的区域不会与 float 元素的区域重叠；\n * 计算 BFC 的高度时，浮动子元素也会参与计算；\n\n使用 BFC 的目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素。（反之依然）\n\n\n# 触发 BFC 的条件\n\n * 根元素 （ html 元素）；\n * 浮动的元素： float 的值为 left | right ；\n * overflow 的值为 auto | scroll | hidden 。不为 visible | clip ；\n * display 的值为 ～ （设置为 inline-block | flex 等）不为 flow-groot\n * position 的值为 absolute | fixed\n\n\n# 参考\n\n * 🪁 CSS 浮动 | notebook (simon1uo.github.io)\n\n * 块格式化上下文 - Web 开发者指南 | MDN (mozilla.org)",normalizedContent:"# 概念\n\n> 引子：当在页面布局的时候，常常可能出现 元素的高度小时；两栏布局没法自适应；两个元素的间距\n\nbfc （block formatting context） ，块级格式化上下文，是页面中的一块渲染区域，并且有一套属于自己的渲染规则。规则如下：\n\n * 内部的盒子会在垂直方向上一个接一个放置；\n * 对于同一个 bfc 中的两个相邻的盒子的 margin 外边距会重叠，与方向无关。\n * 每个元素的左外边距与包含块的左边界相接触（从左到右），对于浮动元素也是如此。\n * bfc 的区域不会与 float 元素的区域重叠；\n * 计算 bfc 的高度时，浮动子元素也会参与计算；\n\n使用 bfc 的目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素。（反之依然）\n\n\n# 触发 bfc 的条件\n\n * 根元素 （ html 元素）；\n * 浮动的元素： float 的值为 left | right ；\n * overflow 的值为 auto | scroll | hidden 。不为 visible | clip ；\n * display 的值为 ～ （设置为 inline-block | flex 等）不为 flow-groot\n * position 的值为 absolute | fixed\n\n\n# 参考\n\n * 🪁 css 浮动 | notebook (simon1uo.github.io)\n\n * 块格式化上下文 - web 开发者指南 | mdn (mozilla.org)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 CSS 弹性盒布局相关",frontmatter:{title:"🍎 CSS 弹性盒布局相关",date:"2022-06-28T11:14:45.000Z",permalink:"/pages/d79434/",categories:["🪞 前端面试题收集","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8E%20CSS%20%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/10. 🍎 CSS 弹性盒布局相关.md",key:"v-173573e4",path:"/pages/d79434/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:35},{level:2,title:"详细",slug:"详细",normalizedTitle:"详细",charIndex:234},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:288}],headersStr:"概念 详细 参考",content:"> 相关问题：\n> \n>  * 对 CSS 弹性布局的理解？\n\n\n# 概念\n\n弹性布局（Flexible Box， flex ）可以帮助我们简单、完整、响应式的实现各种页面的布局。\n\n采用 flex 布局的元素，称为 flex 容器（container）。容器中所有的子元素会自动称为容器的成员，称为 flex 项目（item）。\n\n容器中默认存在两条轴，主轴和交叉轴，呈九十度关系。项目默认沿着主轴排列。通过 flex-direction 决定主轴的方向。\n\n\n# 详细\n\n🗃 CSS 弹性盒子模型 | notebook (simon1uo.github.io)\n\n\n# 参考\n\n * flex - CSS（层叠样式表） | MDN (mozilla.org)",normalizedContent:"> 相关问题：\n> \n>  * 对 css 弹性布局的理解？\n\n\n# 概念\n\n弹性布局（flexible box， flex ）可以帮助我们简单、完整、响应式的实现各种页面的布局。\n\n采用 flex 布局的元素，称为 flex 容器（container）。容器中所有的子元素会自动称为容器的成员，称为 flex 项目（item）。\n\n容器中默认存在两条轴，主轴和交叉轴，呈九十度关系。项目默认沿着主轴排列。通过 flex-direction 决定主轴的方向。\n\n\n# 详细\n\n🗃 css 弹性盒子模型 | notebook (simon1uo.github.io)\n\n\n# 参考\n\n * flex - css（层叠样式表） | mdn (mozilla.org)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 CSS 预编语言相关",frontmatter:{title:"🍎 CSS 预编语言相关",date:"2022-07-03T15:17:30.000Z",permalink:"/pages/babf64/",categories:["🪞 前端面试题收集","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/101.%20%F0%9F%8D%8E%20CSS%20%E9%A2%84%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/101. 🍎 CSS 预编语言相关.md",key:"v-c577cb28",path:"/pages/babf64/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:45},{level:3,title:"预处理语言",slug:"预处理语言",normalizedTitle:"预处理语言",charIndex:170},{level:3,title:"种类",slug:"种类",normalizedTitle:"种类",charIndex:290},{level:3,title:"常用特性",slug:"常用特性",normalizedTitle:"常用特性",charIndex:343}],headersStr:"概念 预处理语言 种类 常用特性",content:"> 相关问题：\n> \n>  * CSS 的预处理器\n>  * CSS 的预编语言\n\n\n# 概念\n\nCSS 是一门标记性语言，语法相对简单。但也存在也写问题，需要输血大量看似没有逻辑的代码，不方便维护以及拓展，不利于复用，尤其对于非前端的开发工程师，往往会因为缺少 CSS 的编写经验而难以写出组织良好并且易于维护的 CSS 代码。\n\n\n# 预处理语言\n\n这些语言拓展了 CSS 的概念，增加了 变量、混合、函数，让 CSS 代码更加易于维护、方便阅读。\n\n包含一套自定义的语法以及解析器，根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成 CSS 代码。\n\n\n# 种类\n\n常见的 CSS 预编处理器有以下：\n\n * sass\n * less\n * stylus\n\n\n# 常用特性\n\n预编处理器常用的特性有以下；\n\n * 变量 Variables\n * 作用域 Scope\n * 代码混合 mixins\n * 嵌套 nested rules\n * 代码模块化 modules",normalizedContent:"> 相关问题：\n> \n>  * css 的预处理器\n>  * css 的预编语言\n\n\n# 概念\n\ncss 是一门标记性语言，语法相对简单。但也存在也写问题，需要输血大量看似没有逻辑的代码，不方便维护以及拓展，不利于复用，尤其对于非前端的开发工程师，往往会因为缺少 css 的编写经验而难以写出组织良好并且易于维护的 css 代码。\n\n\n# 预处理语言\n\n这些语言拓展了 css 的概念，增加了 变量、混合、函数，让 css 代码更加易于维护、方便阅读。\n\n包含一套自定义的语法以及解析器，根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成 css 代码。\n\n\n# 种类\n\n常见的 css 预编处理器有以下：\n\n * sass\n * less\n * stylus\n\n\n# 常用特性\n\n预编处理器常用的特性有以下；\n\n * 变量 variables\n * 作用域 scope\n * 代码混合 mixins\n * 嵌套 nested rules\n * 代码模块化 modules",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 CSS 网格布局相关",frontmatter:{title:"🍎 CSS 网格布局相关",date:"2022-06-28T11:15:12.000Z",permalink:"/pages/574676/",categories:["🪞 前端面试题收集","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/11.%20%F0%9F%8D%8E%20CSS%20%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/11. 🍎 CSS 网格布局相关.md",key:"v-5d4c33ae",path:"/pages/574676/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:39}],headersStr:"概念",content:"> 相关问题：\n> \n>  * 说一下对 Grid 网格布局的理解？\n\n\n# 概念\n\nGrid 网格布局是一种二维的布局方式，由纵横交错的两组网格形成的框架性布局结构，能够同时处理行与列；\n\n可以将一个页面划分为几个主要的区域，以及定义这些区域的大小、位置、层次等关系。\n\n与 Flex 弹性布局不同，设置为 display: grid | inline-grid 的元素为网格布局容器。\n\n流行的 CSS 框架 Bootstrap 中的栅格布局：🅱️ Bootstrap 使用笔记 | notebook (simon1uo.github.io)",normalizedContent:"> 相关问题：\n> \n>  * 说一下对 grid 网格布局的理解？\n\n\n# 概念\n\ngrid 网格布局是一种二维的布局方式，由纵横交错的两组网格形成的框架性布局结构，能够同时处理行与列；\n\n可以将一个页面划分为几个主要的区域，以及定义这些区域的大小、位置、层次等关系。\n\n与 flex 弹性布局不同，设置为 display: grid | inline-grid 的元素为网格布局容器。\n\n流行的 css 框架 bootstrap 中的栅格布局：🅱️ bootstrap 使用笔记 | notebook (simon1uo.github.io)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 CSS 性能优化相关",frontmatter:{title:"🍏 CSS 性能优化相关",date:"2022-06-29T14:38:08.000Z",permalink:"/pages/928d4e/",categories:["🪞 前端面试题收集","🏞 CSS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/07.%20%F0%9F%8F%9E%20CSS%20%E7%9B%B8%E5%85%B3/90.%20%F0%9F%8D%8F%20CSS%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/07. 🏞 CSS 相关/90. 🍏 CSS 性能优化相关.md",key:"v-c211ae4e",path:"/pages/928d4e/",headers:[{level:2,title:"实现方式",slug:"实现方式",normalizedTitle:"实现方式",charIndex:34},{level:3,title:"内联首屏关键 CSS / Critical CSS",slug:"内联首屏关键-css-critical-css",normalizedTitle:"内联首屏关键 css / critical css",charIndex:131},{level:3,title:"异步加载 CSS",slug:"异步加载-css",normalizedTitle:"异步加载 css",charIndex:70},{level:3,title:"资源压缩",slug:"资源压缩",normalizedTitle:"资源压缩",charIndex:82},{level:3,title:"合理使用 CSS 选择器",slug:"合理使用-css-选择器",normalizedTitle:"合理使用 css 选择器",charIndex:1317},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:3,title:"减少使用昂贵的属性",slug:"减少使用昂贵的属性",normalizedTitle:"减少使用昂贵的属性",charIndex:101},{level:3,title:"不要使用 @import",slug:"不要使用-import",normalizedTitle:"不要使用 @import",charIndex:114},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1988},{level:3,title:"",slug:"-2",normalizedTitle:"",charIndex:0},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2107}],headersStr:"实现方式 内联首屏关键 CSS / Critical CSS 异步加载 CSS 资源压缩 合理使用 CSS 选择器  减少使用昂贵的属性 不要使用 @import 其他  参考",content:'> 相关问题：\n> \n>  * 如果提高 CSS 的性能？\n\n\n# 实现方式\n\n主要有以下的方面入手：\n\n * 内联首屏关键 CSS\n * 异步加载 CSS\n * 资源压缩\n * 合理使用选择器\n * 减少使用昂贵的属性\n * 不要使用 @import\n\n\n# 内联首屏关键 CSS / Critical CSS\n\n打开一个页面，页面的首要内容出现在屏幕的事件影响着用户的体验。而通过内联 CSS 关键代码能够使得浏览器在下载完 HTML 之后立刻渲染。\n\n而如果外部引用 CSS 代码，只有在在解析 HTML 结构的过程中遇到了外部 CSS 文件，才会开始下载 CSS 代码，再进行渲染。\n\n所以，内联使用 CSS 样式可以使渲染时间提前。\n\n但是，较大的 CSS 代码不适合内联（会造成初始拥塞窗口、没有缓存），而其余的代码采取外部引用的方式。\n\n\n# 异步加载 CSS\n\nCSS 文件请求、下载、解析完成之前，CSS 会造成阻塞渲染，浏览器将不会渲染任何已处理的内容。\n\n在加载内联 CSS 代码后，后面的外部引用 CSS 没必要阻塞浏览器渲染。这时可以采取异步加载的方案，主要有以下：\n\n * 使用 JavaScript 将 link 标签插入到 head 标签的最后：\n   \n   const myCSS = document.createElement("link")\n   myCSS.rel = "stylesheet"\n   myCSS.href = "mystyles.css"\n   document.head.insertBefore(myCss, docuemnt.head.childNodes[document.head.childNodes.length - 1].nextSibiling)\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 设置 link 标签的 media 属性为 noexist ，浏览器会认为当前样式表不使用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完毕之后，将 media 的值设置为 screen 或者 all ，从而让浏览器开始解析 CSS。\n   \n   <link rel="stylesheet" href="mystyle.css" media=noexist` onload="this.media=\'all\'">\n   \n   \n   1\n   \n\n * 通过 rel 属性将 link 元素标记为 alternate 可选样式表，也能实现浏览器的异步加载。在加载完成之后， rel 设置回为 stylesheet ：\n   \n   <link rel="alternate stylesheet" href="mystyles.css" onload="this.rel=\'stylesheet\'">\n   \n   \n   1\n   \n\n\n# 资源压缩\n\n利用 webpack 、 gulp / grunt 、 rollup 等模块化工具，可以将 CSS 的代码进行压缩，使得文件变小，大大降低浏览器的加载时间。\n\n\n# 合理使用 CSS 选择器\n\nCSS 的匹配规则是 从右向左 开始匹配。\n\n🌰 例子 / 例如 #markdown .content h3 匹配的规则如下：\n\n * 先找到 h3 标签的元素；\n * 然后去除祖先不是 .content 类的元素；\n * 最后取出祖先不是 #markdown 的元素；\n\n如果嵌套的层级更多，页面中的元素更多，那么匹配所要话费的时间代价更高。所以在编写选择器时，应该遵循以下规则：\n\n * 不要嵌套使用过多复杂的选择器，最好不要三层以上；\n * 使用 id 选择器就没有必要再进行嵌套；\n * 通配符 * 和属性选择器效率最低，避免使用；\n\n\n#\n\n\n# 减少使用昂贵的属性\n\n页面发生重绘的时候，昂贵属性例如 box-shadow / border-radius / filter / transparent / :nth-child 等属性，会降低 浏览器的渲染性能。\n\n\n# 不要使用 @import\n\nCSS 样式文件有两种引入的方式，一种是 link 元素，另一种是 @import 。 @import 会影响浏览器的并行下载，使得页面在加载的时候增加额外的延迟，增添额外的往返耗时。\n\n并且多个 @import 可能会导致下载顺序紊乱。\n\n🌰 例子：如果一个 CSS 文件 index.css 中包含了以下的导入内容： @import url("reset.css") ，那么浏览器就必须先把 index.css 下载、解析和执行后，才下载、解析和执行第二个文件 reset.css 。\n\n\n# 其他\n\n * 减少重排的操作，以及减少不必要的重绘；\n * 了解哪些属性可以继承而来，避免对这些属性重复编写；\n * 动画或者过渡尽量使用 transform 和 opacity ，避免使用 left 和 top 属性。\n\n\n#\n\n\n# 参考\n\n * 面试官：如果要做优化，CSS 提高性能的方法有哪些？ | web 前端面试 - 面试官系列 (vue3js.cn)\n * 🌟 CSS 性能优化的 8 个技巧 - 掘金 (juejin.cn)',normalizedContent:'> 相关问题：\n> \n>  * 如果提高 css 的性能？\n\n\n# 实现方式\n\n主要有以下的方面入手：\n\n * 内联首屏关键 css\n * 异步加载 css\n * 资源压缩\n * 合理使用选择器\n * 减少使用昂贵的属性\n * 不要使用 @import\n\n\n# 内联首屏关键 css / critical css\n\n打开一个页面，页面的首要内容出现在屏幕的事件影响着用户的体验。而通过内联 css 关键代码能够使得浏览器在下载完 html 之后立刻渲染。\n\n而如果外部引用 css 代码，只有在在解析 html 结构的过程中遇到了外部 css 文件，才会开始下载 css 代码，再进行渲染。\n\n所以，内联使用 css 样式可以使渲染时间提前。\n\n但是，较大的 css 代码不适合内联（会造成初始拥塞窗口、没有缓存），而其余的代码采取外部引用的方式。\n\n\n# 异步加载 css\n\ncss 文件请求、下载、解析完成之前，css 会造成阻塞渲染，浏览器将不会渲染任何已处理的内容。\n\n在加载内联 css 代码后，后面的外部引用 css 没必要阻塞浏览器渲染。这时可以采取异步加载的方案，主要有以下：\n\n * 使用 javascript 将 link 标签插入到 head 标签的最后：\n   \n   const mycss = document.createelement("link")\n   mycss.rel = "stylesheet"\n   mycss.href = "mystyles.css"\n   document.head.insertbefore(mycss, docuemnt.head.childnodes[document.head.childnodes.length - 1].nextsibiling)\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 设置 link 标签的 media 属性为 noexist ，浏览器会认为当前样式表不使用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完毕之后，将 media 的值设置为 screen 或者 all ，从而让浏览器开始解析 css。\n   \n   <link rel="stylesheet" href="mystyle.css" media=noexist` onload="this.media=\'all\'">\n   \n   \n   1\n   \n\n * 通过 rel 属性将 link 元素标记为 alternate 可选样式表，也能实现浏览器的异步加载。在加载完成之后， rel 设置回为 stylesheet ：\n   \n   <link rel="alternate stylesheet" href="mystyles.css" onload="this.rel=\'stylesheet\'">\n   \n   \n   1\n   \n\n\n# 资源压缩\n\n利用 webpack 、 gulp / grunt 、 rollup 等模块化工具，可以将 css 的代码进行压缩，使得文件变小，大大降低浏览器的加载时间。\n\n\n# 合理使用 css 选择器\n\ncss 的匹配规则是 从右向左 开始匹配。\n\n🌰 例子 / 例如 #markdown .content h3 匹配的规则如下：\n\n * 先找到 h3 标签的元素；\n * 然后去除祖先不是 .content 类的元素；\n * 最后取出祖先不是 #markdown 的元素；\n\n如果嵌套的层级更多，页面中的元素更多，那么匹配所要话费的时间代价更高。所以在编写选择器时，应该遵循以下规则：\n\n * 不要嵌套使用过多复杂的选择器，最好不要三层以上；\n * 使用 id 选择器就没有必要再进行嵌套；\n * 通配符 * 和属性选择器效率最低，避免使用；\n\n\n#\n\n\n# 减少使用昂贵的属性\n\n页面发生重绘的时候，昂贵属性例如 box-shadow / border-radius / filter / transparent / :nth-child 等属性，会降低 浏览器的渲染性能。\n\n\n# 不要使用 @import\n\ncss 样式文件有两种引入的方式，一种是 link 元素，另一种是 @import 。 @import 会影响浏览器的并行下载，使得页面在加载的时候增加额外的延迟，增添额外的往返耗时。\n\n并且多个 @import 可能会导致下载顺序紊乱。\n\n🌰 例子：如果一个 css 文件 index.css 中包含了以下的导入内容： @import url("reset.css") ，那么浏览器就必须先把 index.css 下载、解析和执行后，才下载、解析和执行第二个文件 reset.css 。\n\n\n# 其他\n\n * 减少重排的操作，以及减少不必要的重绘；\n * 了解哪些属性可以继承而来，避免对这些属性重复编写；\n * 动画或者过渡尽量使用 transform 和 opacity ，避免使用 left 和 top 属性。\n\n\n#\n\n\n# 参考\n\n * 面试官：如果要做优化，css 提高性能的方法有哪些？ | web 前端面试 - 面试官系列 (vue3js.cn)\n * 🌟 css 性能优化的 8 个技巧 - 掘金 (juejin.cn)',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 数据类型",frontmatter:{title:"🍎 JavaScript 数据类型",date:"2022-06-08T20:12:46.000Z",permalink:"/pages/7f3bfc/",categories:["🪞冲刺","🗾 JavaScript 相关","🍎 JavaScript 数据类型相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/01. 🍎 JavaScript 数据类型.md",key:"v-5cc9cd12",path:"/pages/7f3bfc/",headers:[{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:29},{level:2,title:"存储区别",slug:"存储区别",normalizedTitle:"存储区别",charIndex:285}],headersStr:"数据类型 存储区别",content:'> 相关问题：\n> \n>  * JavaScript 上的数据类型有哪些？\n>  * 存储上有哪些不同？\n\n\n# 数据类型\n\nJavaScript 中的数据类型可以分为两种，分别是：\n\n * 六种基本类型：\n   * Number 数值\n   * String 字符串\n   * Boolean 布尔\n   * Undefined\n   * Null\n   * Symbol\n * 引用类型：\n   * Object 对象\n   * Array 数组\n   * Function 函数\n   * 其他引用类型，Map 集合、Set 字典、Date 日期对象 …\n\n\n# 存储区别\n\n基本数据类型和引用数据类型存储 在内存的位置不同：\n\n * 基本数据类型存储在内存的 栈 中；\n * 引用数据类型的 对象 存储在 堆 中；\n\n将一个变量赋值给一个变量时，解析器首先要确认这个值是 基本数据类型 还是 引用类型值。\n\n🌰 例子 / 基本类型：\n\nlet a = 10;\nlet b = a;\nb = 20;\nconsole.log(a)\n\n\n1\n2\n3\n4\n\n\n> a 的值是一个基本类型，存储在栈中；将 a 的值赋给 b ，虽然连那个变量的值相等，但实际上保存了两个不同的内存地址，所以后来给 b 赋值不会影响 a 变量的值。\n\n🌰 例子 / 引用类型：\n\nlet obj1 = {}\nlet obj2 = obj1\n\nobj2.name = "simon"\nconsole.log(obj.name) // simon\n\n\n1\n2\n3\n4\n5\n\n\n> 对于引用数据类型，存放在内存的堆中，每个堆在内存中都有一个内存地址，引用的地址存放在栈中。 obj1 是一个引用类型，赋值给 obj2 实际上是把 obj1 内存栈中的引用地址复制一份给 obj2 ，即指向内存堆中同一个引用对象，所以更改 obj2 对象会对 obj1 产生影响；',normalizedContent:'> 相关问题：\n> \n>  * javascript 上的数据类型有哪些？\n>  * 存储上有哪些不同？\n\n\n# 数据类型\n\njavascript 中的数据类型可以分为两种，分别是：\n\n * 六种基本类型：\n   * number 数值\n   * string 字符串\n   * boolean 布尔\n   * undefined\n   * null\n   * symbol\n * 引用类型：\n   * object 对象\n   * array 数组\n   * function 函数\n   * 其他引用类型，map 集合、set 字典、date 日期对象 …\n\n\n# 存储区别\n\n基本数据类型和引用数据类型存储 在内存的位置不同：\n\n * 基本数据类型存储在内存的 栈 中；\n * 引用数据类型的 对象 存储在 堆 中；\n\n将一个变量赋值给一个变量时，解析器首先要确认这个值是 基本数据类型 还是 引用类型值。\n\n🌰 例子 / 基本类型：\n\nlet a = 10;\nlet b = a;\nb = 20;\nconsole.log(a)\n\n\n1\n2\n3\n4\n\n\n> a 的值是一个基本类型，存储在栈中；将 a 的值赋给 b ，虽然连那个变量的值相等，但实际上保存了两个不同的内存地址，所以后来给 b 赋值不会影响 a 变量的值。\n\n🌰 例子 / 引用类型：\n\nlet obj1 = {}\nlet obj2 = obj1\n\nobj2.name = "simon"\nconsole.log(obj.name) // simon\n\n\n1\n2\n3\n4\n5\n\n\n> 对于引用数据类型，存放在内存的堆中，每个堆在内存中都有一个内存地址，引用的地址存放在栈中。 obj1 是一个引用类型，赋值给 obj2 实际上是把 obj1 内存栈中的引用地址复制一份给 obj2 ，即指向内存堆中同一个引用对象，所以更改 obj2 对象会对 obj1 产生影响；',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 数组常用方法",frontmatter:{title:"🍎 JavaScript 数组常用方法",date:"2022-06-08T20:36:12.000Z",permalink:"/pages/3cfb49/",categories:["🪞面试题收集","🗾 JavaScript 相关","🍎 JavaScript 数据类型相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/02. 🍎 JavaScript 数组常用方法.md",key:"v-ceb7a5d6",path:"/pages/3cfb49/",headersStr:null,content:"> 相关问题：\n> \n>  * JavaScript 数组的常用方法有哪些？\n\n更多关于 JavaScript 数组的内容：🔃 JavaScript 数组\n\n * 添加 / 移除元素相关：\n   \n   * push(...items) ：在数组的尾端添加任意数量的参数。返回新的数组的长度；\n   * unshift(...items) ：在数组的开头添加任意个值。返回新的数组的长度；\n   * slice(start, end) ：创建一个新数组，将从索引 start 到索引 end （但不包括 end ）的元素 复制 进去。 不会影响原始数组。返回新数组的元素值。\n   * splice(pos, deleteCount, ...items) ： 从 pos 开始删除 deleteCount 个元素，并插入 items 。会影响原数组。返回包含除元素的数组。\n   * pop() ：删除数组的最后一个元素，返回被删除的元素。\n   * shift() ：删除数组的第一个元素，返回被删除的元素。\n   * concat(...items) ：返回一个新数组：复制 当前数组的所有元素，并向其中添加 items 。如果 items 中的任意一项是一个数组，那么就取其元素。（其他对象则为对象本身）\n\n * 查找元素相关：\n   \n   * indexOf / lastIndexOf(item, pos) ：从索引 pos 开始搜索 item ，搜索到则返回该项的 索引值，否则返回 -1 。\n   * includes(value) ：如果数组有 value ，则返回 true ，否则返回 false 。\n   * find(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 第一个匹配的值。\n   * filter(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 所有值。\n   * findIndex 和 find 类似，但返回 索引 而不是值。\n\n * 排序 / 转换数组相关：\n   \n   * sort(func) ： 对数组进行 原位排序，然后返回排序后的数组。\n   * reverse() ： 原位反转 数组，然后返回反转后的数组。\n   * map((item,index,array)=>{ return ... }) ： 根据对每个元素调用 func 的结果创建一个新数组。\n   * join ：接受一个参数，数组分隔符，返回包含所有项目的字符串。\n   * reduce / reduceRight(func, initial) ：通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。（常见用法累加）\n\n * 数组迭代方法：\n   \n   * arr.some(fn) / arr.every(fn) 检查数组。对数组的每个元素调用函数 fn ：\n     * ** 有一 true 所有就返回 true **：如果 fn 返回一个真值， arr.some() 立即返回 true 并停止迭代其余数组项；\n     * 所有 true 才返回 true ：如果 fn 返回一个假值， arr.every() 立即返回 false 并停止对其余数组项的迭代。\n   * forEach((item,index,array)=>{ ... }) ：对数组的每一个元素都运行传入的函数，没有返回值。\n\n * 其他：\n   \n   * Array.isArray(arr) ：检查 arr 是否是一个数组。",normalizedContent:"> 相关问题：\n> \n>  * javascript 数组的常用方法有哪些？\n\n更多关于 javascript 数组的内容：🔃 javascript 数组\n\n * 添加 / 移除元素相关：\n   \n   * push(...items) ：在数组的尾端添加任意数量的参数。返回新的数组的长度；\n   * unshift(...items) ：在数组的开头添加任意个值。返回新的数组的长度；\n   * slice(start, end) ：创建一个新数组，将从索引 start 到索引 end （但不包括 end ）的元素 复制 进去。 不会影响原始数组。返回新数组的元素值。\n   * splice(pos, deletecount, ...items) ： 从 pos 开始删除 deletecount 个元素，并插入 items 。会影响原数组。返回包含除元素的数组。\n   * pop() ：删除数组的最后一个元素，返回被删除的元素。\n   * shift() ：删除数组的第一个元素，返回被删除的元素。\n   * concat(...items) ：返回一个新数组：复制 当前数组的所有元素，并向其中添加 items 。如果 items 中的任意一项是一个数组，那么就取其元素。（其他对象则为对象本身）\n\n * 查找元素相关：\n   \n   * indexof / lastindexof(item, pos) ：从索引 pos 开始搜索 item ，搜索到则返回该项的 索引值，否则返回 -1 。\n   * includes(value) ：如果数组有 value ，则返回 true ，否则返回 false 。\n   * find(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 第一个匹配的值。\n   * filter(func) ： 通过 func 过滤元素，返回使 func 返回 true 的 所有值。\n   * findindex 和 find 类似，但返回 索引 而不是值。\n\n * 排序 / 转换数组相关：\n   \n   * sort(func) ： 对数组进行 原位排序，然后返回排序后的数组。\n   * reverse() ： 原位反转 数组，然后返回反转后的数组。\n   * map((item,index,array)=>{ return ... }) ： 根据对每个元素调用 func 的结果创建一个新数组。\n   * join ：接受一个参数，数组分隔符，返回包含所有项目的字符串。\n   * reduce / reduceright(func, initial) ：通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。（常见用法累加）\n\n * 数组迭代方法：\n   \n   * arr.some(fn) / arr.every(fn) 检查数组。对数组的每个元素调用函数 fn ：\n     * ** 有一 true 所有就返回 true **：如果 fn 返回一个真值， arr.some() 立即返回 true 并停止迭代其余数组项；\n     * 所有 true 才返回 true ：如果 fn 返回一个假值， arr.every() 立即返回 false 并停止对其余数组项的迭代。\n   * foreach((item,index,array)=>{ ... }) ：对数组的每一个元素都运行传入的函数，没有返回值。\n\n * 其他：\n   \n   * array.isarray(arr) ：检查 arr 是否是一个数组。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 字符串常用方法",frontmatter:{title:"🍎 JavaScript 字符串常用方法",date:"2022-06-08T20:36:29.000Z",permalink:"/pages/d3e8df/",categories:["🪞面试题收集","🗾 JavaScript 相关","🍎 JavaScript 数据类型相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/03. 🍎 JavaScript 字符串常用方法.md",key:"v-46a7403e",path:"/pages/d3e8df/",headersStr:null,content:"> 相关问题：\n> \n>  * JavaScript 的字符串常用方法有哪些？\n\n * 字符串增加相关（一般创建一个字符串副本再操作）：\n   \n   * 使用运算 + 和 ${} 拼接字符串；\n   * concat(str) ： 将一个或者多个字符串拼接成一个新的字符串。返回值为这个新的字符串。\n\n * 字符串删除（剪切）相关（一般创建一个字符串副本再操作）：\n   \n   * slice(str)\n   * substr(str)\n   * substring(str)\n   \n   以上三个方法都返回调用它们的字符串的一个子字符串，接收一或者两个参数。\n\n * 字符串修改相关：\n   \n   * trim() / trimLeft() / trimRight() ： 删除前、后、或者前后所有 空格符号，返回值为新的字符串；\n   * repeat(num) ：接收一个整数参数，表示字符串复制多少次，然后返回拼接所有副本后的结果。\n   * toLowerCase() / toUpperCase() ：转换字符串的大小写。\n\n * 字符串查找相关：\n   \n   * charAt(index) ：返回索引值位置的字符。\n   * indexOf(str) ：在字符串中搜索传入的字符串，找到则返回位置索引值，找不到返回 -1 ；\n   * startWith() / includes() ：从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值；\n\n * 字符串转换方法：\n   \n   * split() ： 根据指定的字符分隔符，拆分成数组；返回值为拆分后的数组；\n   * match() ：接收一个正则字符串或者 RegExp 对象，返回符合字符串的数组；\n   * search() ：接收一个正则字符串或者 RegExp 对象，找到符合的字符串则返回匹配索引值；否则返回 -1 ；\n   * replace() ：接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可以用函数）。",normalizedContent:"> 相关问题：\n> \n>  * javascript 的字符串常用方法有哪些？\n\n * 字符串增加相关（一般创建一个字符串副本再操作）：\n   \n   * 使用运算 + 和 ${} 拼接字符串；\n   * concat(str) ： 将一个或者多个字符串拼接成一个新的字符串。返回值为这个新的字符串。\n\n * 字符串删除（剪切）相关（一般创建一个字符串副本再操作）：\n   \n   * slice(str)\n   * substr(str)\n   * substring(str)\n   \n   以上三个方法都返回调用它们的字符串的一个子字符串，接收一或者两个参数。\n\n * 字符串修改相关：\n   \n   * trim() / trimleft() / trimright() ： 删除前、后、或者前后所有 空格符号，返回值为新的字符串；\n   * repeat(num) ：接收一个整数参数，表示字符串复制多少次，然后返回拼接所有副本后的结果。\n   * tolowercase() / touppercase() ：转换字符串的大小写。\n\n * 字符串查找相关：\n   \n   * charat(index) ：返回索引值位置的字符。\n   * indexof(str) ：在字符串中搜索传入的字符串，找到则返回位置索引值，找不到返回 -1 ；\n   * startwith() / includes() ：从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值；\n\n * 字符串转换方法：\n   \n   * split() ： 根据指定的字符分隔符，拆分成数组；返回值为拆分后的数组；\n   * match() ：接收一个正则字符串或者 regexp 对象，返回符合字符串的数组；\n   * search() ：接收一个正则字符串或者 regexp 对象，找到符合的字符串则返回匹配索引值；否则返回 -1 ；\n   * replace() ：接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可以用函数）。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 JavaScript typeof 与 instanceof",frontmatter:{title:"🍏 JavaScript typeof 与 instanceof",date:"2022-06-27T10:51:00.000Z",permalink:"/pages/d7f372/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 数据类型相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3/04.%20%F0%9F%8D%8F%20JavaScript%20typeof%20%E4%B8%8E%20instanceof.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/04. 🍏 JavaScript typeof 与 instanceof.md",key:"v-f2eceaa8",path:"/pages/d7f372/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2},{level:3,title:"typeof",slug:"typeof",normalizedTitle:"typeof",charIndex:9},{level:3,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:662},{level:3,title:"两者的区别",slug:"两者的区别",normalizedTitle:"两者的区别",charIndex:1570},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3356}],headersStr:"概念 typeof instanceof 两者的区别 参考",content:'# 概念\n\n\n# typeof\n\n * 返回一个字符串，表示未经计算的操作数的类型。\n\n * 使用语法： typeof operand / typeof (operand) （ operand 为对象或者原始值的表达式）\n\n🌰 例子：\n\ntypeof 1 // \'number\'\ntypeof \'1\' // \'string\'\ntypeof undefined // \'undefined\'\ntypeof true // \'boolean\'\ntypeof Symbol() // \'symbol\'\ntypeof null // \'object\'\ntypeof [] // \'object\'\ntypeof {} // \'object\'\ntypeof console // \'object\'\ntypeof console.log // \'function\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n>  * typeof null 是一个特殊情况， null 本身不是对象。所以 typeof 不能判断 null 的情况。判断变量是否为空，可以直接在 if 语句中判断是否 ===null 即可。\n> \n>  * 对于引用数据类型，可以使用 typeof 判断，除了 函数 function 可以被识别出来类型，其他的都是 object 类型。\n> \n>  * 判断一个变量是否存在，可以使用 typeof ：如 typeof a != \'undefined\' 。如果直接 if(a) ，当变量为空时会报错。\n\n\n# instanceof\n\n * instanceof 运算符用于检测 构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n   \n   理解为，因为构造函数可以通过 new 生成实例对象， instance 判断某个实例对象是否为某个构造函数的实例对象。\n\n * 使用语法： object instanceof constructor （ object 为实例对象， constructor 为构造对象）。\n\n🌰 例子：\n\nlet Car = function() {}\nlet benz = new Car()\nbenz instanceof Car // true\n\nlet car = new String(\'xxx\')\ncar instanceof String // true\nlet str = \'xxx\'\nstr instanceof String // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> instanceof 的实现原理：\n> \n> fucntion iInstanceof(left, right) {\n>   // 如果左边不为对象类型或者为空，则返回 false\n>   if(typeof left !== \'object\' || left === null) return false;\n>   \n>   let proto = Object.getPrototypeOf(left);\n>   while(true) {\n>     if(proto === null) return false;\n>     if(proto === right.prototype) return true;\n>    \tproto = Object.getPrototype(proto)\n>   }\n>   \n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 顺着原型链去找，直到找到相同的原型对象，如果找到则返回 true ，找不到则返回 false 。\n\n\n# 两者的区别\n\n * 相同点： typeof 和 instanceof 都用于判断数据的类型。\n * 不同点：\n   * typeof 会返回一个变量的基本类型的字符串； instanceof 返回的是一个布尔值；\n   * instanceof 可以准确判断 复杂引用数据类型，但是不能准确判断基础数据类型； typeof 虽然可以 准确判断基础数据类型，但是引用数据类型中，除了 function 以外，其他的数据类型无法判断。\n\n可以看到，两种方法判断数据类型都有弊端，并不能满足所有的场景的需求。如果需要通用监测数据类型可以采用 Object.prototype.toString 方法，统一返回 [object XXX] 格式。\n\n🌰 例子：\n\nObject.prototype.toString({}) // "[object Object]"\nObject.prototype.toString.call({}) // 结果桶上升\nObject.prototype.toString.call(1)  // "[object Number]"\nObject.prototype.toString.call(\'1\')  // "[object String]"\nObject.prototype.toString.call(true)  // "[object Boolean]"\nObject.prototype.toString.call(function(){})  // "[object Function]"\nObject.prototype.toString.call(null)   //"[object Null]"\nObject.prototype.toString.call(undefined) //"[object Undefined]"\nObject.prototype.toString.call(/123/g)    //"[object RegExp]"\nObject.prototype.toString.call(new Date()) //"[object Date]"\nObject.prototype.toString.call([])       //"[object Array]"\nObject.prototype.toString.call(document)  //"[object HTMLDocument]"\nObject.prototype.toString.call(window)   //"[object Window]"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以将这个方法封装为一个全局通用的数据类型判断方法：\n\nfunction getType(obj) {\n  let type = typeof obj\n  if (type !=== \'ojbect\') {\n    return type\n  }\n  return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, \'$1\');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用如下：\n\ngetType([])     // "Array" typeof []是object，因此toString返回\ngetType(\'123\')  // "string" typeof 直接返回\ngetType(window) // "Window" toString返回\ngetType(null)   // "Null"首字母大写，typeof null是object，需toString来判断\ngetType(undefined)   // "undefined" typeof 直接返回\ngetType()            // "undefined" typeof 直接返回\ngetType(function(){}) // "function" typeof能判断，因此首字母小写\ngetType(/123/g)      //"RegExp" toString返回\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 参考\n\n * 面试官：typeof 与 instanceof 区别 | web 前端面试 - 面试官系列 (vue3js.cn)',normalizedContent:'# 概念\n\n\n# typeof\n\n * 返回一个字符串，表示未经计算的操作数的类型。\n\n * 使用语法： typeof operand / typeof (operand) （ operand 为对象或者原始值的表达式）\n\n🌰 例子：\n\ntypeof 1 // \'number\'\ntypeof \'1\' // \'string\'\ntypeof undefined // \'undefined\'\ntypeof true // \'boolean\'\ntypeof symbol() // \'symbol\'\ntypeof null // \'object\'\ntypeof [] // \'object\'\ntypeof {} // \'object\'\ntypeof console // \'object\'\ntypeof console.log // \'function\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n>  * typeof null 是一个特殊情况， null 本身不是对象。所以 typeof 不能判断 null 的情况。判断变量是否为空，可以直接在 if 语句中判断是否 ===null 即可。\n> \n>  * 对于引用数据类型，可以使用 typeof 判断，除了 函数 function 可以被识别出来类型，其他的都是 object 类型。\n> \n>  * 判断一个变量是否存在，可以使用 typeof ：如 typeof a != \'undefined\' 。如果直接 if(a) ，当变量为空时会报错。\n\n\n# instanceof\n\n * instanceof 运算符用于检测 构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n   \n   理解为，因为构造函数可以通过 new 生成实例对象， instance 判断某个实例对象是否为某个构造函数的实例对象。\n\n * 使用语法： object instanceof constructor （ object 为实例对象， constructor 为构造对象）。\n\n🌰 例子：\n\nlet car = function() {}\nlet benz = new car()\nbenz instanceof car // true\n\nlet car = new string(\'xxx\')\ncar instanceof string // true\nlet str = \'xxx\'\nstr instanceof string // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> instanceof 的实现原理：\n> \n> fucntion iinstanceof(left, right) {\n>   // 如果左边不为对象类型或者为空，则返回 false\n>   if(typeof left !== \'object\' || left === null) return false;\n>   \n>   let proto = object.getprototypeof(left);\n>   while(true) {\n>     if(proto === null) return false;\n>     if(proto === right.prototype) return true;\n>    \tproto = object.getprototype(proto)\n>   }\n>   \n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 顺着原型链去找，直到找到相同的原型对象，如果找到则返回 true ，找不到则返回 false 。\n\n\n# 两者的区别\n\n * 相同点： typeof 和 instanceof 都用于判断数据的类型。\n * 不同点：\n   * typeof 会返回一个变量的基本类型的字符串； instanceof 返回的是一个布尔值；\n   * instanceof 可以准确判断 复杂引用数据类型，但是不能准确判断基础数据类型； typeof 虽然可以 准确判断基础数据类型，但是引用数据类型中，除了 function 以外，其他的数据类型无法判断。\n\n可以看到，两种方法判断数据类型都有弊端，并不能满足所有的场景的需求。如果需要通用监测数据类型可以采用 object.prototype.tostring 方法，统一返回 [object xxx] 格式。\n\n🌰 例子：\n\nobject.prototype.tostring({}) // "[object object]"\nobject.prototype.tostring.call({}) // 结果桶上升\nobject.prototype.tostring.call(1)  // "[object number]"\nobject.prototype.tostring.call(\'1\')  // "[object string]"\nobject.prototype.tostring.call(true)  // "[object boolean]"\nobject.prototype.tostring.call(function(){})  // "[object function]"\nobject.prototype.tostring.call(null)   //"[object null]"\nobject.prototype.tostring.call(undefined) //"[object undefined]"\nobject.prototype.tostring.call(/123/g)    //"[object regexp]"\nobject.prototype.tostring.call(new date()) //"[object date]"\nobject.prototype.tostring.call([])       //"[object array]"\nobject.prototype.tostring.call(document)  //"[object htmldocument]"\nobject.prototype.tostring.call(window)   //"[object window]"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以将这个方法封装为一个全局通用的数据类型判断方法：\n\nfunction gettype(obj) {\n  let type = typeof obj\n  if (type !=== \'ojbect\') {\n    return type\n  }\n  return object.prototype.tostring.call(obj).replace(/^\\[object (\\s+)\\]$/, \'$1\');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用如下：\n\ngettype([])     // "array" typeof []是object，因此tostring返回\ngettype(\'123\')  // "string" typeof 直接返回\ngettype(window) // "window" tostring返回\ngettype(null)   // "null"首字母大写，typeof null是object，需tostring来判断\ngettype(undefined)   // "undefined" typeof 直接返回\ngettype()            // "undefined" typeof 直接返回\ngettype(function(){}) // "function" typeof能判断，因此首字母小写\ngettype(/123/g)      //"regexp" tostring返回\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 参考\n\n * 面试官：typeof 与 instanceof 区别 | web 前端面试 - 面试官系列 (vue3js.cn)',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 JavaScript 数字精度丢失相关",frontmatter:{title:"🍏 JavaScript 数字精度丢失相关",date:"2022-07-03T15:07:16.000Z",permalink:"/pages/aef8c2/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 数据类型相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3/05.%20%F0%9F%8D%8F%20JavaScript%20%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/05. 🍏 JavaScript 数字精度丢失相关.md",key:"v-17bfcefe",path:"/pages/aef8c2/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:51},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:156},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:875}],headersStr:"概念 解决方案 参考",content:"> 相关问题：\n> \n>  * 对于 JavaScript 中数组精度丢失的问题，如何解决？\n\n\n# 概念\n\n🌰 例子 / 引入：\n\n0.1 + 0.2 === 0.3 // false\n\n\n1\n\n\n🔢 JavaScript 数字类型 | notebook (simon1uo.github.io)\n\n\n# 解决方案\n\n理论上有限的空间不能存储无限的小数，并且保证数字的精确。但是可以处理一下得到期望的结果。\n\n当要展示如 1.4000000000000001 这样的数字时，建议使用 toPrecision 凑整并且使用 parseFloat 转化成数字再显示。\n\n🌰 例子：\n\nparseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True\n\n\n1\n\n\n将这种方法封装为函数：\n\nfunction strip(num, precision = 12) {\n  return +parseFloat(num.toPrecision(precision))\n}\n\n\n1\n2\n3\n\n\n对于运算类的操作，例如 加减乘除，就不能使用 toPrecision 。正确的做法是将小数转换成整数后再运算。以加法为例子：\n\nfunction add(num1, num2) {\n  const num1Digits = (num1.toString().split('.')[1] || '').length;\n  const num2Digits = (num2.toString().split('.')[1] || '').length;\n  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits))\n  return (num1 * baseNum + num2 * baseNum) / baseNum\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n或者使用第三方库， Math.js / BigDecimal.js\n\n\n# 参考\n\n * BigInt - JavaScript | MDN (mozilla.org)",normalizedContent:"> 相关问题：\n> \n>  * 对于 javascript 中数组精度丢失的问题，如何解决？\n\n\n# 概念\n\n🌰 例子 / 引入：\n\n0.1 + 0.2 === 0.3 // false\n\n\n1\n\n\n🔢 javascript 数字类型 | notebook (simon1uo.github.io)\n\n\n# 解决方案\n\n理论上有限的空间不能存储无限的小数，并且保证数字的精确。但是可以处理一下得到期望的结果。\n\n当要展示如 1.4000000000000001 这样的数字时，建议使用 toprecision 凑整并且使用 parsefloat 转化成数字再显示。\n\n🌰 例子：\n\nparsefloat(1.4000000000000001.toprecision(12)) === 1.4  // true\n\n\n1\n\n\n将这种方法封装为函数：\n\nfunction strip(num, precision = 12) {\n  return +parsefloat(num.toprecision(precision))\n}\n\n\n1\n2\n3\n\n\n对于运算类的操作，例如 加减乘除，就不能使用 toprecision 。正确的做法是将小数转换成整数后再运算。以加法为例子：\n\nfunction add(num1, num2) {\n  const num1digits = (num1.tostring().split('.')[1] || '').length;\n  const num2digits = (num2.tostring().split('.')[1] || '').length;\n  const basenum = math.pow(10, math.max(num1digits, num2digits))\n  return (num1 * basenum + num2 * basenum) / basenum\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n或者使用第三方库， math.js / bigdecimal.js\n\n\n# 参考\n\n * bigint - javascript | mdn (mozilla.org)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 JavaScript 数据变量内存",frontmatter:{title:"🍏 JavaScript 数据变量内存",date:"2022-06-10T15:31:47.000Z",permalink:"/pages/6e10ef/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 数据类型相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8F%20JavaScript%20%E6%95%B0%E6%8D%AE%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/10. 🍏 JavaScript 数据变量内存.md",key:"v-1605ad46",path:"/pages/6e10ef/",headers:[{level:3,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:2},{level:3,title:"内存",slug:"内存",normalizedTitle:"内存",charIndex:9},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:311},{level:3,title:"三者关系",slug:"三者关系",normalizedTitle:"三者关系",charIndex:424},{level:3,title:"相关问题",slug:"相关问题",normalizedTitle:"相关问题",charIndex:472}],headersStr:"数据 内存 变量 三者关系 相关问题",content:"# 数据\n\n存储在内存中代表特定信息，本质上是 0101… 。\n\n🌰 例子：\n\nvar age = 18 // 特定信息\nvar a = 2 // 未知特定信息\n\n\n1\n2\n\n\n * 数据的特点：可传递、可运算。\n\n * 内存中的所有操作的目标为：数据。\n   \n   * 算数运算、逻辑运算、赋值、运行函数。\n\n\n# 内存\n\n内存条通电后产生的可存储数据的空间（临时的）。\n\n * 内存的产生和死亡：内存条 === 通电 > 产生内存空间 ===> 存储数据 ===> 处理数据 === 断电 > 内存空间和数据都消失。\n * 内存数据的两个数据： 内部存储的数据、地址值数据。\n * 内存的分类：\n   * 栈：全局变量 / 局部变量（包括标识对象的变量）\n   * 堆：对象\n\n\n# 变量\n\n可变化的量：\n\n * 由变量名、变量值组成，每个变量都对应一块小内存。\n * 变量名用来查找对应的内存。\n * 变量值是内存中保存的数据。\n\n\n# 三者关系\n\n * 内存是用来存储数据的空间；\n * 变量是内存的标识，查找内存的空间；\n\n\n# 相关问题\n\n❓ var a = xxx ， a 中保存的是什么？\n\n * 当 xxx 是基本数据，保存的是这个数据。\n * 当 xxx 是对象，保存的时对象的地址值。\n * 当 xxx 是一个变量，保存的是 xxx 的内存内容（可以是基本数据也可以是地址值）。\n\n❓引用变量赋值问题：\n\n * 当多个引用变量指向同一个对象，这多个变量都指向同一个地址值。通过一个变量修改对象的内部数据，其他所有变量看到的是修改后的数据。\n\nvar obj1 = {name: 'Simon'}\nvar obj2 = obj1\nobj1.name = 'Jack'\ncosole.log(obj2.name) // 'Jack'\n\n\n1\n2\n3\n4\n\n\nfunction fn(obj) {\n  obj.name = 'Bob'\n}\nfn(obj1)\nconsole.log(obj2.name) // Bob\n\n\n1\n2\n3\n4\n5\n\n * 两个引用变量指向相同同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象。\n\nvar a = {age: 12}\nvar b = a\na = {name: 'Simon', age: 13}\nb.age = 14\ncosole.log(b.age, a.namae, b.age) // 14 Simon 13\n\n\n1\n2\n3\n4\n5\n\n * 在函数中，要是用的参数与原来的变量指向同一个对象，但是在函数中的对象在函数执行完后，回哦成为垃圾对象，而不影响原来的变量指向的对象。\n\nfunction fn2 (obj){\n  obj = {age: 15}\n}\nfn2(a)\nconsole.log(a.age) // 13\n\n\n1\n2\n3\n4\n5\n\n\n❓ 在 JavaScript 调用函数传递变量参数是，是值传递还是引用传递问题：\n\n * 都是值传递，分为两种情况，基本值与地址值。\n * 可能是值传递，也可能是引用传递（地址值）。\n\nvar a = 3\nfunction fn(a) {\n  a = a + 1\n  console.log(a) //4\n}\nfn(a)\nconsole.log(a)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfunction fn2(obj) {\n  console.log(obj.name)\n}\nvar obj = {name: 'Simon'}\nfn2(obj)\n// 先读到obj的对象地址值，将地址值赋值给局部变量obj，然后函数內的局部变量\n\n\n1\n2\n3\n4\n5\n6\n\n\n❓JavaScript 引擎如何管理内存：\n\n * 内存的生命周期：\n   \n   * 分配小内存空间，得到它的使用权。\n   * 存储数据，可以反复进行操作。\n   * 释放小内存空间。（释放占用内存）\n\n * 内存的释放：\n   \n   * 局部变量：函数执行完后自动释放。\n   * 对象：成为垃圾对象，垃圾回收器回收。\n\nvar a = 3\nvar obj = {}\nobj = null\n\nfuction fn (){\n  // var b =123\n  var b = {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 数据\n\n存储在内存中代表特定信息，本质上是 0101… 。\n\n🌰 例子：\n\nvar age = 18 // 特定信息\nvar a = 2 // 未知特定信息\n\n\n1\n2\n\n\n * 数据的特点：可传递、可运算。\n\n * 内存中的所有操作的目标为：数据。\n   \n   * 算数运算、逻辑运算、赋值、运行函数。\n\n\n# 内存\n\n内存条通电后产生的可存储数据的空间（临时的）。\n\n * 内存的产生和死亡：内存条 === 通电 > 产生内存空间 ===> 存储数据 ===> 处理数据 === 断电 > 内存空间和数据都消失。\n * 内存数据的两个数据： 内部存储的数据、地址值数据。\n * 内存的分类：\n   * 栈：全局变量 / 局部变量（包括标识对象的变量）\n   * 堆：对象\n\n\n# 变量\n\n可变化的量：\n\n * 由变量名、变量值组成，每个变量都对应一块小内存。\n * 变量名用来查找对应的内存。\n * 变量值是内存中保存的数据。\n\n\n# 三者关系\n\n * 内存是用来存储数据的空间；\n * 变量是内存的标识，查找内存的空间；\n\n\n# 相关问题\n\n❓ var a = xxx ， a 中保存的是什么？\n\n * 当 xxx 是基本数据，保存的是这个数据。\n * 当 xxx 是对象，保存的时对象的地址值。\n * 当 xxx 是一个变量，保存的是 xxx 的内存内容（可以是基本数据也可以是地址值）。\n\n❓引用变量赋值问题：\n\n * 当多个引用变量指向同一个对象，这多个变量都指向同一个地址值。通过一个变量修改对象的内部数据，其他所有变量看到的是修改后的数据。\n\nvar obj1 = {name: 'simon'}\nvar obj2 = obj1\nobj1.name = 'jack'\ncosole.log(obj2.name) // 'jack'\n\n\n1\n2\n3\n4\n\n\nfunction fn(obj) {\n  obj.name = 'bob'\n}\nfn(obj1)\nconsole.log(obj2.name) // bob\n\n\n1\n2\n3\n4\n5\n\n * 两个引用变量指向相同同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象。\n\nvar a = {age: 12}\nvar b = a\na = {name: 'simon', age: 13}\nb.age = 14\ncosole.log(b.age, a.namae, b.age) // 14 simon 13\n\n\n1\n2\n3\n4\n5\n\n * 在函数中，要是用的参数与原来的变量指向同一个对象，但是在函数中的对象在函数执行完后，回哦成为垃圾对象，而不影响原来的变量指向的对象。\n\nfunction fn2 (obj){\n  obj = {age: 15}\n}\nfn2(a)\nconsole.log(a.age) // 13\n\n\n1\n2\n3\n4\n5\n\n\n❓ 在 javascript 调用函数传递变量参数是，是值传递还是引用传递问题：\n\n * 都是值传递，分为两种情况，基本值与地址值。\n * 可能是值传递，也可能是引用传递（地址值）。\n\nvar a = 3\nfunction fn(a) {\n  a = a + 1\n  console.log(a) //4\n}\nfn(a)\nconsole.log(a)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfunction fn2(obj) {\n  console.log(obj.name)\n}\nvar obj = {name: 'simon'}\nfn2(obj)\n// 先读到obj的对象地址值，将地址值赋值给局部变量obj，然后函数內的局部变量\n\n\n1\n2\n3\n4\n5\n6\n\n\n❓javascript 引擎如何管理内存：\n\n * 内存的生命周期：\n   \n   * 分配小内存空间，得到它的使用权。\n   * 存储数据，可以反复进行操作。\n   * 释放小内存空间。（释放占用内存）\n\n * 内存的释放：\n   \n   * 局部变量：函数执行完后自动释放。\n   * 对象：成为垃圾对象，垃圾回收器回收。\n\nvar a = 3\nvar obj = {}\nobj = null\n\nfuction fn (){\n  // var b =123\n  var b = {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 深拷贝与浅拷贝",frontmatter:{title:"🍎 JavaScript 深拷贝与浅拷贝",date:"2022-06-26T18:46:43.000Z",permalink:"/pages/99b9ce/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 数据类型相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3/20.%20%F0%9F%8D%8E%20JavaScript%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/20. 🍎 JavaScript 深拷贝与浅拷贝.md",key:"v-01a08eb8",path:"/pages/99b9ce/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:117},{level:2,title:"相关实现例子",slug:"相关实现例子",normalizedTitle:"相关实现例子",charIndex:713},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:940}],headersStr:"概念 相关实现例子 参考",content:"> 回顾 JavaScript 中两大类数据类型：基本数据类型与引用数据类型。\n> \n>  * 基本类型数据保存在 栈内存；\n>  * 引用类型数据保存在 堆内存。引用数据变量是一个指向堆内存中保存在栈内存中实际对象的引用。\n\n\n# 概念\n\n * 浅拷贝：指的是创建新的数据，这个数据有着原始数据的属性值的一份精确拷贝。\n   \n   如果属性是 基本类型，拷贝的值就是基本类型的值；\n   \n   如果属性是 引用内省，拷贝的值是 内存地址；\n   \n   简单地说，浅拷贝就是一层的拷贝，对于深层次引用类型仅共享内存地址。\n   \n   * 在 JavaScript 中，存在浅拷贝的现象有：\n     * Object.assign\n     * Array.prototype.slice() , Array.prototype.concat()\n     * 使用拓展运算符实现的复制\n\n * 深拷贝：开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的内存地址。所以修改其中一个对象的属性，不会改变另一个对象的属性。\n   \n   常见的深拷贝方式有：\n   \n   * _.cloneDeep()\n   * jQuery.extend()\n   * JSON.stringify()\n   * 手写循环递归\n\n * 浅拷贝与深拷贝的区别：\n   \n   * 浅拷贝复制对象时，只复制指向某个对象的指针，而不复制对象本身，新旧对象是共享同一块内存，修改复制后的对象属性会影响原对象。\n   * 深拷贝会另外创造一个与原对象一样的对象（新开栈），新对象与原对象不共享内存，修改新对象不会影响原对象。\n\n\n\n\n# 相关实现例子\n\n🌰 例子 / 简单实现浅拷贝：\n\n点击查看\n\nfunction shallowClone(obj) {\n  const newObj = {}\n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      newObj[prop] = obj[prop]\n    }\n  }\n  return newObj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参考\n\n * js 深拷贝和浅拷贝及其实现方式 - SegmentFault 思否",normalizedContent:"> 回顾 javascript 中两大类数据类型：基本数据类型与引用数据类型。\n> \n>  * 基本类型数据保存在 栈内存；\n>  * 引用类型数据保存在 堆内存。引用数据变量是一个指向堆内存中保存在栈内存中实际对象的引用。\n\n\n# 概念\n\n * 浅拷贝：指的是创建新的数据，这个数据有着原始数据的属性值的一份精确拷贝。\n   \n   如果属性是 基本类型，拷贝的值就是基本类型的值；\n   \n   如果属性是 引用内省，拷贝的值是 内存地址；\n   \n   简单地说，浅拷贝就是一层的拷贝，对于深层次引用类型仅共享内存地址。\n   \n   * 在 javascript 中，存在浅拷贝的现象有：\n     * object.assign\n     * array.prototype.slice() , array.prototype.concat()\n     * 使用拓展运算符实现的复制\n\n * 深拷贝：开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的内存地址。所以修改其中一个对象的属性，不会改变另一个对象的属性。\n   \n   常见的深拷贝方式有：\n   \n   * _.clonedeep()\n   * jquery.extend()\n   * json.stringify()\n   * 手写循环递归\n\n * 浅拷贝与深拷贝的区别：\n   \n   * 浅拷贝复制对象时，只复制指向某个对象的指针，而不复制对象本身，新旧对象是共享同一块内存，修改复制后的对象属性会影响原对象。\n   * 深拷贝会另外创造一个与原对象一样的对象（新开栈），新对象与原对象不共享内存，修改新对象不会影响原对象。\n\n\n\n\n# 相关实现例子\n\n🌰 例子 / 简单实现浅拷贝：\n\n点击查看\n\nfunction shallowclone(obj) {\n  const newobj = {}\n  for (let prop in obj) {\n    if (obj.hasownproperty(prop)) {\n      newobj[prop] = obj[prop]\n    }\n  }\n  return newobj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参考\n\n * js 深拷贝和浅拷贝及其实现方式 - segmentfault 思否",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript new 操作符相关",frontmatter:{title:"🍎 JavaScript new 操作符相关",date:"2022-07-02T22:08:08.000Z",permalink:"/pages/b0ab4c/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 对象相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20JavaScript%20%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20JavaScript%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/02. 🍎 JavaScript 对象相关/02. 🍎 JavaScript new 操作符相关.md",key:"v-05f2fd30",path:"/pages/b0ab4c/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:58},{level:2,title:"new 的过程中做了什么？",slug:"new-的过程中做了什么",normalizedTitle:"new 的过程中做了什么？",charIndex:943},{level:2,title:"手写模拟实现 new 操作符",slug:"手写模拟实现-new-操作符",normalizedTitle:"手写模拟实现 new 操作符",charIndex:1106}],headersStr:"概念 new 的过程中做了什么？ 手写模拟实现 new 操作符",content:'> 相关问题；\n> \n>  * 对 new 操作符的理解？\n> \n>  * new 操作符号具体做了什么？\n\n\n# 概念\n\nJavaScript 中， new 操作符用于创建一个给定 构造函数 的 实例对象。\n\n🌰 例子：\n\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age\n}\n\nPerson.prototype.sayName = function() {\n  console.log(this.name)\n}\n\nconst person1 = new Person("Simon", 18)\nconsole.log(person1)\nperson1.sayName() // "Simon"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这个例子中： new 通过构造函数 Person 创建出来的实例对象可以访问到构造函数中的属性；并且可以访问构造函数原型链中的属性，即 实例对象与构造函数通过原型链 连接起来。\n\n🌰 例子 / 构造函数拥有返回值：\n\nfunction Test(name) {\n  this.name = name\n  return 1\n}\n\nconst test = new Test("test")\nconsole.log(test.name) // "test"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如果构造函数拥有返回值，并且返回值的类型是原始类型。但是这个返回值并没有作用。\n\n但是如果 构造函数的返回值类型是一个对象：\n\nfunction Test(name) {\n  this.name = name\n  console.log(this.name)\n  return {age: 18}\n}\n\nconst test = new Test("Simon")\nconsole.log(test) // {age: 18}\nconsole.log(test.name) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果构造函数的返回值为一个对象，那么返回值会被正常使用。即创建的实例对象都是这个返回值。\n\n\n# new 的过程中做了什么？\n\n主要完成以下工作：\n\n * 创建一个新的对象；\n\n * 将对象与构造函数通过原型链链接起来。\n   \n   将新对象的 [[prototype]] 指向为 构造函数.prototype\n\n * 根据构造函数的返回类型做判断，如果是原始值则会被忽略，如果是返回一个对象，需要正常处理。\n\n\n\n\n# 手写模拟实现 new 操作符\n\nfunction iNew(func, ...args) {\n  // 创建一个新的对象\n  const obj = {}\n  // 连接原型\n  obj.__proto__ = func.prototype\n  // 将构造函数的 this 连接到新的对象\n  let result = func.apply(obj, args)\n  // 根据返回值判断\n  return result instanceof Object ? result : obj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n测试使用：\n\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n}\n\nPerson.prototype.sayName = function() {\n  console.log(this.name)\n}\n\nlet person = iNew(Person, "Simon", 18)\nconsole.log(person)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:'> 相关问题；\n> \n>  * 对 new 操作符的理解？\n> \n>  * new 操作符号具体做了什么？\n\n\n# 概念\n\njavascript 中， new 操作符用于创建一个给定 构造函数 的 实例对象。\n\n🌰 例子：\n\nfunction person(name, age) {\n  this.name = name;\n  this.age = age\n}\n\nperson.prototype.sayname = function() {\n  console.log(this.name)\n}\n\nconst person1 = new person("simon", 18)\nconsole.log(person1)\nperson1.sayname() // "simon"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这个例子中： new 通过构造函数 person 创建出来的实例对象可以访问到构造函数中的属性；并且可以访问构造函数原型链中的属性，即 实例对象与构造函数通过原型链 连接起来。\n\n🌰 例子 / 构造函数拥有返回值：\n\nfunction test(name) {\n  this.name = name\n  return 1\n}\n\nconst test = new test("test")\nconsole.log(test.name) // "test"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如果构造函数拥有返回值，并且返回值的类型是原始类型。但是这个返回值并没有作用。\n\n但是如果 构造函数的返回值类型是一个对象：\n\nfunction test(name) {\n  this.name = name\n  console.log(this.name)\n  return {age: 18}\n}\n\nconst test = new test("simon")\nconsole.log(test) // {age: 18}\nconsole.log(test.name) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 如果构造函数的返回值为一个对象，那么返回值会被正常使用。即创建的实例对象都是这个返回值。\n\n\n# new 的过程中做了什么？\n\n主要完成以下工作：\n\n * 创建一个新的对象；\n\n * 将对象与构造函数通过原型链链接起来。\n   \n   将新对象的 [[prototype]] 指向为 构造函数.prototype\n\n * 根据构造函数的返回类型做判断，如果是原始值则会被忽略，如果是返回一个对象，需要正常处理。\n\n\n\n\n# 手写模拟实现 new 操作符\n\nfunction inew(func, ...args) {\n  // 创建一个新的对象\n  const obj = {}\n  // 连接原型\n  obj.__proto__ = func.prototype\n  // 将构造函数的 this 连接到新的对象\n  let result = func.apply(obj, args)\n  // 根据返回值判断\n  return result instanceof object ? result : obj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n测试使用：\n\nfunction person(name, age) {\n  this.name = name\n  this.age = age\n}\n\nperson.prototype.sayname = function() {\n  console.log(this.name)\n}\n\nlet person = inew(person, "simon", 18)\nconsole.log(person)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 JavaScript 对象模式",frontmatter:{title:"🍏 JavaScript 对象模式",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/d76014/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 对象相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20JavaScript%20%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8F%20JavaScript%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/02. 🍎 JavaScript 对象相关/03. 🍏 JavaScript 对象模式.md",key:"v-bbf26266",path:"/pages/d76014/",headers:[{level:2,title:"JavaScript 对象创建模式",slug:"javascript-对象创建模式",normalizedTitle:"javascript 对象创建模式",charIndex:2},{level:3,title:"Object 构造函数模式",slug:"object-构造函数模式",normalizedTitle:"object 构造函数模式",charIndex:24},{level:3,title:"对象字面量模式",slug:"对象字面量模式",normalizedTitle:"对象字面量模式",charIndex:339},{level:3,title:"工厂模式",slug:"工厂模式",normalizedTitle:"工厂模式",charIndex:815},{level:3,title:"自定义函数构造模式",slug:"自定义函数构造模式",normalizedTitle:"自定义函数构造模式",charIndex:1374},{level:3,title:"构造函数与原型组合模式",slug:"构造函数与原型组合模式",normalizedTitle:"构造函数与原型组合模式",charIndex:2085},{level:2,title:"继承模式",slug:"继承模式",normalizedTitle:"继承模式",charIndex:2479},{level:3,title:"原型链继承",slug:"原型链继承",normalizedTitle:"原型链继承",charIndex:2488},{level:3,title:"借用构造函数继承",slug:"借用构造函数继承",normalizedTitle:"借用构造函数继承",charIndex:3272},{level:3,title:"组合继承",slug:"组合继承",normalizedTitle:"组合继承",charIndex:3791}],headersStr:"JavaScript 对象创建模式 Object 构造函数模式 对象字面量模式 工厂模式 自定义函数构造模式 构造函数与原型组合模式 继承模式 原型链继承 借用构造函数继承 组合继承",content:"# JavaScript 对象创建模式\n\n\n# Object 构造函数模式\n\n * 套路：首先创建空的 Object 对象，然后再动态添加属性和方法。\n * 适用场景：起始时不确定对象内部的数据\n * 存在问题：设计对象时语句太多。\n\n🌰 例子：\n\nvar p = new Object() // 开始是未确定对象内部的数据\n\np.name = 'Tom'\np.age = 12\np.setName = function(name) {\n  this.name = name\n}\n\n// 测试对象：\np.setName('Jack')\nconsole.log(p.name, p.age)// 'Jack' 12\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象字面量模式\n\n * 套路：使用 { } 创建对象，同时指定属性和方法。\n\n * 适用场景：起始时对象内部的数据时确定的。\n\n * 问题：解决了上面的语句太多的问题。但是如果要创建多个对象时，存在重复代码。\n\n🌰 例子：\n\nvar p = { // 开始时确定对象的内部数据\n  name: 'Tom',\n  age: 12,\n  setName: function(name) {\n  this.name = name\n  }\n}\n\n// 测试对象：\nconsole.log(p.name, p.age) // 'Tom' 12\np.setName('Jack')\nconsole.log(p.name, p.age) // 'Jack' 12\n\nvar p2 = { \n  name: 'Bob',\n  age: 13,\n  setName: function(name) {\n  this.name = name\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 工厂模式\n\n * 套路：通过工厂函数动态创建对象并返回。\n * 适用场景：需要创建多个对象。\n * 存在问题：解决了要创建多个对象时存在重复语句的问题，但是返回的对象没有一个具体的类型，都是 Object 类型。\n\n🌰 例子：\n\nfunction createPerson(name, age) { \n  // 返回一个对象的函数（工厂函数）\n  var obj = {\n    name: name,\n    age: age,\n    setName: function(name) {\n      this.name = name\n    }\n  }\n  return obj\n}\n\n// 创建两个对象\nvar p1 = createPerson('Tom', 12)\nvar p2 = createPerson('Jack', 13)\n\n// 创建另一种对象时\nfunction createStudent(name, grade) {\n var obj = {\n    name: name,\n    grade: grade\n  }\n  return obj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 自定义函数构造模式\n\n * 套路：自定义构造函数，通过 new 创建对象\n * 适用场景：需要创建多个类型确定的对象。\n * 问题：每个对象（实际上）都有相同的数据，会浪费内存。\n\n🌰 例子：\n\n// 定义类型\nfunction Person(name, age) {\n  this.name = bane\n  this.age = age\n  this.setName = function(name) {\n      this.name = name\n    }\n}\n\nvar p1 = new Person('Tom', 12)\np1.setName('Jack')\nconsole.log(p1.name, p1.age)\n\nconosle.log(p1 instanceof Person)\n\nfunction Student(name, grade) {\n  this.name = name\n  this.grade = grade\n  this.setName = function(name) {\n      this.name = name\n    } \n}\n\nvar s = new Student('Bob', 1)\nconsole.log(s instanceof Student)\n\nvar p2 = new Person('Tom', 23)\nconsole.log(p1, p2) // 两个类型一样的对象，存在相同的数据\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 构造函数与原型组合模式\n\n * 套路：自定义构造函数，属性在函数中初始化，方法（共同点）添加到原型上。\n * 适用场景：需要创建多个类型确定的对象。\n\n🌰 例子：\n\nfunction Student(name, grade) {\n  // 在构造函数中只初始化一般属性\n  this.name = name\n  this.grade = grade\n}\n\nPerson.prototype.setName = function(name) {\n  this.name = name\n}\n\nvar p1 = new Person('Tom', 12)\nvar p2 = new Person('Jack', 18)\n\nconsole.log(p1, p2) // 两个类型相同的对象，但是方法保存在原型中 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 继承模式\n\n\n# 原型链继承\n\n * 🔗 套路：\n   1. 定义父类型构造函数\n   2. 给父类型的原型添加方法\n   3. 定义子类型的构造函数\n   4. ⚠️ 创建父类型的对象赋值给子类型的原型\n   5. 将子类型原型的构造属性设置为子类型\n   6. 给子类型原型添加方法\n   7. 创建子类型的对象，可以调用父类型的方法\n * ⚠️ 关键：子类型的原型为父类型的一个实例对象\n\n🌰 例子 ：\n\nfunction Super(){\n  this.superProp = 'Super property'\n}\nSuper.prototype.showSuperProperty = function () {\n  console.log(this.superProp)\n}\n\nfunction Sub() {\n  this.subProp = 'Sub property'\n}\n\n// 子类型的原型指向父类型的一个实例对象\nSub.prototype = new Super()\n// 让子类型的原型的constructor指向子类型\nSub.portotype.constructor() = Sub // 拨乱反正\nSub.prototype.showSubProperty = function () {\n  console.log(this.subProp)\n}\n\nvar sub = new Sub() //* 关键\nsub.showSuperProperty()\nsub.showSubProperty()\n\nconsole.log(sub.constructor()) // function Super()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n\n# 借用构造函数继承\n\n * 套路：\n   1. 定义父类型的构造函数\n   2. 定义子类型的构造函数\n   3. 在子类型构造函数中调用父类型的构造函数\n * 关键： ⚠️ 在子类型的构造函数中使用 call() 调用父类型的构造函数。\n\n🌰 例子：\n\nfunction Person(name, age) {\n  this.name = bane\n  this.age = age\n}\n\nfunction Student(name, age, grade) {\n  Person.call(this, name, age) \n  // 相当于 this.Person(name, age)\n  \t// this.name = name\n    // this.age = age\n  this.grade = grade\n} \n// 相当于Student借用Person的构造函数，但实际上没有继承\n\nvar s = new Student('Tom', 18, 1)\nconsole.log(s.name, s.age, s.grade)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 组合继承\n\n（是前面两种的结合）\n\n * 套路：原型链以及借用构造函数的组合继承\n   1. 利用原型链实现对父类型对象的方法继承。\n   2. 利用 call() 借用父类型构造函数初始化相同属性。\n\n🌰 例子：\n\nfunction Person(name, age) {\n  this.name = bane\n  this.age = age\n}\n\nPerson.prototype.setName = function (name) {\n  this.name = name\n}\n\nfunction Student(name, age, grade) {\n  Person.call(this, name, age)  // 为了得到父类型的属性\n  this.grade = grade\n} \n\nStudent.prototype = new Person() // 真正产生继承，为了最终能看到父类型中的方法\nStudent.prototype.constructor = Student\nStudent.prototype.setGrade = function(grade) {\n  this.grade = grade\n}\n\nvar s = new Student('Jack', 24, 1)\ns.setName('Bob')\ns.Grade(2)\nconsole.log(s.name, s.age, s.grade)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",normalizedContent:"# javascript 对象创建模式\n\n\n# object 构造函数模式\n\n * 套路：首先创建空的 object 对象，然后再动态添加属性和方法。\n * 适用场景：起始时不确定对象内部的数据\n * 存在问题：设计对象时语句太多。\n\n🌰 例子：\n\nvar p = new object() // 开始是未确定对象内部的数据\n\np.name = 'tom'\np.age = 12\np.setname = function(name) {\n  this.name = name\n}\n\n// 测试对象：\np.setname('jack')\nconsole.log(p.name, p.age)// 'jack' 12\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象字面量模式\n\n * 套路：使用 { } 创建对象，同时指定属性和方法。\n\n * 适用场景：起始时对象内部的数据时确定的。\n\n * 问题：解决了上面的语句太多的问题。但是如果要创建多个对象时，存在重复代码。\n\n🌰 例子：\n\nvar p = { // 开始时确定对象的内部数据\n  name: 'tom',\n  age: 12,\n  setname: function(name) {\n  this.name = name\n  }\n}\n\n// 测试对象：\nconsole.log(p.name, p.age) // 'tom' 12\np.setname('jack')\nconsole.log(p.name, p.age) // 'jack' 12\n\nvar p2 = { \n  name: 'bob',\n  age: 13,\n  setname: function(name) {\n  this.name = name\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 工厂模式\n\n * 套路：通过工厂函数动态创建对象并返回。\n * 适用场景：需要创建多个对象。\n * 存在问题：解决了要创建多个对象时存在重复语句的问题，但是返回的对象没有一个具体的类型，都是 object 类型。\n\n🌰 例子：\n\nfunction createperson(name, age) { \n  // 返回一个对象的函数（工厂函数）\n  var obj = {\n    name: name,\n    age: age,\n    setname: function(name) {\n      this.name = name\n    }\n  }\n  return obj\n}\n\n// 创建两个对象\nvar p1 = createperson('tom', 12)\nvar p2 = createperson('jack', 13)\n\n// 创建另一种对象时\nfunction createstudent(name, grade) {\n var obj = {\n    name: name,\n    grade: grade\n  }\n  return obj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 自定义函数构造模式\n\n * 套路：自定义构造函数，通过 new 创建对象\n * 适用场景：需要创建多个类型确定的对象。\n * 问题：每个对象（实际上）都有相同的数据，会浪费内存。\n\n🌰 例子：\n\n// 定义类型\nfunction person(name, age) {\n  this.name = bane\n  this.age = age\n  this.setname = function(name) {\n      this.name = name\n    }\n}\n\nvar p1 = new person('tom', 12)\np1.setname('jack')\nconsole.log(p1.name, p1.age)\n\nconosle.log(p1 instanceof person)\n\nfunction student(name, grade) {\n  this.name = name\n  this.grade = grade\n  this.setname = function(name) {\n      this.name = name\n    } \n}\n\nvar s = new student('bob', 1)\nconsole.log(s instanceof student)\n\nvar p2 = new person('tom', 23)\nconsole.log(p1, p2) // 两个类型一样的对象，存在相同的数据\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 构造函数与原型组合模式\n\n * 套路：自定义构造函数，属性在函数中初始化，方法（共同点）添加到原型上。\n * 适用场景：需要创建多个类型确定的对象。\n\n🌰 例子：\n\nfunction student(name, grade) {\n  // 在构造函数中只初始化一般属性\n  this.name = name\n  this.grade = grade\n}\n\nperson.prototype.setname = function(name) {\n  this.name = name\n}\n\nvar p1 = new person('tom', 12)\nvar p2 = new person('jack', 18)\n\nconsole.log(p1, p2) // 两个类型相同的对象，但是方法保存在原型中 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 继承模式\n\n\n# 原型链继承\n\n * 🔗 套路：\n   1. 定义父类型构造函数\n   2. 给父类型的原型添加方法\n   3. 定义子类型的构造函数\n   4. ⚠️ 创建父类型的对象赋值给子类型的原型\n   5. 将子类型原型的构造属性设置为子类型\n   6. 给子类型原型添加方法\n   7. 创建子类型的对象，可以调用父类型的方法\n * ⚠️ 关键：子类型的原型为父类型的一个实例对象\n\n🌰 例子 ：\n\nfunction super(){\n  this.superprop = 'super property'\n}\nsuper.prototype.showsuperproperty = function () {\n  console.log(this.superprop)\n}\n\nfunction sub() {\n  this.subprop = 'sub property'\n}\n\n// 子类型的原型指向父类型的一个实例对象\nsub.prototype = new super()\n// 让子类型的原型的constructor指向子类型\nsub.portotype.constructor() = sub // 拨乱反正\nsub.prototype.showsubproperty = function () {\n  console.log(this.subprop)\n}\n\nvar sub = new sub() //* 关键\nsub.showsuperproperty()\nsub.showsubproperty()\n\nconsole.log(sub.constructor()) // function super()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n\n# 借用构造函数继承\n\n * 套路：\n   1. 定义父类型的构造函数\n   2. 定义子类型的构造函数\n   3. 在子类型构造函数中调用父类型的构造函数\n * 关键： ⚠️ 在子类型的构造函数中使用 call() 调用父类型的构造函数。\n\n🌰 例子：\n\nfunction person(name, age) {\n  this.name = bane\n  this.age = age\n}\n\nfunction student(name, age, grade) {\n  person.call(this, name, age) \n  // 相当于 this.person(name, age)\n  \t// this.name = name\n    // this.age = age\n  this.grade = grade\n} \n// 相当于student借用person的构造函数，但实际上没有继承\n\nvar s = new student('tom', 18, 1)\nconsole.log(s.name, s.age, s.grade)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 组合继承\n\n（是前面两种的结合）\n\n * 套路：原型链以及借用构造函数的组合继承\n   1. 利用原型链实现对父类型对象的方法继承。\n   2. 利用 call() 借用父类型构造函数初始化相同属性。\n\n🌰 例子：\n\nfunction person(name, age) {\n  this.name = bane\n  this.age = age\n}\n\nperson.prototype.setname = function (name) {\n  this.name = name\n}\n\nfunction student(name, age, grade) {\n  person.call(this, name, age)  // 为了得到父类型的属性\n  this.grade = grade\n} \n\nstudent.prototype = new person() // 真正产生继承，为了最终能看到父类型中的方法\nstudent.prototype.constructor = student\nstudent.prototype.setgrade = function(grade) {\n  this.grade = grade\n}\n\nvar s = new student('jack', 24, 1)\ns.setname('bob')\ns.grade(2)\nconsole.log(s.name, s.age, s.grade)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 作用域与作用域链",frontmatter:{title:"🍎 JavaScript 作用域与作用域链",date:"2022-06-26T19:05:25.000Z",permalink:"/pages/8ae2cd/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 函数相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/03. 🍎 JavaScript 作用域与作用域链.md",key:"v-c81ae684",path:"/pages/8ae2cd/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:34},{level:3,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:21},{level:3,title:"词法作用域",slug:"词法作用域",normalizedTitle:"词法作用域",charIndex:1156},{level:2,title:"作用域与执行上下文",slug:"作用域与执行上下文",normalizedTitle:"作用域与执行上下文",charIndex:1453},{level:2,title:"作用域链",slug:"作用域链",normalizedTitle:"作用域链",charIndex:21}],headersStr:"概念 作用域 词法作用域 作用域与执行上下文 作用域链",content:"> 相关问题：\n> \n>  * 说一下你对作用域链的理解？\n\n\n# 概念\n\n\n# 作用域\n\n * 作用域：一个代码段所在的区域。它是静态的（相当于上下文对象），在编写代码时就确定了。\n   \n   作用域决定了代码区块中和其他资源的可见性。\n\n * 作用域分类：\n   \n   * 全局作用域：任何不在函数中或者大括号中声明的变量，都是在全局作用域中，全局作用域定义的变量可以在程序的任何位置中访问。\n     \n     var greeting = 'hello world'\n     function greet() {\n       console.log(greeting)\n     }\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 函数作用域：也叫局部作用句。变量在函数内部声明，这些变量只能在函数内部访问，不能在函数以外的访问。\n     \n     function greet() {\n       var greeting = 'hello world'\n       console.log(greeting)\n     }\n     \n     greet()\n     console.log(greeting) // Uncaught ReferenceError: greeting is not defined\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * 块级作用域：ES6 引入了 let 和 const 关键字。在大括号中使用 let 和 const 声明的变量存在于块级作用域，在大括号之外不能访问这些变量。（使用 var 声明的不存在块级作用域变量）\n     \n     {\n       // 块级作用域中的变量\n       let greeting = 'Hello World!';\n       var lang = 'English';\n       console.log(greeting);\n     }\n     \n     console.log(lang); // English\n     console.log(greeting); // Uncaught ReferenceError: greeting is not defined\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n * 作用：隔离变量，不同作用域下同名变量不会有冲突。\n\n\n# 词法作用域\n\n又称静态作用域，在变量被创建时就已经确定好了，而非执行阶段确定（也就是说，在写好代码时作用域就确定了），JavaScript 遵循的是词法作用域。\n\n🌰 例子：\n\nvar a = 2\nfunction foo() {\n  console.log(a)\n}\n\nfunction bar() {\n  var a = 3\n  foo()\n}\nbar()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 上面的运行过程可以看作：\n> \n> 由于 JavaScript 遵循的是词法作用域，相同层级的 foo 和 bar 没有办法访问到彼此作用域块的变量，所以输出的是 2\n\n\n# 作用域与执行上下文\n\n * 区别 ：\n   * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时。\n   * 全局执行上下文环境是在全局作用域确定之后， JavaScript 代码马上执行之前创建。（词法作用域）\n   * 函数执行上下文环境是在调用函数时，函数体代码执行之前创建。\n * 区别 ：\n   * 作用域是静态的，只要函数定义好了就一直存在并且不会再变化。\n   * 上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放。\n * 联系：\n   * 上下文环境（对象） 是从属于所在的作用域。\n   * 全局上下文环境从属于全局作用域。\n   * 函数上下文环境从属于对应的函数使用域。\n\n注意\n\n两个 n+1：\n\n * 在判断执行上下文个数中：n 为调用的函数个数。\n * 在判断作用域个数中：n 为定义的函数个数。\n\n\n# 作用域链\n\nJavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找变量，如果没找到会在上层作用域寻找，以此类推直到找到该变量或者到达全局作用域。如果全局作用域找不到该变量则报错。\n\n * 作用域链是多个上下级关系的作用域形成的链，它的方向时从下向上的（从内到外）。\n\n * 查找变量就是沿着作用链来查找的。\n   \n   查找一个变量的查找规则：\n   \n   1. 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入 2.\n   2. 在上一级作用域的执行上下文中查找相应的属性，如果有直接返回，否则进入 3.\n   3. 再次执行 2. 的相同操作，直到全局作用域，如果还找不到就抛出找不到变量的异常。\n\n🌰 例子：\n\nvar a = 2\nfunction fn1() {\n  var b = 3\n  function fn2() {\n    var c = 4\n    console.log(c) // 4\n    console.log(b) // 3\n    console.log(a) // 2\n    console.log(d) // ReferenceError: Can't find variable: d \n  }\n  fn2()\n}\nfn1()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n🌰 例子：\n\nvar fn = function () {\n  console.log(fn)\n}\nfn()\n\nvar obj = {\n  fn2: function (){\n    console.log(fn2) //ReferenceError: Can't find variable: fn2 \n    // console.log(this.fn2)\n  }\n}\nobj.fn2()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"> 相关问题：\n> \n>  * 说一下你对作用域链的理解？\n\n\n# 概念\n\n\n# 作用域\n\n * 作用域：一个代码段所在的区域。它是静态的（相当于上下文对象），在编写代码时就确定了。\n   \n   作用域决定了代码区块中和其他资源的可见性。\n\n * 作用域分类：\n   \n   * 全局作用域：任何不在函数中或者大括号中声明的变量，都是在全局作用域中，全局作用域定义的变量可以在程序的任何位置中访问。\n     \n     var greeting = 'hello world'\n     function greet() {\n       console.log(greeting)\n     }\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 函数作用域：也叫局部作用句。变量在函数内部声明，这些变量只能在函数内部访问，不能在函数以外的访问。\n     \n     function greet() {\n       var greeting = 'hello world'\n       console.log(greeting)\n     }\n     \n     greet()\n     console.log(greeting) // uncaught referenceerror: greeting is not defined\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * 块级作用域：es6 引入了 let 和 const 关键字。在大括号中使用 let 和 const 声明的变量存在于块级作用域，在大括号之外不能访问这些变量。（使用 var 声明的不存在块级作用域变量）\n     \n     {\n       // 块级作用域中的变量\n       let greeting = 'hello world!';\n       var lang = 'english';\n       console.log(greeting);\n     }\n     \n     console.log(lang); // english\n     console.log(greeting); // uncaught referenceerror: greeting is not defined\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n * 作用：隔离变量，不同作用域下同名变量不会有冲突。\n\n\n# 词法作用域\n\n又称静态作用域，在变量被创建时就已经确定好了，而非执行阶段确定（也就是说，在写好代码时作用域就确定了），javascript 遵循的是词法作用域。\n\n🌰 例子：\n\nvar a = 2\nfunction foo() {\n  console.log(a)\n}\n\nfunction bar() {\n  var a = 3\n  foo()\n}\nbar()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 上面的运行过程可以看作：\n> \n> 由于 javascript 遵循的是词法作用域，相同层级的 foo 和 bar 没有办法访问到彼此作用域块的变量，所以输出的是 2\n\n\n# 作用域与执行上下文\n\n * 区别 ：\n   * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时。\n   * 全局执行上下文环境是在全局作用域确定之后， javascript 代码马上执行之前创建。（词法作用域）\n   * 函数执行上下文环境是在调用函数时，函数体代码执行之前创建。\n * 区别 ：\n   * 作用域是静态的，只要函数定义好了就一直存在并且不会再变化。\n   * 上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放。\n * 联系：\n   * 上下文环境（对象） 是从属于所在的作用域。\n   * 全局上下文环境从属于全局作用域。\n   * 函数上下文环境从属于对应的函数使用域。\n\n注意\n\n两个 n+1：\n\n * 在判断执行上下文个数中：n 为调用的函数个数。\n * 在判断作用域个数中：n 为定义的函数个数。\n\n\n# 作用域链\n\njavascript 中使用一个变量时，javascript 引擎会尝试在当前作用域下去寻找变量，如果没找到会在上层作用域寻找，以此类推直到找到该变量或者到达全局作用域。如果全局作用域找不到该变量则报错。\n\n * 作用域链是多个上下级关系的作用域形成的链，它的方向时从下向上的（从内到外）。\n\n * 查找变量就是沿着作用链来查找的。\n   \n   查找一个变量的查找规则：\n   \n   1. 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入 2.\n   2. 在上一级作用域的执行上下文中查找相应的属性，如果有直接返回，否则进入 3.\n   3. 再次执行 2. 的相同操作，直到全局作用域，如果还找不到就抛出找不到变量的异常。\n\n🌰 例子：\n\nvar a = 2\nfunction fn1() {\n  var b = 3\n  function fn2() {\n    var c = 4\n    console.log(c) // 4\n    console.log(b) // 3\n    console.log(a) // 2\n    console.log(d) // referenceerror: can't find variable: d \n  }\n  fn2()\n}\nfn1()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n🌰 例子：\n\nvar fn = function () {\n  console.log(fn)\n}\nfn()\n\nvar obj = {\n  fn2: function (){\n    console.log(fn2) //referenceerror: can't find variable: fn2 \n    // console.log(this.fn2)\n  }\n}\nobj.fn2()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 闭包",frontmatter:{title:"🍎 JavaScript 闭包",date:"2022-06-26T19:03:07.000Z",permalink:"/pages/7a9353/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 函数相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20JavaScript%20%E9%97%AD%E5%8C%85.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/02. 🍎 JavaScript 闭包.md",key:"v-96855454",path:"/pages/7a9353/",headers:[{level:2,title:"概念解释",slug:"概念解释",normalizedTitle:"概念解释",charIndex:42},{level:2,title:"闭包的使用场景",slug:"闭包的使用场景",normalizedTitle:"闭包的使用场景",charIndex:29},{level:2,title:"闭包的注意事项",slug:"闭包的注意事项",normalizedTitle:"闭包的注意事项",charIndex:2179},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2857}],headersStr:"概念解释 闭包的使用场景 闭包的注意事项 参考",content:"> 相关问题：\n> \n>  * 对闭包的理解？\n>  * 闭包的使用场景？\n\n\n# 概念解释\n\n * 闭包：一个函数以及其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合称为闭包。\n   \n   简单地说，闭包是可以使内层函数访问到其外层函数的作用域。\n\n🌰 例子：\n\nfunction init() {\n  var name = \"Mozila\";\n  function displayName() {\n    alert(name);\n  }\n  displayName();\n}\n\ninit()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> displayName 函数没有自己的局部变量，但是由于闭包的特性，可以访问到函数外部的变量。\n\n\n# 闭包的使用场景\n\n使用场景特点：\n\n * 创建私有变量；\n * 延长变量的生命周期。\n\n> 一般函数的词法环境会在函数返回后就被销毁，而闭包会保存对创建时所在的词法环境的引用，即便创建时所在的执行上下文被销毁，但是创建时的词法环境依然存在，以达到延长变量的生命周期的目的。\n\n相关使用场景的例子：\n\n🌰 例子 / 调整字号按钮：\n\nfunction makeSizer(size) {\n  return function() {\n    document.body.style.fontStyle = size + 'px'\n  }\n}\n\nvar size12 = makeSizer(12)\nvar size14 = makeSizer(14)\nvar size16 = makeSizer(16)\n\ndocument.getElementById('size-12').onclick = size12;\ndocument.getElementById('size-14').onclick = size14;\ndocument.getElementById('size-16').onclick = size16;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n🌰 例子 / 柯里化函数：\n\n> 柯里化的目的在于避免频繁调用具有相同参数的函数的同时，又能轻松重用函数。\n\n// 获取矩形面积的函数\nfunction getArea(width, height) {\n  return width * height;\n}\n\nconst area1 = getArea(10, 20)\nconst area1 = getArea(10, 30)\nconst area1 = getArea(10, 40)\n\n// 可以使用闭包柯里化这个函数\nfunction getArea(width) {\n  return height => {\n    return width * height\n  }\n}\n\nconst getTenWidthArea = getArea(10)\nconst area1 = getTenWidthArea(20) // 相当于 getArea(10,20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / 使用闭包模拟私有方法：\n\n> JavaScript 中不支持声明私有变量，可以通过 闭包 实现模拟私有方法。\n\nvar makeCounter = (function() {\n  var privateCounter = 0;\n\n  function changeBy(val) {\n    privateCounter += val;\n  }\n\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1)\n    },\n    value: function() {\n      return privateCounter\n    }\n  }\n})();\n\nvar Counter1 = makeCounter\nvar Counter2 = makeCounter\nconsole.log(Counter1.value())\nCounter1.increment()\nconsole.log(Counter1.value())\nCounter1.decrement()\nconsole.log(Counter1.value())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> 上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式。\n> \n> 两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量。\n\n🌰 其他例子：例如延迟调用、回调等闭包的应用，核心思想还是差 u 你姑姐爱你私有变量和延长变量的生命周期。\n\n\n# 闭包的注意事项\n\n如果不是某些特定的任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本的性能具有负面影响。\n\n🌰 例子 / 创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造其中。\n\nfunction MyObject(name, message) {\n  this.name = name.toString()\n  this.message = message.toString()\n  this.getName = function() {\n    return this.name\n  }\n  this.getMessage = function() {\n    return this.message\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此处应该修改为 原型，因为此处并没有应用闭包的优点，应该避免使用闭包：\n\nfunction MyObject(name, message) {\n  this.name = name.toString()\n  this.message = message.toString()\n}\n\nMyObject.prototype.getName = function () {\n  return this.name\n}\n\nMyObject.prototype.getMessage = function () {\n  return this.message\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 参考\n\n * 面试官：说说你对闭包的理解？闭包使用场景 | web 前端面试 - 面试官系列 (vue3js.cn)",normalizedContent:"> 相关问题：\n> \n>  * 对闭包的理解？\n>  * 闭包的使用场景？\n\n\n# 概念解释\n\n * 闭包：一个函数以及其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合称为闭包。\n   \n   简单地说，闭包是可以使内层函数访问到其外层函数的作用域。\n\n🌰 例子：\n\nfunction init() {\n  var name = \"mozila\";\n  function displayname() {\n    alert(name);\n  }\n  displayname();\n}\n\ninit()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> displayname 函数没有自己的局部变量，但是由于闭包的特性，可以访问到函数外部的变量。\n\n\n# 闭包的使用场景\n\n使用场景特点：\n\n * 创建私有变量；\n * 延长变量的生命周期。\n\n> 一般函数的词法环境会在函数返回后就被销毁，而闭包会保存对创建时所在的词法环境的引用，即便创建时所在的执行上下文被销毁，但是创建时的词法环境依然存在，以达到延长变量的生命周期的目的。\n\n相关使用场景的例子：\n\n🌰 例子 / 调整字号按钮：\n\nfunction makesizer(size) {\n  return function() {\n    document.body.style.fontstyle = size + 'px'\n  }\n}\n\nvar size12 = makesizer(12)\nvar size14 = makesizer(14)\nvar size16 = makesizer(16)\n\ndocument.getelementbyid('size-12').onclick = size12;\ndocument.getelementbyid('size-14').onclick = size14;\ndocument.getelementbyid('size-16').onclick = size16;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n🌰 例子 / 柯里化函数：\n\n> 柯里化的目的在于避免频繁调用具有相同参数的函数的同时，又能轻松重用函数。\n\n// 获取矩形面积的函数\nfunction getarea(width, height) {\n  return width * height;\n}\n\nconst area1 = getarea(10, 20)\nconst area1 = getarea(10, 30)\nconst area1 = getarea(10, 40)\n\n// 可以使用闭包柯里化这个函数\nfunction getarea(width) {\n  return height => {\n    return width * height\n  }\n}\n\nconst gettenwidtharea = getarea(10)\nconst area1 = gettenwidtharea(20) // 相当于 getarea(10,20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / 使用闭包模拟私有方法：\n\n> javascript 中不支持声明私有变量，可以通过 闭包 实现模拟私有方法。\n\nvar makecounter = (function() {\n  var privatecounter = 0;\n\n  function changeby(val) {\n    privatecounter += val;\n  }\n\n  return {\n    increment: function() {\n      changeby(1);\n    },\n    decrement: function() {\n      changeby(-1)\n    },\n    value: function() {\n      return privatecounter\n    }\n  }\n})();\n\nvar counter1 = makecounter\nvar counter2 = makecounter\nconsole.log(counter1.value())\ncounter1.increment()\nconsole.log(counter1.value())\ncounter1.decrement()\nconsole.log(counter1.value())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> 上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式。\n> \n> 两个计数器 counter1 和 counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量。\n\n🌰 其他例子：例如延迟调用、回调等闭包的应用，核心思想还是差 u 你姑姐爱你私有变量和延长变量的生命周期。\n\n\n# 闭包的注意事项\n\n如果不是某些特定的任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本的性能具有负面影响。\n\n🌰 例子 / 创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造其中。\n\nfunction myobject(name, message) {\n  this.name = name.tostring()\n  this.message = message.tostring()\n  this.getname = function() {\n    return this.name\n  }\n  this.getmessage = function() {\n    return this.message\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此处应该修改为 原型，因为此处并没有应用闭包的优点，应该避免使用闭包：\n\nfunction myobject(name, message) {\n  this.name = name.tostring()\n  this.message = message.tostring()\n}\n\nmyobject.prototype.getname = function () {\n  return this.name\n}\n\nmyobject.prototype.getmessage = function () {\n  return this.message\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 参考\n\n * 面试官：说说你对闭包的理解？闭包使用场景 | web 前端面试 - 面试官系列 (vue3js.cn)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript this 指向问题",frontmatter:{title:"🍎 JavaScript this 指向问题",date:"2022-06-26T19:04:23.000Z",permalink:"/pages/b16ce1/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 函数相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/05.%20%F0%9F%8D%8E%20JavaScript%20%20this%20%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/05. 🍎 JavaScript  this 指向问题.md",key:"v-4291a2a5",path:"/pages/b16ce1/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:46},{level:3,title:"this 指向什么？",slug:"this-指向什么",normalizedTitle:"this 指向什么？",charIndex:340},{level:2,title:"绑定规则",slug:"绑定规则",normalizedTitle:"绑定规则",charIndex:653},{level:3,title:"默认绑定",slug:"默认绑定",normalizedTitle:"默认绑定",charIndex:687},{level:3,title:"隐式绑定",slug:"隐式绑定",normalizedTitle:"隐式绑定",charIndex:2082},{level:3,title:"显式修改绑定",slug:"显式修改绑定",normalizedTitle:"显式修改绑定",charIndex:3145},{level:3,title:"内置函数",slug:"内置函数",normalizedTitle:"内置函数",charIndex:3996},{level:3,title:"new 绑定",slug:"new-绑定",normalizedTitle:"new 绑定",charIndex:5101},{level:3,title:"绑定的优先级",slug:"绑定的优先级",normalizedTitle:"绑定的优先级",charIndex:5820},{level:2,title:"其他情况绑定规则",slug:"其他情况绑定规则",normalizedTitle:"其他情况绑定规则",charIndex:6846},{level:3,title:"忽略规则绑定",slug:"忽略规则绑定",normalizedTitle:"忽略规则绑定",charIndex:6859},{level:3,title:"间接函数引用",slug:"间接函数引用",normalizedTitle:"间接函数引用",charIndex:7170},{level:3,title:"箭头函数的 this 指向",slug:"箭头函数的-this-指向",normalizedTitle:"箭头函数的 this 指向",charIndex:7590},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:8559}],headersStr:"概念 this 指向什么？ 绑定规则 默认绑定 隐式绑定 显式修改绑定 内置函数 new 绑定 绑定的优先级 其他情况绑定规则 忽略规则绑定 间接函数引用 箭头函数的 this 指向 参考",content:'> 相关问题：\n> \n>  * JavaScript 中对函数 this 的理解？\n\n\n# 概念\n\nthis 关键字时函数运行时自动生成的一个 内部对象。只能在函数内部使用，总是指向 调用它 的对象。 this 可以更加使用便捷的方式来引用对象，进行一些 API 设计时，代码更加简洁和易于复用。\n\n绝大多数情况下，函数的调用方式决定了 this 的值（调用时绑定）。同时 this 在函数执行的过程中，一旦被确定了就不能再更改。\n\n> this 是什么：\n> \n>  * 任何函数本质上都是通过某个对象来调用的，⭐️ 如果没有制定就是全局作用域下的 window 。\n> \n>  * 所有函数内部都有一个变量 this ；\n> \n>  * 它的值是调用函数的当前对象；\n\n\n# this 指向什么？\n\n在全局作用域下：\n\n * 浏览器中 this 没有指定时，为 window ；\n * 所以全局作用域下，一般 this 指向的是 window ；\n\n但是开发中很少在全局作用域下使用 this ，一般在函数中使用 this 。\n\n在函数被调用时，都会创建一个 执行上下文。这个执行上下文中记录函数的调用栈、函数的调用方法、传入的参数信息等； this 是函数内部其中的一个属性。\n\n * 函数在定义时，默认会给 this 绑定一个值；\n\n * this 的绑定和定义的位置（编写的位置）没有关系；\n\n * this 的绑定与调用方式和调用的位置有关系。\n\n * this 是在运行时被绑定的。\n\n\n# 绑定规则\n\n根据不同的使用场景， this 会有不同的值。\n\n\n# 默认绑定\n\n在独立的函数中调用，意味着函数没有绑定到每个对象上进行调用。可以分为两种情况：\n\n * 普通函数调用。函数直接被调用，并没有任何的对象关联。这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的 this 指向全局对象 window 。\n   \n   此时全局环境中定义的变量，在函数中可以通过 this 获取。（针对 var 生命的变量）\n   \n   🌰 例子：\n   \n   var name = "Simon"\n   function person() {\n     return this.name\n   }\n   console.log(person()) // Simon\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 调用 this 的对象是函数，而函数本身没有 name 这个变量，所以往外找，最终找到指向 window 。\n   > \n   > 严格模式下，不能讲全局对象用于默认绑定， this 会绑定到 undefined 。\n\n * 函数调用链：所有的函数调用都没有被绑定到某个对象上。\n   \n   🌰 例子：\n   \n   function test1() {\n     console.log(this); // window\n     test2();\n   }\n   \n   function test2() {\n     console.log(this); // window\n     test3()\n   }\n   \n   function test3() {\n     console.log(this); // window\n   }\n   test1();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n * 将函数作为参数，传入到另一个函数中：\n   \n   🌰 例子：\n   \n   function foo(func) {\n     func()\n   }\n   \n   function bar() {\n     console.log(this) // window\n   }\n   \n   foo(bar)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   🌰 🌟 例子 ：\n   \n   function foo(func) {\n     func()\n   }\n   \n   var obj = {\n     name: "why",\n     bar: function() {\n       console.log(this); // window\n     }\n   }\n   \n   foo(obj.bar);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   > 此时的函数虽然在对象之中，但是真正调用函数的位置，并没有进行任何的对象绑定，只是一个独立函数的调用，所以这里的 this 仍然为 window 。\n\n\n# 隐式绑定\n\n函数还可以作为某个对象的方法调用，此时 this 指向的就是这个上级对象。可以分为以下的情况：\n\n * 通过对象调用函数：\n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this) // obj\n   }\n   \n   var obj = {\n     name: "Simon",\n     foo: foo\n   }\n   \n   obj.foo()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this) // obj1\n   }\n   \n   var obj1 = {\n     name: "Simon",\n     foo: foo\n   }\n   \n   var obj2 = {\n     name: "Simon2",\n     obj1: obj1\n   }\n   \n   obj2.obj1.foo()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 此时， foo 调用的位置仍然是 obj1 ，所以这里 this 绑定的对象仍然是 obj1 。\n\n * 隐式丢失：\n   \n   function foo() {\n     console.log(this) // window\n   }\n   \n   var obj = {\n     name: "Simon",\n     foo: foo\n   }\n   \n   var bar = obj1.foo\n   bar()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   > 因为这里 foo 被调用的位置时 bar ，而 bar 在进行调用的时候没有绑定任何的对象，也就是没有形成隐形绑定。相当于默认绑定。\n\n隐式绑定有一个前提条件：必须在调用的对象内部有一个对函数的引用（例如一个属性）。如果没有这样的引用，在进行调用的时候，会报找不到该函数的错误。正是通过这个引用，间接地将 this 绑定到这个对象上。\n\n\n# 显式修改绑定\n\n如果不希望在对象内部包含这个函数的引用，又希望在这个对象上强制调用。使用 apply / call / bind 方法。改变函数调用的对象，它们的第一个参数表示改变后调用这个函数的对象，因此 this 指向这个对象，这个过程明确的指定了 this 指向的对象所以称为显式绑定。\n\n> JavaScript 的所有函数都可以使用 call / apply 方法。\n\n * call / apply ：\n   \n   两者的区别知识参数上的传递有区别：🚃 JavaScript 装饰器模式和转发 | notebook (simon1uo.github.io)，功能类似。\n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this)\n   }\n   \n   foo.call(window) // window\n   foo.call({name: "simon"}) // {name: "simon"}\n   foo.call(123) // Number 对象存放123\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * bind ：如果希望函数总是显式绑定到一个对象上，这样每次调用函数时就不用每次都绑定 this 到一个特定的对象上。\n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this) // window\n   }\n   \n   var obj = {\n     name: "simon"\n   }\n   \n   var bar = foo.bind(obj)\n   \n   bar() // obj\n   bar() // obj\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 内置函数\n\n在 JavaScript 的内置函数（或者第三方库中的内置函数），这些内置函数允许传入另一个函数（回调函数），此时我们不会显式调用这些函数，而是 JavaScript 内部帮助我们执行。\n\n * setTimeout() ：\n   \n   🌰 例子：\n   \n   setTimeout(function() {\n     console.log(this) // window\n   }, 1000)\n   \n   \n   1\n   2\n   3\n   \n   \n   > 与 setTimeout 的内部调用有关。 setTimeout 内部通过 apply 绑定 this 对象，并且绑定的是 window 对象。\n\n * forEach() ：\n   \n   🌰 例子：\n   \n   var names = [\'abc\', \'def\', \'ghi\']\n   names.forEach(function(name) {\n     console.log(this) // window*3\n   })\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 默认情况下传入的函数是自动调用函数（默认绑定）；\n   \n   可以根据 forEach(value, thisArg) 的方法传入第二个参数，改变传入的对象：\n   \n   var obj = {name: "why"};\n   names.forEach(function(name) {\n     console.log(this) // window*3\n   }, obj)\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * HTML 元素的点击：\n   \n   🌰 例子 / div ：\n   \n   <div class="box"></div>\n   \n   \n   1\n   \n   \n   var box = document.querySelector(".box");\n   box.onclick = function() {\n     console.log(this); // box对象\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 因为发生点击时，执行传入的回调函数被调用时，会将 box 对象绑定到该函数中。\n\n传入到内置函数的回调函数 this ：\n\n * 某些内置函数很难判断。一方面可以分析源码，另一方面通过经验判断。无论如何最终都是根据之前的 默认绑定或者隐式 / 显式绑定。\n\n\n# new 绑定\n\nJavaScript 通过构造器 new 关键字生成一个实例对象，此时 this 指向这个实例对象。\n\n> 步骤：\n> \n>  * 创建一个全新的对象；\n>  * 这个新对象会被执行 Prototype 连接；\n>  * 这个新对象会绑定到函数调用的 this 上（ this 的绑定在这个步骤完成）；\n>  * 如果函数没有返回其他对象，表达式会返回这个新对象；\n\n🌰 例子：\n\nfunction test() {\n  this.x = 1\n}\n\nvar obj = new test()\nobj.x // 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 之所以 obj.x 为 1 ，是因为 new 改变了 this 的指向。\n\n🌰 例子 / 特殊情况：\n\nfunction fn() {\n  this.user = \'xxx\'\n  return {}\n}\nvar a = new fn()\nconsole.log(a.user) // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 此时 new 的过程中遇到了一个 return ，此时 this 指向的是返回的对象。\n> \n> 当返回的是一个简单类型时， this 指向实例对象：\n> \n> function fn() {\n>   this.user = \'xxx\'\n>   return 1\n> }\n> var a = new fn()\n> console.log(a.user) // xxx\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> \n> \n> 当返回的是 null 时，虽然也是对象，但是此时 this 指向实例对象。\n\n\n# 绑定的优先级\n\n显示绑定 > new 绑定 > 隐式绑定 > 默认绑定\n\n * 因为存在其他规则是，就会使用其他规则绑定 this 。而不是默认绑定，所以默认绑定的优先级最低。\n\n🌰 例子 / 隐式绑定与显式绑定比较：\n\nfunction foo() {\n  console.log(this.a)\n}\n\nvar obj1 = {\n  a: 2,\n  foo: foo\n}\n\nvar obj2 = {\n  a: 3,\n  foo: foo\n}\n\nobj1.foo() // 2\nobj2.foo() // 3\nobj1.foo.call(obj2) // 3\nobj2,foo.call(obj1) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / new 绑定与隐式绑定比较：\n\nfunction foo(something) {\n  this.a = something\n}\n\nvar obj1 = {\n  foo: foo\n}\nvar obj2 = {}\n\nobj1.foo(2)\nconsole.log(obj1.a) // 2\n\nobj1.foo.call(obj2, 3) // 3\nconsole.log(obj2.a) // 3\n\nvar bar = new obj1.foo(4)\nconsole.log(obj1.a) // 2\nconsole.log(bar.a) // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / new 绑定与显示绑定比较：\n\nfunction foo(something) {\n  this.a = something\n}\n\nvar obj1 = {}\nvar bar = foo.bind(obj1)\nbar(2)\nconsole.log(obj1.a) // 2\n\nvar baz = new bar(3);\nconsole.log(obj1.a) // 2\nconsole.log(baz.a) // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> bar 被绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。但是， new 修改了绑定调用 bar() 中的 this\n\n\n# 其他情况绑定规则\n\n\n# 忽略规则绑定\n\n如果在显式绑定中，绑定对象时传入的参数为 undefined 或者 null ，那么这个显式绑定就会被忽略，然后使用默认规则。\n\n🌰 例子：\n\nfunction foo() {\n  console.log(this)\n}\n\nvar obj = {\n  name = "simon"\n}\n\nfoo.call(obj) // obj\nfoo.call(undefined) // window\nfoo.call(null) // window\n\nvar bar = foo.bind(null)\nbar() // window\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 间接函数引用\n\n创建函数的间接引用，这时使用默认绑定规则。\n\n🌰 例子：\n\nvar num1 = 100\nvar num2 = 0\nvar result = (num2 = num1)\nconsole.log(result) // 100\n\n\n1\n2\n3\n4\n\n\n引申到：\n\nfunction foo() {\n  console.log(this)\n}\n\nvar obj1 = {\n  name = "obj1",\n  foo: foo\n}\n\nvar obj2 = {\n \tname = "obj2" \n}\n\nobj1.foo() // obj1\n(obj2.foo = obj1.foo)() // window \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 因为赋值 (obj2.foo = obj1.foo) 的结果是 foo 函数。所以 foo 函数被直接调用，使用默认绑定规则。\n\n\n# 箭头函数的 this 指向\n\nES6 中箭头函数的语法，不使用四种绑定规则（不绑定 this ），而是由外层作用域决定 this 。\n\n🌰 例子：\n\nvar obj = {\n  data: [],\n  getData: function() {\n    var _this = this;\n    setTimeout(function() {\n      // 模拟获取到的数据\n      var res = ["abc", "cba", "nba"];\n      _this.data.push(...res);\n    }, 1000);\n  }\n}\n\nobj.getData();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 使用 setTimeout 来模拟网络请求，需要通过 this 获取 obj 对象存放到 data 。但是 setTimeout 中的函数直接的 this 绑定的是 window ，所以需要在外层定义 var _this = this 。\n\n如果使用 箭头函数，可以直接使用 this 。因为箭头函数不会绑定 this 对象，那么 this 引用就会从上层作用域找到对应的 this ：\n\nvar obj = {\n  data: [],\n  getData: function() {\n    setTimeout(() => {\n      // 模拟获取到的数据\n      var res = ["abc", "cba", "nba"];\n      this.data.push(...res);\n    }, 1000);\n  }\n}\n\nobj.getData();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果 getData 也是箭头函数：\n\nvar obj = {\n  data: [],\n  getData: () => {\n    setTimeout(() => {\n      console.log(this)\n    }, 1000);\n  }\n}\n\nobj.getData();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 那么 this 会从上层作用域找，找到全局作用域。所以为 window 。\n\n\n# 参考\n\n * 面试官：谈谈 this 对象的理解 | web 前端面试 - 面试官系列 (vue3js.cn)\n * 前端面试之彻底搞懂 this 指向 (qq.com)\n * 尚硅谷 JavaScript 进阶教程\n * this - JavaScript | MDN (mozilla.org)',normalizedContent:'> 相关问题：\n> \n>  * javascript 中对函数 this 的理解？\n\n\n# 概念\n\nthis 关键字时函数运行时自动生成的一个 内部对象。只能在函数内部使用，总是指向 调用它 的对象。 this 可以更加使用便捷的方式来引用对象，进行一些 api 设计时，代码更加简洁和易于复用。\n\n绝大多数情况下，函数的调用方式决定了 this 的值（调用时绑定）。同时 this 在函数执行的过程中，一旦被确定了就不能再更改。\n\n> this 是什么：\n> \n>  * 任何函数本质上都是通过某个对象来调用的，⭐️ 如果没有制定就是全局作用域下的 window 。\n> \n>  * 所有函数内部都有一个变量 this ；\n> \n>  * 它的值是调用函数的当前对象；\n\n\n# this 指向什么？\n\n在全局作用域下：\n\n * 浏览器中 this 没有指定时，为 window ；\n * 所以全局作用域下，一般 this 指向的是 window ；\n\n但是开发中很少在全局作用域下使用 this ，一般在函数中使用 this 。\n\n在函数被调用时，都会创建一个 执行上下文。这个执行上下文中记录函数的调用栈、函数的调用方法、传入的参数信息等； this 是函数内部其中的一个属性。\n\n * 函数在定义时，默认会给 this 绑定一个值；\n\n * this 的绑定和定义的位置（编写的位置）没有关系；\n\n * this 的绑定与调用方式和调用的位置有关系。\n\n * this 是在运行时被绑定的。\n\n\n# 绑定规则\n\n根据不同的使用场景， this 会有不同的值。\n\n\n# 默认绑定\n\n在独立的函数中调用，意味着函数没有绑定到每个对象上进行调用。可以分为两种情况：\n\n * 普通函数调用。函数直接被调用，并没有任何的对象关联。这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的 this 指向全局对象 window 。\n   \n   此时全局环境中定义的变量，在函数中可以通过 this 获取。（针对 var 生命的变量）\n   \n   🌰 例子：\n   \n   var name = "simon"\n   function person() {\n     return this.name\n   }\n   console.log(person()) // simon\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 调用 this 的对象是函数，而函数本身没有 name 这个变量，所以往外找，最终找到指向 window 。\n   > \n   > 严格模式下，不能讲全局对象用于默认绑定， this 会绑定到 undefined 。\n\n * 函数调用链：所有的函数调用都没有被绑定到某个对象上。\n   \n   🌰 例子：\n   \n   function test1() {\n     console.log(this); // window\n     test2();\n   }\n   \n   function test2() {\n     console.log(this); // window\n     test3()\n   }\n   \n   function test3() {\n     console.log(this); // window\n   }\n   test1();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n * 将函数作为参数，传入到另一个函数中：\n   \n   🌰 例子：\n   \n   function foo(func) {\n     func()\n   }\n   \n   function bar() {\n     console.log(this) // window\n   }\n   \n   foo(bar)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   🌰 🌟 例子 ：\n   \n   function foo(func) {\n     func()\n   }\n   \n   var obj = {\n     name: "why",\n     bar: function() {\n       console.log(this); // window\n     }\n   }\n   \n   foo(obj.bar);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   > 此时的函数虽然在对象之中，但是真正调用函数的位置，并没有进行任何的对象绑定，只是一个独立函数的调用，所以这里的 this 仍然为 window 。\n\n\n# 隐式绑定\n\n函数还可以作为某个对象的方法调用，此时 this 指向的就是这个上级对象。可以分为以下的情况：\n\n * 通过对象调用函数：\n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this) // obj\n   }\n   \n   var obj = {\n     name: "simon",\n     foo: foo\n   }\n   \n   obj.foo()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this) // obj1\n   }\n   \n   var obj1 = {\n     name: "simon",\n     foo: foo\n   }\n   \n   var obj2 = {\n     name: "simon2",\n     obj1: obj1\n   }\n   \n   obj2.obj1.foo()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 此时， foo 调用的位置仍然是 obj1 ，所以这里 this 绑定的对象仍然是 obj1 。\n\n * 隐式丢失：\n   \n   function foo() {\n     console.log(this) // window\n   }\n   \n   var obj = {\n     name: "simon",\n     foo: foo\n   }\n   \n   var bar = obj1.foo\n   bar()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   > 因为这里 foo 被调用的位置时 bar ，而 bar 在进行调用的时候没有绑定任何的对象，也就是没有形成隐形绑定。相当于默认绑定。\n\n隐式绑定有一个前提条件：必须在调用的对象内部有一个对函数的引用（例如一个属性）。如果没有这样的引用，在进行调用的时候，会报找不到该函数的错误。正是通过这个引用，间接地将 this 绑定到这个对象上。\n\n\n# 显式修改绑定\n\n如果不希望在对象内部包含这个函数的引用，又希望在这个对象上强制调用。使用 apply / call / bind 方法。改变函数调用的对象，它们的第一个参数表示改变后调用这个函数的对象，因此 this 指向这个对象，这个过程明确的指定了 this 指向的对象所以称为显式绑定。\n\n> javascript 的所有函数都可以使用 call / apply 方法。\n\n * call / apply ：\n   \n   两者的区别知识参数上的传递有区别：🚃 javascript 装饰器模式和转发 | notebook (simon1uo.github.io)，功能类似。\n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this)\n   }\n   \n   foo.call(window) // window\n   foo.call({name: "simon"}) // {name: "simon"}\n   foo.call(123) // number 对象存放123\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * bind ：如果希望函数总是显式绑定到一个对象上，这样每次调用函数时就不用每次都绑定 this 到一个特定的对象上。\n   \n   🌰 例子：\n   \n   function foo() {\n     console.log(this) // window\n   }\n   \n   var obj = {\n     name: "simon"\n   }\n   \n   var bar = foo.bind(obj)\n   \n   bar() // obj\n   bar() // obj\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 内置函数\n\n在 javascript 的内置函数（或者第三方库中的内置函数），这些内置函数允许传入另一个函数（回调函数），此时我们不会显式调用这些函数，而是 javascript 内部帮助我们执行。\n\n * settimeout() ：\n   \n   🌰 例子：\n   \n   settimeout(function() {\n     console.log(this) // window\n   }, 1000)\n   \n   \n   1\n   2\n   3\n   \n   \n   > 与 settimeout 的内部调用有关。 settimeout 内部通过 apply 绑定 this 对象，并且绑定的是 window 对象。\n\n * foreach() ：\n   \n   🌰 例子：\n   \n   var names = [\'abc\', \'def\', \'ghi\']\n   names.foreach(function(name) {\n     console.log(this) // window*3\n   })\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 默认情况下传入的函数是自动调用函数（默认绑定）；\n   \n   可以根据 foreach(value, thisarg) 的方法传入第二个参数，改变传入的对象：\n   \n   var obj = {name: "why"};\n   names.foreach(function(name) {\n     console.log(this) // window*3\n   }, obj)\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * html 元素的点击：\n   \n   🌰 例子 / div ：\n   \n   <div class="box"></div>\n   \n   \n   1\n   \n   \n   var box = document.queryselector(".box");\n   box.onclick = function() {\n     console.log(this); // box对象\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 因为发生点击时，执行传入的回调函数被调用时，会将 box 对象绑定到该函数中。\n\n传入到内置函数的回调函数 this ：\n\n * 某些内置函数很难判断。一方面可以分析源码，另一方面通过经验判断。无论如何最终都是根据之前的 默认绑定或者隐式 / 显式绑定。\n\n\n# new 绑定\n\njavascript 通过构造器 new 关键字生成一个实例对象，此时 this 指向这个实例对象。\n\n> 步骤：\n> \n>  * 创建一个全新的对象；\n>  * 这个新对象会被执行 prototype 连接；\n>  * 这个新对象会绑定到函数调用的 this 上（ this 的绑定在这个步骤完成）；\n>  * 如果函数没有返回其他对象，表达式会返回这个新对象；\n\n🌰 例子：\n\nfunction test() {\n  this.x = 1\n}\n\nvar obj = new test()\nobj.x // 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 之所以 obj.x 为 1 ，是因为 new 改变了 this 的指向。\n\n🌰 例子 / 特殊情况：\n\nfunction fn() {\n  this.user = \'xxx\'\n  return {}\n}\nvar a = new fn()\nconsole.log(a.user) // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 此时 new 的过程中遇到了一个 return ，此时 this 指向的是返回的对象。\n> \n> 当返回的是一个简单类型时， this 指向实例对象：\n> \n> function fn() {\n>   this.user = \'xxx\'\n>   return 1\n> }\n> var a = new fn()\n> console.log(a.user) // xxx\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> \n> \n> 当返回的是 null 时，虽然也是对象，但是此时 this 指向实例对象。\n\n\n# 绑定的优先级\n\n显示绑定 > new 绑定 > 隐式绑定 > 默认绑定\n\n * 因为存在其他规则是，就会使用其他规则绑定 this 。而不是默认绑定，所以默认绑定的优先级最低。\n\n🌰 例子 / 隐式绑定与显式绑定比较：\n\nfunction foo() {\n  console.log(this.a)\n}\n\nvar obj1 = {\n  a: 2,\n  foo: foo\n}\n\nvar obj2 = {\n  a: 3,\n  foo: foo\n}\n\nobj1.foo() // 2\nobj2.foo() // 3\nobj1.foo.call(obj2) // 3\nobj2,foo.call(obj1) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / new 绑定与隐式绑定比较：\n\nfunction foo(something) {\n  this.a = something\n}\n\nvar obj1 = {\n  foo: foo\n}\nvar obj2 = {}\n\nobj1.foo(2)\nconsole.log(obj1.a) // 2\n\nobj1.foo.call(obj2, 3) // 3\nconsole.log(obj2.a) // 3\n\nvar bar = new obj1.foo(4)\nconsole.log(obj1.a) // 2\nconsole.log(bar.a) // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / new 绑定与显示绑定比较：\n\nfunction foo(something) {\n  this.a = something\n}\n\nvar obj1 = {}\nvar bar = foo.bind(obj1)\nbar(2)\nconsole.log(obj1.a) // 2\n\nvar baz = new bar(3);\nconsole.log(obj1.a) // 2\nconsole.log(baz.a) // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> bar 被绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。但是， new 修改了绑定调用 bar() 中的 this\n\n\n# 其他情况绑定规则\n\n\n# 忽略规则绑定\n\n如果在显式绑定中，绑定对象时传入的参数为 undefined 或者 null ，那么这个显式绑定就会被忽略，然后使用默认规则。\n\n🌰 例子：\n\nfunction foo() {\n  console.log(this)\n}\n\nvar obj = {\n  name = "simon"\n}\n\nfoo.call(obj) // obj\nfoo.call(undefined) // window\nfoo.call(null) // window\n\nvar bar = foo.bind(null)\nbar() // window\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 间接函数引用\n\n创建函数的间接引用，这时使用默认绑定规则。\n\n🌰 例子：\n\nvar num1 = 100\nvar num2 = 0\nvar result = (num2 = num1)\nconsole.log(result) // 100\n\n\n1\n2\n3\n4\n\n\n引申到：\n\nfunction foo() {\n  console.log(this)\n}\n\nvar obj1 = {\n  name = "obj1",\n  foo: foo\n}\n\nvar obj2 = {\n \tname = "obj2" \n}\n\nobj1.foo() // obj1\n(obj2.foo = obj1.foo)() // window \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 因为赋值 (obj2.foo = obj1.foo) 的结果是 foo 函数。所以 foo 函数被直接调用，使用默认绑定规则。\n\n\n# 箭头函数的 this 指向\n\nes6 中箭头函数的语法，不使用四种绑定规则（不绑定 this ），而是由外层作用域决定 this 。\n\n🌰 例子：\n\nvar obj = {\n  data: [],\n  getdata: function() {\n    var _this = this;\n    settimeout(function() {\n      // 模拟获取到的数据\n      var res = ["abc", "cba", "nba"];\n      _this.data.push(...res);\n    }, 1000);\n  }\n}\n\nobj.getdata();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 使用 settimeout 来模拟网络请求，需要通过 this 获取 obj 对象存放到 data 。但是 settimeout 中的函数直接的 this 绑定的是 window ，所以需要在外层定义 var _this = this 。\n\n如果使用 箭头函数，可以直接使用 this 。因为箭头函数不会绑定 this 对象，那么 this 引用就会从上层作用域找到对应的 this ：\n\nvar obj = {\n  data: [],\n  getdata: function() {\n    settimeout(() => {\n      // 模拟获取到的数据\n      var res = ["abc", "cba", "nba"];\n      this.data.push(...res);\n    }, 1000);\n  }\n}\n\nobj.getdata();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果 getdata 也是箭头函数：\n\nvar obj = {\n  data: [],\n  getdata: () => {\n    settimeout(() => {\n      console.log(this)\n    }, 1000);\n  }\n}\n\nobj.getdata();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 那么 this 会从上层作用域找，找到全局作用域。所以为 window 。\n\n\n# 参考\n\n * 面试官：谈谈 this 对象的理解 | web 前端面试 - 面试官系列 (vue3js.cn)\n * 前端面试之彻底搞懂 this 指向 (qq.com)\n * 尚硅谷 javascript 进阶教程\n * this - javascript | mdn (mozilla.org)',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 执行上下文与执行栈",frontmatter:{title:"🍎 JavaScript 执行上下文与执行栈",date:"2022-06-27T09:36:06.000Z",permalink:"/pages/b66da8/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 函数相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/04.%20%F0%9F%8D%8E%20JavaScript%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%A0%88.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/04. 🍎 JavaScript 执行上下文与执行栈.md",key:"v-f6070724",path:"/pages/b66da8/",headers:[{level:2,title:"变量提升与函数提升",slug:"变量提升与函数提升",normalizedTitle:"变量提升与函数提升",charIndex:2},{level:2,title:"执行上下文",slug:"执行上下文",normalizedTitle:"执行上下文",charIndex:454},{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:1691},{level:3,title:"创建阶段",slug:"创建阶段",normalizedTitle:"创建阶段",charIndex:1719},{level:3,title:"执行阶段",slug:"执行阶段",normalizedTitle:"执行阶段",charIndex:1728},{level:3,title:"回收阶段",slug:"回收阶段",normalizedTitle:"回收阶段",charIndex:1737},{level:2,title:"执行上下文栈",slug:"执行上下文栈",normalizedTitle:"执行上下文栈",charIndex:3062},{level:2,title:"面试题",slug:"面试题",normalizedTitle:"面试题",charIndex:3482}],headersStr:"变量提升与函数提升 执行上下文 生命周期 创建阶段 执行阶段 回收阶段 执行上下文栈 面试题",content:"# 变量提升与函数提升\n\n * 变量声明提升：\n   * 通过 var 定义（声明）的变量，在定义语句之前就可以访问。值为 undefined 。\n * 函数声明提升：\n   * 通过 function 声明的函数，在之前就可以直接调用，值为函数定义（对象）。但是通过 var 定义的函数不适用函数提升（为变量提升）。\n\n🌰 例子：\n\nvar a = 3\nfunction fn(){\n  // var a\n  console.log(a) // undefined\n  var a = 4\n}\nfn()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfn2() // undefined 可调用\n\nfunction fn2(){\n  console.log('fn2()')\n}\n\n\n1\n2\n3\n4\n5\n\n\nfn3() // error\n\nvar fn3() = function (){\n  console.log('fn3()')\n}\n\n\n1\n2\n3\n4\n5\n\n\n❓ 变量提升和函数提升是如何产生的？\n\n\n# 执行上下文\n\n执行上下文是一种对 JavaScript 代码执行环境的抽象概念。也就是说，只要有 JavaScript 代码执行，就一定是运行在执行上下文中。\n\n>  * 按照位置给代码进行分类：\n>    \n>    * 全局代码\n>    \n>    * 函数代码\n>    \n>    * Eval 函数执行上下文。运行在 eval 函数中。很少使用而且不建议使用。\n\n * 全局执行上下文：（只有一个）\n   \n   * 在执行全局代码前将 window 确定为全局执行上下文。\n   \n   * 对全局数据进行预处理：\n     \n     * 使用 var 定义的全局变量值为 undefined ，添加为 window 的属性；\n     \n     * 使用 function 声明的全局函数赋值，添加为 window 的方法；\n     \n     * this 赋值为 window 。\n       \n       （在浏览器中 window 为全局对象）\n   \n   * 开始执行全局代码。\n\n * 函数执行上下文 ：（存在无数个）\n   \n   * 在调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）；\n   * 对局部数据进行预处理：\n     * 形参变量赋值 ** 实参 的数据 **，添加为执行上下文的属性；\n     * arguments 赋值 ** 实参 的数据列表（伪数组）**，添加为执行上下文的属性；\n     * 使用 var 定义的局部变量赋值 undefined ，添加为执行上下文的属性；\n     * 使用 function 声明的函数，赋值 fun ，添加为执行上下文的方法；\n     * this 赋值 调用函数的对象 。\n   * 开始执行函数体代码。\n\n🌰 例子：全局执行上下文：\n\nconsole.log(a1) // window.a1\na2() // window.a2()\nconsole.log(this) // window\n\nvar a1 = 1\nfunction a2() {\n  console.log('a2()')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子：函数执行上下文：\n\nfunction fn(a1) {\n\tconsole.log(a1) // 2\n  console.log(a2) // undefined\n  a3() // a3()\n  console.log(this) // window 调用fn()的对象 \n  console.log(arguments) // 伪数组(2,3)\n  \n  var a2 = 3\n  function a3() {\n    console.log('a3()')\n  }\n}\n\nfn(2, 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 生命周期\n\n执行上下文的生命周期分为三个阶段：\n\n * 创建阶段；\n * 执行阶段；\n * 回收阶段；\n\n\n# 创建阶段\n\n * 当函数被调用，但未执行任何其内部代码之前。\n\n * 完成三件事：\n   \n   * 确定 this 的值（ this binding ， this 的绑定）；因为 this 的值是在执行的时候被确认的，定义的时候不能确认。\n   * 创建词法环境（Lexical Environment）\n   * 创建变量环境（Variable Environment）\n   \n   ExecutionContext = {\n     ThisBinding = <this value>,\n     LexicalEnvironment = { ... },\n   \tVariableEnvironment = { ... }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   >  * 词法环境有两个组成部分：\n   >    \n   >    * 全局环境：没有外部环境的词法环境，其外部环境引用的是 null ；有一个全局对象， this 指向这个全局对象。\n   >    * 函数环境：用户在函数中定义的变量被存储在环境记录中，包含 arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。\n   > \n   >  * 变量环境：也是一个词法环境，因此具有上面定义的词法环境的所有属性。\n   >    \n   >    ES6 中，词法环境和变量环境的区别在于，词法环境用于存储函数声明和变量（ let / const ）绑定；变量环境仅用于存储变量（ var ） 绑定。\n   > \n   > 🌰 例子：\n   > \n   > let a = 20;  \n   > const b = 30;  \n   > var c;\n   > \n   > function multiply(e, f) {  \n   >  var g = 20;  \n   >  return e * f * g;  \n   > }\n   > \n   > c = multiply(20, 30);\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > \n   > let 和 const 定义的变量 a 和 b 在创建阶段没有被赋值，但是 var 声明的变量从在创建阶段被赋值为 undefined 。因为创建阶段会在代码中扫描变量和函数声明， 将函数声明存储在环境中；而变量会变初始化为 undefined （ var 声明的变量）和 uninitialized （未初始化）（ let 和 const 声明的变量）。\n   > \n   > 这是变量提升的实际原因。\n\n\n# 执行阶段\n\n在这个阶段，执行变量赋值、代码执行。如果 JavaScript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配为 undefined 值。\n\n\n# 回收阶段\n\n执行上下文出栈，等待虚拟机回收执行上下文。\n\n\n# 执行上下文栈\n\n * 在全局代码执行之前，JavaScript 引擎就会创建一个栈来存储管理所有的执行上下文对象。\n * 在全局执行上下文 window 确定后，将其添加到栈中（压栈）。\n * （调用函数时）在函数执行上下文创建后，将其添加到栈中（压栈）。\n * 在当前函数执行完后，将栈顶的对象移除（出栈）。\n * 当所有的代码执行完后，栈中只剩下 window 。\n\n🌰 例子：\n\n// 1.进入全局执行上下文\nvar a =10\n\nvar bar = function(x) {\n  var b = 5\n  foo(x + b) // 3. 进入foo执行上下文\n}\n\nvar foo = function(y) {\n  var c = 5\n  console.log(a + c + y)\n}\n\nbar(10) // 2. 进入bar函数执行上下文\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 面试题\n\n1️⃣ ：\n\n * 依次输出的内容。\n * 整个过程产生了几个执行上下文？\n\nconsole.log('global begin:' + i)\nvar i = 1\nfoo(1)\nfunction foo(i){\n  if(i == 4) {\n    return;\n  }\n  console.log('foo() begin:' + i)\n  foo(i + 1) \n  console.log('foo() end:' + i)\n}\nconsole.log('global end:' + i)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * \n * 5 。\n\n2️⃣：\n\nfunction a() { }\nvar a\nconsole.log(typeof a) // function\n\n\n1\n2\n3\n\n\n先执行变量提升再执行函数提升。\n\nif(!(b in window)) {\n  var b = 1\n}\nconsole.log(b)\n\n\n1\n2\n3\n4\n\n\nvar c = 1\nfunction c(c){\n  console.log(c)\n}\nc(2) // TypeError: c is not a function. (In 'c(2)', 'c' is 1) \n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 变量提升与函数提升\n\n * 变量声明提升：\n   * 通过 var 定义（声明）的变量，在定义语句之前就可以访问。值为 undefined 。\n * 函数声明提升：\n   * 通过 function 声明的函数，在之前就可以直接调用，值为函数定义（对象）。但是通过 var 定义的函数不适用函数提升（为变量提升）。\n\n🌰 例子：\n\nvar a = 3\nfunction fn(){\n  // var a\n  console.log(a) // undefined\n  var a = 4\n}\nfn()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfn2() // undefined 可调用\n\nfunction fn2(){\n  console.log('fn2()')\n}\n\n\n1\n2\n3\n4\n5\n\n\nfn3() // error\n\nvar fn3() = function (){\n  console.log('fn3()')\n}\n\n\n1\n2\n3\n4\n5\n\n\n❓ 变量提升和函数提升是如何产生的？\n\n\n# 执行上下文\n\n执行上下文是一种对 javascript 代码执行环境的抽象概念。也就是说，只要有 javascript 代码执行，就一定是运行在执行上下文中。\n\n>  * 按照位置给代码进行分类：\n>    \n>    * 全局代码\n>    \n>    * 函数代码\n>    \n>    * eval 函数执行上下文。运行在 eval 函数中。很少使用而且不建议使用。\n\n * 全局执行上下文：（只有一个）\n   \n   * 在执行全局代码前将 window 确定为全局执行上下文。\n   \n   * 对全局数据进行预处理：\n     \n     * 使用 var 定义的全局变量值为 undefined ，添加为 window 的属性；\n     \n     * 使用 function 声明的全局函数赋值，添加为 window 的方法；\n     \n     * this 赋值为 window 。\n       \n       （在浏览器中 window 为全局对象）\n   \n   * 开始执行全局代码。\n\n * 函数执行上下文 ：（存在无数个）\n   \n   * 在调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）；\n   * 对局部数据进行预处理：\n     * 形参变量赋值 ** 实参 的数据 **，添加为执行上下文的属性；\n     * arguments 赋值 ** 实参 的数据列表（伪数组）**，添加为执行上下文的属性；\n     * 使用 var 定义的局部变量赋值 undefined ，添加为执行上下文的属性；\n     * 使用 function 声明的函数，赋值 fun ，添加为执行上下文的方法；\n     * this 赋值 调用函数的对象 。\n   * 开始执行函数体代码。\n\n🌰 例子：全局执行上下文：\n\nconsole.log(a1) // window.a1\na2() // window.a2()\nconsole.log(this) // window\n\nvar a1 = 1\nfunction a2() {\n  console.log('a2()')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n🌰 例子：函数执行上下文：\n\nfunction fn(a1) {\n\tconsole.log(a1) // 2\n  console.log(a2) // undefined\n  a3() // a3()\n  console.log(this) // window 调用fn()的对象 \n  console.log(arguments) // 伪数组(2,3)\n  \n  var a2 = 3\n  function a3() {\n    console.log('a3()')\n  }\n}\n\nfn(2, 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 生命周期\n\n执行上下文的生命周期分为三个阶段：\n\n * 创建阶段；\n * 执行阶段；\n * 回收阶段；\n\n\n# 创建阶段\n\n * 当函数被调用，但未执行任何其内部代码之前。\n\n * 完成三件事：\n   \n   * 确定 this 的值（ this binding ， this 的绑定）；因为 this 的值是在执行的时候被确认的，定义的时候不能确认。\n   * 创建词法环境（lexical environment）\n   * 创建变量环境（variable environment）\n   \n   executioncontext = {\n     thisbinding = <this value>,\n     lexicalenvironment = { ... },\n   \tvariableenvironment = { ... }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   >  * 词法环境有两个组成部分：\n   >    \n   >    * 全局环境：没有外部环境的词法环境，其外部环境引用的是 null ；有一个全局对象， this 指向这个全局对象。\n   >    * 函数环境：用户在函数中定义的变量被存储在环境记录中，包含 arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。\n   > \n   >  * 变量环境：也是一个词法环境，因此具有上面定义的词法环境的所有属性。\n   >    \n   >    es6 中，词法环境和变量环境的区别在于，词法环境用于存储函数声明和变量（ let / const ）绑定；变量环境仅用于存储变量（ var ） 绑定。\n   > \n   > 🌰 例子：\n   > \n   > let a = 20;  \n   > const b = 30;  \n   > var c;\n   > \n   > function multiply(e, f) {  \n   >  var g = 20;  \n   >  return e * f * g;  \n   > }\n   > \n   > c = multiply(20, 30);\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > \n   > let 和 const 定义的变量 a 和 b 在创建阶段没有被赋值，但是 var 声明的变量从在创建阶段被赋值为 undefined 。因为创建阶段会在代码中扫描变量和函数声明， 将函数声明存储在环境中；而变量会变初始化为 undefined （ var 声明的变量）和 uninitialized （未初始化）（ let 和 const 声明的变量）。\n   > \n   > 这是变量提升的实际原因。\n\n\n# 执行阶段\n\n在这个阶段，执行变量赋值、代码执行。如果 javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配为 undefined 值。\n\n\n# 回收阶段\n\n执行上下文出栈，等待虚拟机回收执行上下文。\n\n\n# 执行上下文栈\n\n * 在全局代码执行之前，javascript 引擎就会创建一个栈来存储管理所有的执行上下文对象。\n * 在全局执行上下文 window 确定后，将其添加到栈中（压栈）。\n * （调用函数时）在函数执行上下文创建后，将其添加到栈中（压栈）。\n * 在当前函数执行完后，将栈顶的对象移除（出栈）。\n * 当所有的代码执行完后，栈中只剩下 window 。\n\n🌰 例子：\n\n// 1.进入全局执行上下文\nvar a =10\n\nvar bar = function(x) {\n  var b = 5\n  foo(x + b) // 3. 进入foo执行上下文\n}\n\nvar foo = function(y) {\n  var c = 5\n  console.log(a + c + y)\n}\n\nbar(10) // 2. 进入bar函数执行上下文\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 面试题\n\n1️⃣ ：\n\n * 依次输出的内容。\n * 整个过程产生了几个执行上下文？\n\nconsole.log('global begin:' + i)\nvar i = 1\nfoo(1)\nfunction foo(i){\n  if(i == 4) {\n    return;\n  }\n  console.log('foo() begin:' + i)\n  foo(i + 1) \n  console.log('foo() end:' + i)\n}\nconsole.log('global end:' + i)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * \n * 5 。\n\n2️⃣：\n\nfunction a() { }\nvar a\nconsole.log(typeof a) // function\n\n\n1\n2\n3\n\n\n先执行变量提升再执行函数提升。\n\nif(!(b in window)) {\n  var b = 1\n}\nconsole.log(b)\n\n\n1\n2\n3\n4\n\n\nvar c = 1\nfunction c(c){\n  console.log(c)\n}\nc(2) // typeerror: c is not a function. (in 'c(2)', 'c' is 1) \n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 函数式编程相关",frontmatter:{title:"🍎 JavaScript 函数式编程相关",date:"2022-07-03T11:31:12.000Z",permalink:"/pages/e6af48/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 函数相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/10. 🍎 JavaScript 函数式编程相关.md",key:"v-0ddafc4e",path:"/pages/e6af48/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:70},{level:3,title:"纯函数",slug:"纯函数",normalizedTitle:"纯函数",charIndex:605},{level:3,title:"高阶函数",slug:"高阶函数",normalizedTitle:"高阶函数",charIndex:975},{level:3,title:"柯里化",slug:"柯里化",normalizedTitle:"柯里化",charIndex:1599},{level:3,title:"组合与管理",slug:"组合与管理",normalizedTitle:"组合与管理",charIndex:2319},{level:2,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:61},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3228}],headersStr:"概念 纯函数 高阶函数 柯里化 组合与管理 优缺点 参考",content:'> 相关问题：\n> \n>  * 对 JavaScript 函数式编程的理解？\n>  * JavaScript 函数式编程的优缺点？\n\n\n# 概念\n\nJavaScript 函数式编程是一种「编程范式」（Programming Paradigm），一种编写程序的方法论。\n\n> 主要的编程范式有三种：命令式编程、声明式编程以及函数式编程。\n\n相比于命令式编程，函数式编程 更加强调程序的执行结果而非执行的过程，倡导利用若干的简单的执行单元让计算结果不断渐进，逐渐推导复杂的运算，而非设计一个复杂的执行过程。\n\n🌰 例子 / 命令式编程与函数式编程比较：\n\n// 命令式编程\nvar array = [0, 1, 2, 3]\nfor (let i = 0; i < array.length; i++) {\n  array[i] = Math.pow(array[i], 2)\n}\n\n// 函数式编程\n[0, 1, 2, 3].map(num => Math.pow(num, 2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n简单来说，函数式编程就是将过程逻辑写成函数，定义好输入参数，只关心它的输出结果。即是一种描述集合与几何之间的转换关系，输入通过函数都会返回有且只有一个值。\n\n函数实际上是一个关系（映射），这个关系是可以组合的。一旦知道函数的输出类型可以匹配一个函数的输入，就将它们可以进行组合。\n\n\n# 纯函数\n\n函数式编程旨在尽可能提高代码的无状态性和不变形。要做到这一点就要使用 无副作用的函数，也就是纯函数。\n\n纯函数是给定输入返还相同输出的函数，并且要求所有的数据都是不可变的。即 纯函数 = 无状态 + 数据不可变。\n\n🌰 例子：\n\nlet double = value => value * 2\n\n\n1\n\n\n纯函数的特点：\n\n * 函数内部传入指定的值，就会返回确定唯一的值；\n * 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数；\n\n纯函数的优势：\n\n * 使用纯函数可以产生可测试的代码；\n * 不依赖外部环境计算，不会产生副作用，提高函数的可复用性；\n * 代码可读性强，函数不管是否是一个纯函数都会有一个语义化名称，便于理解阅读；\n * 可以组装成复杂任务的可能性，符合模块化的概念以及单一职责原则。\n\n\n# 高阶函数\n\n> 在编程世界中，只需要处理的是 「数据」 和「关系」，而关系就是函数。\n> \n> 编程工作也是在找一种关系，一旦关系找到了，问题就解决了。剩下的事情就是让数据流过这种关系，转换成另一种数据。\n\n高阶函数的作用，就是以函数作为输入或者输出的函数。通过高阶函数 抽象过程，注重结果。\n\n🌰 例子：\n\nconst forEach = function(arr, fn) {\n  for(let i = 0; i < arr.length; i++) {\n    fn(arr[i])\n  }\n}\n\nlet arr = [1, 2, 3]\nforEach(arr, (item) => {\n  console.log(item)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> forEach 是一个高阶函数，抽象了循环如何做的逻辑，然后直接关注做了什么。\n\n高阶函数存在缓存的特性，主要利用闭包。\n\n🌰 例子：\n\nconst once = (fn) => {\n  let done = false\n  return function() {\n    if(!done) {\n      fn.apply(this, fn)\n    } else {\n      console.log("该函数已执行")\n    }\n    done = true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 柯里化\n\n讲一个多参数函数转化成一个嵌套的一元函数的过程。\n\n柯里化函数的意义：\n\n * 让纯函数更纯。每接受一个参数，松散结构。\n * 惰性执行。\n\n🌰 例子：\n\nlet fn = (x, y) => x + y\n\n\n1\n\n\n转换为柯里化函数：\n\nlet fn = (x, y) => x + y\nconst curry = function(fn) {\n  return function(x) {\n    return function(y) {\n      return fn(x, y)\n    }\n  }\n}\n\nlet myfn = curry(fn)\nconsole.log(myfn(1)(2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 / 多参数的柯里化函数：\n\nconst curry = function(fn) {\n  return function curriedFn(...args) {\n    if (args.length < fn.length) {\n      return function() {\n        return curriedFn(...args.concat([...arguments]))\n      }\n    }\n    return fn(...args)\n  }\n}\n\nconst fn = (x, y, z, a) => x + y + z + a\nconst myfn = curry(fn)\nconsole.log(myfn(1)(2)(3)(4))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 组合与管理\n\n组合函数与管道函数的意义在于将多个函数组合成一个函数，完成更复杂的逻辑。\n\n🌰 例子：\n\nfunction afn(a) {\n  return a * 2\n}\n\nfunction bfn(b) {\n  return b * 3\n}\n\nconst compose = (a, b) => c => a(b(c))\nlet myfn = compost(afn, bfn)\nconsole.log(myfn(2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> compose 实现了一个简单的功能：形成了一个新的函数。而这个函数就是一条从 afn -> bfn 的流水线。\n\n实现一个多函数组合：\n\nconst compose = (...fns) => val => fns.reverse().((acc, fn) => fn(acc), val)\n\n\n1\n\n\ncompost 从右到左执行。\n\n管道函数执行顺序从左到右：\n\nconst pipe = (...fns) => val => fns.reduce((acc, fn) => fn(acc), val)\n\n\n1\n\n\n\n# 优缺点\n\n函数式编程的优点：\n\n * 更好的管理状态。宗旨是无状态，或者更少的状态，能最大化的减少这些未知、优化代码、减少出错的情况；\n * 更简单的复用。固定输入 和 固定输出，没有其他外部变量的影响，并且没有副作用。这样代码复用的时候，完全不需要考虑它的内部实现和外部影响；\n * 更优雅的组合。在网页中可以由各个组件组成；一个函数可以由多个小函数组成。更强的复用性，能带来更强大的组合性。\n * 隐性好处。减少代码量，提高维护性。\n\n函数式编程缺点：\n\n * 性能。函数式编程相对于指令时编程，性能是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销。\n * 资源占用。在 JavaScript 中为了实现对象状态的不可变，往往会创建新的对象，因此对于垃圾回收所产生的压力远远超过其他编程方式。\n * 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作。\n\n\n# 参考\n\n * 简明 JavaScript 函数式编程 —— 入门篇 - 知乎 (zhihu.com)',normalizedContent:'> 相关问题：\n> \n>  * 对 javascript 函数式编程的理解？\n>  * javascript 函数式编程的优缺点？\n\n\n# 概念\n\njavascript 函数式编程是一种「编程范式」（programming paradigm），一种编写程序的方法论。\n\n> 主要的编程范式有三种：命令式编程、声明式编程以及函数式编程。\n\n相比于命令式编程，函数式编程 更加强调程序的执行结果而非执行的过程，倡导利用若干的简单的执行单元让计算结果不断渐进，逐渐推导复杂的运算，而非设计一个复杂的执行过程。\n\n🌰 例子 / 命令式编程与函数式编程比较：\n\n// 命令式编程\nvar array = [0, 1, 2, 3]\nfor (let i = 0; i < array.length; i++) {\n  array[i] = math.pow(array[i], 2)\n}\n\n// 函数式编程\n[0, 1, 2, 3].map(num => math.pow(num, 2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n简单来说，函数式编程就是将过程逻辑写成函数，定义好输入参数，只关心它的输出结果。即是一种描述集合与几何之间的转换关系，输入通过函数都会返回有且只有一个值。\n\n函数实际上是一个关系（映射），这个关系是可以组合的。一旦知道函数的输出类型可以匹配一个函数的输入，就将它们可以进行组合。\n\n\n# 纯函数\n\n函数式编程旨在尽可能提高代码的无状态性和不变形。要做到这一点就要使用 无副作用的函数，也就是纯函数。\n\n纯函数是给定输入返还相同输出的函数，并且要求所有的数据都是不可变的。即 纯函数 = 无状态 + 数据不可变。\n\n🌰 例子：\n\nlet double = value => value * 2\n\n\n1\n\n\n纯函数的特点：\n\n * 函数内部传入指定的值，就会返回确定唯一的值；\n * 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数；\n\n纯函数的优势：\n\n * 使用纯函数可以产生可测试的代码；\n * 不依赖外部环境计算，不会产生副作用，提高函数的可复用性；\n * 代码可读性强，函数不管是否是一个纯函数都会有一个语义化名称，便于理解阅读；\n * 可以组装成复杂任务的可能性，符合模块化的概念以及单一职责原则。\n\n\n# 高阶函数\n\n> 在编程世界中，只需要处理的是 「数据」 和「关系」，而关系就是函数。\n> \n> 编程工作也是在找一种关系，一旦关系找到了，问题就解决了。剩下的事情就是让数据流过这种关系，转换成另一种数据。\n\n高阶函数的作用，就是以函数作为输入或者输出的函数。通过高阶函数 抽象过程，注重结果。\n\n🌰 例子：\n\nconst foreach = function(arr, fn) {\n  for(let i = 0; i < arr.length; i++) {\n    fn(arr[i])\n  }\n}\n\nlet arr = [1, 2, 3]\nforeach(arr, (item) => {\n  console.log(item)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> foreach 是一个高阶函数，抽象了循环如何做的逻辑，然后直接关注做了什么。\n\n高阶函数存在缓存的特性，主要利用闭包。\n\n🌰 例子：\n\nconst once = (fn) => {\n  let done = false\n  return function() {\n    if(!done) {\n      fn.apply(this, fn)\n    } else {\n      console.log("该函数已执行")\n    }\n    done = true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 柯里化\n\n讲一个多参数函数转化成一个嵌套的一元函数的过程。\n\n柯里化函数的意义：\n\n * 让纯函数更纯。每接受一个参数，松散结构。\n * 惰性执行。\n\n🌰 例子：\n\nlet fn = (x, y) => x + y\n\n\n1\n\n\n转换为柯里化函数：\n\nlet fn = (x, y) => x + y\nconst curry = function(fn) {\n  return function(x) {\n    return function(y) {\n      return fn(x, y)\n    }\n  }\n}\n\nlet myfn = curry(fn)\nconsole.log(myfn(1)(2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n🌰 例子 / 多参数的柯里化函数：\n\nconst curry = function(fn) {\n  return function curriedfn(...args) {\n    if (args.length < fn.length) {\n      return function() {\n        return curriedfn(...args.concat([...arguments]))\n      }\n    }\n    return fn(...args)\n  }\n}\n\nconst fn = (x, y, z, a) => x + y + z + a\nconst myfn = curry(fn)\nconsole.log(myfn(1)(2)(3)(4))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 组合与管理\n\n组合函数与管道函数的意义在于将多个函数组合成一个函数，完成更复杂的逻辑。\n\n🌰 例子：\n\nfunction afn(a) {\n  return a * 2\n}\n\nfunction bfn(b) {\n  return b * 3\n}\n\nconst compose = (a, b) => c => a(b(c))\nlet myfn = compost(afn, bfn)\nconsole.log(myfn(2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> compose 实现了一个简单的功能：形成了一个新的函数。而这个函数就是一条从 afn -> bfn 的流水线。\n\n实现一个多函数组合：\n\nconst compose = (...fns) => val => fns.reverse().((acc, fn) => fn(acc), val)\n\n\n1\n\n\ncompost 从右到左执行。\n\n管道函数执行顺序从左到右：\n\nconst pipe = (...fns) => val => fns.reduce((acc, fn) => fn(acc), val)\n\n\n1\n\n\n\n# 优缺点\n\n函数式编程的优点：\n\n * 更好的管理状态。宗旨是无状态，或者更少的状态，能最大化的减少这些未知、优化代码、减少出错的情况；\n * 更简单的复用。固定输入 和 固定输出，没有其他外部变量的影响，并且没有副作用。这样代码复用的时候，完全不需要考虑它的内部实现和外部影响；\n * 更优雅的组合。在网页中可以由各个组件组成；一个函数可以由多个小函数组成。更强的复用性，能带来更强大的组合性。\n * 隐性好处。减少代码量，提高维护性。\n\n函数式编程缺点：\n\n * 性能。函数式编程相对于指令时编程，性能是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销。\n * 资源占用。在 javascript 中为了实现对象状态的不可变，往往会创建新的对象，因此对于垃圾回收所产生的压力远远超过其他编程方式。\n * 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作。\n\n\n# 参考\n\n * 简明 javascript 函数式编程 —— 入门篇 - 知乎 (zhihu.com)',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 函数缓存相关",frontmatter:{title:"🍎 JavaScript 函数缓存相关",date:"2022-07-03T13:42:13.000Z",permalink:"/pages/f5f615/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 函数相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/11.%20%F0%9F%8D%8E%20JavaScript%20%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/11. 🍎 JavaScript 函数缓存相关.md",key:"v-685447f2",path:"/pages/f5f615/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:69},{level:2,title:"如何实现",slug:"如何实现",normalizedTitle:"如何实现",charIndex:28},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:59},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1087}],headersStr:"概念 如何实现 应用场景 参考",content:"> 相关问题：\n> \n>  * JavaScript 中如何实现函数缓存？\n>  * JavaScript 函数缓存的应用场景。\n\n\n# 概念\n\nJavaScript 函数缓存是将函数运算过的结果进行缓存。本质上是用 空间（缓存存储） 换 时间（计算过程）。常用于缓存数据计算结果和缓存对象。\n\n缓存是一个临时的数据存储，保存数据以便将来对数据的请求能够更快地得到处理。\n\n🌰 例子：\n\nconst add = (a, b) => a + b\nconst calc = memoize(add)\ncalc(10, 20)\ncalc(10, 20) \n\n\n1\n2\n3\n4\n\n\n\n# 如何实现\n\n实现函数缓存主要依靠 闭包、柯里化、高阶函数。\n\n实现原理，把参数和对应的结果保存在一个对象中，调用时判断参数对应的数据是否存在，存在就返回对应的结果护具，否则就返回计算结果。\n\n🌰 例子：\n\nconst memoize = function(func, content) {\n  let cache = Object.create(null)\n  content = content || this\n  return (...key) => {\n    if(!cache[key]) {\n      cache[key] = func.apply(content, key)\n    }\n    return cache[key]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n调用方式：\n\nconst calc = memoize(add)\nconst num1 = calc(100, 200)\nconst num2 = calc(100, 200)\n\n\n1\n2\n3\n\n\n过程分析：\n\n * 在当前函数作用域定义了一个空的独享，用于缓存运行结果；\n * 运行柯里化返回一个函数，返回的函数由于闭包的特性，可以访问到 cache 。\n * 然后判断输入参数是不是在 cache 中。如果已经存在，直接返回 cache 的内容，如果没有存在，使用函数 func 对输入参数求值，然后把结果存储在 cache 。\n\n\n# 应用场景\n\n虽然缓存效率很高， 但并不适用所有场景，因此不能极端地将所有函数都添加缓存。\n\n对于以下几种情况可以使用函数缓存：\n\n * 对于昂贵函数调用时，需要执行复杂计算的函数；\n * 对于具有有限且高度重复输入范围的函数；\n * 对于具有重复输入值的递归函数；\n * 对于纯函数，即每次使用特定输入调用时返回相同输出的函数。\n\n\n# 参考\n\n * Javascript 缓存函数 & 柯里化 & 偏函数 - 知乎 (zhihu.com)\n * 面试官：Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？ | web 前端面试 - 面试官系列 (vue3js.cn)",normalizedContent:"> 相关问题：\n> \n>  * javascript 中如何实现函数缓存？\n>  * javascript 函数缓存的应用场景。\n\n\n# 概念\n\njavascript 函数缓存是将函数运算过的结果进行缓存。本质上是用 空间（缓存存储） 换 时间（计算过程）。常用于缓存数据计算结果和缓存对象。\n\n缓存是一个临时的数据存储，保存数据以便将来对数据的请求能够更快地得到处理。\n\n🌰 例子：\n\nconst add = (a, b) => a + b\nconst calc = memoize(add)\ncalc(10, 20)\ncalc(10, 20) \n\n\n1\n2\n3\n4\n\n\n\n# 如何实现\n\n实现函数缓存主要依靠 闭包、柯里化、高阶函数。\n\n实现原理，把参数和对应的结果保存在一个对象中，调用时判断参数对应的数据是否存在，存在就返回对应的结果护具，否则就返回计算结果。\n\n🌰 例子：\n\nconst memoize = function(func, content) {\n  let cache = object.create(null)\n  content = content || this\n  return (...key) => {\n    if(!cache[key]) {\n      cache[key] = func.apply(content, key)\n    }\n    return cache[key]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n调用方式：\n\nconst calc = memoize(add)\nconst num1 = calc(100, 200)\nconst num2 = calc(100, 200)\n\n\n1\n2\n3\n\n\n过程分析：\n\n * 在当前函数作用域定义了一个空的独享，用于缓存运行结果；\n * 运行柯里化返回一个函数，返回的函数由于闭包的特性，可以访问到 cache 。\n * 然后判断输入参数是不是在 cache 中。如果已经存在，直接返回 cache 的内容，如果没有存在，使用函数 func 对输入参数求值，然后把结果存储在 cache 。\n\n\n# 应用场景\n\n虽然缓存效率很高， 但并不适用所有场景，因此不能极端地将所有函数都添加缓存。\n\n对于以下几种情况可以使用函数缓存：\n\n * 对于昂贵函数调用时，需要执行复杂计算的函数；\n * 对于具有有限且高度重复输入范围的函数；\n * 对于具有重复输入值的递归函数；\n * 对于纯函数，即每次使用特定输入调用时返回相同输出的函数。\n\n\n# 参考\n\n * javascript 缓存函数 & 柯里化 & 偏函数 - 知乎 (zhihu.com)\n * 面试官：javascript 中如何实现函数缓存？函数缓存有哪些应用场景？ | web 前端面试 - 面试官系列 (vue3js.cn)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 原型与原型链",frontmatter:{title:"🍎 JavaScript 原型与原型链",date:"2022-06-26T19:06:48.000Z",permalink:"/pages/a78536/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 原型与继承相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/04.%20%F0%9F%8D%8E%20JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/04. 🍎 JavaScript 原型与继承相关/01. 🍎 JavaScript 原型与原型链.md",key:"v-044944ba",path:"/pages/a78536/",headers:[{level:2,title:"JavaScript 原型",slug:"javascript-原型",normalizedTitle:"javascript 原型",charIndex:49},{level:3,title:"显式原型与隐式原型",slug:"显式原型与隐式原型",normalizedTitle:"显式原型与隐式原型",charIndex:693},{level:2,title:"JavaScript 原型链",slug:"javascript-原型链",normalizedTitle:"javascript 原型链",charIndex:1297},{level:3,title:"原型链的属性问题",slug:"原型链的属性问题",normalizedTitle:"原型链的属性问题",charIndex:2555},{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:2135},{level:2,title:"⭐️ 题相关",slug:"题相关",normalizedTitle:"⭐️ 题相关",charIndex:3898}],headersStr:"JavaScript 原型 显式原型与隐式原型 JavaScript 原型链 原型链的属性问题 instanceof ⭐️ 题相关",content:"> 相关问题：\n> \n>  * 说说你对原型、原型链的理解。\n>  * 原型有什么特点。\n\n\n# JavaScript 原型\n\n> JavaScript 的每个对象都拥有一个原型对象，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。\n\n * 函数的 prototype 属性：\n   * 每个函数都有一个 prototype 属性，它默认指向一个 Object 空对象（即原型对象 ）。\n   * 原型对象中有一个属性 constructor ，它指向函数对象。\n * 给原型对象添加属性（一般为方法），⭐️ 作用：函数的所有实例对象自动拥有原型中的属性（方法）。\n\n🌰 例子：\n\nconsole.log(Date.prototype, typeof Date.prototype)\n\nfunction Fun(){\n  \n}\nconsole.log(Fun.prototype)\nconsole.log(Date.prototype.constructor===Date)\nconsole.log(Fun.prototype.constructor===Fun)\n\nFun.prototype.test = function (){\n  cosole.log(\"test()\")\n}\n\nvar fun = new Fun()\nfun.test() // \"test()\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n:::\n\n\n# 显式原型与隐式原型\n\n * 显式原型：指每个函数 function 都有的原型 prototype （属性）。默认指向一个空的 Object 对象。\n * 隐式原型：指每个实例对象都有一个的 __proto__ （属性）。\n\n对象的隐式原型的值为其对应构造函数的显性原型的值。\n\n注意\n\n⚠️ 在 ES6 之前，程序员能直接操作显式原型，但是不能直接操作隐式原型。\n\n🌰 例子：\n\nfunction Fn(){\n  // ... \n} // 可理解为 this.prototype = { ... }\n\n// (1)\nconsole.log(Fn.prototype) // Object\n// (2)\nvar fn = new Fn() // 可理解为 this.__proto__ = Fn.prototype\nconsole.log(fn.__proto__) // Object\n// (3)\nconsole.log(Fn.prototype==fn.__proto__) // true\n\nFn.prototype.test = function () {\n  console.log(\"test\")\n} // 给原型添加方法\nfn.test() // test // 可以通过实例调用原型的方法 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n\n# JavaScript 原型链\n\n * 当访问一个对象的属性时，\n   1. 先在自身的属性中查找，找到则返回；\n   2. 如果没有找到，则再沿着 __proto__ 这条链向上查找，找到则返回；\n   3. 如果最终没找到，则返回 undefined 。\n\n上述查找过程为原型链，又称为隐式原型链。\n\n🌰 例子：\n\nfunction Fn(){\n  this.test1 = function (){\n    console.log(\"test1)\")\n  }\n}\n\nFn.prototype.test2 = function () {\n  console.log(\"test2()\")\n}\n\nvar fn = new Fn()\n\nfn.test1()\nfn.test2()\nconsole.log(fn.toString())\nfn.test3() // ERROR!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n作用：查找对象的属性（方法）\n\n * 构造函数 / 原型 / 实例对象的关系 1️⃣：\n   \n   var o1 = new Object()\n   var o2 = {}\n   \n   \n   1\n   2\n   \n   \n   \n\n * 构造函数 / 原型 / 实例对象的关系 2️⃣ ：\n   \n   function Foo(){ }\n   // var Foo = new Function()\n   // Function = new Function()\n   \n   \n   1\n   2\n   3\n   \n   \n   注意\n   \n   所有函数的 __proto__ 都是一样的。\n   \n   \n\n🔧 问题补充：\n\n注意\n\n * 函数的显式原型指向的对象是是空的 Object 实例对象，但是 Object 不满足。\n   \n   console.log(Fn.prototype instanceof Object) // true\n   console.log(Object.prototype instanceof Object) // false\n   cosole.log(Function.prototype instanceof Object) // true\n   \n   \n   1\n   2\n   3\n   \n\n * 所有的函数都是 Function 的实例，包括 Function 本身（ Function 是它自身的实例）。\n   \n   console.log(Function.__proto__===Function.prototype) // true\n   \n   \n   1\n   \n\n * Object 的原型对象是原型链的尽头。\n   \n   console.log(Object.prototype.__proto__) // null\n   \n   \n   1\n   \n\n\n# 原型链的属性问题\n\n * 读取对象的属性时，会自动到原型链中查找。\n * 设置对象的属性值时，⚠️ 不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置此值。\n * 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。\n\n🌰 例子：\n\nfunction Fn() {}\nFn.prototype.a = 'xxx'\nvar fn1 = new Fn()\nconsole.log(fn.a) // 'xxx'\n\nvar fn2 = new Fn()\nfn2.a = 'yyy'\nconsole.log(fn1.a) // 'xxx'\nconsole.log(fn2.a) // 'yyy' \n//  cosole.log(fn2.__proto__.a) // 'xxx'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子：\n\nfunction Person(name, age) {\n  this.name = name\n  this.age =age\n}\n\nPerson.prototype.setName = function(name) = {\n  this.name = name\n}\n\nvar p1 = new Person('Tom', 12)\np1.setName('Bob')\nconsole.log(p1.name, p1.age) // Bob, 12\n\nvar p2 = Person('Sid', 12)\np2.setName('Kat')\nconsole.log(p2.name, p2.age) // Kat, 12\nconsole.log(p1.__proto__==p2.__proto__) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# instanceof\n\n * 表达式： a instanceof b\n * 如果 b 函数的显示原型对象在 a 对象的原型链上（则 a 是 b 的实例），返回 true ，否则返回 false 。\n\n🌰 例子 1️⃣ ：\n\nfunction Foo() { }\nvar f1 = new Foo() // 左边实例对象，右边构造函数\nconsole.log(f1 instanceof Foo) // true\nconsole.log(f1 instanceof Object) //* true \n\n\n1\n2\n3\n4\n\n\n\n\n🌰 例子 2️⃣：\n\nconsole.log(Object instanceof Function) // true\nconsole.log(Object instanceof Object) // true\nconsole.log(Function instanceof Function) // true\nconsole.log(Function instanceof Object) // true\n\n\n1\n2\n3\n4\n\n\nfunction Foo() { }\nconsole.log(Object instanceof Foo) // false\n\n\n1\n2\n\n\n\n\n\n# ⭐️ 题相关\n\n1️⃣\n\nfunction A() { }\nA.prototype.n = 1\n\nvar b = new A()\n\nA.prototype = {\n  n: 2,\n  m: 3\n}\n\nvar c = new A()\n\nconsole.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n2️⃣\n\nfunction F() { }\nObject.prototype.a = function(){\n  console.log('a()')\n}\nFunction.prototype.b = function(){\n  console.log('b()')\n}\n\nvar f = new F()\nf.a() // 'a()'\n// f.b() // error\nF.a() // 'a()'\nF.b() // 'b()'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"> 相关问题：\n> \n>  * 说说你对原型、原型链的理解。\n>  * 原型有什么特点。\n\n\n# javascript 原型\n\n> javascript 的每个对象都拥有一个原型对象，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。\n\n * 函数的 prototype 属性：\n   * 每个函数都有一个 prototype 属性，它默认指向一个 object 空对象（即原型对象 ）。\n   * 原型对象中有一个属性 constructor ，它指向函数对象。\n * 给原型对象添加属性（一般为方法），⭐️ 作用：函数的所有实例对象自动拥有原型中的属性（方法）。\n\n🌰 例子：\n\nconsole.log(date.prototype, typeof date.prototype)\n\nfunction fun(){\n  \n}\nconsole.log(fun.prototype)\nconsole.log(date.prototype.constructor===date)\nconsole.log(fun.prototype.constructor===fun)\n\nfun.prototype.test = function (){\n  cosole.log(\"test()\")\n}\n\nvar fun = new fun()\nfun.test() // \"test()\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n:::\n\n\n# 显式原型与隐式原型\n\n * 显式原型：指每个函数 function 都有的原型 prototype （属性）。默认指向一个空的 object 对象。\n * 隐式原型：指每个实例对象都有一个的 __proto__ （属性）。\n\n对象的隐式原型的值为其对应构造函数的显性原型的值。\n\n注意\n\n⚠️ 在 es6 之前，程序员能直接操作显式原型，但是不能直接操作隐式原型。\n\n🌰 例子：\n\nfunction fn(){\n  // ... \n} // 可理解为 this.prototype = { ... }\n\n// (1)\nconsole.log(fn.prototype) // object\n// (2)\nvar fn = new fn() // 可理解为 this.__proto__ = fn.prototype\nconsole.log(fn.__proto__) // object\n// (3)\nconsole.log(fn.prototype==fn.__proto__) // true\n\nfn.prototype.test = function () {\n  console.log(\"test\")\n} // 给原型添加方法\nfn.test() // test // 可以通过实例调用原型的方法 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n\n# javascript 原型链\n\n * 当访问一个对象的属性时，\n   1. 先在自身的属性中查找，找到则返回；\n   2. 如果没有找到，则再沿着 __proto__ 这条链向上查找，找到则返回；\n   3. 如果最终没找到，则返回 undefined 。\n\n上述查找过程为原型链，又称为隐式原型链。\n\n🌰 例子：\n\nfunction fn(){\n  this.test1 = function (){\n    console.log(\"test1)\")\n  }\n}\n\nfn.prototype.test2 = function () {\n  console.log(\"test2()\")\n}\n\nvar fn = new fn()\n\nfn.test1()\nfn.test2()\nconsole.log(fn.tostring())\nfn.test3() // error!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n作用：查找对象的属性（方法）\n\n * 构造函数 / 原型 / 实例对象的关系 1️⃣：\n   \n   var o1 = new object()\n   var o2 = {}\n   \n   \n   1\n   2\n   \n   \n   \n\n * 构造函数 / 原型 / 实例对象的关系 2️⃣ ：\n   \n   function foo(){ }\n   // var foo = new function()\n   // function = new function()\n   \n   \n   1\n   2\n   3\n   \n   \n   注意\n   \n   所有函数的 __proto__ 都是一样的。\n   \n   \n\n🔧 问题补充：\n\n注意\n\n * 函数的显式原型指向的对象是是空的 object 实例对象，但是 object 不满足。\n   \n   console.log(fn.prototype instanceof object) // true\n   console.log(object.prototype instanceof object) // false\n   cosole.log(function.prototype instanceof object) // true\n   \n   \n   1\n   2\n   3\n   \n\n * 所有的函数都是 function 的实例，包括 function 本身（ function 是它自身的实例）。\n   \n   console.log(function.__proto__===function.prototype) // true\n   \n   \n   1\n   \n\n * object 的原型对象是原型链的尽头。\n   \n   console.log(object.prototype.__proto__) // null\n   \n   \n   1\n   \n\n\n# 原型链的属性问题\n\n * 读取对象的属性时，会自动到原型链中查找。\n * 设置对象的属性值时，⚠️ 不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置此值。\n * 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。\n\n🌰 例子：\n\nfunction fn() {}\nfn.prototype.a = 'xxx'\nvar fn1 = new fn()\nconsole.log(fn.a) // 'xxx'\n\nvar fn2 = new fn()\nfn2.a = 'yyy'\nconsole.log(fn1.a) // 'xxx'\nconsole.log(fn2.a) // 'yyy' \n//  cosole.log(fn2.__proto__.a) // 'xxx'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子：\n\nfunction person(name, age) {\n  this.name = name\n  this.age =age\n}\n\nperson.prototype.setname = function(name) = {\n  this.name = name\n}\n\nvar p1 = new person('tom', 12)\np1.setname('bob')\nconsole.log(p1.name, p1.age) // bob, 12\n\nvar p2 = person('sid', 12)\np2.setname('kat')\nconsole.log(p2.name, p2.age) // kat, 12\nconsole.log(p1.__proto__==p2.__proto__) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# instanceof\n\n * 表达式： a instanceof b\n * 如果 b 函数的显示原型对象在 a 对象的原型链上（则 a 是 b 的实例），返回 true ，否则返回 false 。\n\n🌰 例子 1️⃣ ：\n\nfunction foo() { }\nvar f1 = new foo() // 左边实例对象，右边构造函数\nconsole.log(f1 instanceof foo) // true\nconsole.log(f1 instanceof object) //* true \n\n\n1\n2\n3\n4\n\n\n\n\n🌰 例子 2️⃣：\n\nconsole.log(object instanceof function) // true\nconsole.log(object instanceof object) // true\nconsole.log(function instanceof function) // true\nconsole.log(function instanceof object) // true\n\n\n1\n2\n3\n4\n\n\nfunction foo() { }\nconsole.log(object instanceof foo) // false\n\n\n1\n2\n\n\n\n\n\n# ⭐️ 题相关\n\n1️⃣\n\nfunction a() { }\na.prototype.n = 1\n\nvar b = new a()\n\na.prototype = {\n  n: 2,\n  m: 3\n}\n\nvar c = new a()\n\nconsole.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n2️⃣\n\nfunction f() { }\nobject.prototype.a = function(){\n  console.log('a()')\n}\nfunction.prototype.b = function(){\n  console.log('b()')\n}\n\nvar f = new f()\nf.a() // 'a()'\n// f.b() // error\nf.a() // 'a()'\nf.b() // 'b()'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 继承相关",frontmatter:{title:"🍎 JavaScript 继承相关",date:"2022-06-26T23:19:10.000Z",permalink:"/pages/bc77a3/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 JavaScript 原型与继承相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/04.%20%F0%9F%8D%8E%20JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20JavaScript%20%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/04. 🍎 JavaScript 原型与继承相关/02. 🍎 JavaScript 继承相关.md",key:"v-c8d7917a",path:"/pages/bc77a3/",headersStr:null,content:"> 相关问题：\n> \n>  * JavaScript 中如何实现继承？",normalizedContent:"> 相关问题：\n> \n>  * javascript 中如何实现继承？",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 ES6 新增特性",frontmatter:{title:"🍏 ES6 新增特性",date:"2022-06-08T17:38:36.000Z",permalink:"/pages/104705/",categories:["🪞冲刺","🗾 JavaScript 相关","🍎 ES6 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8E%20ES6%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8F%20ES6%20%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/02. 🍏 ES6 新增特性.md",key:"v-150471d8",path:"/pages/104705/",headers:[{level:2,title:"ES6 数组",slug:"es6-数组",normalizedTitle:"es6 数组",charIndex:2},{level:2,title:"ES6 对象",slug:"es6-对象",normalizedTitle:"es6 对象",charIndex:13},{level:2,title:"ES6 函数",slug:"es6-函数",normalizedTitle:"es6 函数",charIndex:24},{level:2,title:"ES6 Map / Set",slug:"es6-map-set",normalizedTitle:"es6 map / set",charIndex:35}],headersStr:"ES6 数组 ES6 对象 ES6 函数 ES6 Map / Set",content:"# ES6 数组\n\n\n# ES6 对象\n\n\n# ES6 函数\n\n\n# ES6 Map / Set\n\nMap 字典：是一些元素的集合，每个元素都有一个 key ，不同的元素的 key 不同。\n\nSet 集合：由一堆无序、相关联，并且不重复的内存结构（元素）组成的组合。\n\n两者的区别：\n\n * 共同点：集合和字典都可以存储不重复的值；\n * 不同点：集合以 [value, value] 的形式存储元素；字典以 [key, value] 的形式存储。",normalizedContent:"# es6 数组\n\n\n# es6 对象\n\n\n# es6 函数\n\n\n# es6 map / set\n\nmap 字典：是一些元素的集合，每个元素都有一个 key ，不同的元素的 key 不同。\n\nset 集合：由一堆无序、相关联，并且不重复的内存结构（元素）组成的组合。\n\n两者的区别：\n\n * 共同点：集合和字典都可以存储不重复的值；\n * 不同点：集合以 [value, value] 的形式存储元素；字典以 [key, value] 的形式存储。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 ES6 Promise 相关",frontmatter:{title:"🍎 ES6 Promise 相关",date:"2022-06-08T17:39:18.000Z",permalink:"/pages/c14014/",categories:["🪞冲刺","🗾 JavaScript 相关","🍎 ES6 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8E%20ES6%20%E7%9B%B8%E5%85%B3/03.%20%F0%9F%8D%8E%20ES6%20Promise%20%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/03. 🍎 ES6 Promise 相关.md",key:"v-cd5ad1da",path:"/pages/c14014/",headers:[{level:2,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:14},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:32},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:423}],headersStr:"理解 应用场景 参考",content:">  * Promise 的理解？\n>  * Promise 的应用场景？\n\n\n# 理解\n\nPromise 是一种异步编程的解决方案，相比传统的解决方案（回调函数）更加合理和强大。可以理解为一个容器，保存着某个未来才会结束的事件（通常是一个异步操作的结果）。\n\n语法上，Promise 是一个对象，从它可以获取异步操作的信息。Promise 提供统一的 API，各种异步操作都可以用同样的方式处理。\n\nPromise 解决异步编程的优点：\n\n * 链式操作降低编码难度；\n * 代码可读性增强啊；\n\nPromise 有三种状态：\n\n * pending / 进行中\n * fulfilled / 已成功\n * rejected / 已失败\n\nPromise 的特点：\n\n * 对象的状态不会受到外界的影响，只有异步操作的结果，可以决定当前是哪一种状态；\n * 一旦状态发生改变，就不会再变，任何时候都可以得到这个结果。\n\n\n# 应用场景\n\n\n# 参考\n\n * ES6 入门教程 (ruanyifeng.com)",normalizedContent:">  * promise 的理解？\n>  * promise 的应用场景？\n\n\n# 理解\n\npromise 是一种异步编程的解决方案，相比传统的解决方案（回调函数）更加合理和强大。可以理解为一个容器，保存着某个未来才会结束的事件（通常是一个异步操作的结果）。\n\n语法上，promise 是一个对象，从它可以获取异步操作的信息。promise 提供统一的 api，各种异步操作都可以用同样的方式处理。\n\npromise 解决异步编程的优点：\n\n * 链式操作降低编码难度；\n * 代码可读性增强啊；\n\npromise 有三种状态：\n\n * pending / 进行中\n * fulfilled / 已成功\n * rejected / 已失败\n\npromise 的特点：\n\n * 对象的状态不会受到外界的影响，只有异步操作的结果，可以决定当前是哪一种状态；\n * 一旦状态发生改变，就不会再变，任何时候都可以得到这个结果。\n\n\n# 应用场景\n\n\n# 参考\n\n * es6 入门教程 (ruanyifeng.com)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 ES6 Generator 相关",frontmatter:{title:"🍏 ES6 Generator 相关",date:"2022-06-08T17:39:49.000Z",permalink:"/pages/f1fa30/",categories:["🪞冲刺","🗾 JavaScript 相关","🍎 ES6 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8E%20ES6%20%E7%9B%B8%E5%85%B3/04.%20%F0%9F%8D%8F%20ES6%20Generator%20%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/04. 🍏 ES6 Generator 相关.md",key:"v-3cd3d4c7",path:"/pages/f1fa30/",headers:[{level:2,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:7},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:45}],headersStr:"理解 使用场景",content:">  * 怎么理解 ES6 中的 Generator ？\n>  * Generator 的使用场景？\n\n\n# 理解\n\nES6 中的 Generator 函数是一种异步编程的解决方案，语法行为与传统的函数不相同。\n\n> 此前，解决异步编程的手段有：回调函数和 Promise。\n\n执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。形式上，Generator 函数是一个普通函数，但是有两个特征： function 关键词与 Generator 函数名称之间有一个星号 * ；函数体内部使用 yield 表达式，定义不同的内部状态。\n\n🌰 例子：\n\nfunction* myGenerator() {\n  yield 'hello'\n  yield 'world'\n}\n\n\n1\n2\n3\n4\n\n\n\n# 使用场景\n\nGenerator 函数会返回一个遍历器对象，即具有 Symbol.iterator （可迭代）属性，并且返回自身。\n\n🌰 例子：\n\nfunction* gen {\n  // ...\n}\n\nvar g = gen()\ng[Symol.iterator]() === g // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过 yield 关键字可以暂停 Generator 函数返回的遍历器对象的状态。\n\n🌰 例子：\n\nfunction* myGenerator() {\n  yield 'hello'\n  yield 'world'\n  yield 'generator'\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 这个例子中的 Generator 函数存在三个状态，分别是 hello 、 world 、 generator 。\n\n通过 next 方法可以遍历到下一个内部状态。其运行逻辑为：\n\n * 遇到 yield 表达式就会暂停执行后面的操作，并将紧跟 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。\n * 下一次调用 next 方法时，再继续往下执行，知道遇到下一个 yield 表达式。\n * 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并且将 return 语句后面的表达式的值作为返回的对象的 value 属性值。\n * 如果该函数没有 return 表达式，则返回的对象的 value 属性值为 undefined 。\n\nvar mg = myGenerator()\n\nmg.next() // { value: 'hello', done: false }\nmg.next() // { value: 'world', done: false }\nmg.next() // { value: 'generator', done: true }\nmg.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n\n\n> value 对应状态值， done 表示下个状态是否存在（存在为 false ， true 为不存在）。 yield 表达式本身没有返回值，总是返回 undefined 。\n\n🌰 完整例子：\n\nfunction* foo(x) {\n \tlet y = 2 * (yield (x + 1))\n  let z = yield (y / 3)\n  return (x + y + z)\n}\n\nlet a = foo(5)\na.next() // Object{value:6, done:false}\na.next() // Object{null, done:false}\na.next() // Object{null, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:">  * 怎么理解 es6 中的 generator ？\n>  * generator 的使用场景？\n\n\n# 理解\n\nes6 中的 generator 函数是一种异步编程的解决方案，语法行为与传统的函数不相同。\n\n> 此前，解决异步编程的手段有：回调函数和 promise。\n\n执行 generator 函数会返回一个遍历器对象，可以依次遍历 generator 函数内部的每一个状态。形式上，generator 函数是一个普通函数，但是有两个特征： function 关键词与 generator 函数名称之间有一个星号 * ；函数体内部使用 yield 表达式，定义不同的内部状态。\n\n🌰 例子：\n\nfunction* mygenerator() {\n  yield 'hello'\n  yield 'world'\n}\n\n\n1\n2\n3\n4\n\n\n\n# 使用场景\n\ngenerator 函数会返回一个遍历器对象，即具有 symbol.iterator （可迭代）属性，并且返回自身。\n\n🌰 例子：\n\nfunction* gen {\n  // ...\n}\n\nvar g = gen()\ng[symol.iterator]() === g // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过 yield 关键字可以暂停 generator 函数返回的遍历器对象的状态。\n\n🌰 例子：\n\nfunction* mygenerator() {\n  yield 'hello'\n  yield 'world'\n  yield 'generator'\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 这个例子中的 generator 函数存在三个状态，分别是 hello 、 world 、 generator 。\n\n通过 next 方法可以遍历到下一个内部状态。其运行逻辑为：\n\n * 遇到 yield 表达式就会暂停执行后面的操作，并将紧跟 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。\n * 下一次调用 next 方法时，再继续往下执行，知道遇到下一个 yield 表达式。\n * 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并且将 return 语句后面的表达式的值作为返回的对象的 value 属性值。\n * 如果该函数没有 return 表达式，则返回的对象的 value 属性值为 undefined 。\n\nvar mg = mygenerator()\n\nmg.next() // { value: 'hello', done: false }\nmg.next() // { value: 'world', done: false }\nmg.next() // { value: 'generator', done: true }\nmg.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n\n\n> value 对应状态值， done 表示下个状态是否存在（存在为 false ， true 为不存在）。 yield 表达式本身没有返回值，总是返回 undefined 。\n\n🌰 完整例子：\n\nfunction* foo(x) {\n \tlet y = 2 * (yield (x + 1))\n  let z = yield (y / 3)\n  return (x + y + z)\n}\n\nlet a = foo(5)\na.next() // object{value:6, done:false}\na.next() // object{null, done:false}\na.next() // object{null, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 ES6 Module 模块化相关",frontmatter:{title:"🍏 ES6 Module 模块化相关",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/0e8ab8/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关","🍎 ES6 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/10.%20%F0%9F%8D%8E%20ES6%20%E7%9B%B8%E5%85%B3/05.%20%F0%9F%8D%8F%20ES6%20Module%20%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/05. 🍏 ES6 Module 模块化相关.md",key:"v-42cd3ee3",path:"/pages/0e8ab8/",headersStr:null,content:"> 相关问题：\n> \n>  * ",normalizedContent:"> 相关问题：\n> \n>  * ",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 事件循环相关",frontmatter:{title:"🍎 JavaScript 事件循环相关",date:"2022-07-02T22:48:22.000Z",permalink:"/pages/a30824/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/12.%20%F0%9F%8D%8E%20JavaScript%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/12. 🍎 JavaScript 事件循环相关.md",key:"v-397483cd",path:"/pages/a30824/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:30},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:"微任务与宏任务",slug:"微任务与宏任务",normalizedTitle:"微任务与宏任务",charIndex:1053},{level:3,title:"微任务",slug:"微任务",normalizedTitle:"微任务",charIndex:1053},{level:3,title:"宏任务",slug:"宏任务",normalizedTitle:"宏任务",charIndex:1057},{level:3,title:"微任务与宏任务的关系",slug:"微任务与宏任务的关系",normalizedTitle:"微任务与宏任务的关系",charIndex:2107},{level:2,title:"async 与 await",slug:"async-与-await",normalizedTitle:"async 与 await",charIndex:2488},{level:3,title:"async",slug:"async",normalizedTitle:"async",charIndex:2488},{level:3,title:"await",slug:"await",normalizedTitle:"await",charIndex:2496}],headersStr:"概念  微任务与宏任务 微任务 宏任务 微任务与宏任务的关系 async 与 await async await",content:"> 相关问题：\n> \n>  * 对事件循环的理解。\n\n\n# 概念\n\nJavaScript 是一门单线程的语言。意味着同一时间内只做一件事情，但不意味着单线程就是阻塞，而实现单线程不阻塞的方法就是事件循环。\n\nJavaScript 中的所有的任务都可以分为 同步任务 和 异步任务：\n\n * 同步任务：立即执行的任务，同步任务一般直接进入主线程中；\n * 异步任务：异步执行的任务。例如 AJAX 网络请求； setTimeout 定时函数。\n\n如下图，同步任务与异步任务的运行流程图：\n\n\n\n同步任务进入主线程，即主执行栈；异步任务进入任务队列，主线程内的任务执行完毕为空，就会去任务队列中读取对应的任务，推入到主线程执行，上述过程不断重复形成 事件循环。\n\n\n#\n\n🌰 例子：\n\n::: demo[vanilla]\n\n<html>\n  <button id=\"btn\">\n    启动定时器\n  </button>\n</html>\n<script>\ndocument.getElementById(\"btn\").onclick = function () {\n  var start = Date.now();\n  alert(\"启动定时器前\");\n  setTimeout(function () {\n    console.log(\"定时器执行了\", Date.now() - start);\n  });\n  alert(\"启动定时结果\");\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n:::\n\n> 定时器真的是定时执行吗：定时器并不能保证真正定时执行，一般会存在可以接受的延迟，但也有可能受代码量的影响带来不能接受的很长的延迟时间。\n> \n> 定时器回调函数是在分线程执行的吗：在主线程执行的，JavaScript 是单线程的。\n> \n> 定时器是如何实现的：事件循环模型。\n\n如何证明 JavaScript 是单线程的：\n\n * setTimeout() 的回调函数是在主线程执行的。\n * 定时器回调数只有运行栈中的代码全部运行完才有可能执行。\n\n为什么 JavaScript 要用单线程模式，而不用多线程模式：\n\n * JavaScript 的单线程 ** 与它的用途有关：** 作为浏览器的脚本语言，JavaScript 的主要用途是与用户互动以及操作 DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。\n\n\n# 微任务与宏任务\n\n🌰 例子：\n\nconsole.log(1)\n\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\n\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\n\nconsole.log(3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 按照上面的 事件循环机制：\n> \n>  * console.log(1) ，同步任务，主线程中执行；\n>  * setTimeout() ，异步任务，放到 Event Table ，0 毫秒后 console.log(2) 回调推入 Event Queue 中；\n>  * new Promise ，同步任务，主线程直接执行；\n>  * .then ，异步任务，放到 Event Table ；\n>  * console.log(3) ，同步任务，主线程执行；\n> \n> 所以按照这个分析，输出的结果应该是： 1 => new Promise => 3 => 2 => then 。\n> \n> 但是实际的结果应该是： 1 => new Promise => 3 => then => 2 。\n> \n> 因为异步任务的执行也有顺序。事件队列其实是一个 先进先出的数据结构，排在前面的事件优先被主线程读取。但是这里 .then 的执行却早于 setTimeout 的回调事件。\n\n原因在于异步任务还可以细分为 微任务与宏任务。\n\n\n# 微任务\n\n一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。\n\n常见的微任务有：\n\n * Promise.then\n * MutationObserver\n * Object.observe() （已废弃，被 Proxy 对象替代）\n * process.nextTick （NodeJS）\n\n\n# 宏任务\n\n宏任务的时间粒度较大，执行的时间间隔不能精确控制，对于一些高实时性的需求不太符合。\n\n常见的宏任务有：\n\n * script\n * setTimeout\n * UI 渲染事件 / UI rendering\n * postMessage / MessageChannel\n * setImmediate 、 I/O （NodeJS）\n\n\n# 微任务与宏任务的关系\n\n事件循环中：\n\n执行一个宏任务，如果遇到微任务就将它放进微任务的事务队列中。\n\n当前宏任务执行完成之后，会查看微任务的时间队列，然后将里面的所有微任务依次执行完。\n\n回到上面的例子：\n\n * 遇到 console.log(1) ，直接打印 1 ；\n * 遇到定时器，属于新的宏任务，留着后面执行；\n * 遇到 new Promise ，这个是直接执行的，打印 'new Promise' ；\n * 遇到 .then 属于微任务，放入微任务队列，后面再执行；\n * 遇到 console.log(3) 直接打印 3 ；\n * 本轮宏任务执行完毕，然后去微任务列表中查看是否有微任务，发现 .then 的回调，执行它，打印 ‘.then’ 。\n * 当一次宏任务执行完，再去执行新的宏任务，这里就剩下一个宏任务，执行它，打印 2 。\n\n\n# async 与 await\n\nasync 是异步的意思， await 则可以理解为 async wait 。所以可以理解 async 就是用来声明一个异步方法，而 await 是用来等待异步方法执行。\n\n\n# async\n\nasync 函数返回一个 promise 对象。\n\n🌰 例子：\n\nfunction f() {\n    return Promise.resolve('TEST');\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n    return 'TEST';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 两种方法等效。\n\n\n# await\n\n正常情况下， await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。\n\n🌰 例子：\n\nasync function f() {\n  return await 123\n  // return 123\n}\n\nf().then(v => console.log(v)) // 123\n\n\n1\n2\n3\n4\n5\n6\n\n\n不管 await 后面跟着什么， await 都会阻塞后面的代码：\n\nasync function fn1() {\n  console.log(1)\n  await fn2()\n  console.log(2)\n}\n\nasync function fn2 (){\n  console.log('fn2')\n}\n\nfn1()\nconsole.log(3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> await 会阻塞下面的代码（即加入微任务队列），先执行 async 外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码。\n> \n> 所以输出的结果的顺序为 1 => fn2 => 3 => 2",normalizedContent:"> 相关问题：\n> \n>  * 对事件循环的理解。\n\n\n# 概念\n\njavascript 是一门单线程的语言。意味着同一时间内只做一件事情，但不意味着单线程就是阻塞，而实现单线程不阻塞的方法就是事件循环。\n\njavascript 中的所有的任务都可以分为 同步任务 和 异步任务：\n\n * 同步任务：立即执行的任务，同步任务一般直接进入主线程中；\n * 异步任务：异步执行的任务。例如 ajax 网络请求； settimeout 定时函数。\n\n如下图，同步任务与异步任务的运行流程图：\n\n\n\n同步任务进入主线程，即主执行栈；异步任务进入任务队列，主线程内的任务执行完毕为空，就会去任务队列中读取对应的任务，推入到主线程执行，上述过程不断重复形成 事件循环。\n\n\n#\n\n🌰 例子：\n\n::: demo[vanilla]\n\n<html>\n  <button id=\"btn\">\n    启动定时器\n  </button>\n</html>\n<script>\ndocument.getelementbyid(\"btn\").onclick = function () {\n  var start = date.now();\n  alert(\"启动定时器前\");\n  settimeout(function () {\n    console.log(\"定时器执行了\", date.now() - start);\n  });\n  alert(\"启动定时结果\");\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n:::\n\n> 定时器真的是定时执行吗：定时器并不能保证真正定时执行，一般会存在可以接受的延迟，但也有可能受代码量的影响带来不能接受的很长的延迟时间。\n> \n> 定时器回调函数是在分线程执行的吗：在主线程执行的，javascript 是单线程的。\n> \n> 定时器是如何实现的：事件循环模型。\n\n如何证明 javascript 是单线程的：\n\n * settimeout() 的回调函数是在主线程执行的。\n * 定时器回调数只有运行栈中的代码全部运行完才有可能执行。\n\n为什么 javascript 要用单线程模式，而不用多线程模式：\n\n * javascript 的单线程 ** 与它的用途有关：** 作为浏览器的脚本语言，javascript 的主要用途是与用户互动以及操作 dom，这决定了它只能是单线程，否则会带来很复杂的同步问题。\n\n\n# 微任务与宏任务\n\n🌰 例子：\n\nconsole.log(1)\n\nsettimeout(()=>{\n    console.log(2)\n}, 0)\n\nnew promise((resolve, reject)=>{\n    console.log('new promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\n\nconsole.log(3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 按照上面的 事件循环机制：\n> \n>  * console.log(1) ，同步任务，主线程中执行；\n>  * settimeout() ，异步任务，放到 event table ，0 毫秒后 console.log(2) 回调推入 event queue 中；\n>  * new promise ，同步任务，主线程直接执行；\n>  * .then ，异步任务，放到 event table ；\n>  * console.log(3) ，同步任务，主线程执行；\n> \n> 所以按照这个分析，输出的结果应该是： 1 => new promise => 3 => 2 => then 。\n> \n> 但是实际的结果应该是： 1 => new promise => 3 => then => 2 。\n> \n> 因为异步任务的执行也有顺序。事件队列其实是一个 先进先出的数据结构，排在前面的事件优先被主线程读取。但是这里 .then 的执行却早于 settimeout 的回调事件。\n\n原因在于异步任务还可以细分为 微任务与宏任务。\n\n\n# 微任务\n\n一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。\n\n常见的微任务有：\n\n * promise.then\n * mutationobserver\n * object.observe() （已废弃，被 proxy 对象替代）\n * process.nexttick （nodejs）\n\n\n# 宏任务\n\n宏任务的时间粒度较大，执行的时间间隔不能精确控制，对于一些高实时性的需求不太符合。\n\n常见的宏任务有：\n\n * script\n * settimeout\n * ui 渲染事件 / ui rendering\n * postmessage / messagechannel\n * setimmediate 、 i/o （nodejs）\n\n\n# 微任务与宏任务的关系\n\n事件循环中：\n\n执行一个宏任务，如果遇到微任务就将它放进微任务的事务队列中。\n\n当前宏任务执行完成之后，会查看微任务的时间队列，然后将里面的所有微任务依次执行完。\n\n回到上面的例子：\n\n * 遇到 console.log(1) ，直接打印 1 ；\n * 遇到定时器，属于新的宏任务，留着后面执行；\n * 遇到 new promise ，这个是直接执行的，打印 'new promise' ；\n * 遇到 .then 属于微任务，放入微任务队列，后面再执行；\n * 遇到 console.log(3) 直接打印 3 ；\n * 本轮宏任务执行完毕，然后去微任务列表中查看是否有微任务，发现 .then 的回调，执行它，打印 ‘.then’ 。\n * 当一次宏任务执行完，再去执行新的宏任务，这里就剩下一个宏任务，执行它，打印 2 。\n\n\n# async 与 await\n\nasync 是异步的意思， await 则可以理解为 async wait 。所以可以理解 async 就是用来声明一个异步方法，而 await 是用来等待异步方法执行。\n\n\n# async\n\nasync 函数返回一个 promise 对象。\n\n🌰 例子：\n\nfunction f() {\n    return promise.resolve('test');\n}\n\n// asyncf is equivalent to f!\nasync function asyncf() {\n    return 'test';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 两种方法等效。\n\n\n# await\n\n正常情况下， await 命令后面是一个 promise 对象，返回该对象的结果。如果不是 promise 对象，就直接返回对应的值。\n\n🌰 例子：\n\nasync function f() {\n  return await 123\n  // return 123\n}\n\nf().then(v => console.log(v)) // 123\n\n\n1\n2\n3\n4\n5\n6\n\n\n不管 await 后面跟着什么， await 都会阻塞后面的代码：\n\nasync function fn1() {\n  console.log(1)\n  await fn2()\n  console.log(2)\n}\n\nasync function fn2 (){\n  console.log('fn2')\n}\n\nfn1()\nconsole.log(3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> await 会阻塞下面的代码（即加入微任务队列），先执行 async 外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码。\n> \n> 所以输出的结果的顺序为 1 => fn2 => 3 => 2",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 事件模型",frontmatter:{title:"🍎 JavaScript 事件模型",date:"2022-06-27T10:51:25.000Z",permalink:"/pages/2f3265/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/11.%20%F0%9F%8D%8E%20JavaScript%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/11. 🍎 JavaScript 事件模型.md",key:"v-307c0396",path:"/pages/2f3265/",headers:[{level:2,title:"概念：事件与事件流",slug:"概念-事件与事件流",normalizedTitle:"概念：事件与事件流",charIndex:42},{level:2,title:"概念：事件模型",slug:"概念-事件模型",normalizedTitle:"概念：事件模型",charIndex:220},{level:3,title:"原始事件模型",slug:"原始事件模型",normalizedTitle:"原始事件模型",charIndex:247},{level:3,title:"标准事件模型",slug:"标准事件模型",normalizedTitle:"标准事件模型",charIndex:266}],headersStr:"概念：事件与事件流 概念：事件模型 原始事件模型 标准事件模型",content:"> 相关问题：\n> \n>  * JavaScript 中对事件模型的理解。\n\n\n# 概念：事件与事件流\n\nJavaScript 中的事件，理解为在 HTML 文档或者浏览器中发生的交互操作。常见的事件有 加载事件、鼠标事件、自定义事件。\n\nDOM 是一个树结构，如果父子节点绑定事件时，当触发子节点时，存在事件的顺序问题。这就涉及事件流的概念。\n\n事件流都会经历三个阶段：\n\n * 事件捕获阶段\n * 目标阶段\n * 冒泡阶段\n\n\n\n\n# 概念：事件模型\n\n事件模型可以分为三种类型：\n\n * 原始事件模型（DOM 0 级）\n * 标准事件模型（DOM 2 级）\n * IE 事件模型（基本不用）\n\n\n# 原始事件模型\n\n特点：\n\n * 事件绑定速度快；\n * 只支持冒泡，不支持捕获；\n * 同一类型的事件只能绑定一次；\n\n🌰 例子 / 事件绑定监听函数的方式：\n\n在 HTML 中直接绑定：\n\n<input type=\"button\" onclick=\"fun()\">\n\n\n1\n\n\n通过 JavaScript 代码绑定：\n\nvar btn = document.getElementById(\"#btn\")\nbtn.onclick = function() {\n  ...\n}\n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 同类型的事件只能绑定一次：\n\n<input type=\"button\" id=\"btn\" onclick=\"fun1()\">\n\n\n1\n\n\nvar btn = document.getElementById('.btn');\nbtn.onclick = fun2;\n\n\n1\n2\n\n\n> 这里为 btn 绑定了两个同类型的（点击）事件，后面绑定的事件会覆盖之前的事件。\n\n🌰 例子 / 删除之间绑定的事件：\n\nbtn.onclick = null\n\n\n1\n\n\n\n# 标准事件模型\n\n该事件模型中，一次事件共有三个过程：\n\n * 事件捕获阶段：事件从 document 一直向下传播到目标元素，一次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n * 事件处理阶段：事件到达目标元素，触发目标元素的监听函数。\n * 事件冒泡阶段：事件从目标元素冒泡到 document ，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n\n特点：\n\n * 可以在一个 DOM 元素上绑定多个事件处理器，各自不会冲突；\n * 执行实时机：当 addEventListener() 第三个参数 useCapture 设置为 true 就在捕获过程中执行，反之在冒泡过程中执行处理函数；\n\n🌰 例子 / 绑定监听函数和移除监听函数：\n\naddEventListener(eventType, handler, useCapture)\n\n\n1\n\n\nremoveEventListener(eventType, handler, useCapture)\n\n\n1\n\n\n🌰 例子 / 绑定点击事件：\n\nvar btn = document.getElementById('.btn');\nbtn.addEventListener(‘click’, showMessage, false);\nbtn.removeEventListener(‘click’, showMessage, false);\n\n\n1\n2\n3\n\n\n绑定多个点击事件：\n\nbtn.addEventListener(‘click’, showMessage1, false);\nbtn.addEventListener(‘click’, showMessage2, false);\nbtn.addEventListener(‘click’, showMessage3, false);\n\n\n1\n2\n3\n\n\n🌰 例子 / 设置事件的执行时机：\n\n<div id='div'>\n    <p id='p'>\n        <span id='span'>Click Me!</span>\n    </p >\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n设置 useCapture 为 false ：\n\nvar div = document.getElementById('div');\nvar p = document.getElementById('p');\n\nfunction onClickFn (event) {\n    var tagName = event.currentTarget.tagName;\n    var phase = event.eventPhase;\n    console.log(tagName, phase);\n}\n\ndiv.addEventListener('click', onClickFn, false);\np.addEventListener('click', onClickFn, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 使用了 eventPhase ，返回一个代表当前执行阶段的整数值。1 为捕获阶段、2 为事件对象触发阶段、3 为冒泡阶段。\n> \n> 此时， p 和 div 都在冒泡阶段响应了事件，因为冒泡的特性，所以 p 率先做出响应。\n> \n> 如果把 useCapture 设置为 true ，输出的结果应该为：\n> \n> DIV 1\n> P 1\n> \n> \n> 1\n> 2\n> \n> \n> 意味着两者都是在捕获阶段响应事件，所以 div 比 p 先做出响应。",normalizedContent:"> 相关问题：\n> \n>  * javascript 中对事件模型的理解。\n\n\n# 概念：事件与事件流\n\njavascript 中的事件，理解为在 html 文档或者浏览器中发生的交互操作。常见的事件有 加载事件、鼠标事件、自定义事件。\n\ndom 是一个树结构，如果父子节点绑定事件时，当触发子节点时，存在事件的顺序问题。这就涉及事件流的概念。\n\n事件流都会经历三个阶段：\n\n * 事件捕获阶段\n * 目标阶段\n * 冒泡阶段\n\n\n\n\n# 概念：事件模型\n\n事件模型可以分为三种类型：\n\n * 原始事件模型（dom 0 级）\n * 标准事件模型（dom 2 级）\n * ie 事件模型（基本不用）\n\n\n# 原始事件模型\n\n特点：\n\n * 事件绑定速度快；\n * 只支持冒泡，不支持捕获；\n * 同一类型的事件只能绑定一次；\n\n🌰 例子 / 事件绑定监听函数的方式：\n\n在 html 中直接绑定：\n\n<input type=\"button\" onclick=\"fun()\">\n\n\n1\n\n\n通过 javascript 代码绑定：\n\nvar btn = document.getelementbyid(\"#btn\")\nbtn.onclick = function() {\n  ...\n}\n\n\n1\n2\n3\n4\n\n\n🌰 例子 / 同类型的事件只能绑定一次：\n\n<input type=\"button\" id=\"btn\" onclick=\"fun1()\">\n\n\n1\n\n\nvar btn = document.getelementbyid('.btn');\nbtn.onclick = fun2;\n\n\n1\n2\n\n\n> 这里为 btn 绑定了两个同类型的（点击）事件，后面绑定的事件会覆盖之前的事件。\n\n🌰 例子 / 删除之间绑定的事件：\n\nbtn.onclick = null\n\n\n1\n\n\n\n# 标准事件模型\n\n该事件模型中，一次事件共有三个过程：\n\n * 事件捕获阶段：事件从 document 一直向下传播到目标元素，一次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n * 事件处理阶段：事件到达目标元素，触发目标元素的监听函数。\n * 事件冒泡阶段：事件从目标元素冒泡到 document ，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n\n特点：\n\n * 可以在一个 dom 元素上绑定多个事件处理器，各自不会冲突；\n * 执行实时机：当 addeventlistener() 第三个参数 usecapture 设置为 true 就在捕获过程中执行，反之在冒泡过程中执行处理函数；\n\n🌰 例子 / 绑定监听函数和移除监听函数：\n\naddeventlistener(eventtype, handler, usecapture)\n\n\n1\n\n\nremoveeventlistener(eventtype, handler, usecapture)\n\n\n1\n\n\n🌰 例子 / 绑定点击事件：\n\nvar btn = document.getelementbyid('.btn');\nbtn.addeventlistener(‘click’, showmessage, false);\nbtn.removeeventlistener(‘click’, showmessage, false);\n\n\n1\n2\n3\n\n\n绑定多个点击事件：\n\nbtn.addeventlistener(‘click’, showmessage1, false);\nbtn.addeventlistener(‘click’, showmessage2, false);\nbtn.addeventlistener(‘click’, showmessage3, false);\n\n\n1\n2\n3\n\n\n🌰 例子 / 设置事件的执行时机：\n\n<div id='div'>\n    <p id='p'>\n        <span id='span'>click me!</span>\n    </p >\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n设置 usecapture 为 false ：\n\nvar div = document.getelementbyid('div');\nvar p = document.getelementbyid('p');\n\nfunction onclickfn (event) {\n    var tagname = event.currenttarget.tagname;\n    var phase = event.eventphase;\n    console.log(tagname, phase);\n}\n\ndiv.addeventlistener('click', onclickfn, false);\np.addeventlistener('click', onclickfn, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 使用了 eventphase ，返回一个代表当前执行阶段的整数值。1 为捕获阶段、2 为事件对象触发阶段、3 为冒泡阶段。\n> \n> 此时， p 和 div 都在冒泡阶段响应了事件，因为冒泡的特性，所以 p 率先做出响应。\n> \n> 如果把 usecapture 设置为 true ，输出的结果应该为：\n> \n> div 1\n> p 1\n> \n> \n> 1\n> 2\n> \n> \n> 意味着两者都是在捕获阶段响应事件，所以 div 比 p 先做出响应。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 JavaScript 线程机制相关",frontmatter:{title:"🍏 JavaScript 线程机制相关",date:"2022-07-02T23:30:23.000Z",permalink:"/pages/a50766/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/13.%20%F0%9F%8D%8F%20JavaScript%20%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/13. 🍏 JavaScript 线程机制相关.md",key:"v-50732f42",path:"/pages/a50766/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2}],headersStr:"概念",content:"# 概念\n\n> 进程（Process）：程序的一次执行过程，它占有一片独有的内存空间。\n> \n> 线程（thread）：是进程内的一个独立执行单元，是程序执行的一个完整流程，是 CPU 的最小调度单位。\n> \n> \n> \n>  * 应用程序必须运行在某个进程的线程上。\n>  * 一个进程中至少有一个运行的线程：主线程（进程启动后会自动创建）。\n>  * 一个进程中也可以通行运行多个线程，即程序是多线程运行的。\n>  * 一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的。\n> \n> 线程池（Thread Pool）：保存多个线程对象的容器，实现对象的反复利用。\n> \n> 相关问题：\n> \n>  * 多进程运行：一个应用程序可以启动多个实例运行。\n>  * 多线程：在一个进程内，同时有多个线程运行。\n> \n> ----------------------------------------\n> \n> 比较单线程与多线程：\n> \n>  * 单线程：优点：顺序编程简单易懂。缺点：效率低。\n>  * 多线程：优点：能够有效提高 CPU 利用率；缺点：创建多线程的开销，线程间切换的开销，死锁与状态同步的问题。\n\nJavaSript 是单线程运行的脚本。但是在使用 HTML5 中的 Web Workers 可以多线程运行。\n\n浏览器运行是都是多线程运行的。\n\n浏览器运行有的是单进程有的是多进程。\n\n> 浏览器内核：\n> \n>  * 是支持浏览器运行的最核心的程序。\n> \n>  * 不同的浏览器可能不一样。\n>    \n>    * Chrome / Safari： Webkit\n>    * Firefox：Gecko\n>    * IE ：Trident\n> \n>  * 内核由很多模块组成：\n>    \n>    （主线程）\n>    \n>    * JS 引擎模块：负责 JavaScript 程序的编译和运行\n>    * HTML / CSS 文档解析模块：负责页面文本的解析\n>    * DOM / CSS 模块：负责 DOM / CSS 在内存中的相关处理\n>    * 布局和渲染模块：负责页面的布局和效果的绘制（参照内存中的对象）\n>    \n>    （分线程）\n>    \n>    * 定时器模块：负责定时器的管理\n>    * DOM 事件响应模块：负责事件的管理\n>    * 网络请求模块：负责 AJAX 等的请求\n\nJavaScript 的代码分类：\n\n * 初始化代码\n\n * 回调代码\n\nJavaScript 引擎执行代码的基本流程：\n\n 1. 先执行初始化代码，包含一些特别的代码。\n    * 设置定时器（回调函数异步执行）。\n    * 绑定监听。\n    * 发送 AJAX 请求。\n 2. 后面在某个时刻才会执行回调代码。",normalizedContent:"# 概念\n\n> 进程（process）：程序的一次执行过程，它占有一片独有的内存空间。\n> \n> 线程（thread）：是进程内的一个独立执行单元，是程序执行的一个完整流程，是 cpu 的最小调度单位。\n> \n> \n> \n>  * 应用程序必须运行在某个进程的线程上。\n>  * 一个进程中至少有一个运行的线程：主线程（进程启动后会自动创建）。\n>  * 一个进程中也可以通行运行多个线程，即程序是多线程运行的。\n>  * 一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的。\n> \n> 线程池（thread pool）：保存多个线程对象的容器，实现对象的反复利用。\n> \n> 相关问题：\n> \n>  * 多进程运行：一个应用程序可以启动多个实例运行。\n>  * 多线程：在一个进程内，同时有多个线程运行。\n> \n> ----------------------------------------\n> \n> 比较单线程与多线程：\n> \n>  * 单线程：优点：顺序编程简单易懂。缺点：效率低。\n>  * 多线程：优点：能够有效提高 cpu 利用率；缺点：创建多线程的开销，线程间切换的开销，死锁与状态同步的问题。\n\njavasript 是单线程运行的脚本。但是在使用 html5 中的 web workers 可以多线程运行。\n\n浏览器运行是都是多线程运行的。\n\n浏览器运行有的是单进程有的是多进程。\n\n> 浏览器内核：\n> \n>  * 是支持浏览器运行的最核心的程序。\n> \n>  * 不同的浏览器可能不一样。\n>    \n>    * chrome / safari： webkit\n>    * firefox：gecko\n>    * ie ：trident\n> \n>  * 内核由很多模块组成：\n>    \n>    （主线程）\n>    \n>    * js 引擎模块：负责 javascript 程序的编译和运行\n>    * html / css 文档解析模块：负责页面文本的解析\n>    * dom / css 模块：负责 dom / css 在内存中的相关处理\n>    * 布局和渲染模块：负责页面的布局和效果的绘制（参照内存中的对象）\n>    \n>    （分线程）\n>    \n>    * 定时器模块：负责定时器的管理\n>    * dom 事件响应模块：负责事件的管理\n>    * 网络请求模块：负责 ajax 等的请求\n\njavascript 的代码分类：\n\n * 初始化代码\n\n * 回调代码\n\njavascript 引擎执行代码的基本流程：\n\n 1. 先执行初始化代码，包含一些特别的代码。\n    * 设置定时器（回调函数异步执行）。\n    * 绑定监听。\n    * 发送 ajax 请求。\n 2. 后面在某个时刻才会执行回调代码。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🎱 JavaScript BOM 相关问题",frontmatter:{title:"🎱 JavaScript BOM 相关问题",date:"2022-06-06T15:26:34.000Z",permalink:"/pages/b84b16/",categories:["🪞冲刺","🗾 JavaScript 相关","JavaScript BOM 与 DOM"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/20.%20%F0%9F%8D%8F%20JavaScript%20BOM%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/20. 🍏 JavaScript BOM 相关问题.md",key:"v-4f7538bc",path:"/pages/b84b16/",headers:[{level:2,title:"BOM 的概念",slug:"bom-的概念",normalizedTitle:"bom 的概念",charIndex:37},{level:2,title:"常用的 BOM 对象 属性/方法",slug:"常用的-bom-对象-属性-方法",normalizedTitle:"常用的 bom 对象 属性 / 方法",charIndex:354},{level:3,title:"window",slug:"window",normalizedTitle:"window",charIndex:264},{level:3,title:"location",slug:"location",normalizedTitle:"location",charIndex:863},{level:3,title:"navigator",slug:"navigator",normalizedTitle:"navigator",charIndex:1417},{level:3,title:"screen",slug:"screen",normalizedTitle:"screen",charIndex:1552},{level:3,title:"history",slug:"history",normalizedTitle:"history",charIndex:1600}],headersStr:"BOM 的概念 常用的 BOM 对象 属性/方法 window location navigator screen history",content:">  * 对 BOM 的理解？\n>  * 常见的 BOM 对象？\n\n\n# BOM 的概念\n\nBOM （Browser Object Model） 是 浏览器对象模型，提供独立于内容与浏览器窗口进行交互的对象。\n\nBOM 的作用是，与浏览器完成交互，例如完成页面的后退、前进、刷新；浏览器的窗口的变化、滚动条的滚动；获取用户的客户端信息、浏览器信息、窗口分辨率等。\n\n> 与 DOM / 文档对象模型 相比：\n> \n> BOM              DOM\n> 浏览器对象模型          文档对象模型\n> 顶级对象是 window     顶级对象是 document\n> 主要是浏览器交互的对象      主要是操作页面元素\n> 是浏览器厂商在各自浏览器定义   是 W3C 的标准规范\n\n\n# 常用的 BOM 对象 属性 / 方法\n\n\n# window\n\n在浏览器中， window 既是 浏览器窗口的一个接口，又是全局对象（全局作用域中的变量、函数）。\n\n常用的窗口控制方法：\n\n * moveBy(x,y) ：从当前位置水平移动窗体 x 个像素，垂直移动窗体 y 个像素。右正负左；下正负上。\n * moveTo(x,y) ：移动窗体左上角到相对于屏幕左上角的 (x,y) 点；\n * resizeBy(w,h) ：相对窗体当前的大小，宽度调整 w 个像素，高度调整 h 个像素。如果参数为负值，将缩小窗体，反之扩大窗体。\n * scrollTo(x,y) ：如果有滚动条，将横向滚动条移动到相对于窗体宽度为 x 个像素的位置，将纵向滚动条移动到相对于窗体高度为 y 个像素的位置；\n * scrollBy(x,y) ： 如果有滚动条，将横向滚动条向左移动 x 个像素，将纵向滚动条向下移动 y 个像素；\n\n导航或者打开关闭窗口：\n\n * window.open() ：导航到特定的 URL 或者打开新的浏览器窗口；\n * winodw.close ：关闭通过 window.open 打开的窗口。\n\n\n# location\n\n获取 URL 中的内容，实例 URL：\n\nhttp://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents\n\n\n1\n\n\n * protocol ：使用的协议部分。（ http: ）\n\n * hostname ：URL 中的域名，不包含端口号。（ www.wrox.com ）\n\n * host ：URL 中服务器名称和端口号。（ www.wrox.com:80\n\n * port ：URL 中的端口号。（ 89 ）\n\n * pathname ：路径。( /WileyCDA/ )\n\n * search ：查询字符串，通常为 ? 符号后的内容（ ?q=javascript ）\n\n * hash ：URL 中 # 符号后的内容。（ #contents ）\n\n * href ：完整的 URL。\n\n只要修改 location 中的一个属性（除了 hash ） 就会导致页面重新加载 新的 URL。\n\n * location.reload() ：重新刷新当前页面。根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载。强制从服务器中加载，添加参数 true 。\n\n\n# navigator\n\n主要用来获取 浏览器的属性。\n\n * navigator.userAgent ：获取用户代理头的字符串表示（包括浏览器版本信息等的字符串）；\n * navigator.cookieEnabled ：返回浏览器是否支持（启用）cookie。\n\n\n# screen\n\n主要用来获取浏览器窗口外面客户端的显示器信息，例如像素宽度和像素高度。\n\n\n# history\n\n主要用来操作浏览器 URL 的 历史记录。可以通过参数向前、向后、或者指定 URL 跳转。\n\n * history.go() ：接收一个整数或者字符串参数，向最近的一个记录中包含指定的页面跳转；\n   \n   🌰 例子：\n   \n   history.go('javascript.com')\n   \n   \n   1\n   \n   \n   参数为正数数字时，正数表示向前跳转指定的页面，负数为向后跳转指定的页面：\n   \n   🌰 例子：\n   \n   history.go(2)\n   history.go(-2)\n   \n   \n   1\n   2\n   \n\n * history.forward() ：向前跳转一个页面\n\n * history.back() ：向后跳转一个页面\n\n * history.length ：获取历史记录数",normalizedContent:">  * 对 bom 的理解？\n>  * 常见的 bom 对象？\n\n\n# bom 的概念\n\nbom （browser object model） 是 浏览器对象模型，提供独立于内容与浏览器窗口进行交互的对象。\n\nbom 的作用是，与浏览器完成交互，例如完成页面的后退、前进、刷新；浏览器的窗口的变化、滚动条的滚动；获取用户的客户端信息、浏览器信息、窗口分辨率等。\n\n> 与 dom / 文档对象模型 相比：\n> \n> bom              dom\n> 浏览器对象模型          文档对象模型\n> 顶级对象是 window     顶级对象是 document\n> 主要是浏览器交互的对象      主要是操作页面元素\n> 是浏览器厂商在各自浏览器定义   是 w3c 的标准规范\n\n\n# 常用的 bom 对象 属性 / 方法\n\n\n# window\n\n在浏览器中， window 既是 浏览器窗口的一个接口，又是全局对象（全局作用域中的变量、函数）。\n\n常用的窗口控制方法：\n\n * moveby(x,y) ：从当前位置水平移动窗体 x 个像素，垂直移动窗体 y 个像素。右正负左；下正负上。\n * moveto(x,y) ：移动窗体左上角到相对于屏幕左上角的 (x,y) 点；\n * resizeby(w,h) ：相对窗体当前的大小，宽度调整 w 个像素，高度调整 h 个像素。如果参数为负值，将缩小窗体，反之扩大窗体。\n * scrollto(x,y) ：如果有滚动条，将横向滚动条移动到相对于窗体宽度为 x 个像素的位置，将纵向滚动条移动到相对于窗体高度为 y 个像素的位置；\n * scrollby(x,y) ： 如果有滚动条，将横向滚动条向左移动 x 个像素，将纵向滚动条向下移动 y 个像素；\n\n导航或者打开关闭窗口：\n\n * window.open() ：导航到特定的 url 或者打开新的浏览器窗口；\n * winodw.close ：关闭通过 window.open 打开的窗口。\n\n\n# location\n\n获取 url 中的内容，实例 url：\n\nhttp://foouser:barpassword@www.wrox.com:80/wileycda/?q=javascript#contents\n\n\n1\n\n\n * protocol ：使用的协议部分。（ http: ）\n\n * hostname ：url 中的域名，不包含端口号。（ www.wrox.com ）\n\n * host ：url 中服务器名称和端口号。（ www.wrox.com:80\n\n * port ：url 中的端口号。（ 89 ）\n\n * pathname ：路径。( /wileycda/ )\n\n * search ：查询字符串，通常为 ? 符号后的内容（ ?q=javascript ）\n\n * hash ：url 中 # 符号后的内容。（ #contents ）\n\n * href ：完整的 url。\n\n只要修改 location 中的一个属性（除了 hash ） 就会导致页面重新加载 新的 url。\n\n * location.reload() ：重新刷新当前页面。根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载。强制从服务器中加载，添加参数 true 。\n\n\n# navigator\n\n主要用来获取 浏览器的属性。\n\n * navigator.useragent ：获取用户代理头的字符串表示（包括浏览器版本信息等的字符串）；\n * navigator.cookieenabled ：返回浏览器是否支持（启用）cookie。\n\n\n# screen\n\n主要用来获取浏览器窗口外面客户端的显示器信息，例如像素宽度和像素高度。\n\n\n# history\n\n主要用来操作浏览器 url 的 历史记录。可以通过参数向前、向后、或者指定 url 跳转。\n\n * history.go() ：接收一个整数或者字符串参数，向最近的一个记录中包含指定的页面跳转；\n   \n   🌰 例子：\n   \n   history.go('javascript.com')\n   \n   \n   1\n   \n   \n   参数为正数数字时，正数表示向前跳转指定的页面，负数为向后跳转指定的页面：\n   \n   🌰 例子：\n   \n   history.go(2)\n   history.go(-2)\n   \n   \n   1\n   2\n   \n\n * history.forward() ：向前跳转一个页面\n\n * history.back() ：向后跳转一个页面\n\n * history.length ：获取历史记录数",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 本地存储相关",frontmatter:{title:"🍎 JavaScript 本地存储相关",date:"2022-07-03T11:22:03.000Z",permalink:"/pages/cc4083/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/30.%20%F0%9F%8D%8E%20JavaScript%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/30. 🍎 JavaScript 本地存储相关.md",key:"v-79207f6a",path:"/pages/cc4083/",headers:[{level:2,title:"主要的方式",slug:"主要的方式",normalizedTitle:"主要的方式",charIndex:56},{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:155},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:46},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:697}],headersStr:"主要的方式 区别 应用场景 参考",content:"> 相关问题：\n> \n>  * JavaScript 中的本地存储的方式有哪些？\n>  * 应用场景？\n\n\n# 主要的方式\n\nJavaScript 的本地存储（缓存）的方式有四种：\n\n * Cookie 。\n * sessionStorage\n * localStorage\n * indexedDB\n\n\n# 区别\n\n * 存储大小上：\n   * cookie 数据大小不能超过 4k；\n   * sessionStorage 和 localStorage 虽然有存储大小的限制，但是比 cookie 大得多，可以达到 5M 或者更大。\n * 有效时间：\n   * localStorage 存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据；\n   * sessionStorage 的数据在当前浏览器窗口关闭后就会自动删除；\n   * cookie 在设置的 cookie 过期时间之前一直有效，除非窗口或者浏览器关闭；\n * 数据与服务器交互方式： cookie 的数据会自动传递到服务器，服务器端也可以写 cookie 到客户端； sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。\n\n\n# 应用场景\n\n针对不同的应用场景：\n\n * cookie ：适用于要标记用户和跟踪用户行为的情况；\n * localStorage ：适合长期保存在本地的数据（令牌）；\n * sessionStorage ：敏感账号一次性登录保存的数据；\n * indexedDB ：存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况。\n\n\n# 参考\n\n * 深入浅出前端本地储存・语雀 (yuque.com)\n * 一行代码，搞定浏览器数据库 IndexedDB・语雀 (yuque.com)",normalizedContent:"> 相关问题：\n> \n>  * javascript 中的本地存储的方式有哪些？\n>  * 应用场景？\n\n\n# 主要的方式\n\njavascript 的本地存储（缓存）的方式有四种：\n\n * cookie 。\n * sessionstorage\n * localstorage\n * indexeddb\n\n\n# 区别\n\n * 存储大小上：\n   * cookie 数据大小不能超过 4k；\n   * sessionstorage 和 localstorage 虽然有存储大小的限制，但是比 cookie 大得多，可以达到 5m 或者更大。\n * 有效时间：\n   * localstorage 存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据；\n   * sessionstorage 的数据在当前浏览器窗口关闭后就会自动删除；\n   * cookie 在设置的 cookie 过期时间之前一直有效，除非窗口或者浏览器关闭；\n * 数据与服务器交互方式： cookie 的数据会自动传递到服务器，服务器端也可以写 cookie 到客户端； sessionstorage 和 localstorage 不会自动把数据发给服务器，仅在本地保存。\n\n\n# 应用场景\n\n针对不同的应用场景：\n\n * cookie ：适用于要标记用户和跟踪用户行为的情况；\n * localstorage ：适合长期保存在本地的数据（令牌）；\n * sessionstorage ：敏感账号一次性登录保存的数据；\n * indexeddb ：存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况。\n\n\n# 参考\n\n * 深入浅出前端本地储存・语雀 (yuque.com)\n * 一行代码，搞定浏览器数据库 indexeddb・语雀 (yuque.com)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 JavaScript 防抖与节流相关",frontmatter:{title:"🍎 JavaScript 防抖与节流相关",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/0a56d1/",categories:["🪞 前端面试题收集","🗾 JavaScript 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/08.%20%F0%9F%97%BE%20JavaScript%20%E7%9B%B8%E5%85%B3/40.%20%F0%9F%8D%8E%20JavaScript%20%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/08. 🗾 JavaScript 相关/40. 🍎 JavaScript 防抖与节流相关.md",key:"v-e97a13f8",path:"/pages/0a56d1/",headers:[{level:2,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:12},{level:3,title:"节流",slug:"节流",normalizedTitle:"节流",charIndex:9},{level:3,title:"节流",slug:"节流-2",normalizedTitle:"节流",charIndex:9},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:746}],headersStr:"理解 节流 节流 参考",content:">  * 对防抖和节流的理解；\n>  * 防抖和节流的区别；\n>  * 防抖和节流的应用；\n\n\n# 理解\n\n\n# 节流\n\n> 理解例子：对于某次搜索框的输入操作，为了更好的用户体验，通常会出现联想的内容，这些联想的内容往往需要进行一次网络请求。如果每输入一个字符就提交一次网络请求，会损耗系统的性能，无论是事件处理或者是服务器的压力。\n> \n> 但是往往不需要这么多次网络请求，也就是说应该在合适的情况下发送网络请求。例如快速输入一个关键字，只会在输入完成后才发送请求；监听在输入后的某个时间，没有再次输入时再发送请求。\n\n防抖就是 在某个时间内，没有再次出发某个函数时，才会真正调用这个函数。\n\n防抖的过程：\n\n * 当事件触发时，相应的函数不会立即触发，而是会等待一定的时间；\n * 当事件密集触发时，函数的触发会被频繁的推迟；\n * 只有等待了一段时间没有时间出发，才会真正的执行相应函数。\n\n\n\n防抖的应用场景：\n\n * 输入框频繁的输入内容、搜索框或者提交消息；\n * 频繁点击按钮触发事件；\n * 监听浏览器滚动事件，完成某些特定操作；\n * 用户缩放浏览器窗口大小事件 resize ；\n * …\n\n一般都是密集的事件触发，并且希望触发比较靠后的事件，就可以使用防抖函数 debounce 。\n\n\n# 节流\n\n> 理解例子：在飞机大战游戏中（雷电），即使按下发射子弹的频率非常快，但是子弹也会保持一定的频率来发射。\n\n节流就是 在某个时间内，某个函数只能触发一次。\n\n节流的应用场景：\n\n * 监听页面滚动水岸；\n * 监听鼠标移动事件；\n * 用户频繁点击按钮操作；\n * …\n\n节流一般用于密集的事件触发， 但是不会等待最后一次才触发，而是按照一定的频率进行调用。\n\n\n# 参考\n\n * 🧨 JavaScript 防抖与节流\n\n * JavaScript 防抖和节流 - coderwhy 前端面试精讲\n\n * Debounce – How to Delay a Function in JavaScript (JS ES6 Example) (freecodecamp.org)",normalizedContent:">  * 对防抖和节流的理解；\n>  * 防抖和节流的区别；\n>  * 防抖和节流的应用；\n\n\n# 理解\n\n\n# 节流\n\n> 理解例子：对于某次搜索框的输入操作，为了更好的用户体验，通常会出现联想的内容，这些联想的内容往往需要进行一次网络请求。如果每输入一个字符就提交一次网络请求，会损耗系统的性能，无论是事件处理或者是服务器的压力。\n> \n> 但是往往不需要这么多次网络请求，也就是说应该在合适的情况下发送网络请求。例如快速输入一个关键字，只会在输入完成后才发送请求；监听在输入后的某个时间，没有再次输入时再发送请求。\n\n防抖就是 在某个时间内，没有再次出发某个函数时，才会真正调用这个函数。\n\n防抖的过程：\n\n * 当事件触发时，相应的函数不会立即触发，而是会等待一定的时间；\n * 当事件密集触发时，函数的触发会被频繁的推迟；\n * 只有等待了一段时间没有时间出发，才会真正的执行相应函数。\n\n\n\n防抖的应用场景：\n\n * 输入框频繁的输入内容、搜索框或者提交消息；\n * 频繁点击按钮触发事件；\n * 监听浏览器滚动事件，完成某些特定操作；\n * 用户缩放浏览器窗口大小事件 resize ；\n * …\n\n一般都是密集的事件触发，并且希望触发比较靠后的事件，就可以使用防抖函数 debounce 。\n\n\n# 节流\n\n> 理解例子：在飞机大战游戏中（雷电），即使按下发射子弹的频率非常快，但是子弹也会保持一定的频率来发射。\n\n节流就是 在某个时间内，某个函数只能触发一次。\n\n节流的应用场景：\n\n * 监听页面滚动水岸；\n * 监听鼠标移动事件；\n * 用户频繁点击按钮操作；\n * …\n\n节流一般用于密集的事件触发， 但是不会等待最后一次才触发，而是按照一定的频率进行调用。\n\n\n# 参考\n\n * 🧨 javascript 防抖与节流\n\n * javascript 防抖和节流 - coderwhy 前端面试精讲\n\n * debounce – how to delay a function in javascript (js es6 example) (freecodecamp.org)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 Vue 的理解相关",frontmatter:{title:"🍎 Vue 的理解相关",date:"2022-06-19T13:41:39.000Z",permalink:"/pages/370325/",categories:["🪞 前端面试题收集","🌠 核心框架相关","🍎 Vue"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20Vue/01.%20%F0%9F%8D%8E%20%20Vue%20%E7%9A%84%E7%90%86%E8%A7%A3%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/01. 🍎  Vue 的理解相关.md",key:"v-35c33a67",path:"/pages/370325/",headers:[{level:2,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:454},{level:2,title:"Vue 核心特性",slug:"vue-核心特性",normalizedTitle:"vue 核心特性",charIndex:667},{level:3,title:"数据驱动 MVVM",slug:"数据驱动-mvvm",normalizedTitle:"数据驱动 mvvm",charIndex:680},{level:3,title:"组件化",slug:"组件化",normalizedTitle:"组件化",charIndex:563},{level:3,title:"指令系统",slug:"指令系统",normalizedTitle:"指令系统",charIndex:1091},{level:3,title:"跟传统开发的区别",slug:"跟传统开发的区别",normalizedTitle:"跟传统开发的区别",charIndex:1234},{level:3,title:"与 React 的区别",slug:"与-react-的区别",normalizedTitle:"与 react 的区别",charIndex:1330},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1346}],headersStr:"理解 Vue 核心特性 数据驱动 MVVM 组件化 指令系统 跟传统开发的区别 与 React 的区别 参考",content:"在互联网的历史中，网页可以从不同的阶段来说明发展历史：\n\n * 静态网页 / 石器时代：没有数据库，只展示文字和图片。直到 CGI 技术的出现可以通过 CGI Pearl 与数据库和文件系统交互。\n * ASP、JSP / 文明时代。2005 年左右，出现微软的 ASP 和 JSP（Java Server Pages） 取代 CGI 技术，增强了 Web 客户端和服务端交互的安全性。缺点是不太灵活，因为 JSP 在服务端执行，通常返回客户端一个 HTML 文本，但是每次请求、获取数据、内容加载都需要服务器返回渲染之后的 DOM ，使得开发网站的灵活性大打折扣。\n * JQuery、SPA 雏形 / 工业革命时代。随着移动设备普及，Backbone EmberJS AngularJS 这样一批前端框架随之出现。\n * 百花齐放时代。工业时代提出的 SPA 模型随着 NODE 的兴起、服务端、各种工具、容器的飞速发展、前端 MVC MVVM 模式逐渐清晰、前端涌现了相当一批优秀的开源项目。\n\n\n# 理解\n\nVue 是一款：\n\n * 用于构建用户界面的 JavaScript 框架，也可以创建单页面应用（SPA）的 Web 应用框架。\n * 基于标准 HTML 、 CSS 、 JavaScript 标准，提供声明式、组件化的编程模型，高效开发用户界面，旨在更好组织和简化 Web 应用的开发。\n * Vue 关注的核心是 MVC 模式的是涂层，并且能方便地获取数据更新，通过组件内部特定的方法实现视图与模型的交互。\n\n\n# Vue 核心特性\n\n\n# 数据驱动 MVVM\n\n * 模型层 Model： 负责业务逻辑与服务器端交互。\n\n * 视图层 View： 负责将数据模型转化为 UI 展示出来。\n\n * 视图模型层 ViewModel ：用来连接 Model 和 View。\n\n\n# 组件化\n\n * 组件化就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模型，在 Vue 中每个 .vue 文件中都可以视为一个组件。\n * 组件化的优势：\n   * 降低整个系统的耦合度，在保持接口不变的情况下，可以替换不同的组件完成需求。例如输入框可以替换为日历、事件、范围等。\n   * 调试方便，由于整个系统都是通过组件组合起来的，在出现问题的时候可以排除法直接移除组件或者根据报错的组件快速定位问题，因为组件之间低耦合，职责单一。\n   * 可维护性高。由于每个组件职责单一，并且组件在系统中是被复用的，所以对待吗进行优化可以获得系统的整体升级。\n\n\n# 指令系统\n\n指令是指带有 v- 前缀的特殊属性。\n\n * 作用：当表达式的值发生改变时，将其产生的连带影响，响应式地作用于 DOM。\n * 常用的指令：\n   * 条件渲染指令\n   * 列表渲染指令\n   * 属性绑定指令\n   * 事件绑定指令\n   * 双向数据绑定指令\n\n\n# 跟传统开发的区别\n\n * Vue 所有的界面事件都是只去操作数据，JQuery 操作 DOM；\n * Vue 所有的界面变动，都是根据数据自动绑定出来的，JQuery 操作 DOM。\n\n\n# 与 React 的区别\n\n\n# 参考\n\n * 《从零构建前后分离 web 项目》：开篇 - 纵观 WEB 历史演变 - SegmentFault 思否\n * 简介 | Vue.js (vuejs.org)",normalizedContent:"在互联网的历史中，网页可以从不同的阶段来说明发展历史：\n\n * 静态网页 / 石器时代：没有数据库，只展示文字和图片。直到 cgi 技术的出现可以通过 cgi pearl 与数据库和文件系统交互。\n * asp、jsp / 文明时代。2005 年左右，出现微软的 asp 和 jsp（java server pages） 取代 cgi 技术，增强了 web 客户端和服务端交互的安全性。缺点是不太灵活，因为 jsp 在服务端执行，通常返回客户端一个 html 文本，但是每次请求、获取数据、内容加载都需要服务器返回渲染之后的 dom ，使得开发网站的灵活性大打折扣。\n * jquery、spa 雏形 / 工业革命时代。随着移动设备普及，backbone emberjs angularjs 这样一批前端框架随之出现。\n * 百花齐放时代。工业时代提出的 spa 模型随着 node 的兴起、服务端、各种工具、容器的飞速发展、前端 mvc mvvm 模式逐渐清晰、前端涌现了相当一批优秀的开源项目。\n\n\n# 理解\n\nvue 是一款：\n\n * 用于构建用户界面的 javascript 框架，也可以创建单页面应用（spa）的 web 应用框架。\n * 基于标准 html 、 css 、 javascript 标准，提供声明式、组件化的编程模型，高效开发用户界面，旨在更好组织和简化 web 应用的开发。\n * vue 关注的核心是 mvc 模式的是涂层，并且能方便地获取数据更新，通过组件内部特定的方法实现视图与模型的交互。\n\n\n# vue 核心特性\n\n\n# 数据驱动 mvvm\n\n * 模型层 model： 负责业务逻辑与服务器端交互。\n\n * 视图层 view： 负责将数据模型转化为 ui 展示出来。\n\n * 视图模型层 viewmodel ：用来连接 model 和 view。\n\n\n# 组件化\n\n * 组件化就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模型，在 vue 中每个 .vue 文件中都可以视为一个组件。\n * 组件化的优势：\n   * 降低整个系统的耦合度，在保持接口不变的情况下，可以替换不同的组件完成需求。例如输入框可以替换为日历、事件、范围等。\n   * 调试方便，由于整个系统都是通过组件组合起来的，在出现问题的时候可以排除法直接移除组件或者根据报错的组件快速定位问题，因为组件之间低耦合，职责单一。\n   * 可维护性高。由于每个组件职责单一，并且组件在系统中是被复用的，所以对待吗进行优化可以获得系统的整体升级。\n\n\n# 指令系统\n\n指令是指带有 v- 前缀的特殊属性。\n\n * 作用：当表达式的值发生改变时，将其产生的连带影响，响应式地作用于 dom。\n * 常用的指令：\n   * 条件渲染指令\n   * 列表渲染指令\n   * 属性绑定指令\n   * 事件绑定指令\n   * 双向数据绑定指令\n\n\n# 跟传统开发的区别\n\n * vue 所有的界面事件都是只去操作数据，jquery 操作 dom；\n * vue 所有的界面变动，都是根据数据自动绑定出来的，jquery 操作 dom。\n\n\n# 与 react 的区别\n\n\n# 参考\n\n * 《从零构建前后分离 web 项目》：开篇 - 纵观 web 历史演变 - segmentfault 思否\n * 简介 | vue.js (vuejs.org)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 Vue v-show 与 v-if 的区别",frontmatter:{title:"🍎 Vue v-show 与 v-if 的区别",date:"2022-06-09T00:37:07.000Z",permalink:"/pages/27cb22/",categories:["🪞面试题收集","🌠 核心框架相关","🍎 Vue"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20Vue/03.%20%F0%9F%8D%8E%20Vue%20v-show%20%E4%B8%8E%20v-if%20%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/03. 🍎 Vue v-show 与 v-if 的区别.md",key:"v-0f0c029a",path:"/pages/27cb22/",headers:[{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:75},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:582}],headersStr:"区别 使用场景",content:"共同点：控制元素在页面上是否显示。\n\n * 表达式为 true 时，会占据页面的位置；\n * 表达式为 false 时，不会占据页面的位置。\n\n\n# 区别\n\n * 隐藏控制手段的不同：\n   \n   v-show 隐藏是为元素添加 样式 display:none ，DOM 元素依旧存在。\n   \n   v-if 隐藏是 动态添加或者删除元素；\n\n * 编译过程不同：\n   \n   v-show 只会简单地基于 CSS 切换；\n   \n   v-if 切换隐藏显示有一个局部编译 / 写在的过程，切换过程中合适地笑会和重建内部的事件监听和子组件；\n\n * 编译条件不同：\n   \n   v-if 是真正的条件渲染，确保切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假，并且不做操作，直到为真才渲染。\n\n * 生命周期\n   \n   v-show ：不会触发组件生命周期；\n   \n   v-if ：切换为显示时会触发组件的生命周期 beforeCreate 、 create 、 beforeMount 、 mounted 钩子；切换为隐藏时触发组件的 beforeDestroy 、 destroyed 钩子；\n\n * 性能消耗：\n   \n   v-show ：消耗初始渲染；\n   \n   v-if ：更高的切换组件渲染；\n\n\n# 使用场景\n\n * 由于 v-if 比 v-show 开销更大：\n   \n   频繁切换使用 v-show ；\n   \n   条件很少改变使用 v-if ；",normalizedContent:"共同点：控制元素在页面上是否显示。\n\n * 表达式为 true 时，会占据页面的位置；\n * 表达式为 false 时，不会占据页面的位置。\n\n\n# 区别\n\n * 隐藏控制手段的不同：\n   \n   v-show 隐藏是为元素添加 样式 display:none ，dom 元素依旧存在。\n   \n   v-if 隐藏是 动态添加或者删除元素；\n\n * 编译过程不同：\n   \n   v-show 只会简单地基于 css 切换；\n   \n   v-if 切换隐藏显示有一个局部编译 / 写在的过程，切换过程中合适地笑会和重建内部的事件监听和子组件；\n\n * 编译条件不同：\n   \n   v-if 是真正的条件渲染，确保切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假，并且不做操作，直到为真才渲染。\n\n * 生命周期\n   \n   v-show ：不会触发组件生命周期；\n   \n   v-if ：切换为显示时会触发组件的生命周期 beforecreate 、 create 、 beforemount 、 mounted 钩子；切换为隐藏时触发组件的 beforedestroy 、 destroyed 钩子；\n\n * 性能消耗：\n   \n   v-show ：消耗初始渲染；\n   \n   v-if ：更高的切换组件渲染；\n\n\n# 使用场景\n\n * 由于 v-if 比 v-show 开销更大：\n   \n   频繁切换使用 v-show ；\n   \n   条件很少改变使用 v-if ；",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 Vue v-if 和 v-for",frontmatter:{title:"🍏 Vue v-if 和 v-for",date:"2022-06-09T10:40:29.000Z",permalink:"/pages/c589b0/",categories:["🪞面试题收集","🌠 核心框架相关","🍎 Vue"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20Vue/04.%20%F0%9F%8D%8F%20Vue%20v-if%20%E5%92%8C%20v-for.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/04. 🍏 Vue v-if 和 v-for.md",key:"v-c3849332",path:"/pages/c589b0/",headers:[{level:2,title:"v-if / v-for 区别",slug:"v-if-v-for-区别",normalizedTitle:"v-if /v-for 区别",charIndex:null},{level:2,title:"使用注意事项",slug:"使用注意事项",normalizedTitle:"使用注意事项",charIndex:2366}],headersStr:"v-if / v-for 区别 使用注意事项",content:'>  * 为什么 v-if 和 v-for 不建议一起使用？\n>  * v-if 和 v-for 的优先级？\n\n\n# v-if / v-for 区别\n\n用途区别：\n\n * v-if 用于 条件性渲染一块内容。这块内容只有 v-if 指令的表达式为 true 时被渲染。\n\n * v-for ：基于一个数组来渲染一个列表。需要使用 item in items 形式的特殊语法，其中 items 是原数据数组或者对象，其中 item 是被迭代的数组元素的别名；\n   \n   需要设置 key 保证每个 key 值独一无二，便于 diff 算法的优化。\n\n优先级区别：\n\nv-if 和 v-for 都是 Vue 模版指令，在 Vue 模版编译的时候，会将指令系统转换为可执行的 render 函数。\n\nv-for 的优先级高于 v-if 。\n\n点击查看\n\n🌰 例子：\n\n<div id="app">\n    <p v-if="isShow" v-for="item in items">\n        {{ item.title }}\n    </p>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n创建 Vue 实例：\n\nconst app = new Vue({\n  el: "#app",\n  data() {\n    return {\n      items: [\n        { title: \'foo\'},\n        { title: \'baz\'}\n      ]\n    }\n  },\n  computed: {\n    isShow() {\n      return this.items && this.items.length > 0\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n模版指令的代码会生成到 render 函数中，通过 app.$options.render 就能获得 渲染函数：\n\nƒ anonymous() {\n  with (this) { return \n    _c(\'div\', { attrs: { "id": "app" } }, \n    _l((items), function (item) \n    { return (isShow) ? _c(\'p\', [_v("\\n" + _s(item.title) + "\\n")]) : _e() }), 0) }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> _l 是 vue 的列表渲染函数（输出 v-for 循环的 items 列表），函数内部都会进行一次 if 判断\n\n** 得出结论： v-for 的优先级比 v-if 高。 **\n\n如果将 v-for 与 v-if 置于不同的标签：\n\n<div id="app">\n    <template v-if="isShow">\n        <p v-for="item in items">{{item.title}}</p>\n    </template>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n再输出 render 函数：\n\nƒ anonymous() {\n  with(this){return \n    _c(\'div\',{attrs:{"id":"app"}},\n    [(isShow)?[_v("\\n"),\n    _l((items),function(item){return _c(\'p\',[_v(_s(item.title))])})]:_e()],2)}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以看到 v-for 与 v-if 作用于不同的标签，先进行判断，在进行列表渲染， 此时 v-if 优先高于 v-for 。\n\nVue 源码中 / 生成元素时：\n\nexport function genElement (el: ASTElement, state: CodegenState): string {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre\n  }\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === \'template\' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || \'void 0\'\n  } else if (el.tag === \'slot\') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在进行元素类型 if 判断的时候， v-for 是比 v-if 先进行判断。\n\n\n# 使用注意事项\n\n * 不要把 v-if 和 v-for 放在同一个元素上，可能会带来性能方面的浪费（因为每次渲染都会先循环再进行条件判断）。\n   \n   一定要使用时，则在外层嵌套 template 模版标签上使用 v-if （页面渲染时不会生成 DOM 节点），然后在内部进行 v-for 循环。\n   \n   🌰 例子：\n   \n   <template v-if="isShow">\n   \t<p v-for="item in items" :key="item.id" /> \n   </template>\n   \n   \n   1\n   2\n   3\n   \n\n * 如果条件出现在循环内部，可以通过 computed 计算属性提前筛选掉那一部分不需要显示的项目，而不是在模版中使用 v-if ：\n   \n   🌰 例子：\n   \n   （Options API）\n   \n   computed: {\n     items: function() {\n       return this.list.filter(function (item) {\n         return item.isShow\n       })\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   （Composition API）\n   \n   const item = computed(() => {\n     return list.filter((item) => {\n       return item.isShow\n     })\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   ',normalizedContent:'>  * 为什么 v-if 和 v-for 不建议一起使用？\n>  * v-if 和 v-for 的优先级？\n\n\n# v-if / v-for 区别\n\n用途区别：\n\n * v-if 用于 条件性渲染一块内容。这块内容只有 v-if 指令的表达式为 true 时被渲染。\n\n * v-for ：基于一个数组来渲染一个列表。需要使用 item in items 形式的特殊语法，其中 items 是原数据数组或者对象，其中 item 是被迭代的数组元素的别名；\n   \n   需要设置 key 保证每个 key 值独一无二，便于 diff 算法的优化。\n\n优先级区别：\n\nv-if 和 v-for 都是 vue 模版指令，在 vue 模版编译的时候，会将指令系统转换为可执行的 render 函数。\n\nv-for 的优先级高于 v-if 。\n\n点击查看\n\n🌰 例子：\n\n<div id="app">\n    <p v-if="isshow" v-for="item in items">\n        {{ item.title }}\n    </p>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n创建 vue 实例：\n\nconst app = new vue({\n  el: "#app",\n  data() {\n    return {\n      items: [\n        { title: \'foo\'},\n        { title: \'baz\'}\n      ]\n    }\n  },\n  computed: {\n    isshow() {\n      return this.items && this.items.length > 0\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n模版指令的代码会生成到 render 函数中，通过 app.$options.render 就能获得 渲染函数：\n\nƒ anonymous() {\n  with (this) { return \n    _c(\'div\', { attrs: { "id": "app" } }, \n    _l((items), function (item) \n    { return (isshow) ? _c(\'p\', [_v("\\n" + _s(item.title) + "\\n")]) : _e() }), 0) }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> _l 是 vue 的列表渲染函数（输出 v-for 循环的 items 列表），函数内部都会进行一次 if 判断\n\n** 得出结论： v-for 的优先级比 v-if 高。 **\n\n如果将 v-for 与 v-if 置于不同的标签：\n\n<div id="app">\n    <template v-if="isshow">\n        <p v-for="item in items">{{item.title}}</p>\n    </template>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n再输出 render 函数：\n\nƒ anonymous() {\n  with(this){return \n    _c(\'div\',{attrs:{"id":"app"}},\n    [(isshow)?[_v("\\n"),\n    _l((items),function(item){return _c(\'p\',[_v(_s(item.title))])})]:_e()],2)}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以看到 v-for 与 v-if 作用于不同的标签，先进行判断，在进行列表渲染， 此时 v-if 优先高于 v-for 。\n\nvue 源码中 / 生成元素时：\n\nexport function genelement (el: astelement, state: codegenstate): string {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre\n  }\n  if (el.staticroot && !el.staticprocessed) {\n    return genstatic(el, state)\n  } else if (el.once && !el.onceprocessed) {\n    return genonce(el, state)\n  } else if (el.for && !el.forprocessed) {\n    return genfor(el, state)\n  } else if (el.if && !el.ifprocessed) {\n    return genif(el, state)\n  } else if (el.tag === \'template\' && !el.slottarget && !state.pre) {\n    return genchildren(el, state) || \'void 0\'\n  } else if (el.tag === \'slot\') {\n    return genslot(el, state)\n  } else {\n    // component or element\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在进行元素类型 if 判断的时候， v-for 是比 v-if 先进行判断。\n\n\n# 使用注意事项\n\n * 不要把 v-if 和 v-for 放在同一个元素上，可能会带来性能方面的浪费（因为每次渲染都会先循环再进行条件判断）。\n   \n   一定要使用时，则在外层嵌套 template 模版标签上使用 v-if （页面渲染时不会生成 dom 节点），然后在内部进行 v-for 循环。\n   \n   🌰 例子：\n   \n   <template v-if="isshow">\n   \t<p v-for="item in items" :key="item.id" /> \n   </template>\n   \n   \n   1\n   2\n   3\n   \n\n * 如果条件出现在循环内部，可以通过 computed 计算属性提前筛选掉那一部分不需要显示的项目，而不是在模版中使用 v-if ：\n   \n   🌰 例子：\n   \n   （options api）\n   \n   computed: {\n     items: function() {\n       return this.list.filter(function (item) {\n         return item.isshow\n       })\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   （composition api）\n   \n   const item = computed(() => {\n     return list.filter((item) => {\n       return item.isshow\n     })\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   ',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 Vue 生命周期相关",frontmatter:{title:"🍎 Vue 生命周期相关",date:"2022-06-09T10:39:37.000Z",permalink:"/pages/68ecc7/",categories:["🪞面试题收集","🌠 核心框架相关","🍎 Vue"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20Vue/05.%20%F0%9F%8D%8E%20Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/05. 🍎 Vue 生命周期相关.md",key:"v-26b135d0",path:"/pages/68ecc7/",headers:[{level:2,title:"Vue 的挂载",slug:"vue-的挂载",normalizedTitle:"vue 的挂载",charIndex:2},{level:2,title:"Vue 的生命周期",slug:"vue-的生命周期",normalizedTitle:"vue 的生命周期",charIndex:355},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3052}],headersStr:"Vue 的挂载 Vue 的生命周期 参考",content:"# Vue 的挂载\n\n>  * Vue 实例挂载的过程发生了什么？\n\n * new Vue() 时，会调用 _init() 方法初始化：\n   * 定义 $set 、 $get 、 $delete 、 $watch 等方法；（数据相关）\n   * 定义 $on 、 $off 、 $emit 、 $off 等事件；\n   * 定义 _update 、 $forceUpdate 、 $destroy 生命周期；\n * 调用 $mount 进行页面的挂载；\n   * 页面的挂载主要通过 mountComponent 方法；\n * 定义 updateComponent 更新函数；\n * 执行 render 生成虚拟 DOM；\n * update 将虚拟 DOM 生成真实 DOM 结构，渲染到页面中；\n\n\n# Vue 的生命周期\n\nVue 的生命周期过程：从 Vue 实例的创建到销毁的过程，即从 ** 创建、初始化数据、编译模版、挂载 DOM → 渲染、更新 → 渲染、卸载 ** 等一系列的过程。\n\n> 可以看作工厂中的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始哦给你做。\n\n> Vue 生明周期会自动绑定到 this 上下文实例，因此可以通过 this 访问到数据，对 property 和方法进行运算，但是这意味着不能使用箭头函数定义生命周期方法。\n\nVue 个生命周期（Vue 2），包括 （实例）创建前后、挂载前后、更新前后、销毁前后，以及一些特殊的生命周期：\n\n * beforeCreate ：组件实例被创建之前；\n * created ：组件实例完全创建；\n * beforeMount ：组件挂载之前；\n * mounted ：组件挂载到实例之后；\n * beforeUpdate ：组件数据发生改变，更新之前；\n * updated ：组件数据更新之后；\n * beforeDestroy ：组件实例销毁之前；\n * destroyed ：组件实例销毁之后；\n\n----------------------------------------\n\n * activated ： keep-alive 缓存的组件激活时；\n * deactivated ： keep-alive 缓存的组件停用时；\n * errorCaptured ：捕获一个来自子孙组件的错误时被调用；\n\nVue 生命周期流程：\n\n点击查看\n\nVue 生命周期具体分析：\n\n * beforeCreate → created ： 初始化 Vue 实例，进行数据观测；\n\n * created ：\n   \n   * 完成数据观测、属性与方法的运算； watch 、 event 事件回调的配置；\n   * 可以调用 methods 中的方法，访问和修改 data 数据触发响应式渲染 DOM，可以通过 computed 和 watch 完成数据计算；\n   * 此时 vm.$el 并没有被创建；\n\n * created → beforeMount\n   \n   * 判断是否存在 el ：如果不存在则停止编译，直到调用 vm.$mount(el) 才会继续编译；\n   * 优先级： render > template > outerHTML ；\n   * vm.el 获取到的是 挂载 DOM 的；\n\n * beforeMount → mounted ：\n   \n   * 在这个阶段可以获取到 vm.el ；\n   * 在这个阶段虽然 vm.el 完成了 DOM 初始化，即将开始渲染，但并未挂载在 el 选项上。\n   * 这个阶段可以修改数据，但是不会触发数据更新相关勾子；\n\n * mounted ： vm.el 完成了 DOM 的挂载和渲染，数据完成双向绑定，此时打印 vm.$el 发现此前的挂载点以及内容已经被替换成新的 DOM，可以访问 DOM 节点，使用 $refs 对 DOM 操作；\n\n * beforeUpdate ：\n   \n   * 更新的数据必须是被渲染在模版上的（ el 、 template 、 render 之一）；\n   * 此时 view 层还未更新；\n   * 若在 beforeUpdate 中再次修改数据，不会再次触发更新方法；\n\n * updated ：\n   \n   * 完成 view 层的更新；\n   * 若在 updated 中在此修改数据，会再次触发更新方法（ beforeUpdate 、 updated ）；\n\n * beforeDestroy ：实例被销毁之前调用，此时实例属性与方法仍然可以访问；\n\n * destroyed ：\n   \n   * 完全销毁一个实例，可以清理它与其他实例的连接，解绑它的全部指令以及事件监听器；\n   * 并不能清除 DOM，仅仅销毁实例；\n\n使用场景：\n\n * beforeCreate ：通常用于插件开发中的一些初始化任务（此时组件实例为创建）\n * created ：组件实例创建后，可以获取各种数据，通常用于 异步数据的获取；\n * beforeMount ：未执行渲染、更新，DOM 未创建；\n * mounted ：初始化结束，DOM 已创建；可以用于获取访问数据 和 DOM 元素；\n * beforeUpdate ：数据更新之前，可用于获取更新前的各种状态；\n * updated ：数据更新之后，所有状态已是最新；\n * beforeDestroy ：销毁之前，用于解绑订阅或者定时器；\n * destroyed ：完全销毁之后。\n\n> 数据获取，使用 created 和 mounted 的区别：\n> \n>  * created 在 组件实例一旦创建完成之后 立刻调用，这时 DOM 节点并未生成；\n>    \n>    mounted 是在页面 DOM 节点渲染完毕之后立即执行的；\n>    \n>    所以触发时机， created 比 mounted 更早。\n> \n>  * 两者相同点，都能拿到 实例对象的属性和方法。\n> \n>  * 这个问题的本质就是触发的时机，放在 mounted 请求数据有可能导致页面闪动（因为此时 DOM 结构已经渲染完毕），但是如果在页面加载之前完成数据请求就不会发生。建议放在 created 生命周期中。\n\nVue 生命周期详细流程：\n\n\n\nVue 3 中的生命周期：\n\n * setup\n   * 替代了 beforeCreate / created 。\n * onBeforeMount\n   * 此阶段在组件的 DOM 实际渲染和挂载之前触发。所以根源素还没存在。\n * onMounted\n * onBeforeUpdate\n * onUpdated\n * onBeforeUnmount\n * onUnmounted\n * onErrorCaptured\n\n----------------------------------------\n\n * onActivated\n * onDeactivated\n\n----------------------------------------\n\n调试时使用钩子：\n\n * onRenderTracked\n * onRenderTriggered\n\n\n# 参考\n\n * Vue 官方文档：生命周期钩子 | Vue.js (vuejs.org)",normalizedContent:"# vue 的挂载\n\n>  * vue 实例挂载的过程发生了什么？\n\n * new vue() 时，会调用 _init() 方法初始化：\n   * 定义 $set 、 $get 、 $delete 、 $watch 等方法；（数据相关）\n   * 定义 $on 、 $off 、 $emit 、 $off 等事件；\n   * 定义 _update 、 $forceupdate 、 $destroy 生命周期；\n * 调用 $mount 进行页面的挂载；\n   * 页面的挂载主要通过 mountcomponent 方法；\n * 定义 updatecomponent 更新函数；\n * 执行 render 生成虚拟 dom；\n * update 将虚拟 dom 生成真实 dom 结构，渲染到页面中；\n\n\n# vue 的生命周期\n\nvue 的生命周期过程：从 vue 实例的创建到销毁的过程，即从 ** 创建、初始化数据、编译模版、挂载 dom → 渲染、更新 → 渲染、卸载 ** 等一系列的过程。\n\n> 可以看作工厂中的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始哦给你做。\n\n> vue 生明周期会自动绑定到 this 上下文实例，因此可以通过 this 访问到数据，对 property 和方法进行运算，但是这意味着不能使用箭头函数定义生命周期方法。\n\nvue 个生命周期（vue 2），包括 （实例）创建前后、挂载前后、更新前后、销毁前后，以及一些特殊的生命周期：\n\n * beforecreate ：组件实例被创建之前；\n * created ：组件实例完全创建；\n * beforemount ：组件挂载之前；\n * mounted ：组件挂载到实例之后；\n * beforeupdate ：组件数据发生改变，更新之前；\n * updated ：组件数据更新之后；\n * beforedestroy ：组件实例销毁之前；\n * destroyed ：组件实例销毁之后；\n\n----------------------------------------\n\n * activated ： keep-alive 缓存的组件激活时；\n * deactivated ： keep-alive 缓存的组件停用时；\n * errorcaptured ：捕获一个来自子孙组件的错误时被调用；\n\nvue 生命周期流程：\n\n点击查看\n\nvue 生命周期具体分析：\n\n * beforecreate → created ： 初始化 vue 实例，进行数据观测；\n\n * created ：\n   \n   * 完成数据观测、属性与方法的运算； watch 、 event 事件回调的配置；\n   * 可以调用 methods 中的方法，访问和修改 data 数据触发响应式渲染 dom，可以通过 computed 和 watch 完成数据计算；\n   * 此时 vm.$el 并没有被创建；\n\n * created → beforemount\n   \n   * 判断是否存在 el ：如果不存在则停止编译，直到调用 vm.$mount(el) 才会继续编译；\n   * 优先级： render > template > outerhtml ；\n   * vm.el 获取到的是 挂载 dom 的；\n\n * beforemount → mounted ：\n   \n   * 在这个阶段可以获取到 vm.el ；\n   * 在这个阶段虽然 vm.el 完成了 dom 初始化，即将开始渲染，但并未挂载在 el 选项上。\n   * 这个阶段可以修改数据，但是不会触发数据更新相关勾子；\n\n * mounted ： vm.el 完成了 dom 的挂载和渲染，数据完成双向绑定，此时打印 vm.$el 发现此前的挂载点以及内容已经被替换成新的 dom，可以访问 dom 节点，使用 $refs 对 dom 操作；\n\n * beforeupdate ：\n   \n   * 更新的数据必须是被渲染在模版上的（ el 、 template 、 render 之一）；\n   * 此时 view 层还未更新；\n   * 若在 beforeupdate 中再次修改数据，不会再次触发更新方法；\n\n * updated ：\n   \n   * 完成 view 层的更新；\n   * 若在 updated 中在此修改数据，会再次触发更新方法（ beforeupdate 、 updated ）；\n\n * beforedestroy ：实例被销毁之前调用，此时实例属性与方法仍然可以访问；\n\n * destroyed ：\n   \n   * 完全销毁一个实例，可以清理它与其他实例的连接，解绑它的全部指令以及事件监听器；\n   * 并不能清除 dom，仅仅销毁实例；\n\n使用场景：\n\n * beforecreate ：通常用于插件开发中的一些初始化任务（此时组件实例为创建）\n * created ：组件实例创建后，可以获取各种数据，通常用于 异步数据的获取；\n * beforemount ：未执行渲染、更新，dom 未创建；\n * mounted ：初始化结束，dom 已创建；可以用于获取访问数据 和 dom 元素；\n * beforeupdate ：数据更新之前，可用于获取更新前的各种状态；\n * updated ：数据更新之后，所有状态已是最新；\n * beforedestroy ：销毁之前，用于解绑订阅或者定时器；\n * destroyed ：完全销毁之后。\n\n> 数据获取，使用 created 和 mounted 的区别：\n> \n>  * created 在 组件实例一旦创建完成之后 立刻调用，这时 dom 节点并未生成；\n>    \n>    mounted 是在页面 dom 节点渲染完毕之后立即执行的；\n>    \n>    所以触发时机， created 比 mounted 更早。\n> \n>  * 两者相同点，都能拿到 实例对象的属性和方法。\n> \n>  * 这个问题的本质就是触发的时机，放在 mounted 请求数据有可能导致页面闪动（因为此时 dom 结构已经渲染完毕），但是如果在页面加载之前完成数据请求就不会发生。建议放在 created 生命周期中。\n\nvue 生命周期详细流程：\n\n\n\nvue 3 中的生命周期：\n\n * setup\n   * 替代了 beforecreate / created 。\n * onbeforemount\n   * 此阶段在组件的 dom 实际渲染和挂载之前触发。所以根源素还没存在。\n * onmounted\n * onbeforeupdate\n * onupdated\n * onbeforeunmount\n * onunmounted\n * onerrorcaptured\n\n----------------------------------------\n\n * onactivated\n * ondeactivated\n\n----------------------------------------\n\n调试时使用钩子：\n\n * onrendertracked\n * onrendertriggered\n\n\n# 参考\n\n * vue 官方文档：生命周期钩子 | vue.js (vuejs.org)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎  Vue SPA 单页应用相关",frontmatter:{title:"🍎  Vue SPA 单页应用相关",date:"2022-06-09T15:52:33.000Z",permalink:"/pages/31a16b/",categories:["🪞面试题收集","🌠 核心框架相关","🍎 Vue"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20Vue/10.%20%F0%9F%8D%8E%20%20Vue%20SPA%20%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/10. 🍎  Vue SPA 单页应用相关.md",key:"v-03aac67e",path:"/pages/31a16b/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:47},{level:2,title:"SPA 的优缺点分析",slug:"spa-的优缺点分析",normalizedTitle:"spa 的优缺点分析",charIndex:732},{level:2,title:"SPA 首屏加载",slug:"spa-首屏加载",normalizedTitle:"spa 首屏加载",charIndex:899},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1860}],headersStr:"概念 SPA 的优缺点分析 SPA 首屏加载 参考",content:">  * 说说对 SPA（单页面应用）的理解？优缺点？\n>  * 如何实现 SPA？\n\n\n# 概念\n\nSPA（Single-page Application） 单页面应用是一种 网络应用程序或者网站的模型；\n\n * 通过动态重写当前页面与用户交互，避免了页面切换打断用户体验。\n\n * 在单页面应用中，必要的代码都通过单个页面加载和检索，或者根据需要（响应用户的操作）动态加载适当的资源添加到页面中。\n\n * 页面在任何时间点都不应该会重新加载，也不会将控制转移到其他页面。\n   \n   > 理解例子：看作这个页面应用为一个杯子，杯子中可以装不同的内容，变的始终是杯子中的内容，而不是杯子。\n\n * 常见的 JavaScript 框架 Vue、React、Angular、ember 都属于 SPA。\n\nMPA（Multi-page Application 多页面应用），意味着应用中有多个页面，每个页面都是一个主页面，当访问另一个页面的时候都需要重新加载 HTML、CSS、JavaScript 代码，公共文件则是按需加载。\n\nSPA 与 MPA 两者对比：\n\n             SPA         MPA\n刷新方式         局部刷新        整页刷新\nURL 模式       哈希模式        历史模式\nSEO 搜索引擎优化   难以实现        容易实现\n数据传递         容易          通过 URL、Cookie、localStorage\n页面切换         速度快，用户体验好   需要切换加载资源，速度慢，用户体验差\n维护成本         相对容易        相对复杂\n\n\n# SPA 的优缺点分析\n\n优点：\n\n * 具有桌面应用的即时性、网站的可移植性、可访问性特点；\n * 用户体验好、快速，内容改变不需要重新加载页面；\n * 良好的前后端分离，分工明确；\n\n缺点：\n\n * 不利于搜索引擎 SEO 优化\n * 首次渲染速度相对较慢\n\nTODO：SPA 实现 搜索引擎 SEO 优化；\n\n>  * 如何解决 SPA 首屏加载速度慢；\n\n\n# SPA 首屏加载\n\n首屏加载的概念：浏览器从响应用户输入网址，到首屏内容渲染完成的事件，此时整个网页不一定需要全部渲染完成，但是需要展示当前视窗需要的内容；\n\n计算首屏加载时间：\n\n点击查看\n\n两种方法：\n\n通过 DOMContentLoad 事件：\n\ndocument.addEventListener('DOMContentLoaded', (event) => {\n  conosole.log('first contentful painting')\n})\n\n\n1\n2\n3\n\n\n通过 performance ：\n\nperformance.getEntriesByName(\"first-contentful-paint\")[0].startTime\n\n\n1\n\n\n解决单页应用首屏进入加载慢的问题：\n\n> 页面渲染导致加载速度慢的因素有：\n> \n>  * 网络延时；\n>  * 资源文件体积过大；\n>  * 资源是否重复发送请求去加载；\n>  * 加载脚本时，渲染的内容堵塞了；\n\n解决方案：\n\n * 减小入口文件体积；\n   \n   常见手段是路由懒加载，把不同的路由对应不同的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加。\n   \n   🌰 动态加载路由例子：\n   \n   routes: [\n     path: '/'\n     name: 'main',\n     component: () => import('@/views/main.vue')\n   ]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 函数形式加载路由，可以把各自的路由文件分别打包吗，只有在解析给定的路由时才会加载路由组件。\n\n * 静态资源本地缓存；\n   \n   * 图片资源压缩大小；\n\n * UI 框架按需加载；（组件按序引用）\n\n * 组件重复打包问题，避免重复加载组件；\n\n * 使用 Gzip 压缩；\n   \n   需要浏览器支持。\n\n * 使用 SSR（Server Side）：\n   \n   服务器端的渲染，组件或者页面通过服务器生成 HTML 代码，再发送到浏览器。\n\n\n# 参考\n\n * 面试官：你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢 | web 前端面试 - 面试官系列 (vue3js.cn)\n * 面试官：SPA 首屏加载速度慢的怎么解决？ | web 前端面试 - 面试官系列 (vue3js.cn)",normalizedContent:">  * 说说对 spa（单页面应用）的理解？优缺点？\n>  * 如何实现 spa？\n\n\n# 概念\n\nspa（single-page application） 单页面应用是一种 网络应用程序或者网站的模型；\n\n * 通过动态重写当前页面与用户交互，避免了页面切换打断用户体验。\n\n * 在单页面应用中，必要的代码都通过单个页面加载和检索，或者根据需要（响应用户的操作）动态加载适当的资源添加到页面中。\n\n * 页面在任何时间点都不应该会重新加载，也不会将控制转移到其他页面。\n   \n   > 理解例子：看作这个页面应用为一个杯子，杯子中可以装不同的内容，变的始终是杯子中的内容，而不是杯子。\n\n * 常见的 javascript 框架 vue、react、angular、ember 都属于 spa。\n\nmpa（multi-page application 多页面应用），意味着应用中有多个页面，每个页面都是一个主页面，当访问另一个页面的时候都需要重新加载 html、css、javascript 代码，公共文件则是按需加载。\n\nspa 与 mpa 两者对比：\n\n             spa         mpa\n刷新方式         局部刷新        整页刷新\nurl 模式       哈希模式        历史模式\nseo 搜索引擎优化   难以实现        容易实现\n数据传递         容易          通过 url、cookie、localstorage\n页面切换         速度快，用户体验好   需要切换加载资源，速度慢，用户体验差\n维护成本         相对容易        相对复杂\n\n\n# spa 的优缺点分析\n\n优点：\n\n * 具有桌面应用的即时性、网站的可移植性、可访问性特点；\n * 用户体验好、快速，内容改变不需要重新加载页面；\n * 良好的前后端分离，分工明确；\n\n缺点：\n\n * 不利于搜索引擎 seo 优化\n * 首次渲染速度相对较慢\n\ntodo：spa 实现 搜索引擎 seo 优化；\n\n>  * 如何解决 spa 首屏加载速度慢；\n\n\n# spa 首屏加载\n\n首屏加载的概念：浏览器从响应用户输入网址，到首屏内容渲染完成的事件，此时整个网页不一定需要全部渲染完成，但是需要展示当前视窗需要的内容；\n\n计算首屏加载时间：\n\n点击查看\n\n两种方法：\n\n通过 domcontentload 事件：\n\ndocument.addeventlistener('domcontentloaded', (event) => {\n  conosole.log('first contentful painting')\n})\n\n\n1\n2\n3\n\n\n通过 performance ：\n\nperformance.getentriesbyname(\"first-contentful-paint\")[0].starttime\n\n\n1\n\n\n解决单页应用首屏进入加载慢的问题：\n\n> 页面渲染导致加载速度慢的因素有：\n> \n>  * 网络延时；\n>  * 资源文件体积过大；\n>  * 资源是否重复发送请求去加载；\n>  * 加载脚本时，渲染的内容堵塞了；\n\n解决方案：\n\n * 减小入口文件体积；\n   \n   常见手段是路由懒加载，把不同的路由对应不同的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加。\n   \n   🌰 动态加载路由例子：\n   \n   routes: [\n     path: '/'\n     name: 'main',\n     component: () => import('@/views/main.vue')\n   ]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   > 函数形式加载路由，可以把各自的路由文件分别打包吗，只有在解析给定的路由时才会加载路由组件。\n\n * 静态资源本地缓存；\n   \n   * 图片资源压缩大小；\n\n * ui 框架按需加载；（组件按序引用）\n\n * 组件重复打包问题，避免重复加载组件；\n\n * 使用 gzip 压缩；\n   \n   需要浏览器支持。\n\n * 使用 ssr（server side）：\n   \n   服务器端的渲染，组件或者页面通过服务器生成 html 代码，再发送到浏览器。\n\n\n# 参考\n\n * 面试官：你对 spa 单页面的理解，它的优缺点分别是什么？如何实现 spa 应用呢 | web 前端面试 - 面试官系列 (vue3js.cn)\n * 面试官：spa 首屏加载速度慢的怎么解决？ | web 前端面试 - 面试官系列 (vue3js.cn)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🥗 JavaScript DOM 样式和类",frontmatter:{title:"🥗 JavaScript DOM 样式和类",date:"2022-05-27T15:05:24.000Z",permalink:"/pages/9992c4/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/03.%20%F0%9F%A5%97%20JavaScript%20DOM%20%E6%A0%B7%E5%BC%8F%E5%92%8C%E7%B1%BB.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/03. 🥗 JavaScript DOM 样式和类.md",key:"v-728ffe5c",path:"/pages/9992c4/",headers:[{level:2,title:"class...",slug:"class",normalizedTitle:"class...",charIndex:210},{level:2,title:"元素样式 style",slug:"元素样式-style",normalizedTitle:"元素样式 style",charIndex:830},{level:3,title:"重置样式",slug:"重置样式",normalizedTitle:"重置样式",charIndex:1125},{level:3,title:"完整重写样式",slug:"完整重写样式",normalizedTitle:"完整重写样式",charIndex:1291},{level:3,title:"注意样式单位",slug:"注意样式单位",normalizedTitle:"注意样式单位",charIndex:1754},{level:3,title:"计算样式 getComputedStyle",slug:"计算样式-getcomputedstyle",normalizedTitle:"计算样式 getcomputedstyle",charIndex:2204},{level:2,title:"元素大小",slug:"元素大小",normalizedTitle:"元素大小",charIndex:3256},{level:3,title:"几何属性",slug:"几何属性",normalizedTitle:"几何属性",charIndex:3208},{level:4,title:"offsetParent",slug:"offsetparent",normalizedTitle:"offsetparent",charIndex:4361},{level:4,title:"offsetWidth/Height",slug:"offsetwidth-height",normalizedTitle:"offsetwidth/height",charIndex:5089},{level:4,title:"client*",slug:"client",normalizedTitle:"client*",charIndex:5917},{level:4,title:"clientWidth/Height",slug:"clientwidth-height",normalizedTitle:"clientwidth/height",charIndex:6046},{level:4,title:"scrollWidth/Height",slug:"scrollwidth-height",normalizedTitle:"scrollwidth/height",charIndex:6268},{level:4,title:"scrollLeft/scrollTop",slug:"scrollleft-scrolltop",normalizedTitle:"scrollleft/scrolltop",charIndex:7573},{level:3,title:"CSS 样式属性与集合属性比较",slug:"css-样式属性与集合属性比较",normalizedTitle:"css 样式属性与集合属性比较",charIndex:8361},{level:2,title:"窗口大小",slug:"窗口大小",normalizedTitle:"窗口大小",charIndex:9124},{level:3,title:"获取窗口的 width / height",slug:"获取窗口的-width-height",normalizedTitle:"获取窗口的 width /height",charIndex:null},{level:2,title:"文档大小",slug:"文档大小",normalizedTitle:"文档大小",charIndex:9938},{level:3,title:"获取文档的 width / height",slug:"获取文档的-width-height",normalizedTitle:"获取文档的 width /height",charIndex:null},{level:2,title:"滚动状态",slug:"滚动状态",normalizedTitle:"滚动状态",charIndex:10765},{level:3,title:"获得当前滚动位置",slug:"获得当前滚动位置",normalizedTitle:"获得当前滚动位置",charIndex:10774},{level:3,title:"控制滚动位置",slug:"控制滚动位置",normalizedTitle:"控制滚动位置",charIndex:11062},{level:3,title:"禁止滚动",slug:"禁止滚动",normalizedTitle:"禁止滚动",charIndex:12208},{level:2,title:"坐标",slug:"坐标",normalizedTitle:"坐标",charIndex:57},{level:3,title:"获取元素坐标",slug:"获取元素坐标",normalizedTitle:"获取元素坐标",charIndex:12725},{level:3,title:"elementFromPoint(x,y)",slug:"elementfrompoint-x-y",normalizedTitle:"elementfrompoint(x,y)",charIndex:14027},{level:3,title:"结合 CSS 定位",slug:"结合-css-定位",normalizedTitle:"结合 css 定位",charIndex:14515},{level:3,title:"文档坐标",slug:"文档坐标",normalizedTitle:"文档坐标",charIndex:15429}],headersStr:"class... 元素样式 style 重置样式 完整重写样式 注意样式单位 计算样式 getComputedStyle 元素大小 几何属性 offsetParent offsetWidth/Height client* clientWidth/Height scrollWidth/Height scrollLeft/scrollTop CSS 样式属性与集合属性比较 窗口大小 获取窗口的 width / height 文档大小 获取文档的 width / height 滚动状态 获得当前滚动位置 控制滚动位置 禁止滚动 坐标 获取元素坐标 elementFromPoint(x,y) 结合 CSS 定位 文档坐标",content:'JavaScript 修改样式一般通过 修改 DOM 元素的 style 属性。\n\n🌰 例子 / 动态计算元素的坐标：\n\nlet top = /* 复杂的计算 */;\nlet left = /* 复杂的计算 */;\n\nelem.style.left = left; // 例如 \'123px\'，在运行时计算出的\nelem.style.top = top; // 例如 \'456px\'\n\n\n1\n2\n3\n4\n5\n\n\n\n# class...\n\nelem.className 对应于 class 特性（attribute）， 字符串值，可以很好地管理整个类的集合。。\n\n🌰 例子：\n\n<body class="main page">\n  <script>\n    console.log(document.body.className); // main page\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n\n\n特殊对象 classList （类列表），提供 add/remove/toggle 单个类的方法：\n\n * elem.classList.add/remove(class) ：添加 / 移除类。\n * elem.classList.toggle(class) ：如果类不存在就添加类，存在就移除它。\n * elem.classList.contains(class) ：检查给定类，返回 true/false 。\n\n🌰 例子：\n\n<body class="main page">\n  <script>\n    // 添加一个 class\n    document.body.classList.add(\'article\');\n\n    alert(document.body.className); // main page article\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 元素样式 style\n\nelement.style 属性是一个对象，它对应于 style 特性中所写的内容。\n\n遵循 驼峰式命名，意味着在特性中使用 - 的多词命名， - 意味着大写字母，在属性中使用驼峰式命名，例如 background-color 对应 element.style.backgroundColor 。\n\n🌰 例子：\n\ndocument.body.style.backgroundColor = \'green\'\n\n\n1\n\n\n> 像 -moz-border-radius 和 -webkit-border-radius 这样的浏览器前缀属性，也同样遵循这个规则。\n\n\n# 重置样式\n\n * 隐藏一个 元素，可以设置 element.style.display = \'none\' 。\n * 移除这个样式，将这个样式的属性值设置为空： element.style.display = \'\' 。这时元素重新出现。\n\n（空字符串的样式属性，浏览器会应用 CSS 类以及内建样式，就像这个属性没有出现过）\n\n\n# 完整重写样式\n\n通常使用 element.style.* 对各个样式赋值，但是不能设置完整的样式 style ，因为整个 div.style 是一个只读对象。\n\n想要以字符串的形式设置完整的样式，可以使用特殊属性 style.cssText ：\n\n🌰 例子：\n\n<div id="div">Button</div>\n\n\n1\n\n\ndiv.style.cssText = `color: red !important \n\t\tbackground-color: yellow;\n    width: 100px;\n    text-align: center;`;\n\nconsole.log(div.css.cssText)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这样的方式对元素的样式赋值，会删除现有的元素样式；因为它不是添加而是替换。所以这个方法不安全。\n\n要想在原来的基础上添加，设置一个新的特性实现同样的效果：\n\ndiv.setAttribute(\'style\', \'color: red; ... \')\n\n\n1\n\n\n\n# 注意样式单位\n\n🌰 例子 / 设置 top 样式：\n\n<body>\n  <script>\n    // 无效！\n    document.body.style.margin = 20;\n    alert(document.body.style.margin); // \'\'（空字符串，赋值被忽略了）\n\n    // 现在添加了 CSS 单位（px）— 生效了\n    document.body.style.margin = \'20px\';\n    console.log(document.body.style.margin); // 20px\n\n    console.log(document.body.style.marginTop); // 20px\n    console.log(document.body.style.marginLeft); // 20px\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 计算样式 getComputedStyle\n\n修改样式可以直接对样式对应的属性赋值；例如直接 element.body.style.color 不能获取到样式属性的值。\n\n要获取样式属性的值，可以使用：\n\nlet computedStyle = getComputedStyle(element, [presudo])\n\n\n1\n\n * element ：要被读取样式值的元素；\n * [presudo] ：伪元素；例如 ::before 。空字符串或者无参数意味着 元素本身。\n\n获取到的结果是一个具有 样式属性的只读对象。类似 element.style 。\n\n🌰 例子：\n\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  <script>\n    let computedStyle = getComputedStyle(document.body);\n\n    // 现在我们可以读取它的 margin 和 color 了\n\n    alert( computedStyle.marginTop ); // 5px\n    alert( computedStyle.color ); // rgb(255, 0, 0)\n  <\/script>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 对于 margin 、 padding 类型的样式，最好使用精准的完整属性名，例如 paddingLeft 、 marginTop 或 borderTopWidth 。否则，就不能保证正确的结果。\n\n> getComputedStyle 实际上返回的事属性的 解析值。\n> \n>  * 计算 (computed) 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果。例如 height:1em 或 font-size:125% 。\n>  * 解析 (resolved) 样式值是最终应用于元素的样式值值。诸如 1em 或 125% 这样的值是相对的。浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位，例如： height:20px 或 font-size:16px 。对于几何属性，解析（resolved）值可能具有浮点，例如： width:50.5px 。\n\n\n# 元素大小\n\n在 JavaScript 中有许多属性可让我们读取有关元素宽度、高度和其他几何特征的信息。\n\n🌰 例子：\n\n.example 元素中有以下的样式：\n\n<div id="example">\n  ...Text...\n</div>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #E8C48F;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n<html>\n  <div id="example">\n  Introduction This Ecma Standard is based on several originating technologies, the most well known being JavaScript (Netscape) and JScript (Microsoft). The language was invented by Brendan Eich at Netscape and first appeared in that company’s Navigator 2.0 browser. It has appeared in all subsequent browsers from Netscape and in all browsers from Microsoft starting with ... \n  </div>\n</html>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #E8C48F;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n> 注意 滚动条的占用宽度空间：一些浏览器（并非全部）通过从 内容（content width） 获取空间为 滚动条保留空间。如果没有滚动条，内容宽度将是 300 px ，但是如果滚动条宽度是 16px （不同的设备和浏览器，滚动条的宽度可能有所不同），那么最后的内容宽度还剩下 300 - 16 ＝ 284px 。\n> \n> 最近的浏览器版本已经将 滚动条的宽度 不再占用 内容的宽度了。\n\n\n# 几何属性\n\n# offsetParent\n\n元素最外面的几何属性：\n\n * offsetParent ：是最接近的祖先元素，在浏览器渲染期间，它被用于计算坐标。\n   \n   * 最近的祖先为：CSS 中定位为 position: absolute / relative / fixed ；或者 <td> / <th> / <table> ；或者 <body>\n\n * offsetLeft / offsetTop 提供相对于 offsetParent 左上角的 x / y 坐标。\n\n🌰 例子：\n\n<main style="position: relative" id="main">\n  <article>\n    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>\n  </article>\n</main>\n\n<script>\n  alert(example.offsetParent.id); // main\n  alert(example.offsetLeft); // 180\n  alert(example.offsetTop); // 180\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 注意获取到的是不带单位的 数字（不是字符串 180px ）。\n\n对于几种情况， offsetParent 可能为 null :\n\n * 未显示的元素（ display:none 或者不在文档中）。\n * 对于 <body> 与 <html> 。（无祖先元素）\n * 对于带有 position:fixed 的元素。\n\n# offsetWidth/Height\n\n在元素内部（本身中），这两个属性提供了 元素「外部」的宽度和高度（包括边框的完整大小）\n\n🌰 例子：\n\n<html>\n  <div id="example">\n  Introduction This Ecma Standard is based on several originating technologies, the most well known being JavaScript (Netscape) and JScript (Microsoft). The language was invented by Brendan Eich at Netscape and first appeared in that company’s Navigator 2.0 browser. It has appeared in all subsequent browsers from Netscape and in all browsers from Microsoft starting with ... \n  </div>\n</html>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #E8C48F;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n> 这个例子中：\n> \n>  * offsetWidth 为 390 （外部宽度）：\n>    \n>    25px + 20px + 300px + 20px + 25px （不包含滚动条宽度）\n> \n>  * offsetHeight 为 290 （外部高度）：\n>    \n>    同理。\n\n# client*\n\n元素内部中有 边框 时，为了测量他们（边框的宽度）可以使用 client* （相对来说，是内部和外部的相对坐标）：\n\n同上例子：\n\n * clientTop = 25 ：上边框宽度\n * clientLeft = 25 ：左边框宽度\n\n# clientWidth/Height\n\n计算元素边框内区域的大小。包括 内容宽度（content width）和 padding 。（不包括滚动条宽度）\n\n同上例子：\n\n * clientHeight = 200 ：为内部的元素高度（ 200px ）加上 padding 的宽度（ 2 * 20px ）\n * clientWidth = 340 内部元素宽度（ 300px ） 加上 padding 的宽度 ( 2 * 20px ) 。\n\n# scrollWidth/Height\n\n这个属性是 完整的 clientWidth/Height ：它们包括滚动出的隐藏部分。\n\n * scrollWidth = 340\n * scroll = *\n\n利用这个属性可以将属性展开到整个 宽度或者高度。\n\n🌰 例子：\n\n<html>\n  <div id="example2">\n    text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text\n  </div>\n\t<button id="example2button">\n    展开\n  </button>\n</html>\n<style>\n  #example2 {\n    width: 200px;\n    height: 200px;\n    border: 1px solid #000;\n    overflow: auto;\n  }\n</style>\n<script>\n  let button = document.querySelector("#example2button")\n  button.addEventListener(\'click\', function() {\n    example2.style.height = `${example2.scrollHeight}px`;\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# scrollLeft/scrollTop\n\n这两个属性是元素的 隐藏 / 滚动部分的 width / Height ，换句话说， scrollTop 就是 “已经滚动了多少”。\n\n大多数几何属性是只读的，但是 scrollLeft/scrollTop 是可修改的，并且浏览器会滚动该元素。\n\n🌰 例子：点击下面的元素，则会执行代码 elem.scrollTop += 10 。这使得元素内容向下滚动 10px 。\n\n<html>\n  <ul id="example3">\n  \t<li>click</li>\n    <li>me</li>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n  </ul>\n</html>\n<style>\n  #example3 {\n    width: 100px;\n    height: 50px;\n    overflow: scroll;\n  }\n  #example3 li {\n    cursor: pointer;\n  }\n</style>\n<script>\n  let ul = document.querySelector("#example3")\n  ul.addEventListener(\'click\', function() {\n    this.scrollTop += 10\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n🌰 例子 / 将元素滚动到顶部或者底部：\n\nelement.scrollTop = 0 // 顶部\nelement.scrollTop = 1e9 // 底部\n\n\n1\n2\n\n\n\n# CSS 样式属性与集合属性比较\n\n * getComputedStyle 可以获取 CSS 样式中 元素的 width 和 height 。\n   \n   let element = document.body\n   console.log(getComputedStyle(element).width)\n   \n   \n   1\n   2\n   \n\n * 但是应该使用 几何属性 获得宽度、高度和计算距离：\n   \n   * CSS width / height 取决于另一个属性： box-sizing ，它定义了 CSS 宽度和高度。出于 CSS 的目的而对 box-sizing 进行的更改可能会破坏此类 JavaScript 操作。\n   \n   * CSS 的 width/height 可能是 auto ，例如内联（inline）元素：\n     \n     <span id="elem">Hello!</span>\n     \n     <script>\n       console.log( getComputedStyle(elem).width ); // auto\n     <\/script>\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n     \n     > 从 CSS 的观点来看， width:auto 是完全正常的，但在 JavaScript 中，需要一个确切的 px 大小，以便在计算中使用它。\n   \n   * 滚动条占用元素宽度的原因，导致内容的实际宽度小于 CSS 宽度。\n   \n   * 使用 getComputedStyle(element).width 获取的值是一个字符串。而几何元素是 数值。\n\n\n# 窗口大小\n\n\n# 获取窗口的 width / height\n\n利用几何元素：使用 document.documentElement 的 clientWidth / clientHeight ：\n\n<html>\n  获取窗口的高度和宽度：\n  <button onclick="alert(document.documentElement.clientHeight)">\n    document.documentElement.clientHeight\n  </button>\n  <button onclick="alert(document.documentElement.clientWidth)">\n    document.documentElement.clientWidth\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n关于 window.innerWidth / window.innerHeight ：\n\n<html>\n  获取窗口的高度和宽度：\n  <button onclick="alert(window.innerHeight)">\n    window.innerHeight\n  </button>\n  <button onclick="alert(window.innerWidth)">\n    window.innerWidth\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n注意\n\n对比使用 client* ，窗口的宽度有所不同。因为此时 滚动条占用了宽度的一些空间。而 client* 会减去滚动条的宽度。所以使用 client* 返回的是可见文档内容的 width / heiught 。\n\n在大多数情况下，需要通过 可见窗口的宽度 绘制或者放置元素，所以应该使用更加合适的 client* 。\n\n\n# 文档大小\n\n\n# 获取文档的 width / height\n\n根文档元素是 document.documentElement ，并且它包围了所有内容，因此可以通过使用 documentElement.scrollWidth / scrollHeight 来测量文档的完整大小。\n\n由于未明历史原因， body / document.Element （ html 根元素）获取出来的 高度和宽度可能有所不同，所以要获取可靠的数值，要取最大值：\n\n<html>\n  <button onclick="alert(Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n))">\n    scrollHeight\n  </button>\n  <button onclick="alert(Math.max(\n  document.body.scrollWidth, document.documentElement.scrollWidth,\n  document.body.offsetWidth, document.documentElement.offsetWidth,\n  document.body.clientWidth, document.documentElement.clientWidth\n))">\n    scrollWidth\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n# 滚动状态\n\n\n# 获得当前滚动位置\n\n相对于当前页面：\n\n::: demo[vanilla]\n\n<html>\n  <button onclick="alert(\'当前已从顶部滚动：\' + window.pageYOffset)">当前已从顶部滚动</button>\n  <button onclick="alert(\'当前已从左侧滚动：\' + window.pageXOffset)">当前已从左侧滚动</button>\n</html>\n\n\n1\n2\n3\n4\n\n\n:::\n\n> 也可以从 window.scrollX / window.scrollY 中获取相同的信息（两种属性相同）。\n\n\n# 控制滚动位置\n\n注意\n\n注意要在 页面 DOM 完全构建后 才能通过 JavaScript 滚动页面。所以脚本不能放在 <head> 标签当中。\n\n通过更改 scrollTop / scrollLeft 滚动元素；\n\n使用 document.documentElement.scrollTop/scrollLeft 对页面进行相同的操作（Safari 除外，而应该使用 document.body.scrollTop/Left 代替）。\n\n或者使用更加简单的特殊方法：\n\n * window.scrollBy(x, y) ：将页面滚动至 相对于当前位置的 (x, y) 位置。如， scrollBy(0,10) 会将页面向下滚动 10px 。\n\n🌰 例子：\n\n<html>\n  <button onclick="window.scrollBy(0,10)">\n    window.scrollBy(0,10)\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n * window.scrollTo(pageX, pageY) ：将页面滚动至 绝对坐标，使得可见部分的左上角具有相对于文档左上角的坐标。 (pageX, pageY) 。就像给 scrollLeft / scrollTop 设值一样。\n\n🌰 例子：\n\n<html>\n  <button onclick="window.scrollTo(0,0)">\n    window.scrollTo(0,0) 滚动到顶部\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n（这些方法适用于所有浏览器）\n\n * element.scrollIntoView(top) ：将滚动页面以使 element 可见。它有一个参数：\n   * 如果 top = true （默认值），页面滚动，使 element 出现在窗口顶部。元素的上边缘将与窗口顶部对齐。\n   * 如果 top = false ，页面滚动，使 element 出现在窗口底部。元素的底部边缘将与窗口底部对齐。\n\n<html>\n  滚动页面，以使其自身定位在窗口顶部：\n  <button onclick="this.scrollIntoView()">\n    this.scrollIntoView\n  </button><br>\n  会滚动页面，以使其自身定位在窗口底部：\n\t<button onclick="this.scrollIntoView(false)">\n    this.scrollIntoView(false)\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# 禁止滚动\n\n要使文档不可滚动，只需要设置 document.body.style.overflow = "hidden" 。该页面将 “冻结” 在其当前滚动位置上。\n\n取消只要重置该属性的值即可。\n\n<html>\n  <button onclick="document.body.style.overflow = \'hidden\'">document.body.style.overflow = ‘hidden’</button>\n  <button onclick="document.body.style.overflow = \'\'">document.body.style.overflow = ‘’</button>\n</html>\n\n\n1\n2\n3\n4\n\n\n\n\n# 坐标\n\nJavaScript 两个坐标系：\n\n * 相对于 窗口：类似于 position:fixed ，从窗口的顶部 / 左侧边缘计算得出。** 表示为 clientX / clientY ** ;\n\n * 相对于 文档：与文档根中的 position:absolute 类似，从文档的顶部 / 左侧边缘计算得出。表示为 pageX/pageY 。\n\n\n# 获取元素坐标\n\n使用方法 element.getBoundingClientRect() 返回 最小矩形 的窗口坐标，该矩形将 element 作为内建的 DOMRect 类的对象。\n\nDOMRect 类的对象包含主要的属性有：\n\n * x/y ：矩形原点相对于窗口的 X/Y 坐标；\n * width/height ：矩形的 width/height（可以为负）；\n * top/bottom ：顶部 / 底部矩形边缘的 Y 坐标；\n * left/right ： 左 / 右矩形边缘的 X 坐标。\n\n🌰 例子 / 获取按钮元素的 窗口坐标：\n\n<html>\n  <input id="brTest" type="button" value="Get coordinates using button.getBoundingClientRect() for this button" onclick="showRect(this)">\n</html>\n<script>\nfunction showRect(elem) {\n  let r = elem.getBoundingClientRect();\n  alert(`x:${r.x}\n         y:${r.y}\n         width:${r.width}\n         height:${r.height}\n         top:${r.top}\n         bottom:${r.bottom}\n         left:${r.left}\n         right:${r.right}\n        `);\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 随着窗口相对按钮位置的改变，其窗口坐标（如果你垂直滚动页面，则为 y/top/bottom ）也随之改变。\n\n可以得出：\n\n * left = x\n * top = y\n * right = x + width\n * bottom = y + height\n\n提示\n\n注意：\n\n * 坐标可能是小数；浏览器内部使用小数进行计算，所以设置元素的数值不一定必须舍入。\n * 坐标可能是负数。例如滚动页面，元素在页面上方时。\n\n> 从数学上讲，一个矩形是使用其起点 (x,y) 和方向向量 (width,height) 唯一定义的。因此，其它派生属性是为了方便起见。\n> \n> width/height 可能为负数，负数时从左上方构建 矩形。此时 left / right 不等于 x / y （此时 x/y 在右下角）\n> \n> 但是实际上， elem.getBoundingClientRect() 总是返回正数的 width/height 。看起来重复了的属性，其实不重复的。\n\n注意\n\n此处的 right / bottom 要与 CSS 中的定位区分：\n\n * 在 CSS 定位中， right 属性表示距右边缘的距离，而 bottom 属性表示距下边缘的距离。\n\n\n# elementFromPoint(x,y)\n\n对 document.elementFromPoint(x, y) 的调用会返回在窗口坐标 (x, y) 处嵌套最多的元素。\n\nlet element = document.elementFromPoint(x, y)\n\n\n1\n\n\n🌰 例子 / 高亮显示并输出现在位于窗口中间的元素的标签：\n\nlet centerX = document.documentElement.clientWidth / 2;\nlet centerY = document.documentElement.clientHeight / 2;\n\nlet elem = document.elementFromPoint(centerX, centerY);\nelem.style.background = "red";\nconsole.log(element.tagName)\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意\n\n对于在窗口之外的坐标， elementFromPoint 返回 null 。所以只对在可见区域内的坐标 (x,y) 起作用。\n\n\n# 结合 CSS 定位\n\n使用 getBoundingClientRect 来获取其坐标，然后使用 CSS position 以及 left/top （或 right/bottom ）。\n\n🌰 例子 / 函数 createMessageUnder(elem, html) 在 elem 下显示了消息：\n\nlet elem = document.getElementById("coords-show-mark");\n\nfunction createMessageUnder(elem, html) {\n  // 创建 message 元素\n  let message = document.createElement(\'div\');\n  // 在这里最好使用 CSS class 来定义样式\n  message.style.cssText = "position:fixed; color: red";\n\n  // 分配坐标，不要忘记 "px"！\n  let coords = elem.getBoundingClientRect();\n\n  message.style.left = coords.left + "px";\n  message.style.top = coords.bottom + "px";\n\n  message.innerHTML = html;\n\n  return message;\n}\n\nlet message = createMessageUnder(elem, \'Hello, world!\');\ndocument.body.append(message);\nsetTimeout(() => message.remove(), 5000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 上面的例子 message 元素依赖于 position:fixed ，因此当页面滚动时，它仍位于窗口的同一位置。\n> \n> 如果要使跟随元素移动，要使用 position: relative 以及使用基于文档的坐标。\n\n\n# 文档坐标\n\n文档相对坐标从文档的左上角开始计算。（与顶部的 position:absolute 类似）\n\n获取正确的文档坐标，利用 client* :\n\n * pageY = clientY + 文档的垂直滚动出的部分的高度。\n * pageX = clientX + 文档的水平滚动出的部分的宽度。\n\n🌰 例子 / 将从 elem.getBoundingClientRect() 获取元素相对于窗口坐标，并向其中添加当前滚动：\n\nfunction getCoords(elem) {\n  let box = elem.getBoundingClientRect();\n\n  return {\n    top: box.top + window.pageYOffset,\n    right: box.right + window.pageXOffset,\n    bottom: box.bottom + window.pageYOffset,\n    left: box.left + window.pageXOffset\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结合上面的消息例子：\n\nfunction createMessageUnder(elem, html) {\n  let message = document.createElement(\'div\');\n  message.style.cssText = "position:absolute; color: red";\n\n  let coords = getCoords(elem);\n\n  message.style.left = coords.left + "px";\n  message.style.top = coords.bottom + "px";\n\n  message.innerHTML = html;\n\n  return message;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 此时页面滚动时，消息仍停留在元素附近。',normalizedContent:'javascript 修改样式一般通过 修改 dom 元素的 style 属性。\n\n🌰 例子 / 动态计算元素的坐标：\n\nlet top = /* 复杂的计算 */;\nlet left = /* 复杂的计算 */;\n\nelem.style.left = left; // 例如 \'123px\'，在运行时计算出的\nelem.style.top = top; // 例如 \'456px\'\n\n\n1\n2\n3\n4\n5\n\n\n\n# class...\n\nelem.classname 对应于 class 特性（attribute）， 字符串值，可以很好地管理整个类的集合。。\n\n🌰 例子：\n\n<body class="main page">\n  <script>\n    console.log(document.body.classname); // main page\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n\n\n特殊对象 classlist （类列表），提供 add/remove/toggle 单个类的方法：\n\n * elem.classlist.add/remove(class) ：添加 / 移除类。\n * elem.classlist.toggle(class) ：如果类不存在就添加类，存在就移除它。\n * elem.classlist.contains(class) ：检查给定类，返回 true/false 。\n\n🌰 例子：\n\n<body class="main page">\n  <script>\n    // 添加一个 class\n    document.body.classlist.add(\'article\');\n\n    alert(document.body.classname); // main page article\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 元素样式 style\n\nelement.style 属性是一个对象，它对应于 style 特性中所写的内容。\n\n遵循 驼峰式命名，意味着在特性中使用 - 的多词命名， - 意味着大写字母，在属性中使用驼峰式命名，例如 background-color 对应 element.style.backgroundcolor 。\n\n🌰 例子：\n\ndocument.body.style.backgroundcolor = \'green\'\n\n\n1\n\n\n> 像 -moz-border-radius 和 -webkit-border-radius 这样的浏览器前缀属性，也同样遵循这个规则。\n\n\n# 重置样式\n\n * 隐藏一个 元素，可以设置 element.style.display = \'none\' 。\n * 移除这个样式，将这个样式的属性值设置为空： element.style.display = \'\' 。这时元素重新出现。\n\n（空字符串的样式属性，浏览器会应用 css 类以及内建样式，就像这个属性没有出现过）\n\n\n# 完整重写样式\n\n通常使用 element.style.* 对各个样式赋值，但是不能设置完整的样式 style ，因为整个 div.style 是一个只读对象。\n\n想要以字符串的形式设置完整的样式，可以使用特殊属性 style.csstext ：\n\n🌰 例子：\n\n<div id="div">button</div>\n\n\n1\n\n\ndiv.style.csstext = `color: red !important \n\t\tbackground-color: yellow;\n    width: 100px;\n    text-align: center;`;\n\nconsole.log(div.css.csstext)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这样的方式对元素的样式赋值，会删除现有的元素样式；因为它不是添加而是替换。所以这个方法不安全。\n\n要想在原来的基础上添加，设置一个新的特性实现同样的效果：\n\ndiv.setattribute(\'style\', \'color: red; ... \')\n\n\n1\n\n\n\n# 注意样式单位\n\n🌰 例子 / 设置 top 样式：\n\n<body>\n  <script>\n    // 无效！\n    document.body.style.margin = 20;\n    alert(document.body.style.margin); // \'\'（空字符串，赋值被忽略了）\n\n    // 现在添加了 css 单位（px）— 生效了\n    document.body.style.margin = \'20px\';\n    console.log(document.body.style.margin); // 20px\n\n    console.log(document.body.style.margintop); // 20px\n    console.log(document.body.style.marginleft); // 20px\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 计算样式 getcomputedstyle\n\n修改样式可以直接对样式对应的属性赋值；例如直接 element.body.style.color 不能获取到样式属性的值。\n\n要获取样式属性的值，可以使用：\n\nlet computedstyle = getcomputedstyle(element, [presudo])\n\n\n1\n\n * element ：要被读取样式值的元素；\n * [presudo] ：伪元素；例如 ::before 。空字符串或者无参数意味着 元素本身。\n\n获取到的结果是一个具有 样式属性的只读对象。类似 element.style 。\n\n🌰 例子：\n\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  <script>\n    let computedstyle = getcomputedstyle(document.body);\n\n    // 现在我们可以读取它的 margin 和 color 了\n\n    alert( computedstyle.margintop ); // 5px\n    alert( computedstyle.color ); // rgb(255, 0, 0)\n  <\/script>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 对于 margin 、 padding 类型的样式，最好使用精准的完整属性名，例如 paddingleft 、 margintop 或 bordertopwidth 。否则，就不能保证正确的结果。\n\n> getcomputedstyle 实际上返回的事属性的 解析值。\n> \n>  * 计算 (computed) 样式值是所有 css 规则和 css 继承都应用后的值，这是 css 级联（cascade）的结果。例如 height:1em 或 font-size:125% 。\n>  * 解析 (resolved) 样式值是最终应用于元素的样式值值。诸如 1em 或 125% 这样的值是相对的。浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位，例如： height:20px 或 font-size:16px 。对于几何属性，解析（resolved）值可能具有浮点，例如： width:50.5px 。\n\n\n# 元素大小\n\n在 javascript 中有许多属性可让我们读取有关元素宽度、高度和其他几何特征的信息。\n\n🌰 例子：\n\n.example 元素中有以下的样式：\n\n<div id="example">\n  ...text...\n</div>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #e8c48f;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n<html>\n  <div id="example">\n  introduction this ecma standard is based on several originating technologies, the most well known being javascript (netscape) and jscript (microsoft). the language was invented by brendan eich at netscape and first appeared in that company’s navigator 2.0 browser. it has appeared in all subsequent browsers from netscape and in all browsers from microsoft starting with ... \n  </div>\n</html>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #e8c48f;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n> 注意 滚动条的占用宽度空间：一些浏览器（并非全部）通过从 内容（content width） 获取空间为 滚动条保留空间。如果没有滚动条，内容宽度将是 300 px ，但是如果滚动条宽度是 16px （不同的设备和浏览器，滚动条的宽度可能有所不同），那么最后的内容宽度还剩下 300 - 16 ＝ 284px 。\n> \n> 最近的浏览器版本已经将 滚动条的宽度 不再占用 内容的宽度了。\n\n\n# 几何属性\n\n# offsetparent\n\n元素最外面的几何属性：\n\n * offsetparent ：是最接近的祖先元素，在浏览器渲染期间，它被用于计算坐标。\n   \n   * 最近的祖先为：css 中定位为 position: absolute / relative / fixed ；或者 <td> / <th> / <table> ；或者 <body>\n\n * offsetleft / offsettop 提供相对于 offsetparent 左上角的 x / y 坐标。\n\n🌰 例子：\n\n<main style="position: relative" id="main">\n  <article>\n    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>\n  </article>\n</main>\n\n<script>\n  alert(example.offsetparent.id); // main\n  alert(example.offsetleft); // 180\n  alert(example.offsettop); // 180\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 注意获取到的是不带单位的 数字（不是字符串 180px ）。\n\n对于几种情况， offsetparent 可能为 null :\n\n * 未显示的元素（ display:none 或者不在文档中）。\n * 对于 <body> 与 <html> 。（无祖先元素）\n * 对于带有 position:fixed 的元素。\n\n# offsetwidth/height\n\n在元素内部（本身中），这两个属性提供了 元素「外部」的宽度和高度（包括边框的完整大小）\n\n🌰 例子：\n\n<html>\n  <div id="example">\n  introduction this ecma standard is based on several originating technologies, the most well known being javascript (netscape) and jscript (microsoft). the language was invented by brendan eich at netscape and first appeared in that company’s navigator 2.0 browser. it has appeared in all subsequent browsers from netscape and in all browsers from microsoft starting with ... \n  </div>\n</html>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #e8c48f;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n> 这个例子中：\n> \n>  * offsetwidth 为 390 （外部宽度）：\n>    \n>    25px + 20px + 300px + 20px + 25px （不包含滚动条宽度）\n> \n>  * offsetheight 为 290 （外部高度）：\n>    \n>    同理。\n\n# client*\n\n元素内部中有 边框 时，为了测量他们（边框的宽度）可以使用 client* （相对来说，是内部和外部的相对坐标）：\n\n同上例子：\n\n * clienttop = 25 ：上边框宽度\n * clientleft = 25 ：左边框宽度\n\n# clientwidth/height\n\n计算元素边框内区域的大小。包括 内容宽度（content width）和 padding 。（不包括滚动条宽度）\n\n同上例子：\n\n * clientheight = 200 ：为内部的元素高度（ 200px ）加上 padding 的宽度（ 2 * 20px ）\n * clientwidth = 340 内部元素宽度（ 300px ） 加上 padding 的宽度 ( 2 * 20px ) 。\n\n# scrollwidth/height\n\n这个属性是 完整的 clientwidth/height ：它们包括滚动出的隐藏部分。\n\n * scrollwidth = 340\n * scroll = *\n\n利用这个属性可以将属性展开到整个 宽度或者高度。\n\n🌰 例子：\n\n<html>\n  <div id="example2">\n    text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text\n  </div>\n\t<button id="example2button">\n    展开\n  </button>\n</html>\n<style>\n  #example2 {\n    width: 200px;\n    height: 200px;\n    border: 1px solid #000;\n    overflow: auto;\n  }\n</style>\n<script>\n  let button = document.queryselector("#example2button")\n  button.addeventlistener(\'click\', function() {\n    example2.style.height = `${example2.scrollheight}px`;\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# scrollleft/scrolltop\n\n这两个属性是元素的 隐藏 / 滚动部分的 width / height ，换句话说， scrolltop 就是 “已经滚动了多少”。\n\n大多数几何属性是只读的，但是 scrollleft/scrolltop 是可修改的，并且浏览器会滚动该元素。\n\n🌰 例子：点击下面的元素，则会执行代码 elem.scrolltop += 10 。这使得元素内容向下滚动 10px 。\n\n<html>\n  <ul id="example3">\n  \t<li>click</li>\n    <li>me</li>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n  </ul>\n</html>\n<style>\n  #example3 {\n    width: 100px;\n    height: 50px;\n    overflow: scroll;\n  }\n  #example3 li {\n    cursor: pointer;\n  }\n</style>\n<script>\n  let ul = document.queryselector("#example3")\n  ul.addeventlistener(\'click\', function() {\n    this.scrolltop += 10\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n🌰 例子 / 将元素滚动到顶部或者底部：\n\nelement.scrolltop = 0 // 顶部\nelement.scrolltop = 1e9 // 底部\n\n\n1\n2\n\n\n\n# css 样式属性与集合属性比较\n\n * getcomputedstyle 可以获取 css 样式中 元素的 width 和 height 。\n   \n   let element = document.body\n   console.log(getcomputedstyle(element).width)\n   \n   \n   1\n   2\n   \n\n * 但是应该使用 几何属性 获得宽度、高度和计算距离：\n   \n   * css width / height 取决于另一个属性： box-sizing ，它定义了 css 宽度和高度。出于 css 的目的而对 box-sizing 进行的更改可能会破坏此类 javascript 操作。\n   \n   * css 的 width/height 可能是 auto ，例如内联（inline）元素：\n     \n     <span id="elem">hello!</span>\n     \n     <script>\n       console.log( getcomputedstyle(elem).width ); // auto\n     <\/script>\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n     \n     > 从 css 的观点来看， width:auto 是完全正常的，但在 javascript 中，需要一个确切的 px 大小，以便在计算中使用它。\n   \n   * 滚动条占用元素宽度的原因，导致内容的实际宽度小于 css 宽度。\n   \n   * 使用 getcomputedstyle(element).width 获取的值是一个字符串。而几何元素是 数值。\n\n\n# 窗口大小\n\n\n# 获取窗口的 width / height\n\n利用几何元素：使用 document.documentelement 的 clientwidth / clientheight ：\n\n<html>\n  获取窗口的高度和宽度：\n  <button onclick="alert(document.documentelement.clientheight)">\n    document.documentelement.clientheight\n  </button>\n  <button onclick="alert(document.documentelement.clientwidth)">\n    document.documentelement.clientwidth\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n关于 window.innerwidth / window.innerheight ：\n\n<html>\n  获取窗口的高度和宽度：\n  <button onclick="alert(window.innerheight)">\n    window.innerheight\n  </button>\n  <button onclick="alert(window.innerwidth)">\n    window.innerwidth\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n注意\n\n对比使用 client* ，窗口的宽度有所不同。因为此时 滚动条占用了宽度的一些空间。而 client* 会减去滚动条的宽度。所以使用 client* 返回的是可见文档内容的 width / heiught 。\n\n在大多数情况下，需要通过 可见窗口的宽度 绘制或者放置元素，所以应该使用更加合适的 client* 。\n\n\n# 文档大小\n\n\n# 获取文档的 width / height\n\n根文档元素是 document.documentelement ，并且它包围了所有内容，因此可以通过使用 documentelement.scrollwidth / scrollheight 来测量文档的完整大小。\n\n由于未明历史原因， body / document.element （ html 根元素）获取出来的 高度和宽度可能有所不同，所以要获取可靠的数值，要取最大值：\n\n<html>\n  <button onclick="alert(math.max(\n  document.body.scrollheight, document.documentelement.scrollheight,\n  document.body.offsetheight, document.documentelement.offsetheight,\n  document.body.clientheight, document.documentelement.clientheight\n))">\n    scrollheight\n  </button>\n  <button onclick="alert(math.max(\n  document.body.scrollwidth, document.documentelement.scrollwidth,\n  document.body.offsetwidth, document.documentelement.offsetwidth,\n  document.body.clientwidth, document.documentelement.clientwidth\n))">\n    scrollwidth\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n# 滚动状态\n\n\n# 获得当前滚动位置\n\n相对于当前页面：\n\n::: demo[vanilla]\n\n<html>\n  <button onclick="alert(\'当前已从顶部滚动：\' + window.pageyoffset)">当前已从顶部滚动</button>\n  <button onclick="alert(\'当前已从左侧滚动：\' + window.pagexoffset)">当前已从左侧滚动</button>\n</html>\n\n\n1\n2\n3\n4\n\n\n:::\n\n> 也可以从 window.scrollx / window.scrolly 中获取相同的信息（两种属性相同）。\n\n\n# 控制滚动位置\n\n注意\n\n注意要在 页面 dom 完全构建后 才能通过 javascript 滚动页面。所以脚本不能放在 <head> 标签当中。\n\n通过更改 scrolltop / scrollleft 滚动元素；\n\n使用 document.documentelement.scrolltop/scrollleft 对页面进行相同的操作（safari 除外，而应该使用 document.body.scrolltop/left 代替）。\n\n或者使用更加简单的特殊方法：\n\n * window.scrollby(x, y) ：将页面滚动至 相对于当前位置的 (x, y) 位置。如， scrollby(0,10) 会将页面向下滚动 10px 。\n\n🌰 例子：\n\n<html>\n  <button onclick="window.scrollby(0,10)">\n    window.scrollby(0,10)\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n * window.scrollto(pagex, pagey) ：将页面滚动至 绝对坐标，使得可见部分的左上角具有相对于文档左上角的坐标。 (pagex, pagey) 。就像给 scrollleft / scrolltop 设值一样。\n\n🌰 例子：\n\n<html>\n  <button onclick="window.scrollto(0,0)">\n    window.scrollto(0,0) 滚动到顶部\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n\n\n\n（这些方法适用于所有浏览器）\n\n * element.scrollintoview(top) ：将滚动页面以使 element 可见。它有一个参数：\n   * 如果 top = true （默认值），页面滚动，使 element 出现在窗口顶部。元素的上边缘将与窗口顶部对齐。\n   * 如果 top = false ，页面滚动，使 element 出现在窗口底部。元素的底部边缘将与窗口底部对齐。\n\n<html>\n  滚动页面，以使其自身定位在窗口顶部：\n  <button onclick="this.scrollintoview()">\n    this.scrollintoview\n  </button><br>\n  会滚动页面，以使其自身定位在窗口底部：\n\t<button onclick="this.scrollintoview(false)">\n    this.scrollintoview(false)\n  </button>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# 禁止滚动\n\n要使文档不可滚动，只需要设置 document.body.style.overflow = "hidden" 。该页面将 “冻结” 在其当前滚动位置上。\n\n取消只要重置该属性的值即可。\n\n<html>\n  <button onclick="document.body.style.overflow = \'hidden\'">document.body.style.overflow = ‘hidden’</button>\n  <button onclick="document.body.style.overflow = \'\'">document.body.style.overflow = ‘’</button>\n</html>\n\n\n1\n2\n3\n4\n\n\n\n\n# 坐标\n\njavascript 两个坐标系：\n\n * 相对于 窗口：类似于 position:fixed ，从窗口的顶部 / 左侧边缘计算得出。** 表示为 clientx / clienty ** ;\n\n * 相对于 文档：与文档根中的 position:absolute 类似，从文档的顶部 / 左侧边缘计算得出。表示为 pagex/pagey 。\n\n\n# 获取元素坐标\n\n使用方法 element.getboundingclientrect() 返回 最小矩形 的窗口坐标，该矩形将 element 作为内建的 domrect 类的对象。\n\ndomrect 类的对象包含主要的属性有：\n\n * x/y ：矩形原点相对于窗口的 x/y 坐标；\n * width/height ：矩形的 width/height（可以为负）；\n * top/bottom ：顶部 / 底部矩形边缘的 y 坐标；\n * left/right ： 左 / 右矩形边缘的 x 坐标。\n\n🌰 例子 / 获取按钮元素的 窗口坐标：\n\n<html>\n  <input id="brtest" type="button" value="get coordinates using button.getboundingclientrect() for this button" onclick="showrect(this)">\n</html>\n<script>\nfunction showrect(elem) {\n  let r = elem.getboundingclientrect();\n  alert(`x:${r.x}\n         y:${r.y}\n         width:${r.width}\n         height:${r.height}\n         top:${r.top}\n         bottom:${r.bottom}\n         left:${r.left}\n         right:${r.right}\n        `);\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 随着窗口相对按钮位置的改变，其窗口坐标（如果你垂直滚动页面，则为 y/top/bottom ）也随之改变。\n\n可以得出：\n\n * left = x\n * top = y\n * right = x + width\n * bottom = y + height\n\n提示\n\n注意：\n\n * 坐标可能是小数；浏览器内部使用小数进行计算，所以设置元素的数值不一定必须舍入。\n * 坐标可能是负数。例如滚动页面，元素在页面上方时。\n\n> 从数学上讲，一个矩形是使用其起点 (x,y) 和方向向量 (width,height) 唯一定义的。因此，其它派生属性是为了方便起见。\n> \n> width/height 可能为负数，负数时从左上方构建 矩形。此时 left / right 不等于 x / y （此时 x/y 在右下角）\n> \n> 但是实际上， elem.getboundingclientrect() 总是返回正数的 width/height 。看起来重复了的属性，其实不重复的。\n\n注意\n\n此处的 right / bottom 要与 css 中的定位区分：\n\n * 在 css 定位中， right 属性表示距右边缘的距离，而 bottom 属性表示距下边缘的距离。\n\n\n# elementfrompoint(x,y)\n\n对 document.elementfrompoint(x, y) 的调用会返回在窗口坐标 (x, y) 处嵌套最多的元素。\n\nlet element = document.elementfrompoint(x, y)\n\n\n1\n\n\n🌰 例子 / 高亮显示并输出现在位于窗口中间的元素的标签：\n\nlet centerx = document.documentelement.clientwidth / 2;\nlet centery = document.documentelement.clientheight / 2;\n\nlet elem = document.elementfrompoint(centerx, centery);\nelem.style.background = "red";\nconsole.log(element.tagname)\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意\n\n对于在窗口之外的坐标， elementfrompoint 返回 null 。所以只对在可见区域内的坐标 (x,y) 起作用。\n\n\n# 结合 css 定位\n\n使用 getboundingclientrect 来获取其坐标，然后使用 css position 以及 left/top （或 right/bottom ）。\n\n🌰 例子 / 函数 createmessageunder(elem, html) 在 elem 下显示了消息：\n\nlet elem = document.getelementbyid("coords-show-mark");\n\nfunction createmessageunder(elem, html) {\n  // 创建 message 元素\n  let message = document.createelement(\'div\');\n  // 在这里最好使用 css class 来定义样式\n  message.style.csstext = "position:fixed; color: red";\n\n  // 分配坐标，不要忘记 "px"！\n  let coords = elem.getboundingclientrect();\n\n  message.style.left = coords.left + "px";\n  message.style.top = coords.bottom + "px";\n\n  message.innerhtml = html;\n\n  return message;\n}\n\nlet message = createmessageunder(elem, \'hello, world!\');\ndocument.body.append(message);\nsettimeout(() => message.remove(), 5000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 上面的例子 message 元素依赖于 position:fixed ，因此当页面滚动时，它仍位于窗口的同一位置。\n> \n> 如果要使跟随元素移动，要使用 position: relative 以及使用基于文档的坐标。\n\n\n# 文档坐标\n\n文档相对坐标从文档的左上角开始计算。（与顶部的 position:absolute 类似）\n\n获取正确的文档坐标，利用 client* :\n\n * pagey = clienty + 文档的垂直滚动出的部分的高度。\n * pagex = clientx + 文档的水平滚动出的部分的宽度。\n\n🌰 例子 / 将从 elem.getboundingclientrect() 获取元素相对于窗口坐标，并向其中添加当前滚动：\n\nfunction getcoords(elem) {\n  let box = elem.getboundingclientrect();\n\n  return {\n    top: box.top + window.pageyoffset,\n    right: box.right + window.pagexoffset,\n    bottom: box.bottom + window.pageyoffset,\n    left: box.left + window.pagexoffset\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结合上面的消息例子：\n\nfunction createmessageunder(elem, html) {\n  let message = document.createelement(\'div\');\n  message.style.csstext = "position:absolute; color: red";\n\n  let coords = getcoords(elem);\n\n  message.style.left = coords.left + "px";\n  message.style.top = coords.bottom + "px";\n\n  message.innerhtml = html;\n\n  return message;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 此时页面滚动时，消息仍停留在元素附近。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 Vue 双向数据绑定",frontmatter:{title:"🍎 Vue 双向数据绑定",date:"2022-06-12T00:01:48.000Z",permalink:"/pages/9221e7/",categories:["🪞 前端面试题收集","🌠 核心框架相关","🍎 Vue"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20Vue/21.%20%F0%9F%8D%8E%20Vue%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/21. 🍎 Vue 双向数据绑定.md",key:"v-32b59ad8",path:"/pages/9221e7/",headers:[{level:2,title:"双向数据绑定的概念",slug:"双向数据绑定的概念",normalizedTitle:"双向数据绑定的概念",charIndex:25},{level:2,title:"双向数据绑定的原理",slug:"双向数据绑定的原理",normalizedTitle:"双向数据绑定的原理",charIndex:255},{level:3,title:"理解 ViewModel",slug:"理解-viewmodel",normalizedTitle:"理解 viewmodel",charIndex:440},{level:3,title:"实现双向绑定",slug:"实现双向绑定",normalizedTitle:"实现双向绑定",charIndex:605},{level:2,title:"Vue 的双向绑定原理",slug:"vue-的双向绑定原理",normalizedTitle:"vue 的双向绑定原理",charIndex:961},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1092}],headersStr:"双向数据绑定的概念 双向数据绑定的原理 理解 ViewModel 实现双向绑定 Vue 的双向绑定原理 参考",content:">  * Vue 中双向绑定数据是什么？\n\n\n# 双向数据绑定的概念\n\n> 从单向数据绑定切入。把 Model 绑定到 View ，当用 JavaScript 代码 更新 Model 时， View 会自动更新。\n\n双向数据绑定就是，在单向数据绑定的基础上，用户更新了 View ， Model 中的数据也会自动更新。\n\n🌰 例子 / 填写表单：\n\n当用户填写表单时， View 的状态就被更新了，如果此时可以自动更新 Model 的状态，那就相当于把 Model 和 View 做了双向绑定。\n\n\n\n\n# 双向数据绑定的原理\n\nVue 是双向绑定数据的框架。双向绑定由三个重要部分组成：\n\n * 数据层 / Model ：应用的数据以及业务逻辑；\n * 视图层 / View ：应用的展示效果，各类 UI 组件；\n * 业务逻辑层 / ViewModel ：框架封装的核心，负责将数据与视图关联起来；\n\n这个分层的架构方案称为 MVVM。核心功能为 数据的双向绑定。\n\n\n# 理解 ViewModel\n\n主要职责：\n\n * 数据发生改变后，更新视图\n * 视图发生改变后，更新数据\n\n由两个重要的部分组成：\n\n * 监听器 / Observer ：对所有数据的属性进行监听；\n * 解析器 / Compiler：对每个元素的节点的指令进行扫描和解析，根据指令模版替换数据，以及绑定响应的更新函数。\n\n\n# 实现双向绑定\n\n以 Vue 为例，看数据双向绑定的流程：\n\n 1. new Vue() 执行初始化，对 data 执行 响应化处理。这个过程发生在 Observe 中；\n 2. 同时对模版执行编译，找到其中动态绑定的数据，从 data 中获取并且初始化试图，这个过程发生在 Compiler 中；\n 3. 同时定义一个更新函数和 Watcher ，将来对应数据变化时， Watcher 会调用更新函数；\n 4. 由于 data 某个 key 在一个视图中可能会出现多次，所以每个 key 都需要一个管家 Dep 管理多个 Watcher ；\n 5. 将来 data 中的数据一旦发生变化，首先找到对应的 Dep ，通知所有的 Watcher 执行更新函数。\n\n::: details:::\n\n\n\n:::\n\n\n# Vue 的双向绑定原理\n\nVue 的双向绑定是通过 数据劫持 结合 发布者 - 订阅者模式 的方式来实现的，利用 Object.defineProperty() 这个方法重新定义了对象获取 属性值 和 设置属性值（ getter / setter ）。\n\n\n# 参考\n\n * 双向绑定 - 廖雪峰的官方网站 (liaoxuefeng.com)",normalizedContent:">  * vue 中双向绑定数据是什么？\n\n\n# 双向数据绑定的概念\n\n> 从单向数据绑定切入。把 model 绑定到 view ，当用 javascript 代码 更新 model 时， view 会自动更新。\n\n双向数据绑定就是，在单向数据绑定的基础上，用户更新了 view ， model 中的数据也会自动更新。\n\n🌰 例子 / 填写表单：\n\n当用户填写表单时， view 的状态就被更新了，如果此时可以自动更新 model 的状态，那就相当于把 model 和 view 做了双向绑定。\n\n\n\n\n# 双向数据绑定的原理\n\nvue 是双向绑定数据的框架。双向绑定由三个重要部分组成：\n\n * 数据层 / model ：应用的数据以及业务逻辑；\n * 视图层 / view ：应用的展示效果，各类 ui 组件；\n * 业务逻辑层 / viewmodel ：框架封装的核心，负责将数据与视图关联起来；\n\n这个分层的架构方案称为 mvvm。核心功能为 数据的双向绑定。\n\n\n# 理解 viewmodel\n\n主要职责：\n\n * 数据发生改变后，更新视图\n * 视图发生改变后，更新数据\n\n由两个重要的部分组成：\n\n * 监听器 / observer ：对所有数据的属性进行监听；\n * 解析器 / compiler：对每个元素的节点的指令进行扫描和解析，根据指令模版替换数据，以及绑定响应的更新函数。\n\n\n# 实现双向绑定\n\n以 vue 为例，看数据双向绑定的流程：\n\n 1. new vue() 执行初始化，对 data 执行 响应化处理。这个过程发生在 observe 中；\n 2. 同时对模版执行编译，找到其中动态绑定的数据，从 data 中获取并且初始化试图，这个过程发生在 compiler 中；\n 3. 同时定义一个更新函数和 watcher ，将来对应数据变化时， watcher 会调用更新函数；\n 4. 由于 data 某个 key 在一个视图中可能会出现多次，所以每个 key 都需要一个管家 dep 管理多个 watcher ；\n 5. 将来 data 中的数据一旦发生变化，首先找到对应的 dep ，通知所有的 watcher 执行更新函数。\n\n::: details:::\n\n\n\n:::\n\n\n# vue 的双向绑定原理\n\nvue 的双向绑定是通过 数据劫持 结合 发布者 - 订阅者模式 的方式来实现的，利用 object.defineproperty() 这个方法重新定义了对象获取 属性值 和 设置属性值（ getter / setter ）。\n\n\n# 参考\n\n * 双向绑定 - 廖雪峰的官方网站 (liaoxuefeng.com)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 虚拟 DOM 的理解",frontmatter:{title:"🍎 虚拟 DOM 的理解",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/f561af/",categories:["🪞 前端面试题收集","🌠 核心框架相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20%E8%99%9A%E6%8B%9F%20DOM%20%E7%9A%84%E7%90%86%E8%A7%A3.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 虚拟 DOM 的理解.md",key:"v-01106406",path:"/pages/f561af/",headers:[{level:2,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:14},{level:2,title:"使用 diff 算法",slug:"使用-diff-算法",normalizedTitle:"使用 diff 算法",charIndex:620},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:915}],headersStr:"理解 使用 diff 算法 参考",content:">  * 对虚拟 DOM 的理解？\n>  * 为什么虚拟 DOM 能够提高性能？\n\n\n# 理解\n\n虚拟 DOM 为两个前端流行框架 Vue、 React 都带来了跨平台的能力。\n\n实际上，虚拟 DOM 是对真实 DOM 的一个抽象，以 JavaScript 对象（VNode 节点）作为基础树，用对象的属性来描述节点，最终可以通过一系列的操作使这棵树映射到真实的环境中。这个 JavaScript 对象（Object 对象）包含 标签名 tag 、属性 attrs 、子元素对象 children 是那个属性，不同框架对这三个属性的命名可能会有差别。\n\n创建虚拟 DOM 为了更好的将虚拟的节点渲染到页面视图中，所以虚拟 DOM 对象的节点与真实 DOM 的属性一一对应。\n\n由于真实 DOM 的体量十分庞大，大多数的性能问题都是 DOM 操作带来的。真实的 DOM 节点哪怕是一个简单的 div 也包含很多属性。所以操作真实 DOM 的会带来昂贵的代价。\n\n而通过虚拟 DOM（VNode），会通过 diff 算法计算出真正需要更新的节点，最大限度减少对真实 DOM 的操作，保存到本地的 JavaScript 对象中，将这个 JavaScript 对象一次性绑定到 DOM 树上，从而避免大量的无用计算，显著提高性能。\n\n虚拟 DOM 的优势不在于单次操作，而是在于大量、频繁的数据更新至下啊，能够对视图进行合理、高效的更新。\n\n\n# 使用 diff 算法\n\ndiff（different），顾名思义，在构建 DOM 的过程中，会由 diff 过程就是比对计算 DOM 变动的地方，核心是由 patch 算法将变动映射到真实 DOM 上，所以视图的创建更新流程就是下面这样\n\n 1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中\n 2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较 (diff 过程)，记录两棵树差异\n 3. 把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上 (patch)，视图就更新了\n\n\n# 参考\n\n * JS 基础系列之 —— 虚拟 DOM - 知乎 (zhihu.com)\n * 如何实现虚拟 DOM 参考：面试官：什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路 | web 前端面试 - 面试官系列 (vue3js.cn)",normalizedContent:">  * 对虚拟 dom 的理解？\n>  * 为什么虚拟 dom 能够提高性能？\n\n\n# 理解\n\n虚拟 dom 为两个前端流行框架 vue、 react 都带来了跨平台的能力。\n\n实际上，虚拟 dom 是对真实 dom 的一个抽象，以 javascript 对象（vnode 节点）作为基础树，用对象的属性来描述节点，最终可以通过一系列的操作使这棵树映射到真实的环境中。这个 javascript 对象（object 对象）包含 标签名 tag 、属性 attrs 、子元素对象 children 是那个属性，不同框架对这三个属性的命名可能会有差别。\n\n创建虚拟 dom 为了更好的将虚拟的节点渲染到页面视图中，所以虚拟 dom 对象的节点与真实 dom 的属性一一对应。\n\n由于真实 dom 的体量十分庞大，大多数的性能问题都是 dom 操作带来的。真实的 dom 节点哪怕是一个简单的 div 也包含很多属性。所以操作真实 dom 的会带来昂贵的代价。\n\n而通过虚拟 dom（vnode），会通过 diff 算法计算出真正需要更新的节点，最大限度减少对真实 dom 的操作，保存到本地的 javascript 对象中，将这个 javascript 对象一次性绑定到 dom 树上，从而避免大量的无用计算，显著提高性能。\n\n虚拟 dom 的优势不在于单次操作，而是在于大量、频繁的数据更新至下啊，能够对视图进行合理、高效的更新。\n\n\n# 使用 diff 算法\n\ndiff（different），顾名思义，在构建 dom 的过程中，会由 diff 过程就是比对计算 dom 变动的地方，核心是由 patch 算法将变动映射到真实 dom 上，所以视图的创建更新流程就是下面这样\n\n 1. 用 javascript 对象结构表示 dom 树的结构；然后用这个树构建一个真正的 dom 树，插到文 档当中\n 2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较 (diff 过程)，记录两棵树差异\n 3. 把 2 所记录的差异应用到步骤 1 所构建的真正的 dom 树上 (patch)，视图就更新了\n\n\n# 参考\n\n * js 基础系列之 —— 虚拟 dom - 知乎 (zhihu.com)\n * 如何实现虚拟 dom 参考：面试官：什么是虚拟 dom？如何实现一个虚拟 dom？说说你的思路 | web 前端面试 - 面试官系列 (vue3js.cn)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 对 Webpack 的理解相关",frontmatter:{title:"🍎 对 Webpack 的理解相关",date:"2022-06-19T00:36:18.000Z",permalink:"/pages/96c489/",categories:["🪞 前端面试题收集","📦  Webpack 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/10.%20%F0%9F%93%A6%20%20Webpack%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20%E5%AF%B9%20Webpack%20%E7%9A%84%E7%90%86%E8%A7%A3%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/10. 📦  Webpack 相关/01. 🍎 对 Webpack 的理解相关.md",key:"v-7cf7d88f",path:"/pages/96c489/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:9},{level:3,title:"存在问题",slug:"存在问题",normalizedTitle:"存在问题",charIndex:586},{level:3,title:"Webpack 的理解",slug:"webpack-的理解",normalizedTitle:"webpack 的理解",charIndex:834}],headersStr:"概念 背景 存在问题 Webpack 的理解",content:"# 概念\n\n\n# 背景\n\n最初的目标是 实现前端项目的模块化，更高效管理维护项目的每一个资源。\n\n * 模块化：\n   \n   > 最初，会通过文件划分的形式实现模块化，将每个功能以及相关状态数据各自单独放在不同的 .js 文件中。约定每个文件是一个独立的模块，使用的时候再引入到页面中。\n   > \n   > 这种模块的弊端非常明显，模块都是在 全局 中工作，存在大量模块的成员污染了环境，模块与模块之间没有依赖关系、维护困难、没有私有空间等问题。项目一旦变大，上述问题尤为明显。\n   > \n   > 随后出现了 命名空间 的方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载在这个对象中。这种方式没有解决依赖问题。\n   > \n   > 再后来，使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明。\n   > \n   > 以上都是早起解决模块的方式，但是仍然存在一些没有解决的问题。例如，使用过 script 标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦。\n   \n   最理想的方式是，在页面中引入一个 JavaScript 入口文件，其余用到的模块可以通过代码控制，按需加载。\n   \n   除了模块加载问题，还需要规定模块化的规范，目前流行的规范有：CommonJS、ES Module。\n\n\n# 存在问题\n\n现代前端开发可能会面临的问题：\n\n * 需要通过模块化的方式开发；JavaScript 代码需要模块化，HTML 与 CSS 这些资源文件也会面临需要模块化的问题；\n * 使用一些高级的特性提高开发效率。比如通过 ES6+、TypeScript 开发脚本逻辑，通过 Sass、Less 等方式编写 CSS 样式等；\n * 监听文件的变化反映到浏览器上，提高开发效率；\n * 开发完成之后需要将代码进行 压缩、合并以及其他相关的优化；\n\n而 Webpack 能解决上面的问题。\n\n\n# Webpack 的理解\n\nWebpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。\n\n * 静态模块：指的是开发阶段可以被 Webpack 直接引用的资源（直接被获取打包进 bundle.js 的资源）；\n   \n   > Webpack 处理应用程序时，会在内部构造一个依赖图，此依赖图对应映射到项目所需的每个模块，不再局限 .js 文件，并生成一个或者多个 bundle ：\n\n * Webpack 的能力：\n   \n   * 编译代码能力。提高效率，解决浏览器兼容问题；\n   * 模块整合能力。提高性能，可维护性，解决浏览器频繁请求文件的问题；\n   * 万物皆可模块能力。项目维护性强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制。\n\n> 参考内容：\n> \n>  * webpack 官网 (https://webpack.js.org/)",normalizedContent:"# 概念\n\n\n# 背景\n\n最初的目标是 实现前端项目的模块化，更高效管理维护项目的每一个资源。\n\n * 模块化：\n   \n   > 最初，会通过文件划分的形式实现模块化，将每个功能以及相关状态数据各自单独放在不同的 .js 文件中。约定每个文件是一个独立的模块，使用的时候再引入到页面中。\n   > \n   > 这种模块的弊端非常明显，模块都是在 全局 中工作，存在大量模块的成员污染了环境，模块与模块之间没有依赖关系、维护困难、没有私有空间等问题。项目一旦变大，上述问题尤为明显。\n   > \n   > 随后出现了 命名空间 的方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载在这个对象中。这种方式没有解决依赖问题。\n   > \n   > 再后来，使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明。\n   > \n   > 以上都是早起解决模块的方式，但是仍然存在一些没有解决的问题。例如，使用过 script 标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦。\n   \n   最理想的方式是，在页面中引入一个 javascript 入口文件，其余用到的模块可以通过代码控制，按需加载。\n   \n   除了模块加载问题，还需要规定模块化的规范，目前流行的规范有：commonjs、es module。\n\n\n# 存在问题\n\n现代前端开发可能会面临的问题：\n\n * 需要通过模块化的方式开发；javascript 代码需要模块化，html 与 css 这些资源文件也会面临需要模块化的问题；\n * 使用一些高级的特性提高开发效率。比如通过 es6+、typescript 开发脚本逻辑，通过 sass、less 等方式编写 css 样式等；\n * 监听文件的变化反映到浏览器上，提高开发效率；\n * 开发完成之后需要将代码进行 压缩、合并以及其他相关的优化；\n\n而 webpack 能解决上面的问题。\n\n\n# webpack 的理解\n\nwebpack 是一个用于现代 javascript 应用程序的静态模块打包工具。\n\n * 静态模块：指的是开发阶段可以被 webpack 直接引用的资源（直接被获取打包进 bundle.js 的资源）；\n   \n   > webpack 处理应用程序时，会在内部构造一个依赖图，此依赖图对应映射到项目所需的每个模块，不再局限 .js 文件，并生成一个或者多个 bundle ：\n\n * webpack 的能力：\n   \n   * 编译代码能力。提高效率，解决浏览器兼容问题；\n   * 模块整合能力。提高性能，可维护性，解决浏览器频繁请求文件的问题；\n   * 万物皆可模块能力。项目维护性强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制。\n\n> 参考内容：\n> \n>  * webpack 官网 (https://webpack.js.org/)",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 Webpack 的构建流程",frontmatter:{title:"🍏 Webpack 的构建流程",date:"2022-06-19T13:40:47.000Z",permalink:"/pages/6e40af/",categories:["🪞 前端面试题收集","📦  Webpack 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/10.%20%F0%9F%93%A6%20%20Webpack%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8F%20Webpack%20%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.html",relativePath:"200. 🪞 前端面试题收集/10. 📦  Webpack 相关/02. 🍏 Webpack 的构建流程.md",key:"v-58a84061",path:"/pages/6e40af/",headersStr:null,content:">  * Webpack 的构建流程？",normalizedContent:">  * webpack 的构建流程？",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 NodeJS 理解相关",frontmatter:{title:"🍎 NodeJS 理解相关",date:"2022-06-19T00:15:17.000Z",permalink:"/pages/7bb20b/",categories:["🪞 前端面试题收集","📦 NodeJS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/20.%20%F0%9F%93%A6%20NodeJS%20%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20NodeJS%20%E7%90%86%E8%A7%A3%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/20. 📦 NodeJS 相关/01. 🍎 NodeJS 理解相关.md",key:"v-50e23e90",path:"/pages/7bb20b/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:44},{level:2,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:503},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:693}],headersStr:"概念 优缺点 使用场景",content:">  * 说说对 NodeJS 的理解。\n>  * 为什么要用 NodeJS？\n\n\n# 概念\n\n是一个开源、跨平台的 JavaScript 运行环境。在浏览器外运行 V8 JavaScript 引擎，利用事件驱动、非阻塞、异步输入输出模型等提高性功能。\n\n可以理解为 Node.js 是一个服务器端、非阻塞 I/O 的、事件驱动的 JavaScript 运行环境。\n\n>  * 非阻塞异步：Node.js 采用非阻塞 I/O 机制，在 I/O 操作时不会造成任何的阻塞，完成之后，以时间的形式通知执行操作；\n>    \n>    🌰 例子： 访问数据库代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高程序的执行效率；\n> \n>  * 事件驱动：当进来一个新的请求时，请求将会被压入一个事件队列，然后通过一个循环来检测队列中的事件状态变化，如果检测到状态发生变化，则执行该事件对应的处理代码，一般是回调函数。\n>    \n>    🌰 例子： 读取一个文件时，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理。\n>    \n>    \n\n\n# 优缺点\n\n优点：\n\n * 处理高并发场景性能优势；\n * 适合 I/O 密集型的应用，指定是应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I/O 硬盘内存读写操作；\n\n缺点：\n\n * 因为 Node.js 是单线程，所以不适合 CPU 密集型应用；\n * 只支持单核 CPU，不能充分利用 CPU；\n * 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃；\n\n\n# 使用场景\n\n使用场景分类：\n\n * 善于 I/O 操作；不善于计算；因为 Node.js 是一个单线程，如果计算（同步）太多，会阻塞这个程序；\n * 大量并发的 I/。应用程序内部并不需要进行非常复杂的处理；\n * 与 Websocket 配置，开发长连接的实时交互应用程序；\n\n具体场景：\n\n * 第一类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序；\n\n * 第二大类：基于 web、canvas 等多人联网游戏\n\n * 第三大类：基于 web 的多人实时聊天客户端、聊天室、图文直播\n\n * 第四大类：单页面浏览器应用程序\n\n * 第五大类：操作数据库、为前端和移动端提供基于 json 的 API\n\nNodejs 能实现几乎一切的应用，只是要考虑适不适合使用它。\n\n> 参考：",normalizedContent:">  * 说说对 nodejs 的理解。\n>  * 为什么要用 nodejs？\n\n\n# 概念\n\n是一个开源、跨平台的 javascript 运行环境。在浏览器外运行 v8 javascript 引擎，利用事件驱动、非阻塞、异步输入输出模型等提高性功能。\n\n可以理解为 node.js 是一个服务器端、非阻塞 i/o 的、事件驱动的 javascript 运行环境。\n\n>  * 非阻塞异步：node.js 采用非阻塞 i/o 机制，在 i/o 操作时不会造成任何的阻塞，完成之后，以时间的形式通知执行操作；\n>    \n>    🌰 例子： 访问数据库代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高程序的执行效率；\n> \n>  * 事件驱动：当进来一个新的请求时，请求将会被压入一个事件队列，然后通过一个循环来检测队列中的事件状态变化，如果检测到状态发生变化，则执行该事件对应的处理代码，一般是回调函数。\n>    \n>    🌰 例子： 读取一个文件时，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理。\n>    \n>    \n\n\n# 优缺点\n\n优点：\n\n * 处理高并发场景性能优势；\n * 适合 i/o 密集型的应用，指定是应用在运行极限时，cpu 占用率仍然比较低，大部分时间是在做 i/o 硬盘内存读写操作；\n\n缺点：\n\n * 因为 node.js 是单线程，所以不适合 cpu 密集型应用；\n * 只支持单核 cpu，不能充分利用 cpu；\n * 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃；\n\n\n# 使用场景\n\n使用场景分类：\n\n * 善于 i/o 操作；不善于计算；因为 node.js 是一个单线程，如果计算（同步）太多，会阻塞这个程序；\n * 大量并发的 i/。应用程序内部并不需要进行非常复杂的处理；\n * 与 websocket 配置，开发长连接的实时交互应用程序；\n\n具体场景：\n\n * 第一类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序；\n\n * 第二大类：基于 web、canvas 等多人联网游戏\n\n * 第三大类：基于 web 的多人实时聊天客户端、聊天室、图文直播\n\n * 第四大类：单页面浏览器应用程序\n\n * 第五大类：操作数据库、为前端和移动端提供基于 json 的 api\n\nnodejs 能实现几乎一切的应用，只是要考虑适不适合使用它。\n\n> 参考：",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 NodeJS 前端模块化开发相关",frontmatter:{title:"🍎 NodeJS 前端模块化开发相关",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/d38a08/",categories:["🪞 前端面试题收集","📦 NodeJS 相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/20.%20%F0%9F%93%A6%20NodeJS%20%E7%9B%B8%E5%85%B3/02.%20%F0%9F%8D%8E%20NodeJS%20%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3.html",relativePath:"200. 🪞 前端面试题收集/20. 📦 NodeJS 相关/02. 🍎 NodeJS 前端模块化开发相关.md",key:"v-0655e210",path:"/pages/d38a08/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 设计模式的理解",frontmatter:{title:"🍎 设计模式的理解",date:"2022-08-06T11:50:31.000Z",permalink:"/pages/ce7138/",categories:["🪞 前端面试题收集","📦 设计模式相关"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/60.%20%F0%9F%93%A6%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3.html",relativePath:"200. 🪞 前端面试题收集/60. 📦 设计模式相关/01. 🍎 设计模式的理解.md",key:"v-2dd6bfbf",path:"/pages/ce7138/",headers:[{level:2,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:22},{level:2,title:"常见的设计模式",slug:"常见的设计模式",normalizedTitle:"常见的设计模式",charIndex:31},{level:3,title:"单例模式",slug:"单例模式",normalizedTitle:"单例模式",charIndex:594},{level:3,title:"工厂模式",slug:"工厂模式",normalizedTitle:"工厂模式",charIndex:602},{level:3,title:"策略模式",slug:"策略模式",normalizedTitle:"策略模式",charIndex:610},{level:3,title:"代理模式",slug:"代理模式",normalizedTitle:"代理模式",charIndex:618},{level:3,title:"中介者模式",slug:"中介者模式",normalizedTitle:"中介者模式",charIndex:626},{level:3,title:"装饰着模式",slug:"装饰着模式",normalizedTitle:"装饰着模式",charIndex:635},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1290}],headersStr:"理解 常见的设计模式 单例模式 工厂模式 策略模式 代理模式 中介者模式 装饰着模式 参考",content:"> 相关问题：\n> \n>  * 对设计模式的理解？\n>  * 常见的设计模式有哪些？\n\n\n# 理解\n\n软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案。\n\n * 不直接使用来完成代码的编写，而是描述在不同情况下，要怎么解决问题的一种方案；\n\n * 能使不稳定依赖于相对问题、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。\n\n * 当遇到适合的场景，应该想到对应符合这种场景的设计模式。\n   \n   例如，当系统中的某个接口的结构已经无法满足现在的业务需求，但是又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。因此可以想到，使用 适配器模式 来解决这个问题。\n\n> 设计模式来源于众多专家的经验与智慧，从许多的优秀软件系统中总结出成功的、能够实现可维护复用的设计方案，使用这些方案可以避免做重复性的工作；\n> \n> 设计模式提供了一套通用的设计词汇和通用的形式方便开发人员之间的沟通和交流，使得设计方案更加通俗易懂；\n> \n> 大部分设计模式都兼顾了系统的可用性和可拓展性，使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的设计系统，避免经常做一些重复的设计、重复的代码；\n> \n> 合理使用设计模式并对设计模式文档化，能够有助于更快理解系统；\n\n\n# 常见的设计模式\n\n * 单例模式\n * 工厂模式\n * 策略模式\n * 代理模式\n * 中介者模式\n * 装饰着模式\n * …\n\n\n# 单例模式\n\n单例模式 保证一个类仅有一个实例，并 提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类仅有一个实例。\n\n\n# 工厂模式\n\n工厂模式通常会分三个角色：\n\n * 工厂：负责实现创建所有实例的内部逻辑；\n * 抽象产品角色：所创建的所有对象的父类，负责描述所有实例所共有的公共接口；\n * 具体产品角色：创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n\n# 策略模式\n\n策略模式定义了一系列的算法，把他们封装起来，使他们可以互相替换。至少分成两部分：\n\n * 策略类（可变）：封装具体算法，负责具体计算过程；\n * 环境类（不变）：接受客户请求，随后将请求委托给某一个策略类；\n\n\n# 代理模式\n\n代理模式为对象提供了一个代用品或者占用符，以便控制对它的访问。\n\n🌰 例子：实现图片懒加载，先通过一张 加载中图片占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签中。\n\n\n# 中介者模式\n\n中介者模式通过中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。\n\n通过中介者模式可以解除对象与对象之间的紧耦合关系。\n\n\n# 装饰着模式\n\n装饰着模式在不改变自身的基础上，程序运行期间给对象动态添加方法。\n\n通常运用于在原有方法维持不变，在原有方法上挂载其他方法来满足需求。\n\n\n# 参考\n\n * Study-Plan/README.md at master · xietao3/Study-Plan (github.com) / 学习并理解 23 种设计模式。\n * 图解九种常见的设计模式 - SegmentFault 思否",normalizedContent:"> 相关问题：\n> \n>  * 对设计模式的理解？\n>  * 常见的设计模式有哪些？\n\n\n# 理解\n\n软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案。\n\n * 不直接使用来完成代码的编写，而是描述在不同情况下，要怎么解决问题的一种方案；\n\n * 能使不稳定依赖于相对问题、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。\n\n * 当遇到适合的场景，应该想到对应符合这种场景的设计模式。\n   \n   例如，当系统中的某个接口的结构已经无法满足现在的业务需求，但是又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。因此可以想到，使用 适配器模式 来解决这个问题。\n\n> 设计模式来源于众多专家的经验与智慧，从许多的优秀软件系统中总结出成功的、能够实现可维护复用的设计方案，使用这些方案可以避免做重复性的工作；\n> \n> 设计模式提供了一套通用的设计词汇和通用的形式方便开发人员之间的沟通和交流，使得设计方案更加通俗易懂；\n> \n> 大部分设计模式都兼顾了系统的可用性和可拓展性，使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的设计系统，避免经常做一些重复的设计、重复的代码；\n> \n> 合理使用设计模式并对设计模式文档化，能够有助于更快理解系统；\n\n\n# 常见的设计模式\n\n * 单例模式\n * 工厂模式\n * 策略模式\n * 代理模式\n * 中介者模式\n * 装饰着模式\n * …\n\n\n# 单例模式\n\n单例模式 保证一个类仅有一个实例，并 提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类仅有一个实例。\n\n\n# 工厂模式\n\n工厂模式通常会分三个角色：\n\n * 工厂：负责实现创建所有实例的内部逻辑；\n * 抽象产品角色：所创建的所有对象的父类，负责描述所有实例所共有的公共接口；\n * 具体产品角色：创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n\n# 策略模式\n\n策略模式定义了一系列的算法，把他们封装起来，使他们可以互相替换。至少分成两部分：\n\n * 策略类（可变）：封装具体算法，负责具体计算过程；\n * 环境类（不变）：接受客户请求，随后将请求委托给某一个策略类；\n\n\n# 代理模式\n\n代理模式为对象提供了一个代用品或者占用符，以便控制对它的访问。\n\n🌰 例子：实现图片懒加载，先通过一张 加载中图片占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签中。\n\n\n# 中介者模式\n\n中介者模式通过中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。\n\n通过中介者模式可以解除对象与对象之间的紧耦合关系。\n\n\n# 装饰着模式\n\n装饰着模式在不改变自身的基础上，程序运行期间给对象动态添加方法。\n\n通常运用于在原有方法维持不变，在原有方法上挂载其他方法来满足需求。\n\n\n# 参考\n\n * study-plan/readme.md at master · xietao3/study-plan (github.com) / 学习并理解 23 种设计模式。\n * 图解九种常见的设计模式 - segmentfault 思否",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍏 前端项目使用脚手架",frontmatter:{title:"🍏 前端项目使用脚手架",date:"2022-07-01T23:36:36.000Z",permalink:"/pages/003555/",categories:["🪞 前端面试题收集","📦 前端工程化"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/70.%20%F0%9F%93%A6%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/01.%20%F0%9F%8D%8F%20%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6.html",relativePath:"200. 🪞 前端面试题收集/70. 📦 前端工程化/01. 🍏 前端项目使用脚手架.md",key:"v-c5fea8b6",path:"/pages/003555/",headers:[{level:2,title:"前端脚手架",slug:"前端脚手架",normalizedTitle:"前端脚手架",charIndex:37}],headersStr:"前端脚手架",content:"> 相关问题：\n> \n>  * 为什么开发的时候需要使用脚手架？\n\n\n# 前端脚手架\n\n脚手架是通过几个选项就能快速搭建项目基础代码的工具，能够避免重复编写相同的代码框架的基本配置，提升了项目初始化的效率，减少重复性工作。\n\n脚手架工具的项目模版经过了开发者的提炼和检验，一定程度上代表了某类项目的最佳实践。\n\n常见的前端脚手架工具：\n\n * vue-cli\n * create-react-app",normalizedContent:"> 相关问题：\n> \n>  * 为什么开发的时候需要使用脚手架？\n\n\n# 前端脚手架\n\n脚手架是通过几个选项就能快速搭建项目基础代码的工具，能够避免重复编写相同的代码框架的基本配置，提升了项目初始化的效率，减少重复性工作。\n\n脚手架工具的项目模版经过了开发者的提炼和检验，一定程度上代表了某类项目的最佳实践。\n\n常见的前端脚手架工具：\n\n * vue-cli\n * create-react-app",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"📡 关于本笔记的搭建",frontmatter:{title:"📡 关于本笔记的搭建",date:"2022-06-10T14:40:59.000Z",permalink:"/pages/99638b/",categories:["🚪 其他文章收集"],tags:[null]},regularPath:"/400.%20%F0%9F%9A%AA%20%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/10.%20%F0%9F%93%A1%20%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AC%94%E8%AE%B0%E7%9A%84%E6%90%AD%E5%BB%BA.html",relativePath:"400. 🚪 其他文章收集/10. 📡 关于本笔记的搭建.md",key:"v-f0de70a4",path:"/pages/99638b/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],headersStr:"参考",content:"# 参考\n\n * 主题模版参考 vdoing-template (u2sb.com) ｜ xugaoyi/vuepress-theme-vdoing: 🚀一款简洁高效的 VuePress 知识管理 & 博客 (blog) 主题 (github.com)\n * 部署到 GitHub Pages 参考：使用 GitHub Actions 将博客部署到 GitHub Page | 叉叉白 (xxwhite.com).",normalizedContent:"# 参考\n\n * 主题模版参考 vdoing-template (u2sb.com) ｜ xugaoyi/vuepress-theme-vdoing: 🚀一款简洁高效的 vuepress 知识管理 & 博客 (blog) 主题 (github.com)\n * 部署到 github pages 参考：使用 github actions 将博客部署到 github page | 叉叉白 (xxwhite.com).",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌑 初始化 TypeScript 库项目",frontmatter:{title:"🌑 初始化 TypeScript 库项目",date:"2022-06-10T19:55:42.000Z",permalink:"/pages/a07897/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 封装 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/01.%20%F0%9F%8C%91%20%E5%88%9D%E5%A7%8B%E5%8C%96%20TypeScript%20%E5%BA%93%E9%A1%B9%E7%9B%AE.html",relativePath:"801. 💽 TypeScript-Axios/01. 🌑 初始化 TypeScript 库项目.md",key:"v-a1ea609c",path:"/pages/a07897/",headers:[{level:2,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:286},{level:2,title:"入口文件",slug:"入口文件",normalizedTitle:"入口文件",charIndex:1076}],headersStr:"创建项目 入口文件",content:"🍞 相关资源：\n\n * TypeScript library starter alexjoverm/typescript-library-starter: Starter kit with zero-config for building a library in TypeScript, featuring RollupJS, Jest, Prettier, TSLint, Semantic Release, and more! (github.com)\n   \n   开发 TypeScript 基础库脚手架工具，快速初始化 TypeScript 项目。\n\n\n# 创建项目\n\nclone typescript-library-starter 项目：\n\ngit clone git@github.com:alexjoverm/typescript-library-starter.git axios-typescript\n\n\n1\n\n\n> 文件目录相关：\n> \n> ├── CONTRIBUTING.md\n> ├── LICENSE\n> ├── README.md\n> ├── code-of-conduct.md\n> ├── node_modules\n> ├── package-lock.json\n> ├── package.json\n> ├── rollup.config.ts // rollup 配置文件\n> ├── src // 源码目录\n> ├── test // 测试目录\n> ├── tools // 发布到 GitHup pages 以及 发布到 npm 的一些配置脚本工具\n> ├── tsconfig.json // TypeScript 编译配置文件\n> └── tslint.json // TypeScript lint 文件\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> \n> \n> 集成工具：\n> \n>  * rollup.js：打包工具；\n>  * Prettier / TSLint 格式化代码；\n>  * TypeDoc：自动生成文档；\n>  * Jest：单元测试；\n>  * Commitizen ：生成规范注释；\n>  * Semantic release：管理版本和发布；\n>  * husky：git hooks 工具\n>  * Conventional changelog ：生成 change log；\n\n\n# 入口文件\n\n删除原来 src 的文件，创建整个库入口文件 index.ts 。先定义一个 axios 方法，并默认导出：\n\nfunction axios(config) {\n\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n\n\n要给 config 参数定义一种接口类型。创建 types 目录存放类型接口。\n\n定义 AxiosRequestConfig 接口类型和请求方法字符串字面量类型 Method ：\n\nexport interface AxiosRequestConfig {\n  url: string\n  method?: Method\n  data?: any\n  params?: any\n}\n\nexport type Method =\n  'get'\n  | 'GET'\n  | 'post'\n  | 'POST'\n  | 'delete'\n  | 'DELETE'\n  | 'head'\n  | 'HEAD'\n  | 'options'\n  | 'OPTIONS'\n  | 'put'\n  | 'PUT'\n  | 'patch'\n  | 'PATCH'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n然后在入口文件 index.ts 引入类型作为 config 参数的类型：",normalizedContent:"🍞 相关资源：\n\n * typescript library starter alexjoverm/typescript-library-starter: starter kit with zero-config for building a library in typescript, featuring rollupjs, jest, prettier, tslint, semantic release, and more! (github.com)\n   \n   开发 typescript 基础库脚手架工具，快速初始化 typescript 项目。\n\n\n# 创建项目\n\nclone typescript-library-starter 项目：\n\ngit clone git@github.com:alexjoverm/typescript-library-starter.git axios-typescript\n\n\n1\n\n\n> 文件目录相关：\n> \n> ├── contributing.md\n> ├── license\n> ├── readme.md\n> ├── code-of-conduct.md\n> ├── node_modules\n> ├── package-lock.json\n> ├── package.json\n> ├── rollup.config.ts // rollup 配置文件\n> ├── src // 源码目录\n> ├── test // 测试目录\n> ├── tools // 发布到 githup pages 以及 发布到 npm 的一些配置脚本工具\n> ├── tsconfig.json // typescript 编译配置文件\n> └── tslint.json // typescript lint 文件\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> \n> \n> 集成工具：\n> \n>  * rollup.js：打包工具；\n>  * prettier / tslint 格式化代码；\n>  * typedoc：自动生成文档；\n>  * jest：单元测试；\n>  * commitizen ：生成规范注释；\n>  * semantic release：管理版本和发布；\n>  * husky：git hooks 工具\n>  * conventional changelog ：生成 change log；\n\n\n# 入口文件\n\n删除原来 src 的文件，创建整个库入口文件 index.ts 。先定义一个 axios 方法，并默认导出：\n\nfunction axios(config) {\n\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n\n\n要给 config 参数定义一种接口类型。创建 types 目录存放类型接口。\n\n定义 axiosrequestconfig 接口类型和请求方法字符串字面量类型 method ：\n\nexport interface axiosrequestconfig {\n  url: string\n  method?: method\n  data?: any\n  params?: any\n}\n\nexport type method =\n  'get'\n  | 'get'\n  | 'post'\n  | 'post'\n  | 'delete'\n  | 'delete'\n  | 'head'\n  | 'head'\n  | 'options'\n  | 'options'\n  | 'put'\n  | 'put'\n  | 'patch'\n  | 'patch'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n然后在入口文件 index.ts 引入类型作为 config 参数的类型：",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌒 实现基础请求",frontmatter:{title:"🌒 实现基础请求",date:"2022-06-10T21:10:00.000Z",permalink:"/pages/a6d7da/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库","🌒 基础功能实现"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/02.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/02.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82.html",relativePath:"801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/02. 🌒 实现基础请求.md",key:"v-01beeb53",path:"/pages/a6d7da/",headers:[{level:2,title:"利用 XMLHttpRequest 发送请求",slug:"利用-xmlhttprequest-发送请求",normalizedTitle:"利用 xmlhttprequest 发送请求",charIndex:2},{level:2,title:"DEMO 服务",slug:"demo-服务",normalizedTitle:"demo 服务",charIndex:614}],headersStr:"利用 XMLHttpRequest 发送请求 DEMO 服务",content:"# 利用 XMLHttpRequest 发送请求\n\n创建一个 xhr.ts 文件，导出一个 xhr 方法，接收 config 参数。并且在其中使用 XHLHttpRequest 构造器创建请求实例，从 config 获取相关请求信息：\n\nimport { AxiosRequestConfig } from './types'\n\nexport default function xhr(config: AxiosRequestConfig) {\n  const { data = null, url, method = 'get' } = config\n\n  const request = new XMLHttpRequest()\n\n  request.open(method.toUpperCase(), url, true)\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后在入口文件中引入 xhr 模块：\n\nimport { AxiosRequestConfig } from './types'\nimport xhr from './xhr'\n\nfunction axios(config: AxiosRequestConfig) {\n  xhr(config)\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# DEMO 服务\n\n> 安装相关依赖：\n> \n>  * webpack 是打包构建工具；\n>  * webpack-dev-middleware 和 webpack-hot-middleware 是 2 个 express 的 webpack 中间件；\n>  * ts-loader 和 tslint-loader 是 webpack 需要的 TypeScript 相关 loader， express 是 Node.js 的服务端框架， body-parser 是 express 的一个中间件，解析 body 数据用的。\n\n在 examples 目录下：\n\n创建 webpack 配置文件：\n\n * 会在 examples 目录下建多个子目录；会把不同章节的 demo 放到不同的子目录中，每个子目录的下会创建一个 app.ts ， app.ts 作为 webpack 构建的入口文件； entries 收集了多目录个入口文件，并且每个入口还引入了一个用于热更新的文件， entries 是一个对象， key 为目录名；\n * output ：根据不同的目录名称，打包生成目标 js ，名称和目录名一致。\n\nconst fs = require('fs')\nconst path = require('path')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'development',\n\n  entry: fs.readdirSync(__dirname).reduce((entries, dir) => {\n    const fullDir = path.join(__dirname, dir)\n    const entry = path.join(fullDir, 'app.ts')\n    if (fs.statSync(fullDir).isDirectory() && fs.existsSync(entry)) {\n      entries[dir] = ['webpack-hot-middleware/client', entry]\n    }\n\n    return entries\n  }, {}),\n\n  output: {\n    path: path.join(__dirname, '__build__'),\n    filename: '[name].js',\n    publicPath: '/__build__'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        enforce: 'pre',\n        use: [{ loader: 'tslint-loader' }]\n      },\n      {\n        test: /\\.tsx?$/,\n        options: {\n          transpileOnly: true\n        }\n      }\n    ]\n  },\n\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js']\n  },\n\n  plugins: [new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin()]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n创建 server.js 文件：\n\n点击查看\n\nconst express = require('express')\nconst bodyParser = require('body-parser')\nconst webpack = require('webpack')\nconst webpackDevMiddleware = require('webpack-dev-middleware')\nconst webpackHotMiddleware = require('webpack-hot-middleware')\nconst WebpackConfig = require('./webpack.config')\n\nconst app = express()\nconst complier = webpack(WebpackConfig)\n\napp.use(\n  webpackDevMiddleware(complier, {\n    publicPath: '/__build__/',\n    stats: {\n      colors: true,\n      chunks: false\n    }\n  })\n)\n\napp.use(webpackHotMiddleware(complier))\n\napp.use(express.static(__dirname))\n\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\n\nconst port = process.env.PORT || 8080\nmodule.exports = app.listen(port, ()=> {\n  console.log('Server listening on http://localhost:${port}, Ctrl+C to stop')\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n创建 index.html / global.css ，作为入口文件与全局样式文件：\n\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n  <meta charset='UTF-8'>\n  <title>axios-typescript example</title>\n</head>\n<body style='padding: 0 20px'>\n<h1>examples</h1>\n<ul>\n  <li><a href='simple'>Simple</a></li>\n</ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nhtml, body {\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  color: #2c3e50;\n}\n\nul {\n  line-height: 1.5em;\n  padding-left: 1.5em;\n}\n\na {\n  color: #7f8c8d;\n  text-decoration: none;\n}\n\na:hover {\n  color: #4fc08d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在 examples 目录下创建 simple 目录，作为本章节的 demo 目录，在该目录下再创建 index.html 和 app.ts 文件：\n\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n  <meta charset='UTF-8'>\n  <title>simple example</title>\n</head>\n<body>\n\n<script src=\"/__build__/simple.js\"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: 'simple/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为我们这里通过 axios 发送了请求，那么我们的 server 端要实现对应的路由接口，我们来修改 server.js ，添加如下代码：\n\nconst router = express.Router()\n\nrouter.get('/simple/get', function(req,res) {\n  res.json({\n    msg: 'hello world'\n  })\n})\n\napp.use(router)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在项目 package.json 添加运行 npm run scripts ：\n\n\"dev\": \"node examples/server.js\"\n\n\n1\n",normalizedContent:"# 利用 xmlhttprequest 发送请求\n\n创建一个 xhr.ts 文件，导出一个 xhr 方法，接收 config 参数。并且在其中使用 xhlhttprequest 构造器创建请求实例，从 config 获取相关请求信息：\n\nimport { axiosrequestconfig } from './types'\n\nexport default function xhr(config: axiosrequestconfig) {\n  const { data = null, url, method = 'get' } = config\n\n  const request = new xmlhttprequest()\n\n  request.open(method.touppercase(), url, true)\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后在入口文件中引入 xhr 模块：\n\nimport { axiosrequestconfig } from './types'\nimport xhr from './xhr'\n\nfunction axios(config: axiosrequestconfig) {\n  xhr(config)\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# demo 服务\n\n> 安装相关依赖：\n> \n>  * webpack 是打包构建工具；\n>  * webpack-dev-middleware 和 webpack-hot-middleware 是 2 个 express 的 webpack 中间件；\n>  * ts-loader 和 tslint-loader 是 webpack 需要的 typescript 相关 loader， express 是 node.js 的服务端框架， body-parser 是 express 的一个中间件，解析 body 数据用的。\n\n在 examples 目录下：\n\n创建 webpack 配置文件：\n\n * 会在 examples 目录下建多个子目录；会把不同章节的 demo 放到不同的子目录中，每个子目录的下会创建一个 app.ts ， app.ts 作为 webpack 构建的入口文件； entries 收集了多目录个入口文件，并且每个入口还引入了一个用于热更新的文件， entries 是一个对象， key 为目录名；\n * output ：根据不同的目录名称，打包生成目标 js ，名称和目录名一致。\n\nconst fs = require('fs')\nconst path = require('path')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'development',\n\n  entry: fs.readdirsync(__dirname).reduce((entries, dir) => {\n    const fulldir = path.join(__dirname, dir)\n    const entry = path.join(fulldir, 'app.ts')\n    if (fs.statsync(fulldir).isdirectory() && fs.existssync(entry)) {\n      entries[dir] = ['webpack-hot-middleware/client', entry]\n    }\n\n    return entries\n  }, {}),\n\n  output: {\n    path: path.join(__dirname, '__build__'),\n    filename: '[name].js',\n    publicpath: '/__build__'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        enforce: 'pre',\n        use: [{ loader: 'tslint-loader' }]\n      },\n      {\n        test: /\\.tsx?$/,\n        options: {\n          transpileonly: true\n        }\n      }\n    ]\n  },\n\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js']\n  },\n\n  plugins: [new webpack.hotmodulereplacementplugin(), new webpack.noemitonerrorsplugin()]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n创建 server.js 文件：\n\n点击查看\n\nconst express = require('express')\nconst bodyparser = require('body-parser')\nconst webpack = require('webpack')\nconst webpackdevmiddleware = require('webpack-dev-middleware')\nconst webpackhotmiddleware = require('webpack-hot-middleware')\nconst webpackconfig = require('./webpack.config')\n\nconst app = express()\nconst complier = webpack(webpackconfig)\n\napp.use(\n  webpackdevmiddleware(complier, {\n    publicpath: '/__build__/',\n    stats: {\n      colors: true,\n      chunks: false\n    }\n  })\n)\n\napp.use(webpackhotmiddleware(complier))\n\napp.use(express.static(__dirname))\n\napp.use(bodyparser.json())\napp.use(bodyparser.urlencoded({ extended: true }))\n\nconst port = process.env.port || 8080\nmodule.exports = app.listen(port, ()=> {\n  console.log('server listening on http://localhost:${port}, ctrl+c to stop')\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n创建 index.html / global.css ，作为入口文件与全局样式文件：\n\n<!doctype html>\n<html lang='en'>\n<head>\n  <meta charset='utf-8'>\n  <title>axios-typescript example</title>\n</head>\n<body style='padding: 0 20px'>\n<h1>examples</h1>\n<ul>\n  <li><a href='simple'>simple</a></li>\n</ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nhtml, body {\n  font-family: -apple-system, blinkmacsystemfont, \"segoe ui\", roboto, helvetica, arial, sans-serif, \"apple color emoji\", \"segoe ui emoji\", \"segoe ui symbol\";\n  color: #2c3e50;\n}\n\nul {\n  line-height: 1.5em;\n  padding-left: 1.5em;\n}\n\na {\n  color: #7f8c8d;\n  text-decoration: none;\n}\n\na:hover {\n  color: #4fc08d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在 examples 目录下创建 simple 目录，作为本章节的 demo 目录，在该目录下再创建 index.html 和 app.ts 文件：\n\n<!doctype html>\n<html lang='en'>\n<head>\n  <meta charset='utf-8'>\n  <title>simple example</title>\n</head>\n<body>\n\n<script src=\"/__build__/simple.js\"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: 'simple/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为我们这里通过 axios 发送了请求，那么我们的 server 端要实现对应的路由接口，我们来修改 server.js ，添加如下代码：\n\nconst router = express.router()\n\nrouter.get('/simple/get', function(req,res) {\n  res.json({\n    msg: 'hello world'\n  })\n})\n\napp.use(router)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在项目 package.json 添加运行 npm run scripts ：\n\n\"dev\": \"node examples/server.js\"\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌒 实现处理请求 URL 参数",frontmatter:{title:"🌒 实现处理请求 URL 参数",date:"2022-06-10T22:25:28.000Z",permalink:"/pages/2c5ed7/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库","🌒 基础功能实现"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/02.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/03.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%20URL%20%E5%8F%82%E6%95%B0.html",relativePath:"801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/03. 🌒 实现处理请求 URL 参数.md",key:"v-02cdca3c",path:"/pages/2c5ed7/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"buildURL 函数实现",slug:"buildurl-函数实现",normalizedTitle:"buildurl 函数实现",charIndex:2147},{level:2,title:"在入口文件引入",slug:"在入口文件引入",normalizedTitle:"在入口文件引入",charIndex:4135},{level:2,title:"编写 DEMO 测试",slug:"编写-demo-测试",normalizedTitle:"编写 demo 测试",charIndex:4715}],headersStr:"需求分析 buildURL 函数实现 在入口文件引入 编写 DEMO 测试",content:"# 需求分析\n\n根据不同的 URL params 参数有不同的情况分析：\n\n * 普通参数：\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       a: 1,\n       b: 2\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   最终请求 URL 为： /base/get?a=1&b=2 ，这样服务器就可以通过请求 URL 解析到传送的参数数据。实际上就是把 params 对象中的 key 和 value 拼接到 URL 上。\n\n * 参数值为数组时：\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: ['bar', 'baz']\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 URL 为： /base/get?foo[]=bar&foo[]=baz ；\n\n * 参数值为对象时：\n   \n   const date = new Date()\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: {\n         bar: 'baz'\n       }\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   最终请求 URL 为： /base/get?foo=%7B%22bar%22:%22baz%22%7D ， foo 后面拼接的是 {\"bar\":\"baz\"} encode 后的结果。\n\n * 参数值为 Date 类型：\n   \n   const date = new Date()\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       date\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   最终请求的 url 是 /base/get?date=2019-04-01T05:55:39.030Z ， date 后面拼接的是 date.toISOString() 的结果。\n\n * 支持特殊字符：允许特殊字符出现在 URL 中，不希望被 encode 。\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: '@:$, '\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 URL 为 /base/get?foo=@:$+ ，注意，我们会把空格 转换成 + 。\n\n * 支持空值的忽略：对于值为 null 或者 undefined 的属性，不会添加到 url 参数中的。\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: 'bar',\n       baz: null\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   最终请求 URL 为： /base/get?foo=bar ；\n\n * 丢弃 URL 中的哈希标记：\n   \n   axios({\n     method: 'get',\n     url: '/base/get#hash',\n     params: {\n       foo: 'bar'\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 URL 为： /base/get?foo=bar ；\n\n * 保留 URL 中已经存在的参数：\n   \n   axios({\n     method: 'get',\n     url: '/base/get?foo=bar',\n     params: {\n       bar: 'baz'\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 URL 为： /base/get?foo=bar&bar=baz ；\n\n\n# buildURL 函数实现\n\n根据需求分析，需要实现一个工具函数，将 params 中的数据拼接到 URL 上。\n\n * 创建 helpers 目录，在目录下创建 url.ts 编写处理 URL 相关的工具。\n * 在同目录下创建 util.ts 存放相关的工具；\n\nhelpers/util.ts ：检验数据的类型，是否为 Date 对象，或者是普通对象 object 。\n\nconst toString = Object.prototype.toString\n\nexport function isDate(val: any): val is Date {\n  return toString.call(val) === '[object Date]'\n}\n\nexport function isObject(val: any): val is Object {\n  return val !== null && typeof val === 'object'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nhelpers/url.ts ：\n\nimport { isDate, isObject } from './util'\n\nfunction encode(val: string): string {\n  return encodeURIComponent(val)\n    .replace(/%40/g, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',')\n    .replace(/%20/g, '+')\n    .replace(/%5B/gi, '[')\n    .replace(/%5D/gi, ']')\n}\n\nexport function buildURL(url: string, params?: any) {\n  if (!params) return url\n\n  const parts: string[] = []\n\n  Object.keys(params).forEach(key => {\n    let val = params[key]\n    if (val === null || typeof val === 'undefined') return\n\n    let values: string[]\n    if (Array.isArray(val)) {\n      values = val\n      key += '[]'\n    } else {\n      values = [val]\n    }\n    values.forEach(val => {\n      if (isDate(val)) {\n        val = val.toISOString()\n      } else if(isObject(val)) {\n        val = JSON.stringify(val)\n      }\n      parts.push(`${encode(key)}=${encode(val)}`)\n    })\n  })\n\n  let serializedParams = parts.join('&')\n\n  if(serializedParams) {\n    const markIndex = url.indexOf('#')\n    if(markIndex !== -1) {\n      url = url.slice(0, markIndex)\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams\n  }\n\n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n>  * encode() 函数处理特殊字符；\n>  * buildURL 拼接带有参数的 URL。首先 先遍历 params 对象中的键值，判断其中的类型，分别按照不同的类型（数组、 日期、普通对象）编码，然后再添加到一个处理后的参数字符串数组中；使用 & 拼接这个字符串数组生成序列化的参数字符串；接着处理哈希标记，并且如果 URL 中已经存在参数，要在其后添加 & 再加入字符串处理后的参数。\n\n\n# 在入口文件引入\n\nimport { AxiosRequestConfig } from './types'\nimport xhr from './xhr'\nimport { buildURL } from './helpers/url'\n\nfunction axios(config: AxiosRequestConfig) {\n  processConfig(config)\n  xhr(config)\n}\n\nfunction processConfig(config: AxiosRequestConfig) {\n  config.url = transformURL(config)\n}\n\nfunction transformURL (config: AxiosRequestConfig) {\n  const {url, params} = config\n  return buildURL(url, params)\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n在执行 xhr 函数之前，添加处理 config 的方法 processConfig 。在 processConfig 内部，执行 transformURL 处理 URL。\n\n\n# 编写 DEMO 测试\n\n在 exampls 目录下创建 base 目录：\n\nbase/index.html ：\n\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n  <meta charset='UTF-8'>\n  <title>simple example</title>\n</head>\n<body>\n\n<script src=\"/__build__/simple.js\"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nbase/app.ts ：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: ['bar', 'baz']\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n})\n\nconst date = new Date()\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    date\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: '@:$, '\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: 'bar',\n    baz: null\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get#hash',\n  params: {\n    foo: 'bar'\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get?foo=bar',\n  params: {\n    bar: 'baz'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n在 server.js 中添加 router ：\n\nrouter.get('/base/get', function(req, res) {\n  res.json(req.query)\n})\n\n\n1\n2\n3\n\n\n在 examples/index.html 中添加测试链接：\n\n<li><a href='base'>Base</a></li>\n\n\n1\n\n\n最后进入链接之后，可以看到发送了多个请求，查看请求的 URL 和响应的信息。",normalizedContent:"# 需求分析\n\n根据不同的 url params 参数有不同的情况分析：\n\n * 普通参数：\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       a: 1,\n       b: 2\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   最终请求 url 为： /base/get?a=1&b=2 ，这样服务器就可以通过请求 url 解析到传送的参数数据。实际上就是把 params 对象中的 key 和 value 拼接到 url 上。\n\n * 参数值为数组时：\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: ['bar', 'baz']\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 url 为： /base/get?foo[]=bar&foo[]=baz ；\n\n * 参数值为对象时：\n   \n   const date = new date()\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: {\n         bar: 'baz'\n       }\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   最终请求 url 为： /base/get?foo=%7b%22bar%22:%22baz%22%7d ， foo 后面拼接的是 {\"bar\":\"baz\"} encode 后的结果。\n\n * 参数值为 date 类型：\n   \n   const date = new date()\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       date\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   最终请求的 url 是 /base/get?date=2019-04-01t05:55:39.030z ， date 后面拼接的是 date.toisostring() 的结果。\n\n * 支持特殊字符：允许特殊字符出现在 url 中，不希望被 encode 。\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: '@:$, '\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 url 为 /base/get?foo=@:$+ ，注意，我们会把空格 转换成 + 。\n\n * 支持空值的忽略：对于值为 null 或者 undefined 的属性，不会添加到 url 参数中的。\n   \n   axios({\n     method: 'get',\n     url: '/base/get',\n     params: {\n       foo: 'bar',\n       baz: null\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   最终请求 url 为： /base/get?foo=bar ；\n\n * 丢弃 url 中的哈希标记：\n   \n   axios({\n     method: 'get',\n     url: '/base/get#hash',\n     params: {\n       foo: 'bar'\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 url 为： /base/get?foo=bar ；\n\n * 保留 url 中已经存在的参数：\n   \n   axios({\n     method: 'get',\n     url: '/base/get?foo=bar',\n     params: {\n       bar: 'baz'\n     }\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   最终请求 url 为： /base/get?foo=bar&bar=baz ；\n\n\n# buildurl 函数实现\n\n根据需求分析，需要实现一个工具函数，将 params 中的数据拼接到 url 上。\n\n * 创建 helpers 目录，在目录下创建 url.ts 编写处理 url 相关的工具。\n * 在同目录下创建 util.ts 存放相关的工具；\n\nhelpers/util.ts ：检验数据的类型，是否为 date 对象，或者是普通对象 object 。\n\nconst tostring = object.prototype.tostring\n\nexport function isdate(val: any): val is date {\n  return tostring.call(val) === '[object date]'\n}\n\nexport function isobject(val: any): val is object {\n  return val !== null && typeof val === 'object'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nhelpers/url.ts ：\n\nimport { isdate, isobject } from './util'\n\nfunction encode(val: string): string {\n  return encodeuricomponent(val)\n    .replace(/%40/g, '@')\n    .replace(/%3a/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2c/gi, ',')\n    .replace(/%20/g, '+')\n    .replace(/%5b/gi, '[')\n    .replace(/%5d/gi, ']')\n}\n\nexport function buildurl(url: string, params?: any) {\n  if (!params) return url\n\n  const parts: string[] = []\n\n  object.keys(params).foreach(key => {\n    let val = params[key]\n    if (val === null || typeof val === 'undefined') return\n\n    let values: string[]\n    if (array.isarray(val)) {\n      values = val\n      key += '[]'\n    } else {\n      values = [val]\n    }\n    values.foreach(val => {\n      if (isdate(val)) {\n        val = val.toisostring()\n      } else if(isobject(val)) {\n        val = json.stringify(val)\n      }\n      parts.push(`${encode(key)}=${encode(val)}`)\n    })\n  })\n\n  let serializedparams = parts.join('&')\n\n  if(serializedparams) {\n    const markindex = url.indexof('#')\n    if(markindex !== -1) {\n      url = url.slice(0, markindex)\n    }\n\n    url += (url.indexof('?') === -1 ? '?' : '&') + serializedparams\n  }\n\n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n>  * encode() 函数处理特殊字符；\n>  * buildurl 拼接带有参数的 url。首先 先遍历 params 对象中的键值，判断其中的类型，分别按照不同的类型（数组、 日期、普通对象）编码，然后再添加到一个处理后的参数字符串数组中；使用 & 拼接这个字符串数组生成序列化的参数字符串；接着处理哈希标记，并且如果 url 中已经存在参数，要在其后添加 & 再加入字符串处理后的参数。\n\n\n# 在入口文件引入\n\nimport { axiosrequestconfig } from './types'\nimport xhr from './xhr'\nimport { buildurl } from './helpers/url'\n\nfunction axios(config: axiosrequestconfig) {\n  processconfig(config)\n  xhr(config)\n}\n\nfunction processconfig(config: axiosrequestconfig) {\n  config.url = transformurl(config)\n}\n\nfunction transformurl (config: axiosrequestconfig) {\n  const {url, params} = config\n  return buildurl(url, params)\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n在执行 xhr 函数之前，添加处理 config 的方法 processconfig 。在 processconfig 内部，执行 transformurl 处理 url。\n\n\n# 编写 demo 测试\n\n在 exampls 目录下创建 base 目录：\n\nbase/index.html ：\n\n<!doctype html>\n<html lang='en'>\n<head>\n  <meta charset='utf-8'>\n  <title>simple example</title>\n</head>\n<body>\n\n<script src=\"/__build__/simple.js\"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nbase/app.ts ：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: ['bar', 'baz']\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n})\n\nconst date = new date()\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    date\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: '@:$, '\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: 'bar',\n    baz: null\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get#hash',\n  params: {\n    foo: 'bar'\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get?foo=bar',\n  params: {\n    bar: 'baz'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n在 server.js 中添加 router ：\n\nrouter.get('/base/get', function(req, res) {\n  res.json(req.query)\n})\n\n\n1\n2\n3\n\n\n在 examples/index.html 中添加测试链接：\n\n<li><a href='base'>base</a></li>\n\n\n1\n\n\n最后进入链接之后，可以看到发送了多个请求，查看请求的 url 和响应的信息。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌒 实现处理请求 head",frontmatter:{title:"🌒 实现处理请求 head",date:"2022-06-11T15:00:18.000Z",permalink:"/pages/1d2040/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/02.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/05.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%20head.html",relativePath:"801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/05. 🌒 实现处理请求 head.md",key:"v-361b4710",path:"/pages/1d2040/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"processHeader 函数实现",slug:"processheader-函数实现",normalizedTitle:"processheader 函数实现",charIndex:371},{level:2,title:"在入口文件添加请求 header  处理逻辑",slug:"在入口文件添加请求-header-处理逻辑",normalizedTitle:"在入口文件添加请求 header  处理逻辑",charIndex:null},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:2608}],headersStr:"需求分析 processHeader 函数实现 在入口文件添加请求 header  处理逻辑 编写测试 DEMO",content:"# 需求分析\n\n要支持发送请求的数据类型，需要支持配置 headers 的属性来调整 content-type 。如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json;charset=utf-8'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n并且在当传入的 data 为普通对象的时候， headers 如果没有配置 Content-Type 属性，需要自动设置请求 header 的 Content-Type 字段为： application/json;charset=utf-8 。\n\n\n# processHeader 函数实现\n\n创建文件 src/helpers/headers.ts 实现处理请求头工具函数：\n\nimport { isPlainObject } from './util'\n\nfunction normalizeHeaderName(headers: any, normalizedName: string): void {\n  if (!headers) return\n\n  Object.keys(headers).forEach(name => {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = headers[name]\n      delete headers[name]\n    }\n  })\n}\n\nexport function processHeaders(headers: any, data: any): any {\n  normalizeHeaderName(headers, 'Content-Type')\n\n  if (isPlainObject(data)) {\n    if (headers && !headers['Content-Type']) {\n      headers['Content-Type'] = 'application/json;charset=utf-8'\n    }\n  }\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 由于 header 属性的 key 是大小写不 in 干的，例如之前穿入的 header 属性名 content-type 是全小写的，所以要先把 header 属性名先处理规范化。\n> \n> 然后在添加 header 。\n\n\n# 在入口文件添加请求 header 处理逻辑\n\n首先需要先修改 AxiosRequstConfig 接口类型的定义，要添加 headers 可选属性：\n\n在 src/types/index.ts ：\n\nexport interface AxiosRequestConfig {\n  url: string\n  method?: Method\n  data?: any\n  params?: any\n  headers?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在 src/index.ts 中添加处理 header 逻辑：\n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.headers = transformRequestHeader(config)\n  config.data = transformRequestData(config)\n}\n\n// ... \n\nfunction transformRequestHeader(config: AxiosRequestConfig): any {\n  const { headers = {}, data } = config\n  return processHeaders(headers, data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意，因为处理 header 时，依赖了 data ，所以处理请求 body 数据之前处理请求 header 。\n\n在 src/xhr.ts ：\n\nimport { AxiosRequestConfig } from './types'\n\nexport default function xhr(config: AxiosRequestConfig) {\n  const { data = null, url, method = 'get', headers } = config\n\n  const request = new XMLHttpRequest()\n\n  request.open(method.toUpperCase(), url, true)\n\n  Object.keys(headers).forEach(name => {\n    if (data === null && name.toLowerCase() === 'content-type') {\n      delete headers[name]\n    } else {\n      request.setRequestHeader(name, headers[name])\n    }\n  })\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n在使用 XMLHttpRequest 的实例时，添加额外的判断传入 data 为空的时候，请求 header 配置 Content-Type 是没有意义的，所以将它删除。\n\n\n# 编写测试 DEMO\n\n在上一节处理 body 参数的基础上，添加 headers 的 content-type 类型：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst paramsString = 'q=URLUtils.searchParams&topic=api'\nconst searchParams = new URLSearchParams(paramsString)\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: searchParams\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n> 测试可以看到，没有添加 headers 的 content-type ，检测到请求数据是普通数据也会为其添加；同时当 data 为某些类型如 URLSearchParams 时，浏览器会自动为请求 header 添加合适的 Content-Type 。",normalizedContent:"# 需求分析\n\n要支持发送请求的数据类型，需要支持配置 headers 的属性来调整 content-type 。如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json;charset=utf-8'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n并且在当传入的 data 为普通对象的时候， headers 如果没有配置 content-type 属性，需要自动设置请求 header 的 content-type 字段为： application/json;charset=utf-8 。\n\n\n# processheader 函数实现\n\n创建文件 src/helpers/headers.ts 实现处理请求头工具函数：\n\nimport { isplainobject } from './util'\n\nfunction normalizeheadername(headers: any, normalizedname: string): void {\n  if (!headers) return\n\n  object.keys(headers).foreach(name => {\n    if (name !== normalizedname && name.touppercase() === normalizedname.touppercase()) {\n      headers[normalizedname] = headers[name]\n      delete headers[name]\n    }\n  })\n}\n\nexport function processheaders(headers: any, data: any): any {\n  normalizeheadername(headers, 'content-type')\n\n  if (isplainobject(data)) {\n    if (headers && !headers['content-type']) {\n      headers['content-type'] = 'application/json;charset=utf-8'\n    }\n  }\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 由于 header 属性的 key 是大小写不 in 干的，例如之前穿入的 header 属性名 content-type 是全小写的，所以要先把 header 属性名先处理规范化。\n> \n> 然后在添加 header 。\n\n\n# 在入口文件添加请求 header 处理逻辑\n\n首先需要先修改 axiosrequstconfig 接口类型的定义，要添加 headers 可选属性：\n\n在 src/types/index.ts ：\n\nexport interface axiosrequestconfig {\n  url: string\n  method?: method\n  data?: any\n  params?: any\n  headers?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在 src/index.ts 中添加处理 header 逻辑：\n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.headers = transformrequestheader(config)\n  config.data = transformrequestdata(config)\n}\n\n// ... \n\nfunction transformrequestheader(config: axiosrequestconfig): any {\n  const { headers = {}, data } = config\n  return processheaders(headers, data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意，因为处理 header 时，依赖了 data ，所以处理请求 body 数据之前处理请求 header 。\n\n在 src/xhr.ts ：\n\nimport { axiosrequestconfig } from './types'\n\nexport default function xhr(config: axiosrequestconfig) {\n  const { data = null, url, method = 'get', headers } = config\n\n  const request = new xmlhttprequest()\n\n  request.open(method.touppercase(), url, true)\n\n  object.keys(headers).foreach(name => {\n    if (data === null && name.tolowercase() === 'content-type') {\n      delete headers[name]\n    } else {\n      request.setrequestheader(name, headers[name])\n    }\n  })\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n在使用 xmlhttprequest 的实例时，添加额外的判断传入 data 为空的时候，请求 header 配置 content-type 是没有意义的，所以将它删除。\n\n\n# 编写测试 demo\n\n在上一节处理 body 参数的基础上，添加 headers 的 content-type 类型：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst paramsstring = 'q=urlutils.searchparams&topic=api'\nconst searchparams = new urlsearchparams(paramsstring)\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: searchparams\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n> 测试可以看到，没有添加 headers 的 content-type ，检测到请求数据是普通数据也会为其添加；同时当 data 为某些类型如 urlsearchparams 时，浏览器会自动为请求 header 添加合适的 content-type 。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌒 实现处理请求 body 数据",frontmatter:{title:"🌒 实现处理请求 body 数据",date:"2022-06-11T14:00:59.000Z",permalink:"/pages/fa5bf4/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/02.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/04.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%20body%20%E6%95%B0%E6%8D%AE.html",relativePath:"801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/04. 🌒 实现处理请求 body 数据.md",key:"v-42669813",path:"/pages/fa5bf4/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"transformRequest 函数实现",slug:"transformrequest-函数实现",normalizedTitle:"transformrequest 函数实现",charIndex:436},{level:2,title:"在入口文件加入请求 body 处理逻辑",slug:"在入口文件加入请求-body-处理逻辑",normalizedTitle:"在入口文件加入请求 body 处理逻辑",charIndex:1201},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:1571}],headersStr:"需求分析 transformRequest 函数实现 在入口文件加入请求 body 处理逻辑 编写测试 DEMO",content:"# 需求分析\n\n> 在使用 XMLHttpRequest 对象实例 send 方法发送请求时，通过该方法的参数设置请求的 body 数据。\n> \n> 支持的数据类型有（XMLHttpRequest.send() - Web APIs | MDN (mozilla.org)）： Documnet 、 bodyInt （包括 blob 、 BufferSource 、 FormData 、 URLSearchParams 、 ReadableStream 、 USVString ）没有数据时可以穿入 null ；\n\n最常用的场景时穿入一个 普通对象。\n\n🌰 例子：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 此时的 data 不能直接传给 send 方法，需要先转换为 JSON 字符串。\n\n\n# transformRequest 函数实现\n\n根据需求分析需要实现一个工具函数，对 request 中的 data 进行转换。\n\n文件 src/helpers/util.ts 中添加判断是否为普通对象的方法：\n\nexport function isPlainObject(val: any): val is Object {\n  return toString.call(val) === '[object Object]'\n}\n\n\n1\n2\n3\n\n\n新建文件 src/helpers/data.ts ：\n\nimport { isPlainObject } from './util'\n\nexport function transformRequest(data: any): any {\n  if(isPlainObject(data)) {\n    return JSON.stringify(data)\n  }\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这里需要使用 isPlainObject 而不是之前的 isObject ；因为对于 FormData 、 ArrayBuffer 这些类型， isObject 也为 true ，而这些数据是不必处理的。所以转换应该只对 普通对象有效。\n\n> 修改 src/helpers/url.ts 中的类型判断：\n> \n> if (isDate(val)) {\n>   val = val.toISOString()\n> } else if(isPlainObject(val)) {\n>   val = JSON.stringify(val)\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 这样才更加合理。\n\n\n# 在入口文件加入请求 body 处理逻辑\n\n在上一节的基础上的 src/index.ts ，添加处理 config 中 data 的逻辑：\n\n// ... \n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.data = transformRequestData(config)\n}\n\n// ...\n\nfunction transformRequestData(config: AxiosRequestConfig): any {\n  return transformRequest(config.data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 编写测试 DEMO\n\n在 examples/base/app.ts ，添加新的请求：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst arr = new Int32Array([21, 31])\naxios({\n  method: 'post',\n  url: '/base/buffer',\n  data: arr\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 第一个请求需要经过转换才能传给 XMLHttpRequest 的 send 方法；第二个请求不需要处理可以直接发送。\n\n在 examples/server.js 添加两个路由处理这两个请求， 返回请求穿入的数据：\n\nrouter.post('/base/post', function(req, res) {\n  res.json(req.body)\n})\n\nrouter.post('/base/buffer', function(req, res) {\n  let msg = []\n  req.on('data', chunk => {\n    if (chunk) {\n      msg.push(chunk)\n    }\n  })\n  req.on('end', () => {\n    let buf = Buffer.concat(msg)\n    res.json(buf.toJSON())\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 此时测试 post 发送普通对象，响应并不能显示内容，这是因为执行 send 方法时虽然转换成了 JSON 字符串发送，但是请求头 Content-Type 是 text/plain;charset=UTF-8 ，这里服务器端接收到请求并不能正确解析请求 body 的数据。所以要对请求头进行处理",normalizedContent:"# 需求分析\n\n> 在使用 xmlhttprequest 对象实例 send 方法发送请求时，通过该方法的参数设置请求的 body 数据。\n> \n> 支持的数据类型有（xmlhttprequest.send() - web apis | mdn (mozilla.org)）： documnet 、 bodyint （包括 blob 、 buffersource 、 formdata 、 urlsearchparams 、 readablestream 、 usvstring ）没有数据时可以穿入 null ；\n\n最常用的场景时穿入一个 普通对象。\n\n🌰 例子：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 此时的 data 不能直接传给 send 方法，需要先转换为 json 字符串。\n\n\n# transformrequest 函数实现\n\n根据需求分析需要实现一个工具函数，对 request 中的 data 进行转换。\n\n文件 src/helpers/util.ts 中添加判断是否为普通对象的方法：\n\nexport function isplainobject(val: any): val is object {\n  return tostring.call(val) === '[object object]'\n}\n\n\n1\n2\n3\n\n\n新建文件 src/helpers/data.ts ：\n\nimport { isplainobject } from './util'\n\nexport function transformrequest(data: any): any {\n  if(isplainobject(data)) {\n    return json.stringify(data)\n  }\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 这里需要使用 isplainobject 而不是之前的 isobject ；因为对于 formdata 、 arraybuffer 这些类型， isobject 也为 true ，而这些数据是不必处理的。所以转换应该只对 普通对象有效。\n\n> 修改 src/helpers/url.ts 中的类型判断：\n> \n> if (isdate(val)) {\n>   val = val.toisostring()\n> } else if(isplainobject(val)) {\n>   val = json.stringify(val)\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 这样才更加合理。\n\n\n# 在入口文件加入请求 body 处理逻辑\n\n在上一节的基础上的 src/index.ts ，添加处理 config 中 data 的逻辑：\n\n// ... \n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.data = transformrequestdata(config)\n}\n\n// ...\n\nfunction transformrequestdata(config: axiosrequestconfig): any {\n  return transformrequest(config.data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 编写测试 demo\n\n在 examples/base/app.ts ，添加新的请求：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst arr = new int32array([21, 31])\naxios({\n  method: 'post',\n  url: '/base/buffer',\n  data: arr\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 第一个请求需要经过转换才能传给 xmlhttprequest 的 send 方法；第二个请求不需要处理可以直接发送。\n\n在 examples/server.js 添加两个路由处理这两个请求， 返回请求穿入的数据：\n\nrouter.post('/base/post', function(req, res) {\n  res.json(req.body)\n})\n\nrouter.post('/base/buffer', function(req, res) {\n  let msg = []\n  req.on('data', chunk => {\n    if (chunk) {\n      msg.push(chunk)\n    }\n  })\n  req.on('end', () => {\n    let buf = buffer.concat(msg)\n    res.json(buf.tojson())\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 此时测试 post 发送普通对象，响应并不能显示内容，这是因为执行 send 方法时虽然转换成了 json 字符串发送，但是请求头 content-type 是 text/plain;charset=utf-8 ，这里服务器端接收到请求并不能正确解析请求 body 的数据。所以要对请求头进行处理",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌒 获取响应数据",frontmatter:{title:"🌒 获取响应数据",date:"2022-06-11T15:38:55.000Z",permalink:"/pages/f3a9f8/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/02.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/06.%20%F0%9F%8C%92%20%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE.html",relativePath:"801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/06. 🌒 获取响应数据.md",key:"v-062eca5c",path:"/pages/f3a9f8/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"定义接口类型 AxiosReponse",slug:"定义接口类型-axiosreponse",normalizedTitle:"定义接口类型 axiosreponse",charIndex:446},{level:2,title:"实现获取相应数据的逻辑",slug:"实现获取相应数据的逻辑",normalizedTitle:"实现获取相应数据的逻辑",charIndex:1221},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:3012}],headersStr:"需求分析 定义接口类型 AxiosReponse 实现获取相应数据的逻辑 编写测试 DEMO",content:"# 需求分析\n\n前面的实现中，发送的请求都可以从网络层面接收到服务器端返回的数据；但是代码层面并没有对响应数据进行任何的处理。\n\n需要支持对响应数据的处理，并且支持 Promise 的链式调用的方式，如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 可以获取到 res 对象，并且 res 对象中包括服务器返回的数据 data ，HTTP 响应状态码 status ， 响应头 headers 、请求配置对象 config 以及请求的 XMLHttpRequest 对象实例 request 。\n\n\n# 定义接口类型 AxiosReponse\n\n如下：\n\nexport interface AxiosResponse {\n  data: any\n  status: number\n  statusText: string\n  headers: any\n  config: AxiosRequestConfig\n  request: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n另外 axios 函数返回的是一个 Promise 对象，可以定义一个 AxiosPromise 接口，继承于 Promise<AxiosResponse> 这个泛型接口：\n\nexport interface AxiosPromise extends Promise<AxiosResponse> {\n  \n}\n\n\n1\n2\n3\n\n\n> 此时，当 axios 返回的是 AxiosPromise 类型，那么 resolve 函数中的参数是一个 AxiosResponse 类型。\n\n对于 AJAX 请求的 response ，可以指定它的数据类型，通过设置 XMLHttpRequest 对象的 responseType 属性，可以给 axiosRequestConfig 类型添加一个可选属性：\n\nexport interface AxiosRequestConfig {\n  // ...\n  responseType?: XMLHttpRequestResponseType\n}\n\n\n1\n2\n3\n4\n\n\n> responseType 的类型是一个 XMLHttpRequestResponseType 类型，它的定义是 \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\" 字符串字面量类型。\n\n\n# 实现获取相应数据的逻辑\n\n在 src/xhr.ts 中，添加 onreadystatechange 事件处理函数，并且让 xhr 函数返回的是 AxiosPromise 类型：\n\nimport { AxiosPromise, AxiosRequestConfig, AxiosResponse } from './types'\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise(resolve => {\n    const { data = null, url, method = 'get', headers, responseType } = config\n\n    const request = new XMLHttpRequest()\n\n    if (responseType) {\n      request.responseType = responseType\n    }\n\n    request.open(method.toUpperCase(), url, true)\n\n    request.onreadystatechange = function handleLoad() {\n      if(request.readyState !== 4) {\n        return\n      }\n\n      const responseHeaders = request.getAllResponseHeaders()\n      const responseData = responseType && responseType !== 'text' ? request.response : request.responseText\n      const response: AxiosResponse = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      }\n\n      resolve(response)\n    }\n\n    Object.keys(headers).forEach(name => {\n      if (data === null && name.toLowerCase() === 'content-type') {\n        delete headers[name]\n      } else {\n        request.setRequestHeader(name, headers[name])\n      }\n    })\n\n    request.send(data)\n  })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n>  * 需要判断 如果 config 配置了 responseType ，需要将它设置到 xhr 的 requset.responseType ；\n>  * 在 onreadystatechange 事件函数中，构造了 AxiosResponse 类型的 response 对象，并把它 resolve 出去。\n\n修改了 xhr 函数，同样要修改对应的 axios 函数：\n\nsrc/index.ts ：\n\nfunction axios(config: AxiosRequestConfig): AxiosPromise {\n  processConfig(config)\n  return xhr(config)\n}\n\n\n1\n2\n3\n4\n\n\n> 至此实现了 axios 的 Promise 化。\n\n\n# 编写测试 DEMO\n\nexamples/base/app.ts ，添加：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  responseType: 'json',\n  data: {\n    a: 3,\n    b: 4\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 运行后可以看到可以正常 log 输出这个 res 响应对象， 其中包含 AxiosRepsonse 类型定义的那些属性，不过发现两个问题：\n> \n>  * 第一个 headers 属性是一个字符串，需要解析为 JSON 对象；\n>  * 第一个请求中， res 响应对象中的 data 得到的数据是一个 JSON 字符串，需要转换为对象类型。",normalizedContent:"# 需求分析\n\n前面的实现中，发送的请求都可以从网络层面接收到服务器端返回的数据；但是代码层面并没有对响应数据进行任何的处理。\n\n需要支持对响应数据的处理，并且支持 promise 的链式调用的方式，如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 可以获取到 res 对象，并且 res 对象中包括服务器返回的数据 data ，http 响应状态码 status ， 响应头 headers 、请求配置对象 config 以及请求的 xmlhttprequest 对象实例 request 。\n\n\n# 定义接口类型 axiosreponse\n\n如下：\n\nexport interface axiosresponse {\n  data: any\n  status: number\n  statustext: string\n  headers: any\n  config: axiosrequestconfig\n  request: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n另外 axios 函数返回的是一个 promise 对象，可以定义一个 axiospromise 接口，继承于 promise<axiosresponse> 这个泛型接口：\n\nexport interface axiospromise extends promise<axiosresponse> {\n  \n}\n\n\n1\n2\n3\n\n\n> 此时，当 axios 返回的是 axiospromise 类型，那么 resolve 函数中的参数是一个 axiosresponse 类型。\n\n对于 ajax 请求的 response ，可以指定它的数据类型，通过设置 xmlhttprequest 对象的 responsetype 属性，可以给 axiosrequestconfig 类型添加一个可选属性：\n\nexport interface axiosrequestconfig {\n  // ...\n  responsetype?: xmlhttprequestresponsetype\n}\n\n\n1\n2\n3\n4\n\n\n> responsetype 的类型是一个 xmlhttprequestresponsetype 类型，它的定义是 \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\" 字符串字面量类型。\n\n\n# 实现获取相应数据的逻辑\n\n在 src/xhr.ts 中，添加 onreadystatechange 事件处理函数，并且让 xhr 函数返回的是 axiospromise 类型：\n\nimport { axiospromise, axiosrequestconfig, axiosresponse } from './types'\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise(resolve => {\n    const { data = null, url, method = 'get', headers, responsetype } = config\n\n    const request = new xmlhttprequest()\n\n    if (responsetype) {\n      request.responsetype = responsetype\n    }\n\n    request.open(method.touppercase(), url, true)\n\n    request.onreadystatechange = function handleload() {\n      if(request.readystate !== 4) {\n        return\n      }\n\n      const responseheaders = request.getallresponseheaders()\n      const responsedata = responsetype && responsetype !== 'text' ? request.response : request.responsetext\n      const response: axiosresponse = {\n        data: responsedata,\n        status: request.status,\n        statustext: request.statustext,\n        headers: responseheaders,\n        config,\n        request\n      }\n\n      resolve(response)\n    }\n\n    object.keys(headers).foreach(name => {\n      if (data === null && name.tolowercase() === 'content-type') {\n        delete headers[name]\n      } else {\n        request.setrequestheader(name, headers[name])\n      }\n    })\n\n    request.send(data)\n  })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n>  * 需要判断 如果 config 配置了 responsetype ，需要将它设置到 xhr 的 requset.responsetype ；\n>  * 在 onreadystatechange 事件函数中，构造了 axiosresponse 类型的 response 对象，并把它 resolve 出去。\n\n修改了 xhr 函数，同样要修改对应的 axios 函数：\n\nsrc/index.ts ：\n\nfunction axios(config: axiosrequestconfig): axiospromise {\n  processconfig(config)\n  return xhr(config)\n}\n\n\n1\n2\n3\n4\n\n\n> 至此实现了 axios 的 promise 化。\n\n\n# 编写测试 demo\n\nexamples/base/app.ts ，添加：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  responsetype: 'json',\n  data: {\n    a: 3,\n    b: 4\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 运行后可以看到可以正常 log 输出这个 res 响应对象， 其中包含 axiosrepsonse 类型定义的那些属性，不过发现两个问题：\n> \n>  * 第一个 headers 属性是一个字符串，需要解析为 json 对象；\n>  * 第一个请求中， res 响应对象中的 data 得到的数据是一个 json 字符串，需要转换为对象类型。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌒 实现处理响应 header 和 data",frontmatter:{title:"🌒 实现处理响应 header 和 data",date:"2022-06-11T16:07:27.000Z",permalink:"/pages/e463f4/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/02.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/07.%20%F0%9F%8C%92%20%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%20header%20%E5%92%8C%20data.html",relativePath:"801. 💽 TypeScript-Axios/02. 🌒 实现基础功能/07. 🌒 实现处理响应 header 和 data.md",key:"v-31c26ebc",path:"/pages/e463f4/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"parseHeaders 函数实现及应用",slug:"parseheaders-函数实现及应用",normalizedTitle:"parseheaders 函数实现及应用",charIndex:391},{level:2,title:"需求分析",slug:"需求分析-2",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"transformResponse 函数实现以及应用",slug:"transformresponse-函数实现以及应用",normalizedTitle:"transformresponse 函数实现以及应用",charIndex:1137}],headersStr:"需求分析 parseHeaders 函数实现及应用 需求分析 transformResponse 函数实现以及应用",content:'# 需求分析\n\n前一节，由于返回的 res 响应对象中的 header 是一个字符串，这是因为通过 XMLHttpRequest 对象中的 getAllResponseHeaders 方法获取到的值是如下的一段字符串：\n\nheaders: "connection: keep-alive\\r\\ncontent-length: 13\\r\\ncontent-type: application/json; charset=utf-8\\r\\ndate: Sat, 11 Jun 2022 08:02:53 GMT\\r\\netag: W/\\"d-talgBZSHcQOay+ud5zDrtp+2VNk\\"\\r\\nkeep-alive: timeout=5\\r\\nx-powered-by: Express\\r\\n"\n\n\n1\n\n\n最终希望能攻获取到上面这个字符串解析为一个对象结构。\n\n\n# parseHeaders 函数实现及应用\n\n在 src/helpers/headers.ts 中：\n\nexport function parseHeaders(headers: string): any {\n  let parsed = Object.create(null)\n  if (!headers) return parsed\n\n  headers.split(\'\\r\\n\').forEach(line => {\n    let [key, val] = line.split(\':\')\n    key = key.trim().toLowerCase()\n    if (!key) return\n    if (val) val = val.trim()\n    parsed[key] = val\n  })\n\n  return parsed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 使用字符串的方法，处理 headers 字符串。\n\n然后使用 src/xhr.ts 使用这个工具函数：\n\nconst responseHeaders = parseHeaders(request.getAllResponseHeaders())\n\n\n1\n\n\n> 此时，再运行上一节的 DEMO，可以看到返回的响应对象中的 headers 为一个对象了。\n\n\n# 需求分析\n\n在没有设置 responseType 的情况下，当字符串反应的数据是一个对象字符串吗，可以转换为一个 JSON 对象：\n\ndata: "{\\"a\\":1,\\"b\\":2}"\n\n\n1\n\n\n转换为：\n\ndata: {\n  a: 1,\n  b: 2\n}\n\n\n1\n2\n3\n4\n\n\n\n# transformResponse 函数实现以及应用\n\n在 helpers/data.ts 中：\n\nexport function transformResponse(data: any): any {\n  if(typeof data === \'string\') {\n    try {\n      data = JSON.parse(data)\n    } catch (e) {\n      // do nothing\n    }\n  }\n  \n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 src/index.ts 中：\n\nfunction axios(config: AxiosRequestConfig): AxiosPromise {\n  processConfig(config)\n  return xhr(config).then(res => {\n    return transformResponseData(res)\n  })\n}\n\n// ... \n\nfunction transformResponseData(res: AxiosResponse): AxiosResponse {\n  res.data = transformResponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 此处处理了响应的数据的类型。如果为字符串，则使用 JSON 转换为对象。',normalizedContent:'# 需求分析\n\n前一节，由于返回的 res 响应对象中的 header 是一个字符串，这是因为通过 xmlhttprequest 对象中的 getallresponseheaders 方法获取到的值是如下的一段字符串：\n\nheaders: "connection: keep-alive\\r\\ncontent-length: 13\\r\\ncontent-type: application/json; charset=utf-8\\r\\ndate: sat, 11 jun 2022 08:02:53 gmt\\r\\netag: w/\\"d-talgbzshcqoay+ud5zdrtp+2vnk\\"\\r\\nkeep-alive: timeout=5\\r\\nx-powered-by: express\\r\\n"\n\n\n1\n\n\n最终希望能攻获取到上面这个字符串解析为一个对象结构。\n\n\n# parseheaders 函数实现及应用\n\n在 src/helpers/headers.ts 中：\n\nexport function parseheaders(headers: string): any {\n  let parsed = object.create(null)\n  if (!headers) return parsed\n\n  headers.split(\'\\r\\n\').foreach(line => {\n    let [key, val] = line.split(\':\')\n    key = key.trim().tolowercase()\n    if (!key) return\n    if (val) val = val.trim()\n    parsed[key] = val\n  })\n\n  return parsed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 使用字符串的方法，处理 headers 字符串。\n\n然后使用 src/xhr.ts 使用这个工具函数：\n\nconst responseheaders = parseheaders(request.getallresponseheaders())\n\n\n1\n\n\n> 此时，再运行上一节的 demo，可以看到返回的响应对象中的 headers 为一个对象了。\n\n\n# 需求分析\n\n在没有设置 responsetype 的情况下，当字符串反应的数据是一个对象字符串吗，可以转换为一个 json 对象：\n\ndata: "{\\"a\\":1,\\"b\\":2}"\n\n\n1\n\n\n转换为：\n\ndata: {\n  a: 1,\n  b: 2\n}\n\n\n1\n2\n3\n4\n\n\n\n# transformresponse 函数实现以及应用\n\n在 helpers/data.ts 中：\n\nexport function transformresponse(data: any): any {\n  if(typeof data === \'string\') {\n    try {\n      data = json.parse(data)\n    } catch (e) {\n      // do nothing\n    }\n  }\n  \n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 src/index.ts 中：\n\nfunction axios(config: axiosrequestconfig): axiospromise {\n  processconfig(config)\n  return xhr(config).then(res => {\n    return transformresponsedata(res)\n  })\n}\n\n// ... \n\nfunction transformresponsedata(res: axiosresponse): axiosresponse {\n  res.data = transformresponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 此处处理了响应的数据的类型。如果为字符串，则使用 json 转换为对象。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌘 实现异常情况处理",frontmatter:{title:"🌘 实现异常情况处理",date:"2022-06-11T16:34:09.000Z",permalink:"/pages/3de0b0/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/10.%20%F0%9F%8C%98%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86.html",relativePath:"801. 💽 TypeScript-Axios/10. 🌘 实现异常情况处理.md",key:"v-271f65bc",path:"/pages/3de0b0/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"处理网络异常错误",slug:"处理网络异常错误",normalizedTitle:"处理网络异常错误",charIndex:305},{level:2,title:"处理请求超时错误",slug:"处理请求超时错误",normalizedTitle:"处理请求超时错误",charIndex:676},{level:2,title:"处理非 200 状态码",slug:"处理非-200-状态码",normalizedTitle:"处理非 200 状态码",charIndex:1402},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:2473},{level:2,title:"需求分析",slug:"需求分析-2",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"创建 AxiosError 类型接口",slug:"创建-axioserror-类型接口",normalizedTitle:"创建 axioserror 类型接口",charIndex:4477},{level:2,title:"应用方法 createError",slug:"应用方法-createerror",normalizedTitle:"应用方法 createerror",charIndex:6012},{level:2,title:"导出类型定义",slug:"导出类型定义",normalizedTitle:"导出类型定义",charIndex:6698}],headersStr:"需求分析 处理网络异常错误 处理请求超时错误 处理非 200 状态码 编写测试 DEMO 需求分析 创建 AxiosError 类型接口 应用方法 createError 导出类型定义",content:"# 需求分析\n\n前面实现了请求的基本需求功能。目前为止，都是处理了正常接收请求的逻辑，并没有考虑任何错误情况，所以对于这个程序的健壮性不够，因此需要对 AJAX 的各种情况作处理。\n\n程序能够捕获到这些错误，并且做进一步的处理：\n\naxios({\n  method: 'get',\n  url: 'error/get'\n}).then(res => {\n  console.log(res)\n}).catch(e => {\n  console.log(e)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果请求的过程中发生任何处理，都可以在 reject 回调函数中捕获到。\n\n将错误分为几类处理。\n\n\n# 处理网络异常错误\n\n当网络出现异常时，发送请求会触发 XMLHttpRequest 对象实例中的 error 事件时，所以可以在 onerror 中捕获：\n\n在 src/xhr.ts 中添加：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    // ...\n    \n    request.onerror = function handleError() {\n      reject(new Error('Network Error'))\n    }\n    \n    // ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 处理请求超时错误\n\n可以设置某个请求的超时时间 timeout ，也就是当请求发送后超过某个时间后仍然没有收到响应，则请求自动终止，并且触发 timeout 事件。\n\n请求默认的超时时间为 0，即永不超时；\n\n首先先在 AxiosRequestConfig 类型中添加可选配置字段 timeout ：\n\nexport interface AxiosRequestConfig {\n \ttimeout?: number\n}\n\n\n1\n2\n3\n\n\n然后在 src/xhr.ts 中添加：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const { data = null, url, method = 'get', headers, responseType, timeout } = config\n\n    // ... \n    \n    if (timeout) {\n      request.timeout = timeout\n    }\n\n    //... \n    \n    request.ontimeout = function handleTimeout() {\n      reject(new Error(`Timeout of ${timeout} ms exceeded`))\n    }\n    \n    // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 处理非 200 状态码\n\n对于一个正常的请求，往往会返回 200-300 之间的 HTTP 状态码，对于不在这个区间的状态码，也把它们认为是一种错误的情况做处理。\n\n在 src/xhr.ts 函数中添加 状态码的处理：\n\nrequest.onreadystatechange = function handleLoad() {\n  if(request.readyState !== 4) {\n    return\n  }\n\n  const responseHeaders = parseHeaders(request.getAllResponseHeaders())\n  const responseData = responseType && responseType !== 'text' ? request.response : request.responseText\n  const response: AxiosResponse = {\n    data: responseData,\n    status: request.status,\n    statusText: request.statusText,\n    headers: responseHeaders,\n    config,\n    request\n  }\n  \n  handleResponse(response)\n}\n\nfunction handleResponse(response: AxiosResponse) {\n  if(response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(new Error(`Request failed with status code ${response.status}`))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n>  * 在 onreadystatechange 的回调函数中，添加了对 request.status 的判断，因为当出现网络错误或者超时错误的时候，该值都为 0。\n> \n>  * 在 handleResponse 函数中对 request.status 的值再次判断，如果是 2xx 的状态码，则认为是一个正常的请求，否则抛错；\n\n\n# 编写测试 DEMO\n\n在 examples 目录下创建 error 目录：\n\nexample/error/index.html ：\n\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n  <meta charset='UTF-8'>\n  <title>base example</title>\n</head>\n<body>\n<script src='/__build__/base.js'><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nexamples/erorr/app.ts\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/get1'\n})\n  .then(res => {\n    console.log(res)\n  })\n  .catch(e => {\n    console.log(e)\n  })\n\naxios({\n  method: 'get',\n  url: '/error/get'\n})\n  .then(res => {\n    console.log(res)\n  })\n  .catch(e => {\n    console.log(e)\n  })\n\nsetTimeout(() => {\n  axios({\n    method: 'get',\n    url: '/error/get'\n  })\n    .then(res => {\n      console.log(res)\n    })\n    .catch(e => {\n      console.log(e)\n    })\n}, 5000)\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n})\n  .then(res => {\n    console.log(res)\n  })\n  .catch(e => {\n    console.log(e.message)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n在 examples/server.js 中添加 router ：\n\nrouter.get('/error/get', function(req,res) {\n  if(Math.random() > 0.5) {\n    res.json( {\n      msg: 'hello world'\n    })\n  } else {\n    res.status(500)\n    res.end()\n  }\n})\n\nrouter.get('/error/timeout', function(req, res) {\n  setTimeout(()=>{\n    res.json({\n      msg: 'hello world'\n    })\n  }, 3000)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 通过开发者工具的 network 部分我们可以看到不同的错误情况。\n> \n> 至此对各种错误都做了处理，并把它们抛给了程序应用方，让他们对错误可以做进一步的处理。\n> \n> 但是这里的错误都仅仅是简单的 Error 实例，只有错误文本信息，并不包含是哪个请求、请求的配置、响应对象等其它信息。需要对错误信息增强；\n\n\n# 需求分析\n\n抛出的错误不能只是一个简单的文本信息，应该包括请求的对象配置 config 、错误代码 code 、 XMLHttpRequest 对象实例 request 以及自定义对象 response 。如下：\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e: AxiosError) => {\n  console.log(e.message)\n  console.log(e.request)\n  console.log(e.code)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 这样对于应用方来说，他们就可以捕获到这些错误的详细信息，做进一步的处理。\n\n\n# 创建 AxiosError 类型接口\n\n在 src/type/index.ts 中添加 AxiosError 类型接口：\n\nexport interface AxiosError extends Error {\n  config: AxiosRequestConfig\n  code?: number\n  request?: any\n  response?: AxiosResponse\n  isAxiosError: Boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后创建 src/helpers/erorr.ts 文件，创建 AxiosError 类，继承于 Error ：\n\nimport { AxiosRequestConfig, AxiosResponse } from '../types'\n\nexport class AxiosError extends Error {\n  isAxiosError: boolean\n  config: AxiosRequestConfig\n  code?: string | null\n  request?: any\n  response?: AxiosResponse\n\n  constructor(\n    message: string,\n    config: AxiosRequestConfig,\n    code: string | null,\n    request: any,\n    response: AxiosResponse\n  ) {\n    super(message)\n\n    this.isAxiosError = true\n    this.config = config\n    this.code = code\n    this.request = request\n    this.response = response\n\n    Object.setPrototypeOf(this, AxiosError.prototype)\n  }\n}\n\nexport function createError(\n  message: string,\n  config: AxiosRequestConfig,\n  code?: string | null,\n  request?: any,\n  response?: AxiosResponse\n): AxiosError {\n  return new AxiosError(message, config, code, request, response)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n>  * 使用 Object.setPrototypeOf(this, AxiosError.prototype) 解决 TypeScript 继承内置对象时可能遇到的问题。TypeScript-wiki/Breaking-Changes.md at main · microsoft/TypeScript-wiki (github.com)\n>  * AxiosError 继承于 Error 类，添加了一些自己的属性： config 、 code 、 request 、 response 、 isAxiosError 等属性。\n>  * 为了方便使用，对外暴露一个 createError 方法创建 AxiosError 类的实例。\n\n\n# 应用方法 createError\n\n修改 scr/xhr.ts 中 xhr 函数中的处理错误逻辑：\n\nfunction handleResponse(response: AxiosResponse) {\n  if (response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(\n      createError(\n        `Request failed with status code ${response.status}`,\n        config,\n        null,\n        request,\n        response\n      )\n    )\n  }\n}\n\nrequest.onerror = function handleError() {\n  reject(createError('Network Error', config, null, request))\n}\n\nrequest.ontimeout = function handleTimeout() {\n  reject(createError(`Timeout of ${timeout} ms exceeded`, config, 'ECONNABORTED', request))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 导出类型定义\n\n由于在 DEMO 中， TypeScript 不能把 e 参数推断为 AxiosError 类型，需要手动知名类型，为了让外部应用能引入 AxiosError 类型，需要将它们导出。\n\n创建 axios.ts 文件，把之前 index.ts 的代码拷贝过去，作为 aixos 的主要逻辑；修改 index.ts 为导出文件：\n\nsrc/index.ts ：\n\nimport axios from './axios'\n\nexport * from './types'\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n\n\n这样在 DEMO 中就可以引用 AxiosError 类型了。\n\n如下， examples/error/app.ts ：\n\nimport axios, { AxiosError } from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/get1'\n}).then(res => {\n  console.log(res)\n}).catch((e: AxiosError) => {\n  console.log(e)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# 需求分析\n\n前面实现了请求的基本需求功能。目前为止，都是处理了正常接收请求的逻辑，并没有考虑任何错误情况，所以对于这个程序的健壮性不够，因此需要对 ajax 的各种情况作处理。\n\n程序能够捕获到这些错误，并且做进一步的处理：\n\naxios({\n  method: 'get',\n  url: 'error/get'\n}).then(res => {\n  console.log(res)\n}).catch(e => {\n  console.log(e)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果请求的过程中发生任何处理，都可以在 reject 回调函数中捕获到。\n\n将错误分为几类处理。\n\n\n# 处理网络异常错误\n\n当网络出现异常时，发送请求会触发 xmlhttprequest 对象实例中的 error 事件时，所以可以在 onerror 中捕获：\n\n在 src/xhr.ts 中添加：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    // ...\n    \n    request.onerror = function handleerror() {\n      reject(new error('network error'))\n    }\n    \n    // ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 处理请求超时错误\n\n可以设置某个请求的超时时间 timeout ，也就是当请求发送后超过某个时间后仍然没有收到响应，则请求自动终止，并且触发 timeout 事件。\n\n请求默认的超时时间为 0，即永不超时；\n\n首先先在 axiosrequestconfig 类型中添加可选配置字段 timeout ：\n\nexport interface axiosrequestconfig {\n \ttimeout?: number\n}\n\n\n1\n2\n3\n\n\n然后在 src/xhr.ts 中添加：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const { data = null, url, method = 'get', headers, responsetype, timeout } = config\n\n    // ... \n    \n    if (timeout) {\n      request.timeout = timeout\n    }\n\n    //... \n    \n    request.ontimeout = function handletimeout() {\n      reject(new error(`timeout of ${timeout} ms exceeded`))\n    }\n    \n    // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 处理非 200 状态码\n\n对于一个正常的请求，往往会返回 200-300 之间的 http 状态码，对于不在这个区间的状态码，也把它们认为是一种错误的情况做处理。\n\n在 src/xhr.ts 函数中添加 状态码的处理：\n\nrequest.onreadystatechange = function handleload() {\n  if(request.readystate !== 4) {\n    return\n  }\n\n  const responseheaders = parseheaders(request.getallresponseheaders())\n  const responsedata = responsetype && responsetype !== 'text' ? request.response : request.responsetext\n  const response: axiosresponse = {\n    data: responsedata,\n    status: request.status,\n    statustext: request.statustext,\n    headers: responseheaders,\n    config,\n    request\n  }\n  \n  handleresponse(response)\n}\n\nfunction handleresponse(response: axiosresponse) {\n  if(response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(new error(`request failed with status code ${response.status}`))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n>  * 在 onreadystatechange 的回调函数中，添加了对 request.status 的判断，因为当出现网络错误或者超时错误的时候，该值都为 0。\n> \n>  * 在 handleresponse 函数中对 request.status 的值再次判断，如果是 2xx 的状态码，则认为是一个正常的请求，否则抛错；\n\n\n# 编写测试 demo\n\n在 examples 目录下创建 error 目录：\n\nexample/error/index.html ：\n\n<!doctype html>\n<html lang='en'>\n<head>\n  <meta charset='utf-8'>\n  <title>base example</title>\n</head>\n<body>\n<script src='/__build__/base.js'><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nexamples/erorr/app.ts\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/get1'\n})\n  .then(res => {\n    console.log(res)\n  })\n  .catch(e => {\n    console.log(e)\n  })\n\naxios({\n  method: 'get',\n  url: '/error/get'\n})\n  .then(res => {\n    console.log(res)\n  })\n  .catch(e => {\n    console.log(e)\n  })\n\nsettimeout(() => {\n  axios({\n    method: 'get',\n    url: '/error/get'\n  })\n    .then(res => {\n      console.log(res)\n    })\n    .catch(e => {\n      console.log(e)\n    })\n}, 5000)\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n})\n  .then(res => {\n    console.log(res)\n  })\n  .catch(e => {\n    console.log(e.message)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n在 examples/server.js 中添加 router ：\n\nrouter.get('/error/get', function(req,res) {\n  if(math.random() > 0.5) {\n    res.json( {\n      msg: 'hello world'\n    })\n  } else {\n    res.status(500)\n    res.end()\n  }\n})\n\nrouter.get('/error/timeout', function(req, res) {\n  settimeout(()=>{\n    res.json({\n      msg: 'hello world'\n    })\n  }, 3000)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 通过开发者工具的 network 部分我们可以看到不同的错误情况。\n> \n> 至此对各种错误都做了处理，并把它们抛给了程序应用方，让他们对错误可以做进一步的处理。\n> \n> 但是这里的错误都仅仅是简单的 error 实例，只有错误文本信息，并不包含是哪个请求、请求的配置、响应对象等其它信息。需要对错误信息增强；\n\n\n# 需求分析\n\n抛出的错误不能只是一个简单的文本信息，应该包括请求的对象配置 config 、错误代码 code 、 xmlhttprequest 对象实例 request 以及自定义对象 response 。如下：\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e: axioserror) => {\n  console.log(e.message)\n  console.log(e.request)\n  console.log(e.code)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 这样对于应用方来说，他们就可以捕获到这些错误的详细信息，做进一步的处理。\n\n\n# 创建 axioserror 类型接口\n\n在 src/type/index.ts 中添加 axioserror 类型接口：\n\nexport interface axioserror extends error {\n  config: axiosrequestconfig\n  code?: number\n  request?: any\n  response?: axiosresponse\n  isaxioserror: boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后创建 src/helpers/erorr.ts 文件，创建 axioserror 类，继承于 error ：\n\nimport { axiosrequestconfig, axiosresponse } from '../types'\n\nexport class axioserror extends error {\n  isaxioserror: boolean\n  config: axiosrequestconfig\n  code?: string | null\n  request?: any\n  response?: axiosresponse\n\n  constructor(\n    message: string,\n    config: axiosrequestconfig,\n    code: string | null,\n    request: any,\n    response: axiosresponse\n  ) {\n    super(message)\n\n    this.isaxioserror = true\n    this.config = config\n    this.code = code\n    this.request = request\n    this.response = response\n\n    object.setprototypeof(this, axioserror.prototype)\n  }\n}\n\nexport function createerror(\n  message: string,\n  config: axiosrequestconfig,\n  code?: string | null,\n  request?: any,\n  response?: axiosresponse\n): axioserror {\n  return new axioserror(message, config, code, request, response)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n>  * 使用 object.setprototypeof(this, axioserror.prototype) 解决 typescript 继承内置对象时可能遇到的问题。typescript-wiki/breaking-changes.md at main · microsoft/typescript-wiki (github.com)\n>  * axioserror 继承于 error 类，添加了一些自己的属性： config 、 code 、 request 、 response 、 isaxioserror 等属性。\n>  * 为了方便使用，对外暴露一个 createerror 方法创建 axioserror 类的实例。\n\n\n# 应用方法 createerror\n\n修改 scr/xhr.ts 中 xhr 函数中的处理错误逻辑：\n\nfunction handleresponse(response: axiosresponse) {\n  if (response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(\n      createerror(\n        `request failed with status code ${response.status}`,\n        config,\n        null,\n        request,\n        response\n      )\n    )\n  }\n}\n\nrequest.onerror = function handleerror() {\n  reject(createerror('network error', config, null, request))\n}\n\nrequest.ontimeout = function handletimeout() {\n  reject(createerror(`timeout of ${timeout} ms exceeded`, config, 'econnaborted', request))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 导出类型定义\n\n由于在 demo 中， typescript 不能把 e 参数推断为 axioserror 类型，需要手动知名类型，为了让外部应用能引入 axioserror 类型，需要将它们导出。\n\n创建 axios.ts 文件，把之前 index.ts 的代码拷贝过去，作为 aixos 的主要逻辑；修改 index.ts 为导出文件：\n\nsrc/index.ts ：\n\nimport axios from './axios'\n\nexport * from './types'\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n\n\n这样在 demo 中就可以引用 axioserror 类型了。\n\n如下， examples/error/app.ts ：\n\nimport axios, { axioserror } from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/get1'\n}).then(res => {\n  console.log(res)\n}).catch((e: axioserror) => {\n  console.log(e)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌘 实现接口拓展",frontmatter:{title:"🌘 实现接口拓展",date:"2022-06-11T17:40:14.000Z",permalink:"/pages/8fff17/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/20.%20%F0%9F%8C%98%20%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%8B%93%E5%B1%95.html",relativePath:"801. 💽 TypeScript-Axios/20. 🌘 实现接口拓展.md",key:"v-0fcc2923",path:"/pages/8fff17/",headers:[{level:2,title:"实现接口拓展",slug:"实现接口拓展",normalizedTitle:"实现接口拓展",charIndex:2},{level:3,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:13},{level:3,title:"接口类型定义",slug:"接口类型定义",normalizedTitle:"接口类型定义",charIndex:428},{level:3,title:"创建 Axios 类",slug:"创建-axios-类",normalizedTitle:"创建 axios 类",charIndex:1423},{level:3,title:"混合对象实现",slug:"混合对象实现",normalizedTitle:"混合对象实现",charIndex:4902},{level:3,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:6146},{level:2,title:"实现 axios 函数重载",slug:"实现-axios-函数重载",normalizedTitle:"实现 axios 函数重载",charIndex:6968},{level:3,title:"需求分析",slug:"需求分析-2",normalizedTitle:"需求分析",charIndex:13},{level:3,title:"实现重载",slug:"实现重载",normalizedTitle:"实现重载",charIndex:7348},{level:3,title:"编写测试 DEMO",slug:"编写测试-demo-2",normalizedTitle:"编写测试 demo",charIndex:6146},{level:2,title:"实现响应数据支持泛型",slug:"实现响应数据支持泛型",normalizedTitle:"实现响应数据支持泛型",charIndex:8489},{level:3,title:"需求分析",slug:"需求分析-3",normalizedTitle:"需求分析",charIndex:13},{level:3,title:"接口添加泛型参数",slug:"接口添加泛型参数",normalizedTitle:"接口添加泛型参数",charIndex:9401},{level:3,title:"编写测试 DEMO",slug:"编写测试-demo-3",normalizedTitle:"编写测试 demo",charIndex:6146}],headersStr:"实现接口拓展 需求分析 接口类型定义 创建 Axios 类 混合对象实现 编写测试 DEMO 实现 axios 函数重载 需求分析 实现重载 编写测试 DEMO 实现响应数据支持泛型 需求分析 接口添加泛型参数 编写测试 DEMO",content:"# 实现接口拓展\n\n\n# 需求分析\n\n为了用户更加方便地使用 axios 发送请求，可以为所有支持请求方法扩展一些接口：\n\n * axios.request(config)\n * axios.get(url[, config])\n * axios.delete(url[, config])\n * axios.head(url[, config])\n * axios.options(url[, config])\n * axios.post(url[, data[, config]])\n * axios.put(url[, data[, config]])\n * axios.patch(url[, data[, config]])\n\n如果使用这些方法，就不必在 config 中指定 url 、 method 、 data 这些属性了。\n\n从需求上来看， axios 不再单单是一个方法，更像是一个混合对象，本身是一个方法，又有很多方法属性。\n\n\n# 接口类型定义\n\n根据需求分析，混合对象 axios 本身是一个函数，我们再实现一个包括它属性方法的类，然后把这个类的原型属性和自身属性再拷贝到 axios 上。\n\n先给 axios 混合对象定义接口类型：\n\ntypes/index.ts ：\n\nexport interface Axios {\n  request(config: AxiosRequestConfig): AxiosPromise\n\n  get(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  delete(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  head(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  options(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  post(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise\n\n  put(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise\n}\n\nexport interface AxiosInstance extends Axios {\n  (config: AxiosRequestConfig): AxiosPromise\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 首先定义一个 Axios 类型接口，它描述了 Axios 类中的公共方法，接着定义了 AxiosInstance 接口继承 Axios ，它就是一个混合类型的接口。\n> \n> 另外 AxiosRequestConfig 类型接口中的 url 属性变成了可选属性。\n> \n> export interface AxiosRequestConfig {\n>   url?: string\n>   // ... \n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n\n# 创建 Axios 类\n\n创建一个 Axios 类，来实现接口定义的公共方法。创建了一个 core 目录，用来存放发送请求核心流程的代码。创建 Axios.ts 文件：\n\nsrc/core/Axios.ts ：\n\nimport { AxiosPromise, AxiosRequestConfig, Method } from '../types'\nimport dispatchRequest from './dispatchRequest'\n\nexport default class Axios {\n  request(config: AxiosRequestConfig): AxiosPromise {\n    return dispatchRequest(config)\n  }\n\n  get(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('get', url, config)\n  }\n\n  delete(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('delete', url, config)\n  }\n\n  head(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('head', url, config)\n  }\n\n  options(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('options', url, config)\n  }\n\n  post(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithData('post', url, data, config)\n  }\n\n  put(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithData('put', url, data, config)\n  }\n\n  patch(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithData('patch', url, data, config)\n  }\n\n  _requestMethodWithoutData(method: Method, url: string, config?: AxiosRequestConfig) {\n    return this.request(\n      Object.assign(config || {}, {\n        method,\n        url\n      })\n    )\n  }\n\n  _requestMethodWithData(method: Method, url: string, data?: any, config?: AxiosRequestConfig) {\n    return this.request(\n      Object.assign(config || {}, {\n        method,\n        url,\n        data\n      })\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n> 其中 request 方法的功能和我们之前的 axios 函数功能是一致。 axios 函数的功能就是发送请求。\n\n基于模块化编程的思想，我们把这部分功能抽出一个单独的模块，在 core 目录下创建 dispatchRequest 方法，把之前 axios.ts 的相关代码拷贝过去。\n\ncore/dispatchRequest.ts ：\n\nimport { AxiosPromise, AxiosRequestConfig, AxiosResponse } from '../types'\nimport { buildURL } from '../helpers/url'\nimport { transformRequest, transformResponse } from '../helpers/data'\nimport { processHeaders } from '../helpers/headers'\nimport xhr from './xhr'\n\nexport default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {\n  processConfig(config)\n  return xhr(config).then(res => {\n    return transformResponseData(res)\n  })\n}\n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.headers = transformRequestHeader(config)\n  config.data = transformRequestData(config)\n}\n\nfunction transformURL(config: AxiosRequestConfig): any {\n  const { url, params } = config\n  return buildURL(url, params)\n}\n\nfunction transformRequestData(config: AxiosRequestConfig): any {\n  return transformRequest(config.data)\n}\n\nfunction transformRequestHeader(config: AxiosRequestConfig): any {\n  const { headers = {}, data } = config\n  return processHeaders(headers, data)\n}\n\nfunction transformResponseData(res: AxiosResponse): AxiosResponse {\n  res.data = transformResponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n回到 Axios.ts 文件，对于 get 、 delete 、 head 、 options 、 post 、 patch 、 put 这些方法，都是对外提供的语法糖，内部都是通过调用 request 方法实现发送请求，只不过在调用之前对 config 做了一层合并处理。\n\n\n# 混合对象实现\n\n要实现混合对象，首先这个对象是一个函数，其次这个对象要包括 Axios 类的所有原型属性和实例属性，我们首先来实现一个辅助函数 extend 。\n\n在 src/helpers/util.ts ：\n\nexport function extend<T, U>(to: T, from: U): T & U {\n  for (const key in from) {\n    ;(to as T & U)[key] = from[key] as any\n  }\n\n  return to as T & U\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> extend 方法的实现使用了 交叉类型，并且用到了 类型断言。最终目的是把 from 里面的 属性拓展到 to 中，包括原型上的属性；\n\n接下来对 axios.ts 文件修改，用工厂模式创建一个 axios 混合对象：\n\nsrc/axios.ts ：\n\nimport { AxiosInstance } from './types'\nimport Axios from './core/Axios'\nimport { extend } from './helpers/util'\n\nfunction createInstance(): AxiosInstance {\n  const context = new Axios()\n  const instance = Axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as AxiosInstance\n}\n\nconst axios = createInstance()\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 在 createInstance 工厂函数的内部，首先实例化了 Axios 实例 context ，接着创建 instance 指向 Axios.prototype.request 方法，并绑定了上下文 context ；接着通过 extend 方法把 context 中的原型方法和实例方法全部拷贝到 instance 上，这样就实现了一个混合对象： instance 本身是一个函数，又拥有了 Axios 类的所有原型和实例属性，最终返回这个 instance 。\n> \n> 由于 TypeScript 不能正确推断 instance 的类型，所以需要断言成 AxiosInstance 类型。\n> \n> 这样就可以通过 createInstance 工厂函数创建 axios ，直接调用 axios 方法相当于 执行了 Axios 类的 request 方法发送请求，同样可以调用 axios.get 、 axios.post 等方法；\n\n\n# 编写测试 DEMO\n\n创建 DEMO 文件：\n\nexamples/extend/index.html ：\n\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n  <meta charset='UTF-8'>\n  <title>base example</title>\n</head>\n<body>\n<script src='/__build__/base.js'><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nexamples/extend/app.ts ：\n\nimport axios from '../../src'\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios.request({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\n\naxios.get('/extend/get')\n\naxios.options('/extend/options')\n\naxios.delete('/extend/delete')\n\naxios.head('/extend/head')\n\naxios.post('/extend/post', { msg: 'post' })\n\naxios.put('/extend/put', { msg: 'put' })\n\naxios.patch('/extend/put', { msg: 'patch' })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 实现 axios 函数重载\n\n\n# 需求分析\n\n目前的 axios 只支持传入一个参数，即 config ：\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果要实现同时支持传入两个参数，第一个参数为 url 第二个参数为 config ，如：\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n有点类似 axios.get 的参数类型，不同的是如果需要指定 HTTP 方法，仍然需要在 config 的 method 中指定。\n\n需要用到 函数的重载 的知识。\n\n\n# 实现重载\n\n修改 AxiosInstnace 的定义：\n\nsrc/types/index.ts ：\n\nexport interface AxiosInstance extends Axios {\n  (config: AxiosRequestConfig): AxiosPromise\n\n  (url: string, config?: AxiosRequestConfig): AxiosPromise\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 增加一种函数的定义，支持两个参数，其中 url 是是必选参数， config 是可选参数。\n\n由于 axios 函数实际上指向的是 request 函数，所以修改 request 函数。\n\nsrc/core/Axios.ts ：\n\nrequest(url: any, config?: any): AxiosPromise {\n    if(typeof url === 'string') {\n      if(!config) {\n        config = {}\n      }\n      config.url = url\n    } else {\n      config = url\n    }\n    return dispatchRequest(config)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 把 request 函数的参数改成 2 个， url 和 config 都是 any 类型， config 还是可选参数。\n> \n> 接着在函数体中判断 url 是否为字符串类型，如果为字符串类型，则继续对 config 判断，如果判断 config 为空则构造空对象，将 url 添加到 config.url 。如果 url 不为字符串类型，则说明传入的就是单个参数（ config ），且 url 就是 config ，因此把 url 赋值给 config 。\n> \n> 注意，虽然修改了 request 的实现，支持两个参数，但是对外提供的 request 接口仍然保持不变，可以理解为这仅仅是 内部的实现的修改，与外部接口不必一致，只要保留兼容接口即可。\n\n\n# 编写测试 DEMO\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 实现响应数据支持泛型\n\n\n# 需求分析\n\n通常情况，会将后端返回的数据格式单独放入一个接口中：\n\n// 请求接口数据\nexport interface ResponseData<T = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number\n\n  /**\n   * 数据\n   * @type { T }\n   */\n  result: T\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以将 API 抽离成单独的模块，例如获取用户的信息：\n\nimport { ResponseData } from './interface.ts';\n\nexport function getUser<T>() {\n  return axios.get<ResponseData<T>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着写入返回的数据类型 User ，可以让 TypeScript 顺利推断出想要的类型：\n\ninterface User {\n  name: string\n  age: number\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getUser<User>()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 一般用于 Vue Store 中异步执行请求数据。\n\n\n# 接口添加泛型参数\n\n根据需求分析，需要给相关的接口定义添加泛型参数。\n\n修改 type/index.ts 中 data 的类型：\n\nexport interface AxiosResponse<T = any> {\n  data: T\n  status: number\n  statusText: string\n  headers: any\n  config: AxiosRequestConfig\n  request: any\n}\n\nexport interface AxiosPromise<T = any> extends Promise<AxiosResponse<T>> {\n}\n\nexport interface Axios {\n  request<T = any>(config: AxiosRequestConfig): AxiosPromise<T>\n\n  get<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  delete<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  head<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  options<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise<T>\n}\n\nexport interface AxiosInstance extends Axios {\n  <T = any>(config: AxiosRequestConfig): AxiosPromise<T>\n\n  <T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n> 首先给 AxiosResponse 接口添加泛型参数 T ， T = any 表示泛型的参数默认值为 any 。\n> \n> 然后为 AxiosPromise 、 Axios 、 AxiosInstance 接口添加泛型参数。可以看到这些请求的返回类型都变成了 AxiosPromise<T> ，也就是 Promise<AxiosResponse<T>> 。这样就可以从响应中获取到类型 T 了。\n\n\n# 编写测试 DEMO\n\nexamples/extend/app.ts ：\n\ninterface ResponseData<T = any> {\n  code: number\n  result: T\n  message: string\n}\n\ninterface User {\n  name: string\n  age: number\n}\n\nfunction getUser<T>() {\n  return axios<ResponseData<T>>('/extend/user')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\nasync function test() {\n  const user = await getUser<User>()\n  if (user) {\n    console.log(user.result)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 当调用 getUser<User> 时，相当于调用了 axios<ResponseData<User>> ，也就是传入给 axios 函数的类型 T 为 ResponseData<User> ；相当于返回值 AxiosPromise<T> 中的 T ，实际上也是 Promise<AxiosResponse<T>> 中的 T 的类型是 ResponseData<User> 。所以相应数据中的 data 类型就是 ResponseData<User> ，如下：\n> \n> {\n>   code: number\n>   result: User\n>   message: string\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 这个也是 const user = await getUser<User>() 的返回值 user 的数据类型，所以 TypeScript 能正确推断出 user 的类型。",normalizedContent:"# 实现接口拓展\n\n\n# 需求分析\n\n为了用户更加方便地使用 axios 发送请求，可以为所有支持请求方法扩展一些接口：\n\n * axios.request(config)\n * axios.get(url[, config])\n * axios.delete(url[, config])\n * axios.head(url[, config])\n * axios.options(url[, config])\n * axios.post(url[, data[, config]])\n * axios.put(url[, data[, config]])\n * axios.patch(url[, data[, config]])\n\n如果使用这些方法，就不必在 config 中指定 url 、 method 、 data 这些属性了。\n\n从需求上来看， axios 不再单单是一个方法，更像是一个混合对象，本身是一个方法，又有很多方法属性。\n\n\n# 接口类型定义\n\n根据需求分析，混合对象 axios 本身是一个函数，我们再实现一个包括它属性方法的类，然后把这个类的原型属性和自身属性再拷贝到 axios 上。\n\n先给 axios 混合对象定义接口类型：\n\ntypes/index.ts ：\n\nexport interface axios {\n  request(config: axiosrequestconfig): axiospromise\n\n  get(url: string, config?: axiosrequestconfig): axiospromise\n\n  delete(url: string, config?: axiosrequestconfig): axiospromise\n\n  head(url: string, config?: axiosrequestconfig): axiospromise\n\n  options(url: string, config?: axiosrequestconfig): axiospromise\n\n  post(url: string, data?: any, config?: axiosrequestconfig): axiospromise\n\n  put(url: string, data?: any, config?: axiosrequestconfig): axiospromise\n}\n\nexport interface axiosinstance extends axios {\n  (config: axiosrequestconfig): axiospromise\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 首先定义一个 axios 类型接口，它描述了 axios 类中的公共方法，接着定义了 axiosinstance 接口继承 axios ，它就是一个混合类型的接口。\n> \n> 另外 axiosrequestconfig 类型接口中的 url 属性变成了可选属性。\n> \n> export interface axiosrequestconfig {\n>   url?: string\n>   // ... \n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n\n# 创建 axios 类\n\n创建一个 axios 类，来实现接口定义的公共方法。创建了一个 core 目录，用来存放发送请求核心流程的代码。创建 axios.ts 文件：\n\nsrc/core/axios.ts ：\n\nimport { axiospromise, axiosrequestconfig, method } from '../types'\nimport dispatchrequest from './dispatchrequest'\n\nexport default class axios {\n  request(config: axiosrequestconfig): axiospromise {\n    return dispatchrequest(config)\n  }\n\n  get(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('get', url, config)\n  }\n\n  delete(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('delete', url, config)\n  }\n\n  head(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('head', url, config)\n  }\n\n  options(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('options', url, config)\n  }\n\n  post(url: string, data?: any, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithdata('post', url, data, config)\n  }\n\n  put(url: string, data?: any, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithdata('put', url, data, config)\n  }\n\n  patch(url: string, data?: any, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithdata('patch', url, data, config)\n  }\n\n  _requestmethodwithoutdata(method: method, url: string, config?: axiosrequestconfig) {\n    return this.request(\n      object.assign(config || {}, {\n        method,\n        url\n      })\n    )\n  }\n\n  _requestmethodwithdata(method: method, url: string, data?: any, config?: axiosrequestconfig) {\n    return this.request(\n      object.assign(config || {}, {\n        method,\n        url,\n        data\n      })\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n> 其中 request 方法的功能和我们之前的 axios 函数功能是一致。 axios 函数的功能就是发送请求。\n\n基于模块化编程的思想，我们把这部分功能抽出一个单独的模块，在 core 目录下创建 dispatchrequest 方法，把之前 axios.ts 的相关代码拷贝过去。\n\ncore/dispatchrequest.ts ：\n\nimport { axiospromise, axiosrequestconfig, axiosresponse } from '../types'\nimport { buildurl } from '../helpers/url'\nimport { transformrequest, transformresponse } from '../helpers/data'\nimport { processheaders } from '../helpers/headers'\nimport xhr from './xhr'\n\nexport default function dispatchrequest(config: axiosrequestconfig): axiospromise {\n  processconfig(config)\n  return xhr(config).then(res => {\n    return transformresponsedata(res)\n  })\n}\n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.headers = transformrequestheader(config)\n  config.data = transformrequestdata(config)\n}\n\nfunction transformurl(config: axiosrequestconfig): any {\n  const { url, params } = config\n  return buildurl(url, params)\n}\n\nfunction transformrequestdata(config: axiosrequestconfig): any {\n  return transformrequest(config.data)\n}\n\nfunction transformrequestheader(config: axiosrequestconfig): any {\n  const { headers = {}, data } = config\n  return processheaders(headers, data)\n}\n\nfunction transformresponsedata(res: axiosresponse): axiosresponse {\n  res.data = transformresponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n回到 axios.ts 文件，对于 get 、 delete 、 head 、 options 、 post 、 patch 、 put 这些方法，都是对外提供的语法糖，内部都是通过调用 request 方法实现发送请求，只不过在调用之前对 config 做了一层合并处理。\n\n\n# 混合对象实现\n\n要实现混合对象，首先这个对象是一个函数，其次这个对象要包括 axios 类的所有原型属性和实例属性，我们首先来实现一个辅助函数 extend 。\n\n在 src/helpers/util.ts ：\n\nexport function extend<t, u>(to: t, from: u): t & u {\n  for (const key in from) {\n    ;(to as t & u)[key] = from[key] as any\n  }\n\n  return to as t & u\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> extend 方法的实现使用了 交叉类型，并且用到了 类型断言。最终目的是把 from 里面的 属性拓展到 to 中，包括原型上的属性；\n\n接下来对 axios.ts 文件修改，用工厂模式创建一个 axios 混合对象：\n\nsrc/axios.ts ：\n\nimport { axiosinstance } from './types'\nimport axios from './core/axios'\nimport { extend } from './helpers/util'\n\nfunction createinstance(): axiosinstance {\n  const context = new axios()\n  const instance = axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as axiosinstance\n}\n\nconst axios = createinstance()\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 在 createinstance 工厂函数的内部，首先实例化了 axios 实例 context ，接着创建 instance 指向 axios.prototype.request 方法，并绑定了上下文 context ；接着通过 extend 方法把 context 中的原型方法和实例方法全部拷贝到 instance 上，这样就实现了一个混合对象： instance 本身是一个函数，又拥有了 axios 类的所有原型和实例属性，最终返回这个 instance 。\n> \n> 由于 typescript 不能正确推断 instance 的类型，所以需要断言成 axiosinstance 类型。\n> \n> 这样就可以通过 createinstance 工厂函数创建 axios ，直接调用 axios 方法相当于 执行了 axios 类的 request 方法发送请求，同样可以调用 axios.get 、 axios.post 等方法；\n\n\n# 编写测试 demo\n\n创建 demo 文件：\n\nexamples/extend/index.html ：\n\n<!doctype html>\n<html lang='en'>\n<head>\n  <meta charset='utf-8'>\n  <title>base example</title>\n</head>\n<body>\n<script src='/__build__/base.js'><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nexamples/extend/app.ts ：\n\nimport axios from '../../src'\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios.request({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\n\naxios.get('/extend/get')\n\naxios.options('/extend/options')\n\naxios.delete('/extend/delete')\n\naxios.head('/extend/head')\n\naxios.post('/extend/post', { msg: 'post' })\n\naxios.put('/extend/put', { msg: 'put' })\n\naxios.patch('/extend/put', { msg: 'patch' })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 实现 axios 函数重载\n\n\n# 需求分析\n\n目前的 axios 只支持传入一个参数，即 config ：\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果要实现同时支持传入两个参数，第一个参数为 url 第二个参数为 config ，如：\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n有点类似 axios.get 的参数类型，不同的是如果需要指定 http 方法，仍然需要在 config 的 method 中指定。\n\n需要用到 函数的重载 的知识。\n\n\n# 实现重载\n\n修改 axiosinstnace 的定义：\n\nsrc/types/index.ts ：\n\nexport interface axiosinstance extends axios {\n  (config: axiosrequestconfig): axiospromise\n\n  (url: string, config?: axiosrequestconfig): axiospromise\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 增加一种函数的定义，支持两个参数，其中 url 是是必选参数， config 是可选参数。\n\n由于 axios 函数实际上指向的是 request 函数，所以修改 request 函数。\n\nsrc/core/axios.ts ：\n\nrequest(url: any, config?: any): axiospromise {\n    if(typeof url === 'string') {\n      if(!config) {\n        config = {}\n      }\n      config.url = url\n    } else {\n      config = url\n    }\n    return dispatchrequest(config)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 把 request 函数的参数改成 2 个， url 和 config 都是 any 类型， config 还是可选参数。\n> \n> 接着在函数体中判断 url 是否为字符串类型，如果为字符串类型，则继续对 config 判断，如果判断 config 为空则构造空对象，将 url 添加到 config.url 。如果 url 不为字符串类型，则说明传入的就是单个参数（ config ），且 url 就是 config ，因此把 url 赋值给 config 。\n> \n> 注意，虽然修改了 request 的实现，支持两个参数，但是对外提供的 request 接口仍然保持不变，可以理解为这仅仅是 内部的实现的修改，与外部接口不必一致，只要保留兼容接口即可。\n\n\n# 编写测试 demo\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 实现响应数据支持泛型\n\n\n# 需求分析\n\n通常情况，会将后端返回的数据格式单独放入一个接口中：\n\n// 请求接口数据\nexport interface responsedata<t = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number\n\n  /**\n   * 数据\n   * @type { t }\n   */\n  result: t\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以将 api 抽离成单独的模块，例如获取用户的信息：\n\nimport { responsedata } from './interface.ts';\n\nexport function getuser<t>() {\n  return axios.get<responsedata<t>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着写入返回的数据类型 user ，可以让 typescript 顺利推断出想要的类型：\n\ninterface user {\n  name: string\n  age: number\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getuser<user>()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 一般用于 vue store 中异步执行请求数据。\n\n\n# 接口添加泛型参数\n\n根据需求分析，需要给相关的接口定义添加泛型参数。\n\n修改 type/index.ts 中 data 的类型：\n\nexport interface axiosresponse<t = any> {\n  data: t\n  status: number\n  statustext: string\n  headers: any\n  config: axiosrequestconfig\n  request: any\n}\n\nexport interface axiospromise<t = any> extends promise<axiosresponse<t>> {\n}\n\nexport interface axios {\n  request<t = any>(config: axiosrequestconfig): axiospromise<t>\n\n  get<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  delete<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  head<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  options<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  post<t = any>(url: string, data?: any, config?: axiosrequestconfig): axiospromise<t>\n\n  put<t = any>(url: string, data?: any, config?: axiosrequestconfig): axiospromise<t>\n\n  patch<t = any>(url: string, data?: any, config?: axiosrequestconfig): axiospromise<t>\n}\n\nexport interface axiosinstance extends axios {\n  <t = any>(config: axiosrequestconfig): axiospromise<t>\n\n  <t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n> 首先给 axiosresponse 接口添加泛型参数 t ， t = any 表示泛型的参数默认值为 any 。\n> \n> 然后为 axiospromise 、 axios 、 axiosinstance 接口添加泛型参数。可以看到这些请求的返回类型都变成了 axiospromise<t> ，也就是 promise<axiosresponse<t>> 。这样就可以从响应中获取到类型 t 了。\n\n\n# 编写测试 demo\n\nexamples/extend/app.ts ：\n\ninterface responsedata<t = any> {\n  code: number\n  result: t\n  message: string\n}\n\ninterface user {\n  name: string\n  age: number\n}\n\nfunction getuser<t>() {\n  return axios<responsedata<t>>('/extend/user')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\nasync function test() {\n  const user = await getuser<user>()\n  if (user) {\n    console.log(user.result)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 当调用 getuser<user> 时，相当于调用了 axios<responsedata<user>> ，也就是传入给 axios 函数的类型 t 为 responsedata<user> ；相当于返回值 axiospromise<t> 中的 t ，实际上也是 promise<axiosresponse<t>> 中的 t 的类型是 responsedata<user> 。所以相应数据中的 data 类型就是 responsedata<user> ，如下：\n> \n> {\n>   code: number\n>   result: user\n>   message: string\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 这个也是 const user = await getuser<user>() 的返回值 user 的数据类型，所以 typescript 能正确推断出 user 的类型。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌘 实现拦截器",frontmatter:{title:"🌘 实现拦截器",date:"2022-06-11T17:40:39.000Z",permalink:"/pages/291f04/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/30.%20%F0%9F%8C%98%20%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8.html",relativePath:"801. 💽 TypeScript-Axios/30. 🌘 实现拦截器.md",key:"v-44b8a6d8",path:"/pages/291f04/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"整体设计",slug:"整体设计",normalizedTitle:"整体设计",charIndex:1067},{level:2,title:"拦截器管理类实现",slug:"拦截器管理类实现",normalizedTitle:"拦截器管理类实现",charIndex:1267},{level:3,title:"定义接口",slug:"定义接口",normalizedTitle:"定义接口",charIndex:1482},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:2059},{level:3,title:"链式调用实现",slug:"链式调用实现",normalizedTitle:"链式调用实现",charIndex:3159},{level:2,title:"编写 DEMO 代码",slug:"编写-demo-代码",normalizedTitle:"编写 demo 代码",charIndex:4759}],headersStr:"需求分析 整体设计 拦截器管理类实现 定义接口 代码实现 链式调用实现 编写 DEMO 代码",content:"# 需求分析\n\n要对请求和响应进行拦截。\n\n实现如下的功能：\n\n// 添加一个请求拦截器\naxios.interceptors.request.use(function (config) {\n  // 在发送请求之前可以做一些事情\n  return config;\n}, function (error) {\n  // 处理请求错误\n  return Promise.reject(error);\n});\n// 添加一个响应拦截器\naxios.interceptors.response.use(function (response) {\n  // 处理响应数据\n  return response;\n}, function (error) {\n  // 处理响应错误\n  return Promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 在 axios 对象上有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们都有一个 use 方法， use 方法支持 2 个参数，第一个参数类似 Promise 的 resolve 函数，第二个参数类似 Promise 的 reject 函数。\n> 可以在 resolve 函数和 reject 函数中执行同步代码或者异步代码逻辑。\n\n并且可以添加多个拦截器，拦截器的执行顺序是链式依次执行的方式。对于 request 拦截器，后添加的拦截器会在请求前的过程先执行；对于 response 拦截器，先添加的拦截器会在响应后先执行；\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n也可以支持删除某个拦截器，如下：\n\nconst myInterceptor = axios.interceptors.request.use(function () {/*...*/})\naxios.interceptors.request.eject(myInterceptor)\n\n\n1\n2\n\n\n\n# 整体设计\n\n\n\n整个过程是一个链式调用的过程，而且每一个拦截器都可以支持同步和异步处理，自然想到使用 Promise 链的方式实现整个调用过程。\n\n这个 Promise 链的执行过程中，请求拦截器 resolve 函数处理的是 config 对象，响应拦截器 resolve 函数处理的是 response 对象；\n\n了解这个过程后，先要创建一个 拦截器管理类，允许添加、删除和遍历拦截器。\n\n\n# 拦截器管理类实现\n\n根据需求， axios 拥有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们对外提供一个 use 方法来添加拦截器，可以把这两个属性看做是一个拦截器管理对象。\n\nuser 方法支持两个参数，对于 resolve 函数的参数，请求拦截器是 AxiosRequestConfig 类型的；对于 reject 函数的参数类型则是 any 类型的。\n\n\n# 定义接口\n\nexport interface AxiosInterceptorManager<T> {\n  use(resolved: ResolvedFn<T>, rejected?: RejectedFn): number\n\n  eject(id: number): void\n}\n\nexport interface ResolvedFn<T = any> {\n  (val: T): T | Promise<T>\n}\n\nexport interface RejectedFn {\n  (error: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 定义 AxiosInterceptorManager 泛型接口，对于 resolve 函数的参数，请求拦截器和响应拦截器是不同的。\n\n修改 Aixos 的类型：\n\nexport interface Axios {\n  interceptors: {\n    request: AxiosInterceptorManager<AxiosRequestConfig>,\n    response: AxiosInterceptorManager<AxiosResponse>\n  }\n\n  // ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 代码实现\n\n定义新的类 src/core/InterceptorManager\n\nimport { RejectedFn, ResolvedFn } from '../types'\n\ninterface Interceptor<T> {\n  resolved: ResolvedFn<T>\n  rejected: RejectedFn\n}\n\nexport default class InterceptorManager<T> {\n  private interceptors: Array<Interceptor<T> | null>\n\n  constructor() {\n    this.interceptors = []\n  }\n\n  use(resolved: ResolvedFn<T>, rejected?: RejectedFn): number {\n    this.interceptors.push({\n      resolved,\n      rejected\n    })\n\n    return this.interceptors.length - 1\n  }\n\n  forEach(fn: (interceptor: Interceptor<T>) => void): void {\n    this.interceptors.forEach(interceptor => {\n      if (interceptor != null) fn(interceptor)\n    })\n  }\n\n  eject(id: number): void {\n    if (this.interceptors[id]) {\n      this.interceptors[id] = null\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n> 定义 InterceptorManager 泛型类，内部维护了一个私有属性 interceptors 数组，存储拦截器。该类对外提供三个方法，其中 use 接口添加拦截器到 interceptors ，返回一个 id 用于删除； forEach 接口遍历 interceptors ，支持传入一个函数，遍历的过程会调用该函数，并把每一个 interceptor 作为函数的参数传入； eject 接口删除拦截器，通过传入的拦截器 id 删除。\n\n\n# 链式调用实现\n\n首先在 src/core/Axios 定义一个 interceptors 属性，类型如下接口：\n\ninterface Interceptors {\n  request: InterceptorManager<AxiosRequestConfig>\n  response: InterceptorManager<AxiosResponse>\n}\n\n\n1\n2\n3\n4\n\n\n> Interceptors 类型有两个属性，一个请求拦截器管理类实例，另一个是响应拦截器管理类实例。在实例化 Aixos 时，在它的构造器去初始化这个 interceptors 实例属性。\n\n然后修改 src/core/Axios 中 Axios 类中的 request 方法逻辑，添加拦截器链式调用的逻辑：\n\ninterface PromiseChain<T> {\n  resolved: ResolvedFn<T> | ((config: AxiosRequestConfig) => AxiosPromise)\n  rejected?: RejectedFn\n}\n\n\n1\n2\n3\n4\n\n\n> 定义 PromiseChain 接口。\n\nrequest(url: any, config?: any): AxiosPromise {\n  if (typeof url === 'string') {\n    if (!config) {\n      config = {}\n    }\n    config.url = url\n  } else {\n    config = url\n  }\n\n  const chain: PromiseChain<any>[] = [\n    {\n      resolved: dispatchRequest,\n      rejected: undefined\n    }\n  ]\n\n  this.interceptors.request.forEach(interceptor => {\n    chain.unshift(interceptor)\n  })\n\n  this.interceptors.response.forEach(interceptor => {\n    chain.push(interceptor)\n  })\n\n  let promise = Promise.resolve(config)\n  while (chain.length) {\n    const { resolved, rejected } = chain.shift()!\n    promise = promise.then(resolved, rejected)\n  }\n\n  return promise\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> 首先构造一个 PromiseChain 类型的数组 chain ，并且把 dispatchRequest 函数赋值给 resolved ；接着先遍历请求拦截器插入到 chain 的前面；然后再遍历响应拦截器插入到 chain 的后面。\n> \n> 接下来定义一个已经 resolve 的 Promise ，循环这个 chain ，拿到每个拦截器对象，把它们的 resolved 函数和 rejected 函数添加到 promise.then 的参数中，这样就相当于通过 Promise 的链式调用方式，实现了拦截器一层层的链式调用。\n> \n> 要注意 拦截器的执行顺序。请求拦截器先执行后添加的，再执行先添加的；对于响应拦截器，先执行先添加的，后执行后添加的。\n\n\n# 编写 DEMO 代码\n\nexamples/interceptor/app.ts ：\n\nimport axios from '../../src/index'\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '3'\n  return config\n})\n\naxios.interceptors.response.use(res => {\n  res.data += '1'\n  return res\n})\n\nlet interceptor = axios.interceptors.response.use(res => {\n  res.data += '2'\n  return res\n})\n\naxios.interceptors.response.use(res => {\n  res.data += '3'\n  return res\n})\n\naxios.interceptors.response.eject(interceptor)\n\naxios({\n  url: '/interceptor/get',\n  method: 'get',\n  headers: {\n    test: ''\n  }\n}).then((res)=>{\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n> 运行后，可以查看到 请求头中添加了字段 test ，以及内容为 321 ，说明请求拦截器的执行顺序正确；最后控制台输出的内容为 13 ，说明 响应拦截器根据 id 删除成功，并且执行顺序正确。\n> \n> 拦截器是一个非常实用的功能，在实际的工作中可以利用它添加登录权限认证的功能等。",normalizedContent:"# 需求分析\n\n要对请求和响应进行拦截。\n\n实现如下的功能：\n\n// 添加一个请求拦截器\naxios.interceptors.request.use(function (config) {\n  // 在发送请求之前可以做一些事情\n  return config;\n}, function (error) {\n  // 处理请求错误\n  return promise.reject(error);\n});\n// 添加一个响应拦截器\naxios.interceptors.response.use(function (response) {\n  // 处理响应数据\n  return response;\n}, function (error) {\n  // 处理响应错误\n  return promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 在 axios 对象上有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们都有一个 use 方法， use 方法支持 2 个参数，第一个参数类似 promise 的 resolve 函数，第二个参数类似 promise 的 reject 函数。\n> 可以在 resolve 函数和 reject 函数中执行同步代码或者异步代码逻辑。\n\n并且可以添加多个拦截器，拦截器的执行顺序是链式依次执行的方式。对于 request 拦截器，后添加的拦截器会在请求前的过程先执行；对于 response 拦截器，先添加的拦截器会在响应后先执行；\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n也可以支持删除某个拦截器，如下：\n\nconst myinterceptor = axios.interceptors.request.use(function () {/*...*/})\naxios.interceptors.request.eject(myinterceptor)\n\n\n1\n2\n\n\n\n# 整体设计\n\n\n\n整个过程是一个链式调用的过程，而且每一个拦截器都可以支持同步和异步处理，自然想到使用 promise 链的方式实现整个调用过程。\n\n这个 promise 链的执行过程中，请求拦截器 resolve 函数处理的是 config 对象，响应拦截器 resolve 函数处理的是 response 对象；\n\n了解这个过程后，先要创建一个 拦截器管理类，允许添加、删除和遍历拦截器。\n\n\n# 拦截器管理类实现\n\n根据需求， axios 拥有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们对外提供一个 use 方法来添加拦截器，可以把这两个属性看做是一个拦截器管理对象。\n\nuser 方法支持两个参数，对于 resolve 函数的参数，请求拦截器是 axiosrequestconfig 类型的；对于 reject 函数的参数类型则是 any 类型的。\n\n\n# 定义接口\n\nexport interface axiosinterceptormanager<t> {\n  use(resolved: resolvedfn<t>, rejected?: rejectedfn): number\n\n  eject(id: number): void\n}\n\nexport interface resolvedfn<t = any> {\n  (val: t): t | promise<t>\n}\n\nexport interface rejectedfn {\n  (error: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 定义 axiosinterceptormanager 泛型接口，对于 resolve 函数的参数，请求拦截器和响应拦截器是不同的。\n\n修改 aixos 的类型：\n\nexport interface axios {\n  interceptors: {\n    request: axiosinterceptormanager<axiosrequestconfig>,\n    response: axiosinterceptormanager<axiosresponse>\n  }\n\n  // ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 代码实现\n\n定义新的类 src/core/interceptormanager\n\nimport { rejectedfn, resolvedfn } from '../types'\n\ninterface interceptor<t> {\n  resolved: resolvedfn<t>\n  rejected: rejectedfn\n}\n\nexport default class interceptormanager<t> {\n  private interceptors: array<interceptor<t> | null>\n\n  constructor() {\n    this.interceptors = []\n  }\n\n  use(resolved: resolvedfn<t>, rejected?: rejectedfn): number {\n    this.interceptors.push({\n      resolved,\n      rejected\n    })\n\n    return this.interceptors.length - 1\n  }\n\n  foreach(fn: (interceptor: interceptor<t>) => void): void {\n    this.interceptors.foreach(interceptor => {\n      if (interceptor != null) fn(interceptor)\n    })\n  }\n\n  eject(id: number): void {\n    if (this.interceptors[id]) {\n      this.interceptors[id] = null\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n> 定义 interceptormanager 泛型类，内部维护了一个私有属性 interceptors 数组，存储拦截器。该类对外提供三个方法，其中 use 接口添加拦截器到 interceptors ，返回一个 id 用于删除； foreach 接口遍历 interceptors ，支持传入一个函数，遍历的过程会调用该函数，并把每一个 interceptor 作为函数的参数传入； eject 接口删除拦截器，通过传入的拦截器 id 删除。\n\n\n# 链式调用实现\n\n首先在 src/core/axios 定义一个 interceptors 属性，类型如下接口：\n\ninterface interceptors {\n  request: interceptormanager<axiosrequestconfig>\n  response: interceptormanager<axiosresponse>\n}\n\n\n1\n2\n3\n4\n\n\n> interceptors 类型有两个属性，一个请求拦截器管理类实例，另一个是响应拦截器管理类实例。在实例化 aixos 时，在它的构造器去初始化这个 interceptors 实例属性。\n\n然后修改 src/core/axios 中 axios 类中的 request 方法逻辑，添加拦截器链式调用的逻辑：\n\ninterface promisechain<t> {\n  resolved: resolvedfn<t> | ((config: axiosrequestconfig) => axiospromise)\n  rejected?: rejectedfn\n}\n\n\n1\n2\n3\n4\n\n\n> 定义 promisechain 接口。\n\nrequest(url: any, config?: any): axiospromise {\n  if (typeof url === 'string') {\n    if (!config) {\n      config = {}\n    }\n    config.url = url\n  } else {\n    config = url\n  }\n\n  const chain: promisechain<any>[] = [\n    {\n      resolved: dispatchrequest,\n      rejected: undefined\n    }\n  ]\n\n  this.interceptors.request.foreach(interceptor => {\n    chain.unshift(interceptor)\n  })\n\n  this.interceptors.response.foreach(interceptor => {\n    chain.push(interceptor)\n  })\n\n  let promise = promise.resolve(config)\n  while (chain.length) {\n    const { resolved, rejected } = chain.shift()!\n    promise = promise.then(resolved, rejected)\n  }\n\n  return promise\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> 首先构造一个 promisechain 类型的数组 chain ，并且把 dispatchrequest 函数赋值给 resolved ；接着先遍历请求拦截器插入到 chain 的前面；然后再遍历响应拦截器插入到 chain 的后面。\n> \n> 接下来定义一个已经 resolve 的 promise ，循环这个 chain ，拿到每个拦截器对象，把它们的 resolved 函数和 rejected 函数添加到 promise.then 的参数中，这样就相当于通过 promise 的链式调用方式，实现了拦截器一层层的链式调用。\n> \n> 要注意 拦截器的执行顺序。请求拦截器先执行后添加的，再执行先添加的；对于响应拦截器，先执行先添加的，后执行后添加的。\n\n\n# 编写 demo 代码\n\nexamples/interceptor/app.ts ：\n\nimport axios from '../../src/index'\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '3'\n  return config\n})\n\naxios.interceptors.response.use(res => {\n  res.data += '1'\n  return res\n})\n\nlet interceptor = axios.interceptors.response.use(res => {\n  res.data += '2'\n  return res\n})\n\naxios.interceptors.response.use(res => {\n  res.data += '3'\n  return res\n})\n\naxios.interceptors.response.eject(interceptor)\n\naxios({\n  url: '/interceptor/get',\n  method: 'get',\n  headers: {\n    test: ''\n  }\n}).then((res)=>{\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n> 运行后，可以查看到 请求头中添加了字段 test ，以及内容为 321 ，说明请求拦截器的执行顺序正确；最后控制台输出的内容为 13 ，说明 响应拦截器根据 id 删除成功，并且执行顺序正确。\n> \n> 拦截器是一个非常实用的功能，在实际的工作中可以利用它添加登录权限认证的功能等。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌓 实现合并默认配置",frontmatter:{title:"🌓 实现合并默认配置",date:"2022-06-16T00:51:11.000Z",permalink:"/pages/1e5c77/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/40.%20%F0%9F%8C%93%20%E5%AE%9E%E7%8E%B0%E5%90%88%E5%B9%B6%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.html",relativePath:"801. 💽 TypeScript-Axios/40. 🌓 实现合并默认配置.md",key:"v-87928544",path:"/pages/1e5c77/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"默认配置",slug:"默认配置",normalizedTitle:"默认配置",charIndex:45},{level:3,title:"定义默认配置",slug:"定义默认配置",normalizedTitle:"定义默认配置",charIndex:447},{level:3,title:"添加到 axios 对象中",slug:"添加到-axios-对象中",normalizedTitle:"添加到 axios 对象中",charIndex:1182},{level:3,title:"配置合并及策略",slug:"配置合并及策略",normalizedTitle:"配置合并及策略",charIndex:2361},{level:3,title:"合并方法",slug:"合并方法",normalizedTitle:"合并方法",charIndex:3057},{level:3,title:"默认合并策略",slug:"默认合并策略",normalizedTitle:"默认合并策略",charIndex:3321},{level:3,title:"只接受自定义配置合并策略",slug:"只接受自定义配置合并策略",normalizedTitle:"只接受自定义配置合并策略",charIndex:3513},{level:3,title:"复杂对象合并策略",slug:"复杂对象合并策略",normalizedTitle:"复杂对象合并策略",charIndex:3874},{level:3,title:"扁平化 headers",slug:"扁平化-headers",normalizedTitle:"扁平化 headers",charIndex:6066},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:7514}],headersStr:"需求分析 默认配置 定义默认配置 添加到 axios 对象中 配置合并及策略 合并方法 默认合并策略 只接受自定义配置合并策略 复杂对象合并策略 扁平化 headers 编写测试 DEMO",content:"# 需求分析\n\n在前面，发送请求的时候可以传入一个配置，决定请求的不同行为。要使 它可以有默认配置，定义一些默认的行为，这样在发送每个请求，用户传递的配置可以和默认配置做一层合并。\n\n与 axios 库相同，应该给每一个 aixos 对象添加一个如下的 defaults 属性，表示默认配置，并且可以直接修改这些默认配置：\n\naxios.defaults.headers.common['test'] = 123\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'\naxios.defaults.timeout = 2000\n\n\n1\n2\n3\n\n\n> 其中 headers 的默认配置支持 common 和一些请求方法 method 的字段， common 表示对于任何类型的请求都要添加该属性， method 表示只有该类型的请求方法才会添加对应的属性。\n\n\n# 默认配置\n\n\n# 定义默认配置\n\n创建文件 src/defaults.ts ：\n\nimport { AxiosRequestConfig } from './types'\n\nconst defaults: AxiosRequestConfig = {\n  method: 'get',\n  timeout: 0,\n  headers: {\n    common: {\n      Accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconst methodsNoData = ['delete', 'get', 'head', 'options']\nmethodsNoData.forEach(method => {\n  defaults.headers[method] = {}\n})\n\nconst methodsWithData = ['post', 'put', 'patch']\nmethodsWithData.forEach(method => {\n  defaults.headers[method] = {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n})\n\nexport default defaults\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 定义了 defaults 常量，包含默认请求的方法、超时时间、以及 headers 配置。分别根据请求方法是否会携带数据，对应的情况添加请求头的 Content-Type 。\n\n\n# 添加到 axios 对象中\n\n给 axios 对象添加 defaults 属性，表示默认配置：\n\n在 src/core/Axios.ts 中：\n\nexport default class Axios {\n  defaults: AxiosRequestConfig\n  interceptors: Interceptors\n\n\n  constructor(initConfig: AxiosRequestConfig) {\n    this.defaults = initConfig\n    this.interceptors = {\n      request: new InterceptorManager<AxiosRequestConfig>(),\n      response: new InterceptorManager<AxiosResponse>()\n    }\n  }\n  \n  // ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 在 Aixos 类中添加一个 defaults 成员属性，并且让 Axios 的构造函数接受一个 initConfig 初始化配置对象，把 initConfig 赋值给 this.defaults 。\n\n然后修改 createInstance 的方法，支持传入一个 config 配置对象。\n\n在 src/axios.ts 中：\n\nimport { AxiosInstance, AxiosRequestConfig } from './types'\nimport Axios from './core/Axios'\nimport { extend } from './helpers/util'\nimport defaults from './defaults'\n\nfunction createInstance(config: AxiosRequestConfig): AxiosInstance {\n  const context = new Axios(config)\n  const instance = Axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as AxiosInstance\n}\n\nconst axios = createInstance(defaults)\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 这样在执行 createInstance 创建 axios 对象时，就可以传入一个默认的配置了。\n\n\n# 配置合并及策略\n\n定义了默认配置之后，发送每个请求的时候需要把自定义配置和默认配置做合并。并不是简单的把两个普通对象合并，对于不同字段的合并，会有不同的合并策略。\n\n🌰 例子：\n\n// 默认配置\nconfig1 = {\n  method: 'get',\n  timeout: 0,\n  headers: {\n    common: {\n      Accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconfig2 = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  headers: {\n    test: '321'\n  }\n}\n\n// 合并后\nmerged = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  timeout: 0,\n  headers: {\n    common: {\n      Accept: 'application/json, text/plain, */*'\n    }\n    test: '321'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 对于新的配置要覆盖掉默认的配置，而没有设置的配置，按照默认配置进行配置。\n\n\n# 合并方法\n\n整体思路，对 config1 和 config2 的属性遍历，执行 mereField 方法做合并，这里 config1 代表默认配置， config2 代表自定义配置。\n\n遍历过程中，通过 config2[key] 这种缩阴的方式访问，所以需要给 AxiosRequestConfig 的接口定义添加一个字符串索引签名：\n\nexport interface AxiosRequestConfig {\n  // ...\n  \n  [propName: string]: any\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 默认合并策略\n\nfunction defaultStart(val1: any, val2: any):any {\n  return typeof val2 !== 'undefined' ? val2 : val1\n}\n\n\n1\n2\n3\n\n\n> 如果有 val2 则返回 val2 ，否则返回 val1 。意味着如果存在自定义配置就是用自定义配置的字段，否则就是用默认配置；\n\n\n# 只接受自定义配置合并策略\n\n对于一些 属性： url 、 prams 、 data ，合并策略如下：\n\nfunction fromVal2Strat(val1: any, val2: any):any{\n  if(typeof val2 !== 'undefined') {\n    return val2\n  }\n}\n\nconst stratKeysFromVal2 = ['url', 'params', 'data']\nstratKeysFromVal2.forEach(key => {\n  strats[key] = fromVal2Strat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 对于这些属性，默认配置显然没有意义，因为它们与每个请求都是强相关的，所以只能从自定义配置中获取。\n\n\n# 复杂对象合并策略\n\n对于 headers 这类的复杂对象属性，需要使用深拷贝的方式，同时也处理了其它一些情况，因为它们也可能是一个非对象的普通值。要使用认证授权的时候， auth 属性也是这个合并策略。\n\n对于一些属性例如 headers ，合并策略如下：\n\nfunction deepMergeStrat(val1: any, val2: any):any {\n  if(isPlainObject(val2)) {\n    return deepMerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isPlainObject(val1)) {\n    return deepMerge(val1)\n  } else if (typeof val1 !== 'undefined') {\n    return val1\n  }\n}\n\nconst stratKeysDeepMerge = ['headers']\nstratKeysDeepMerge.forEach(key => {\n  strats[key] = deepMergeStrat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n最后 src/core/mergeConfig.ts 的内容为：\n\nimport { AxiosRequestConfig } from '../types'\nimport { deepMerge, isPlainObject } from '../helpers/util'\n\nconst strats = Object.create(null)\nfunction defaultStrat(val1: any, val2: any):any {\n  return typeof val2 !== 'undefined' ? val2 : val1\n}\n\nfunction fromVal2Strat(val1: any, val2: any):any{\n  if(typeof val2 !== 'undefined') {\n    return val2\n  }\n}\n\nconst stratKeysFromVal2 = ['url', 'params', 'data']\nstratKeysFromVal2.forEach(key => {\n  strats[key] = fromVal2Strat\n})\n\nfunction deepMergeStrat(val1: any, val2: any):any {\n  if(isPlainObject(val2)) {\n    return deepMerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isPlainObject(val1)) {\n    return deepMerge(val1)\n  } else if (typeof val1 !== 'undefined') {\n    return val1\n  }\n}\n\nconst stratKeysDeepMerge = ['headers']\nstratKeysDeepMerge.forEach(key => {\n  strats[key] = deepMergeStrat\n})\n\n\nexport default function mergeConfig(\n  config1: AxiosRequestConfig,\n  config2?: AxiosRequestConfig\n): AxiosRequestConfig {\n  if(!config2) {\n    config2 = {}\n  }\n\n  const config = Object.create(null)\n\n  for(let key in config2) {\n    if (!config[key]) {\n      mergeField(key)\n    }\n  }\n\n  function mergeField(key: string): void {\n    const strat = strats[key] || defaultStrat\n    config[key] = strat(config)\n  }\n\n  return config\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n最后在 request 方法中添加合并配置的逻辑。\n\nconfig = mergeConfig(this.defaults, config)\n\n\n1\n\n\n\n# 扁平化 headers\n\n经过合并之后的配置中， headers 是一个复杂的对象，多了 common 、 post 、 get 等属性，而这些属性中的值最终应该要真正添加到请求的 headers 中：\n\n> 🌰 例子：\n> \n> headers: {\n>   common: {\n>     Accept: 'application/json, text/plain, */*'\n>   },\n>   post: {\n>     'Content-Type':'application/x-www-form-urlencoded'\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 要使它压成一级：\n> \n> headers: {\n>   Accept: 'application/json, text/plain, */*',\n>  'Content-Type':'application/x-www-form-urlencoded'\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n注意，对于 common 定义的 header 字段，都要提取，而对于 get 、 post 这类提取，需要和该次请求方法对应。\n\n在 src/helpers/headers.ts 实现 flatterHeaders 方法：\n\nexport function flatterHeaders(headers: any, method: Method): any {\n  if (!headers) {\n    return headers\n  }\n  headers = deepMerge(headers.common || {}, headers[method] || {}, headers)\n\n  const methodsToDelete = ['delete', 'get', 'head', 'options', 'post', 'put', 'patch', 'common']\n  methodsToDelete.forEach(method => {\n    delete headers[method]\n  })\n\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 通过 deepMerge 方法，把 common 、 post 的属性拷贝到 headers 这一级之后，再把 common 、 post 这些属性删掉。\n\n在阵阵发送请求之前执行这个逻辑：\n\ncore/dispatchRequest.ts ：\n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.headers = transformRequestHeader(config)\n  config.data = transformRequestData(config)\n  config.headers = flattenHeaders(config.headers, config.method!)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这样确保了配置中的 headers 是可以正确添加到请求的 header 当中的。\n\n\n# 编写测试 DEMO\n\nexamples/config/app.ts ：\n\nimport axios from '../../src'\nimport qs from 'qs'\n\naxios.defaults.headers.common['test2'] = 123\n\naxios({\n  url: '/config/post',\n  method: 'post',\n  data: qs.stringify({\n    a: 1\n  }),\n  headers: {\n    test: '321'\n  }\n}).then(res => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 在这个例子中，额外引入 qs 库，用于查询字符串解析和字符串化。比如，对于 {a: 1} 经过字符串化变为 a=1 。\n> \n> 由于，给默认值添加了 post 、和 common 的 headers ，在请求前做配置合并，于是请求就添加了 Content-Type 字段，值为 application/x-www-form-urlencoded ；另外添加了 test2 字段，值为 123 。",normalizedContent:"# 需求分析\n\n在前面，发送请求的时候可以传入一个配置，决定请求的不同行为。要使 它可以有默认配置，定义一些默认的行为，这样在发送每个请求，用户传递的配置可以和默认配置做一层合并。\n\n与 axios 库相同，应该给每一个 aixos 对象添加一个如下的 defaults 属性，表示默认配置，并且可以直接修改这些默认配置：\n\naxios.defaults.headers.common['test'] = 123\naxios.defaults.headers.post['content-type'] = 'application/x-www-form-urlencoded'\naxios.defaults.timeout = 2000\n\n\n1\n2\n3\n\n\n> 其中 headers 的默认配置支持 common 和一些请求方法 method 的字段， common 表示对于任何类型的请求都要添加该属性， method 表示只有该类型的请求方法才会添加对应的属性。\n\n\n# 默认配置\n\n\n# 定义默认配置\n\n创建文件 src/defaults.ts ：\n\nimport { axiosrequestconfig } from './types'\n\nconst defaults: axiosrequestconfig = {\n  method: 'get',\n  timeout: 0,\n  headers: {\n    common: {\n      accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconst methodsnodata = ['delete', 'get', 'head', 'options']\nmethodsnodata.foreach(method => {\n  defaults.headers[method] = {}\n})\n\nconst methodswithdata = ['post', 'put', 'patch']\nmethodswithdata.foreach(method => {\n  defaults.headers[method] = {\n    'content-type': 'application/x-www-form-urlencoded'\n  }\n})\n\nexport default defaults\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 定义了 defaults 常量，包含默认请求的方法、超时时间、以及 headers 配置。分别根据请求方法是否会携带数据，对应的情况添加请求头的 content-type 。\n\n\n# 添加到 axios 对象中\n\n给 axios 对象添加 defaults 属性，表示默认配置：\n\n在 src/core/axios.ts 中：\n\nexport default class axios {\n  defaults: axiosrequestconfig\n  interceptors: interceptors\n\n\n  constructor(initconfig: axiosrequestconfig) {\n    this.defaults = initconfig\n    this.interceptors = {\n      request: new interceptormanager<axiosrequestconfig>(),\n      response: new interceptormanager<axiosresponse>()\n    }\n  }\n  \n  // ... \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 在 aixos 类中添加一个 defaults 成员属性，并且让 axios 的构造函数接受一个 initconfig 初始化配置对象，把 initconfig 赋值给 this.defaults 。\n\n然后修改 createinstance 的方法，支持传入一个 config 配置对象。\n\n在 src/axios.ts 中：\n\nimport { axiosinstance, axiosrequestconfig } from './types'\nimport axios from './core/axios'\nimport { extend } from './helpers/util'\nimport defaults from './defaults'\n\nfunction createinstance(config: axiosrequestconfig): axiosinstance {\n  const context = new axios(config)\n  const instance = axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as axiosinstance\n}\n\nconst axios = createinstance(defaults)\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 这样在执行 createinstance 创建 axios 对象时，就可以传入一个默认的配置了。\n\n\n# 配置合并及策略\n\n定义了默认配置之后，发送每个请求的时候需要把自定义配置和默认配置做合并。并不是简单的把两个普通对象合并，对于不同字段的合并，会有不同的合并策略。\n\n🌰 例子：\n\n// 默认配置\nconfig1 = {\n  method: 'get',\n  timeout: 0,\n  headers: {\n    common: {\n      accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconfig2 = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  headers: {\n    test: '321'\n  }\n}\n\n// 合并后\nmerged = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  timeout: 0,\n  headers: {\n    common: {\n      accept: 'application/json, text/plain, */*'\n    }\n    test: '321'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 对于新的配置要覆盖掉默认的配置，而没有设置的配置，按照默认配置进行配置。\n\n\n# 合并方法\n\n整体思路，对 config1 和 config2 的属性遍历，执行 merefield 方法做合并，这里 config1 代表默认配置， config2 代表自定义配置。\n\n遍历过程中，通过 config2[key] 这种缩阴的方式访问，所以需要给 axiosrequestconfig 的接口定义添加一个字符串索引签名：\n\nexport interface axiosrequestconfig {\n  // ...\n  \n  [propname: string]: any\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 默认合并策略\n\nfunction defaultstart(val1: any, val2: any):any {\n  return typeof val2 !== 'undefined' ? val2 : val1\n}\n\n\n1\n2\n3\n\n\n> 如果有 val2 则返回 val2 ，否则返回 val1 。意味着如果存在自定义配置就是用自定义配置的字段，否则就是用默认配置；\n\n\n# 只接受自定义配置合并策略\n\n对于一些 属性： url 、 prams 、 data ，合并策略如下：\n\nfunction fromval2strat(val1: any, val2: any):any{\n  if(typeof val2 !== 'undefined') {\n    return val2\n  }\n}\n\nconst stratkeysfromval2 = ['url', 'params', 'data']\nstratkeysfromval2.foreach(key => {\n  strats[key] = fromval2strat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 对于这些属性，默认配置显然没有意义，因为它们与每个请求都是强相关的，所以只能从自定义配置中获取。\n\n\n# 复杂对象合并策略\n\n对于 headers 这类的复杂对象属性，需要使用深拷贝的方式，同时也处理了其它一些情况，因为它们也可能是一个非对象的普通值。要使用认证授权的时候， auth 属性也是这个合并策略。\n\n对于一些属性例如 headers ，合并策略如下：\n\nfunction deepmergestrat(val1: any, val2: any):any {\n  if(isplainobject(val2)) {\n    return deepmerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isplainobject(val1)) {\n    return deepmerge(val1)\n  } else if (typeof val1 !== 'undefined') {\n    return val1\n  }\n}\n\nconst stratkeysdeepmerge = ['headers']\nstratkeysdeepmerge.foreach(key => {\n  strats[key] = deepmergestrat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n最后 src/core/mergeconfig.ts 的内容为：\n\nimport { axiosrequestconfig } from '../types'\nimport { deepmerge, isplainobject } from '../helpers/util'\n\nconst strats = object.create(null)\nfunction defaultstrat(val1: any, val2: any):any {\n  return typeof val2 !== 'undefined' ? val2 : val1\n}\n\nfunction fromval2strat(val1: any, val2: any):any{\n  if(typeof val2 !== 'undefined') {\n    return val2\n  }\n}\n\nconst stratkeysfromval2 = ['url', 'params', 'data']\nstratkeysfromval2.foreach(key => {\n  strats[key] = fromval2strat\n})\n\nfunction deepmergestrat(val1: any, val2: any):any {\n  if(isplainobject(val2)) {\n    return deepmerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isplainobject(val1)) {\n    return deepmerge(val1)\n  } else if (typeof val1 !== 'undefined') {\n    return val1\n  }\n}\n\nconst stratkeysdeepmerge = ['headers']\nstratkeysdeepmerge.foreach(key => {\n  strats[key] = deepmergestrat\n})\n\n\nexport default function mergeconfig(\n  config1: axiosrequestconfig,\n  config2?: axiosrequestconfig\n): axiosrequestconfig {\n  if(!config2) {\n    config2 = {}\n  }\n\n  const config = object.create(null)\n\n  for(let key in config2) {\n    if (!config[key]) {\n      mergefield(key)\n    }\n  }\n\n  function mergefield(key: string): void {\n    const strat = strats[key] || defaultstrat\n    config[key] = strat(config)\n  }\n\n  return config\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n最后在 request 方法中添加合并配置的逻辑。\n\nconfig = mergeconfig(this.defaults, config)\n\n\n1\n\n\n\n# 扁平化 headers\n\n经过合并之后的配置中， headers 是一个复杂的对象，多了 common 、 post 、 get 等属性，而这些属性中的值最终应该要真正添加到请求的 headers 中：\n\n> 🌰 例子：\n> \n> headers: {\n>   common: {\n>     accept: 'application/json, text/plain, */*'\n>   },\n>   post: {\n>     'content-type':'application/x-www-form-urlencoded'\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 要使它压成一级：\n> \n> headers: {\n>   accept: 'application/json, text/plain, */*',\n>  'content-type':'application/x-www-form-urlencoded'\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n注意，对于 common 定义的 header 字段，都要提取，而对于 get 、 post 这类提取，需要和该次请求方法对应。\n\n在 src/helpers/headers.ts 实现 flatterheaders 方法：\n\nexport function flatterheaders(headers: any, method: method): any {\n  if (!headers) {\n    return headers\n  }\n  headers = deepmerge(headers.common || {}, headers[method] || {}, headers)\n\n  const methodstodelete = ['delete', 'get', 'head', 'options', 'post', 'put', 'patch', 'common']\n  methodstodelete.foreach(method => {\n    delete headers[method]\n  })\n\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 通过 deepmerge 方法，把 common 、 post 的属性拷贝到 headers 这一级之后，再把 common 、 post 这些属性删掉。\n\n在阵阵发送请求之前执行这个逻辑：\n\ncore/dispatchrequest.ts ：\n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.headers = transformrequestheader(config)\n  config.data = transformrequestdata(config)\n  config.headers = flattenheaders(config.headers, config.method!)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 这样确保了配置中的 headers 是可以正确添加到请求的 header 当中的。\n\n\n# 编写测试 demo\n\nexamples/config/app.ts ：\n\nimport axios from '../../src'\nimport qs from 'qs'\n\naxios.defaults.headers.common['test2'] = 123\n\naxios({\n  url: '/config/post',\n  method: 'post',\n  data: qs.stringify({\n    a: 1\n  }),\n  headers: {\n    test: '321'\n  }\n}).then(res => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 在这个例子中，额外引入 qs 库，用于查询字符串解析和字符串化。比如，对于 {a: 1} 经过字符串化变为 a=1 。\n> \n> 由于，给默认值添加了 post 、和 common 的 headers ，在请求前做配置合并，于是请求就添加了 content-type 字段，值为 application/x-www-form-urlencoded ；另外添加了 test2 字段，值为 123 。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌓 实现请求和响应配置化",frontmatter:{title:"🌓 实现请求和响应配置化",date:"2022-06-16T20:14:02.000Z",permalink:"/pages/4c10b2/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/41.%20%F0%9F%8C%93%20%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E9%85%8D%E7%BD%AE%E5%8C%96.html",relativePath:"801. 💽 TypeScript-Axios/41. 🌓 实现请求和响应配置化.md",key:"v-8c73d138",path:"/pages/4c10b2/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"修改默认配置",slug:"修改默认配置",normalizedTitle:"修改默认配置",charIndex:834},{level:2,title:"transform 逻辑重构",slug:"transform-逻辑重构",normalizedTitle:"transform 逻辑重构",charIndex:1915},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:3135}],headersStr:"需求分析 修改默认配置 transform 逻辑重构 编写测试 DEMO",content:"# 需求分析\n\n在 aixos 库中，默认配置会添加 transformRequest 和 transformResponse 两个字段，它们的值是一个数组或者是一个函数。\n\n * transformRequest ：允许将请求数据发送到服务器之前进行修改，适用于 put 、 post 和 patch 请求方法，如果值是数组，则数组中的最后一个函数必须返回一个字符串 FormData 、 URLSearchParams 、 Blob 等类型作为 xhr.send 方法的参数，而且在 transform 过程中可以修改 headers 对象；\n * transfromResponse 允许在相应数据传递给 then 或者 catch 之前对它们进行修改；当值为数组的时候，数组的每个函数都是一个转换函数，前者的输出作为后者的输入。\n\n> 🌰 例子：\n> \n> axios({\n>   transfromRequest: [(function(data) {\n>     return qs.stringify(data)\n>   }), ...axios.defaults.transformRequest],\n> \ttransformResponse: [axios.defaults.transformResponse, function(data) {\n>     if(typeof data === 'object') {\n>       data.b = 2\n>     }\n>     return data\n>   }],\n>   url: '/config/post',\n>   method: 'post',\n>   data: {\n>     a: 1\n>   }\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n\n\n# 修改默认配置\n\n在 src/types/index.ts 中：\n\n添加一个类型 AxiosTransformer 。\n\nexport interface AxiosTransformer {\n  (data: any, headers?: any):any\n}\n\n\n1\n2\n3\n\n\n然后修改 AxiosRequestConfig 的类型定义：\n\nexport interface AxiosRequestConfig {\n  // ...\n  transformRequest?: AxiosTransformer | AxiosTransformer[]\n  transformResponse?: AxiosTransformer | AxiosTransformer[]\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 添加两个可选属性。\n\n然后修改默认配置，在 src/defaults.ts 中：\n\nimport { AxiosRequestConfig } from './types'\nimport { processHeaders } from './helpers/headers'\nimport { transformRequest, transformResponse } from './helpers/data'\n\nconst defaults: AxiosRequestConfig = {\n  method: 'get',\n  timeout: 0,\n  headers: {\n    common: {\n      Accept: 'application/json, text/plain, */*'\n    }\n  },\n\n  transformRequest: [\n    function(data: any, headers: any): any {\n      processHeaders(headers, data)\n      return transformRequest(data)\n    }\n  ],\n  transformResponse: [\n    function(data: any): any {\n      return transformResponse(data)\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 将之前对请求数据和相应数据的处理逻辑，放到默认配置中。\n\n\n# transform 逻辑重构\n\n重构之前写的 对请求数据和相应数据的处理逻辑。可能会编写多个转换函数，先定义一个 transform 函数处理这些转换函数的调用逻辑。\n\nsrc/core/transform.ts ：\n\nimport { AxiosTransformer } from '../types'\n\nexport default function transform(\n  data: any,\n  headers: any,\n  fns?: AxiosTransformer | AxiosTransformer[]\n): any {\n  if(!fns) return data\n  \n  if(!Array.isArray(fns)) fns = [fns]\n  \n  fns.forEach(fn => {\n    data = fn(data, headers)\n  })\n  \n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> transform 函数中接收三个参数，其中 fns 代表一个或者多个转换函数，内部逻辑为 遍历 fns ，执行这些转换函数，并且把 data 和 headers 作为参数传入，每个转换函数返回的 data 或作为下一个转换函数的参数 data 传入。\n\n修改对请求数据和相应数据处理的逻辑：\n\nsrc/core/dispatchRequest.ts ：\n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.headers = transformRequestHeader(config)\n  config.data = transform(config.data, config.headers, config.transformRequest)\n  config.headers = flattenHeaders(config.headers, config.method!)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nfunction transformResponseData(res: AxiosResponse): AxiosResponse {\n  res.data = transform(res.data, res.headers, res.config.transformResponse)\n  return res\n}\n\n\n1\n2\n3\n4\n\n\n> 将对请求数据的处理和对响应数据的处理改成适用 transform 函数的实现，并且把配置中的 transformRequest 以及 transformResponse 分别传入。\n\n\n# 编写测试 DEMO\n\naxios({\n  transfromRequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...axios.defaults.transformRequest],\n\ttransformResponse: [axios.defaults.transformResponse, function(data) {\n    if(typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }],\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# 需求分析\n\n在 aixos 库中，默认配置会添加 transformrequest 和 transformresponse 两个字段，它们的值是一个数组或者是一个函数。\n\n * transformrequest ：允许将请求数据发送到服务器之前进行修改，适用于 put 、 post 和 patch 请求方法，如果值是数组，则数组中的最后一个函数必须返回一个字符串 formdata 、 urlsearchparams 、 blob 等类型作为 xhr.send 方法的参数，而且在 transform 过程中可以修改 headers 对象；\n * transfromresponse 允许在相应数据传递给 then 或者 catch 之前对它们进行修改；当值为数组的时候，数组的每个函数都是一个转换函数，前者的输出作为后者的输入。\n\n> 🌰 例子：\n> \n> axios({\n>   transfromrequest: [(function(data) {\n>     return qs.stringify(data)\n>   }), ...axios.defaults.transformrequest],\n> \ttransformresponse: [axios.defaults.transformresponse, function(data) {\n>     if(typeof data === 'object') {\n>       data.b = 2\n>     }\n>     return data\n>   }],\n>   url: '/config/post',\n>   method: 'post',\n>   data: {\n>     a: 1\n>   }\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n\n\n# 修改默认配置\n\n在 src/types/index.ts 中：\n\n添加一个类型 axiostransformer 。\n\nexport interface axiostransformer {\n  (data: any, headers?: any):any\n}\n\n\n1\n2\n3\n\n\n然后修改 axiosrequestconfig 的类型定义：\n\nexport interface axiosrequestconfig {\n  // ...\n  transformrequest?: axiostransformer | axiostransformer[]\n  transformresponse?: axiostransformer | axiostransformer[]\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 添加两个可选属性。\n\n然后修改默认配置，在 src/defaults.ts 中：\n\nimport { axiosrequestconfig } from './types'\nimport { processheaders } from './helpers/headers'\nimport { transformrequest, transformresponse } from './helpers/data'\n\nconst defaults: axiosrequestconfig = {\n  method: 'get',\n  timeout: 0,\n  headers: {\n    common: {\n      accept: 'application/json, text/plain, */*'\n    }\n  },\n\n  transformrequest: [\n    function(data: any, headers: any): any {\n      processheaders(headers, data)\n      return transformrequest(data)\n    }\n  ],\n  transformresponse: [\n    function(data: any): any {\n      return transformresponse(data)\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 将之前对请求数据和相应数据的处理逻辑，放到默认配置中。\n\n\n# transform 逻辑重构\n\n重构之前写的 对请求数据和相应数据的处理逻辑。可能会编写多个转换函数，先定义一个 transform 函数处理这些转换函数的调用逻辑。\n\nsrc/core/transform.ts ：\n\nimport { axiostransformer } from '../types'\n\nexport default function transform(\n  data: any,\n  headers: any,\n  fns?: axiostransformer | axiostransformer[]\n): any {\n  if(!fns) return data\n  \n  if(!array.isarray(fns)) fns = [fns]\n  \n  fns.foreach(fn => {\n    data = fn(data, headers)\n  })\n  \n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> transform 函数中接收三个参数，其中 fns 代表一个或者多个转换函数，内部逻辑为 遍历 fns ，执行这些转换函数，并且把 data 和 headers 作为参数传入，每个转换函数返回的 data 或作为下一个转换函数的参数 data 传入。\n\n修改对请求数据和相应数据处理的逻辑：\n\nsrc/core/dispatchrequest.ts ：\n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.headers = transformrequestheader(config)\n  config.data = transform(config.data, config.headers, config.transformrequest)\n  config.headers = flattenheaders(config.headers, config.method!)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nfunction transformresponsedata(res: axiosresponse): axiosresponse {\n  res.data = transform(res.data, res.headers, res.config.transformresponse)\n  return res\n}\n\n\n1\n2\n3\n4\n\n\n> 将对请求数据的处理和对响应数据的处理改成适用 transform 函数的实现，并且把配置中的 transformrequest 以及 transformresponse 分别传入。\n\n\n# 编写测试 demo\n\naxios({\n  transfromrequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...axios.defaults.transformrequest],\n\ttransformresponse: [axios.defaults.transformresponse, function(data) {\n    if(typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }],\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌓 拓展创建axios静态接口",frontmatter:{title:"🌓 拓展创建axios静态接口",date:"2022-06-17T01:06:02.000Z",permalink:"/pages/87b8ba/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/42.%20%F0%9F%8C%93%20%E6%8B%93%E5%B1%95%E5%88%9B%E5%BB%BAaxios%E9%9D%99%E6%80%81%E6%8E%A5%E5%8F%A3.html",relativePath:"801. 💽 TypeScript-Axios/42. 🌓 拓展创建axios静态接口.md",key:"v-1f7eea30",path:"/pages/87b8ba/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"静态方法拓展",slug:"静态方法拓展",normalizedTitle:"静态方法拓展",charIndex:780},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:1577}],headersStr:"需求分析 静态方法拓展 编写测试 DEMO",content:"# 需求分析\n\n目前为止， aixos 都是一个蛋里，一旦修改了 aixos 的默认配置，会影响所有的请求。希望提供一个 axios.create 的静态接口允许我们创建一个 axios.create 的静态接口允许创建一个新的 axios 实例，同时允许传入新的配置和默认配置合并，并作为新的默认配置。\n\n> 🌰 例子：\n> \n> const instance = axios.create({\n>   transformRequest: [(function(data) {\n>     return qs.stringify(data)\n>   }), ...(axios.defaults.transformRequest as AxiosTransformer[])],\n>   transformResponse: [...(axios.defaults.transformResponse as AxiosTransformer[]), function(data) {\n>     if (typeof data === 'object') {\n>       data.b = 2\n>     }\n>     return data\n>   }]\n> })\n> \n> instance({\n>   url: '/config/post',\n>   method: 'post',\n>   data: {\n>     a: 1\n>   }\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> \n> \n> > instance 是利用 axios.create 创建的 axios 实例。\n\n\n# 静态方法拓展\n\n在 src/type/index.ts 中修改接口类型定义：\n\nexport interface AxiosStatic extends AxiosInstance {\n  create(config?: AxiosRequestConfig): AxiosInstance\n}\n\n\n1\n2\n3\n\n\n> create 函数可以接受一个 AxiosRequestConfig 类型的配置作为默认配置的拓展，也可以接受不传参数。\n\n接下来实现 axios.create 静态方法。\n\n在 src/axios.ts 中：\n\nfunction createInstance(config: AxiosRequestConfig): AxiosStatic {\n  const context = new Axios(config)\n  const instance = Axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as AxiosStatic\n}\n\nconst axios = createInstance(defaults)\n\naxios.create = function create(config) {\n  return createInstance(mergeConfig(defaults, config))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 将 createInstance 方法的返回值类型设置为 AxiosStatic 。\n> \n> axios.create 的内部调用了 createInstance 函数，并且把参数 config 于 defaults 合并，作为新的默认配置。\n\n\n# 编写测试 DEMO\n\nconst instance = axios.create({\n  transformRequest: [\n    function(data) {\n      return qs.stringify(data)\n    },\n    ...(axios.defaults.transformRequest as AxiosTransformer[])\n  ],\n  transformResponse: [\n    ...(axios.defaults.transformResponse as AxiosTransformer[]),\n    function(data) {\n      if (typeof data === 'object') {\n        data.b = 2\n      }\n      return data\n    }\n  ]\n})\n\ninstance({\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> 通过 axios.create 方法创建一个新的实例 instance ，并传入了 transformRequest 和 transformResponse 的配置修改了默认配置，然后通过 instance 发送请求，效果和之前是一样的。",normalizedContent:"# 需求分析\n\n目前为止， aixos 都是一个蛋里，一旦修改了 aixos 的默认配置，会影响所有的请求。希望提供一个 axios.create 的静态接口允许我们创建一个 axios.create 的静态接口允许创建一个新的 axios 实例，同时允许传入新的配置和默认配置合并，并作为新的默认配置。\n\n> 🌰 例子：\n> \n> const instance = axios.create({\n>   transformrequest: [(function(data) {\n>     return qs.stringify(data)\n>   }), ...(axios.defaults.transformrequest as axiostransformer[])],\n>   transformresponse: [...(axios.defaults.transformresponse as axiostransformer[]), function(data) {\n>     if (typeof data === 'object') {\n>       data.b = 2\n>     }\n>     return data\n>   }]\n> })\n> \n> instance({\n>   url: '/config/post',\n>   method: 'post',\n>   data: {\n>     a: 1\n>   }\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> \n> \n> > instance 是利用 axios.create 创建的 axios 实例。\n\n\n# 静态方法拓展\n\n在 src/type/index.ts 中修改接口类型定义：\n\nexport interface axiosstatic extends axiosinstance {\n  create(config?: axiosrequestconfig): axiosinstance\n}\n\n\n1\n2\n3\n\n\n> create 函数可以接受一个 axiosrequestconfig 类型的配置作为默认配置的拓展，也可以接受不传参数。\n\n接下来实现 axios.create 静态方法。\n\n在 src/axios.ts 中：\n\nfunction createinstance(config: axiosrequestconfig): axiosstatic {\n  const context = new axios(config)\n  const instance = axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as axiosstatic\n}\n\nconst axios = createinstance(defaults)\n\naxios.create = function create(config) {\n  return createinstance(mergeconfig(defaults, config))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 将 createinstance 方法的返回值类型设置为 axiosstatic 。\n> \n> axios.create 的内部调用了 createinstance 函数，并且把参数 config 于 defaults 合并，作为新的默认配置。\n\n\n# 编写测试 demo\n\nconst instance = axios.create({\n  transformrequest: [\n    function(data) {\n      return qs.stringify(data)\n    },\n    ...(axios.defaults.transformrequest as axiostransformer[])\n  ],\n  transformresponse: [\n    ...(axios.defaults.transformresponse as axiostransformer[]),\n    function(data) {\n      if (typeof data === 'object') {\n        data.b = 2\n      }\n      return data\n    }\n  ]\n})\n\ninstance({\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> 通过 axios.create 方法创建一个新的实例 instance ，并传入了 transformrequest 和 transformresponse 的配置修改了默认配置，然后通过 instance 发送请求，效果和之前是一样的。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现取消功能",frontmatter:{title:"🌗 实现取消功能",date:"2022-06-17T01:17:46.000Z",permalink:"/pages/0a6e3d/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/43.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD.html",relativePath:"801. 💽 TypeScript-Axios/43. 🌗 实现取消功能.md",key:"v-d8eae0b2",path:"/pages/0a6e3d/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"异步分离的设计方案",slug:"异步分离的设计方案",normalizedTitle:"异步分离的设计方案",charIndex:1331},{level:2,title:"CancelToken 类的实现",slug:"canceltoken-类的实现",normalizedTitle:"canceltoken 类的实现",charIndex:1928},{level:3,title:"接口定义",slug:"接口定义",normalizedTitle:"接口定义",charIndex:1949},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:2390},{level:2,title:"CancelToken 拓展静态接口",slug:"canceltoken-拓展静态接口",normalizedTitle:"canceltoken 拓展静态接口",charIndex:3486},{level:3,title:"接口定义",slug:"接口定义-2",normalizedTitle:"接口定义",charIndex:1949},{level:3,title:"代码实现",slug:"代码实现-2",normalizedTitle:"代码实现",charIndex:2390},{level:2,title:"Cancel 类的实现以及 axios 的拓展",slug:"cancel-类的实现以及-axios-的拓展",normalizedTitle:"cancel 类的实现以及 axios 的拓展",charIndex:4391},{level:3,title:"接口定义",slug:"接口定义-3",normalizedTitle:"接口定义",charIndex:1949},{level:3,title:"代码实现",slug:"代码实现-3",normalizedTitle:"代码实现",charIndex:2390},{level:2,title:"额外逻辑实现",slug:"额外逻辑实现",normalizedTitle:"额外逻辑实现",charIndex:6170},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:7151}],headersStr:"需求分析 异步分离的设计方案 CancelToken 类的实现 接口定义 代码实现 CancelToken 拓展静态接口 接口定义 代码实现 Cancel 类的实现以及 axios 的拓展 接口定义 代码实现 额外逻辑实现 编写测试 DEMO",content:"# 需求分析\n\n在有些场景，希望能 主动取消请求。\n\n> 例如常见的搜索框案例，用户在输入过程中，输入框的内容不断变化。正常情况每次变化都应该向服务器发送一次请求。但是当用户输入过快的时候，不希望每次变化请求都会发送出去。通常解决方案是使用 防抖 延时发送请求。\n> \n> 但是有一种极端情况是，后段接口很慢，比如超过 1s 才会响应，这个时候及时做了 200ms 的防抖，在慢慢输入（每次输入间隔超过 200ms）的情况下，在前面的请求没有响应之前，也有可能发出多个请求。因为接口的响应时长不定，如果先发出去的请求响应时长比后发出去的请求要就，那么后请求的响应先回来，先请求的响应后回来，就会出现前面请求响应结果覆盖后面请求响应结果的情况，那么造成响应结果混乱。在这个场景下，除了做防抖，还希望后面的请求发送时，如果前面的请求还没有响应， 可以把前面的请求取消。\n\n从 axios 的取消接口设计层面，可以实现如下：\n\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('/user/12345', {\n  cancelToken: source.token\n}).catch(function (e) {\n  if (axios.isCancel(e)) {\n    console.log('Request canceled', e.message);\n  } else {\n    // 处理错误\n  }\n});\n\n// 取消请求 (请求原因是可选的)\nsource.cancel('Operation canceled by the user.');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 给 axios 添加一个 CancelToken 对象，它有一个 source 方法返回一个 source 对象， source.token 是每一次请求的时候传给配置对象中的 cancelToken 属性，然后在请求中发出去后，可以通过 cancelToken 取消请求。\n\n或者支持另一种方式的调用：\n\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new CancelToken(function executor(c) {\n    cancel = c;\n  })\n});\n\ncancel()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> axios.CancelToken 是一个类，直接把它实例化的对象传给请求配置中的 cancelToken 属性， CancelToken 的构造函数参数支持传入一个 executor 方法，该方法的参数是一个取消函数 c ，可以在 executor 方法执行的内部拿到这个取消函数 c ，赋值给我们外部定义的 cancel 变量，之后可以通过调用这个 cancel 方法来取消请求。\n\n\n# 异步分离的设计方案\n\n通过需求分析，如果想要实现取消某次请求，需要为该请求配置一个 CancelToken ，然后在外部调用一个 cancel 方法。\n\n请求的发送是一个异步过程，最终会执行 xhr.send 方法， xhr 对象提供了 abort 方法，可以把请求取消。但是在外部碰不到 xhr 对象，要想执行 cancel 的时候，去执行 xhr.abort 方法。\n\n相当于在 xhr 异步请求的过程中，插入一段代码，当在外部执行 cancel 的函数的时候，回去懂这段代码的执行，然后执行 xhr.abort 方法取消请求。\n\n利用 Promise 实现异步分离。也就是在 cancelToken 中保存一个 pending 状态的 Promise 对象，然后当执行 cancel 方法时，能够访问搭配这个 Promise 对象，把它从 pending 状态变成 resolved 状态。这样就可以在 then 中实现取消请求的逻辑。\n\n> 类似如下：\n> \n> if (cancelToken) {\n>   cancelToken.promise\n>   \t.then(reason => {\n>     \trequest.abort()\n>     \treject(reason)\n>   \t})\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n\n# CancelToken 类的实现\n\n\n# 接口定义\n\nsrc/types/index.ts ：\n\nexport interface AxiosRequestConfig {\n\t// ...\n  cancelToken?: CancelToken\n}\n\n\n1\n2\n3\n4\n\n\nexport interface CancelToken {\n  promise: Promise<string>\n  reason?: string\n}\n\nexport interface Canceler {\n  (message?: string): void\n}\n\nexport interface CancelExecutor {\n  (cancel: Canceler): void\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> CancelToken 是实例类型的接口定义， Canceler 是取消方法的接口定义， CancelExecutor 是 CancelToken 类构造函数参数的接口定义。\n\n\n# 代码实现\n\n创建单独的目录管理 cancel 相关的代码。\n\n创建文件 cancel/CancelToken.ts ：\n\nimport { CancelExecutor } from '../types'\n\ninterface ResolvePromise {\n  (reason?: string): void\n}\n\nexport default class CancelToken {\n  promise: Promise<string>\n  reason?: string\n\n  constructor(executor: CancelExecutor) {\n    let resolvePromise: ResolvePromise\n    this.promise = new Promise<string>(resolve => {\n      resolvePromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) return\n\n      this.reason = message\n      resolvePromise(this.reason)\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 在 CancelToken 构造函数内部，实例化一个 pending 状态的 Promise 对象，然后用一个 resolvePromise 变量指向 resolve 函数，接着执行 executor 函数，传入一个 cancel 函数，在 cancel 函数内部，调用 resolvePromise 把 Promise 对象 从 pending 变为 resolved 状态。\n\n接着在 src/core/xhr.ts 中添加取消请求的逻辑：\n\nconst { data = null, url, method = 'get', headers, responseType, timeout, cancelToken} = config\n\n\n1\n\n\n> 加入从 config 中获取 cancelToken 。\n\nif (cancelToken) {\n  cancelToken.promise.then(reason =>  {\n    request.abort()\n    reject(reason)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# CancelToken 拓展静态接口\n\n\n# 接口定义\n\n在 src/types/index.ts 中：\n\nexport interface CancelTokenSource {\n  token: CancelToken\n  cancel: Canceler\n}\n\nexport interface CancelTokenStatic{\n  new(executor: CancelExecutor): CancelToken\n  \n  source(): CancelTokenSource\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 其中 CancelTokenSource 作为 CancelToken 类静态方法 source 函数的返回值类型， CancelTokenStatic 作为 CancelToken 类的类类型。\n\n\n# 代码实现\n\n在 src/cancel/CancelToken.ts 中：\n\nexport default class CancelToken {\n  // ...\n  static source(): CancelTokenSource {\n    let cancel!: Canceler\n    const token = new CancelToken(c => {\n      cancel = c\n    })\n    return {\n      cancel,\n      token\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 在类中，添加一个 source 静态方法，定义一个 cancel 变量实例化一个 CancelToken 类型的对象，然后在 executor 函数中，把 cancel 指向参数 c 这个取消函数。\n> \n> 这样满足了需求分析中第一种使用方式，但是第一种使用方式的例子中，在捕获请求的时候，通过 axios.isCancel 来判断错误参数 e 是不是一次取消请求导致的错误。要对取消错误的原因做一层包装，并且给 axios 拓展静态方法。\n\n\n# Cancel 类的实现以及 axios 的拓展\n\n\n# 接口定义\n\nexport interface Cancel {\n  message?: string\n}\n\nexport interface CancelStatic {\n  new(message?: string): Cancel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nexport interface AxiosStatic extends AxiosInstance {\n  create(config?: AxiosRequestConfig): AxiosInstance\n  \n  CancelToken: CancelTokenStatic\n  Cancel: CancelStatic\n  isCancel: (value: any) => boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 其中 Cancel 是实例类型的接口定义； CancelStatic 是类类型的接口定义，并且要给 axios 拓展了多个静态方法。\n\n\n# 代码实现\n\n创建 src/cancel/Cancel.ts 文件：\n\nexport default class Cancel {\n  message?: string\n\n  constructor(message: string) {\n    this.message = message\n  }\n}\n\nexport function isCancel(value: any): boolean {\n  return value instanceof Cancel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> Cancel 类拥有一个 message 公共属性。 isCancel 方法通过 insanceof 来判断传入的值是不是一个 Cancel 对象。\n\n然后对 CancelToken 类中的 reason 类型做修改，把它变成一个 Cancel 类型的实例。\n\n修改定义： src/types/index.ts ：\n\nexport interface CancelToken {\n  promise: Promise<Cancel>\n  reason?: Cancel\n}\n\n\n1\n2\n3\n4\n\n\n然后修改实现部分， src/cancel/CancelToken.ts ：\n\ninterface ResolvePromise {\n  (reason?: Cancel): void\n}\n\n\n1\n2\n3\n\n\nexport default class CancelToken {\n  promise: Promise<Cancel>\n  reason?: Cancel\n\n  constructor(executor: CancelExecutor) {\n    let resolvePromise: ResolvePromise\n    this.promise = new Promise<Cancel>(resolve => {\n      resolvePromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) return\n\n      this.reason = new Cancel(message)\n      resolvePromise(this.reason)\n    })\n  }\n  \n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n然后给 aixos 拓展静态方法，提供用户使用：\n\nsrc/axios ：\n\nimport CancelToken from './cancel/CancelToken'\nimport Cancel, { isCancel } from './cancel/Cancel'\n\naxios.CancelToken = CancelToken\naxios.Cancel = Cancel\naxios.isCancel = isCancel\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 额外逻辑实现\n\n除此之外，还需要实现一些额外逻辑，比如当一个请求携带的 cancelToken 已经被使用过，那么甚至都可以不发送这个请求，直接跑出一个异常即可，并且抛异常的信息就是取消的原因，所以需要给 CancelToken 拓展一个方法。\n\n首先修改定义部分。\n\nsrc/types/index.ts ：\n\nexport interface CancelToken {\n  promise: Promise<Cancel>\n  reason?: Cancel\n\n  throwIfRequested(): void\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n然后实现这个方法：\n\nsrc/cancel/CancelToken.ts ：\n\nexport default class CancelToken {\n  // ... \n\n  throwIfRequested():void {\n    if(this.reason) throw this.reason\n  }\n  \n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 判断如果存在 this.reason ，说明这个 token 已经被使用过了，直接抛出错误即可。\n\n接下来在发送请求之前增加一段逻辑：\n\nsrc/core/dispatchRequest.ts ：\n\nexport default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {\n  throwIfCancellationRequested(config)\n  processConfig(config)\n\n  // ...\n}\n\nfunction throwIfCancellationRequested(config: AxiosRequestConfig): void {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 发送请求之前，需要检查一下配置的 cancelToken 是否被使用过了，如果被使用过就不用发送请求，直接抛出异常即可。\n\n\n# 编写测试 DEMO\n\nexamples/server.js 添加 router ：\n\nrouter.get('/cancel/get',function(req,res){\n  setTimeout(()=>{\n    res.json('hello')\n  },1000)\n})\n\nrouter.post('/cancel/post',function(req,res){\n  setTimeout(()=>{\n    res.json(req.body)\n  },1000)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\napp.ts ：\n\nimport axios, { Canceler } from '../../src'\n\nconst CancelToken = axios.CancelToken\nconst source = CancelToken.source()\n\naxios.get('/cancel/get', {\n  cancelToken: source.token\n}).catch(function(e) {\n  if (axios.isCancel(e)) {\n    console.log('Request canceled', e.message)\n  }\n})\n\n\nsetTimeout(() => {\n  source.cancel('Operation canceled by the user.')\n\n  axios.post('/cancel/post', { a: 1 }, { cancelToken: source.token }).catch(function(e) {\n    if (axios.isCancel(e)) {\n      console.log(e.message)\n    }\n  })\n}, 100)\n\n\nlet cancel: Canceler\n\naxios.get('/cancel/get', {\n  cancelToken: new CancelToken(c => {\n    cancel = c\n  })\n}).catch(function(e) {\n  if (axios.isCancel(e)) {\n    console.log('Request canceled')\n  }\n})\n\nsetTimeout(() => {\n  cancel()\n}, 200)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",normalizedContent:"# 需求分析\n\n在有些场景，希望能 主动取消请求。\n\n> 例如常见的搜索框案例，用户在输入过程中，输入框的内容不断变化。正常情况每次变化都应该向服务器发送一次请求。但是当用户输入过快的时候，不希望每次变化请求都会发送出去。通常解决方案是使用 防抖 延时发送请求。\n> \n> 但是有一种极端情况是，后段接口很慢，比如超过 1s 才会响应，这个时候及时做了 200ms 的防抖，在慢慢输入（每次输入间隔超过 200ms）的情况下，在前面的请求没有响应之前，也有可能发出多个请求。因为接口的响应时长不定，如果先发出去的请求响应时长比后发出去的请求要就，那么后请求的响应先回来，先请求的响应后回来，就会出现前面请求响应结果覆盖后面请求响应结果的情况，那么造成响应结果混乱。在这个场景下，除了做防抖，还希望后面的请求发送时，如果前面的请求还没有响应， 可以把前面的请求取消。\n\n从 axios 的取消接口设计层面，可以实现如下：\n\nconst canceltoken = axios.canceltoken;\nconst source = canceltoken.source();\n\naxios.get('/user/12345', {\n  canceltoken: source.token\n}).catch(function (e) {\n  if (axios.iscancel(e)) {\n    console.log('request canceled', e.message);\n  } else {\n    // 处理错误\n  }\n});\n\n// 取消请求 (请求原因是可选的)\nsource.cancel('operation canceled by the user.');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 给 axios 添加一个 canceltoken 对象，它有一个 source 方法返回一个 source 对象， source.token 是每一次请求的时候传给配置对象中的 canceltoken 属性，然后在请求中发出去后，可以通过 canceltoken 取消请求。\n\n或者支持另一种方式的调用：\n\nconst canceltoken = axios.canceltoken;\nlet cancel;\n\naxios.get('/user/12345', {\n  canceltoken: new canceltoken(function executor(c) {\n    cancel = c;\n  })\n});\n\ncancel()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> axios.canceltoken 是一个类，直接把它实例化的对象传给请求配置中的 canceltoken 属性， canceltoken 的构造函数参数支持传入一个 executor 方法，该方法的参数是一个取消函数 c ，可以在 executor 方法执行的内部拿到这个取消函数 c ，赋值给我们外部定义的 cancel 变量，之后可以通过调用这个 cancel 方法来取消请求。\n\n\n# 异步分离的设计方案\n\n通过需求分析，如果想要实现取消某次请求，需要为该请求配置一个 canceltoken ，然后在外部调用一个 cancel 方法。\n\n请求的发送是一个异步过程，最终会执行 xhr.send 方法， xhr 对象提供了 abort 方法，可以把请求取消。但是在外部碰不到 xhr 对象，要想执行 cancel 的时候，去执行 xhr.abort 方法。\n\n相当于在 xhr 异步请求的过程中，插入一段代码，当在外部执行 cancel 的函数的时候，回去懂这段代码的执行，然后执行 xhr.abort 方法取消请求。\n\n利用 promise 实现异步分离。也就是在 canceltoken 中保存一个 pending 状态的 promise 对象，然后当执行 cancel 方法时，能够访问搭配这个 promise 对象，把它从 pending 状态变成 resolved 状态。这样就可以在 then 中实现取消请求的逻辑。\n\n> 类似如下：\n> \n> if (canceltoken) {\n>   canceltoken.promise\n>   \t.then(reason => {\n>     \trequest.abort()\n>     \treject(reason)\n>   \t})\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n\n# canceltoken 类的实现\n\n\n# 接口定义\n\nsrc/types/index.ts ：\n\nexport interface axiosrequestconfig {\n\t// ...\n  canceltoken?: canceltoken\n}\n\n\n1\n2\n3\n4\n\n\nexport interface canceltoken {\n  promise: promise<string>\n  reason?: string\n}\n\nexport interface canceler {\n  (message?: string): void\n}\n\nexport interface cancelexecutor {\n  (cancel: canceler): void\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> canceltoken 是实例类型的接口定义， canceler 是取消方法的接口定义， cancelexecutor 是 canceltoken 类构造函数参数的接口定义。\n\n\n# 代码实现\n\n创建单独的目录管理 cancel 相关的代码。\n\n创建文件 cancel/canceltoken.ts ：\n\nimport { cancelexecutor } from '../types'\n\ninterface resolvepromise {\n  (reason?: string): void\n}\n\nexport default class canceltoken {\n  promise: promise<string>\n  reason?: string\n\n  constructor(executor: cancelexecutor) {\n    let resolvepromise: resolvepromise\n    this.promise = new promise<string>(resolve => {\n      resolvepromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) return\n\n      this.reason = message\n      resolvepromise(this.reason)\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 在 canceltoken 构造函数内部，实例化一个 pending 状态的 promise 对象，然后用一个 resolvepromise 变量指向 resolve 函数，接着执行 executor 函数，传入一个 cancel 函数，在 cancel 函数内部，调用 resolvepromise 把 promise 对象 从 pending 变为 resolved 状态。\n\n接着在 src/core/xhr.ts 中添加取消请求的逻辑：\n\nconst { data = null, url, method = 'get', headers, responsetype, timeout, canceltoken} = config\n\n\n1\n\n\n> 加入从 config 中获取 canceltoken 。\n\nif (canceltoken) {\n  canceltoken.promise.then(reason =>  {\n    request.abort()\n    reject(reason)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# canceltoken 拓展静态接口\n\n\n# 接口定义\n\n在 src/types/index.ts 中：\n\nexport interface canceltokensource {\n  token: canceltoken\n  cancel: canceler\n}\n\nexport interface canceltokenstatic{\n  new(executor: cancelexecutor): canceltoken\n  \n  source(): canceltokensource\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 其中 canceltokensource 作为 canceltoken 类静态方法 source 函数的返回值类型， canceltokenstatic 作为 canceltoken 类的类类型。\n\n\n# 代码实现\n\n在 src/cancel/canceltoken.ts 中：\n\nexport default class canceltoken {\n  // ...\n  static source(): canceltokensource {\n    let cancel!: canceler\n    const token = new canceltoken(c => {\n      cancel = c\n    })\n    return {\n      cancel,\n      token\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 在类中，添加一个 source 静态方法，定义一个 cancel 变量实例化一个 canceltoken 类型的对象，然后在 executor 函数中，把 cancel 指向参数 c 这个取消函数。\n> \n> 这样满足了需求分析中第一种使用方式，但是第一种使用方式的例子中，在捕获请求的时候，通过 axios.iscancel 来判断错误参数 e 是不是一次取消请求导致的错误。要对取消错误的原因做一层包装，并且给 axios 拓展静态方法。\n\n\n# cancel 类的实现以及 axios 的拓展\n\n\n# 接口定义\n\nexport interface cancel {\n  message?: string\n}\n\nexport interface cancelstatic {\n  new(message?: string): cancel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nexport interface axiosstatic extends axiosinstance {\n  create(config?: axiosrequestconfig): axiosinstance\n  \n  canceltoken: canceltokenstatic\n  cancel: cancelstatic\n  iscancel: (value: any) => boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 其中 cancel 是实例类型的接口定义； cancelstatic 是类类型的接口定义，并且要给 axios 拓展了多个静态方法。\n\n\n# 代码实现\n\n创建 src/cancel/cancel.ts 文件：\n\nexport default class cancel {\n  message?: string\n\n  constructor(message: string) {\n    this.message = message\n  }\n}\n\nexport function iscancel(value: any): boolean {\n  return value instanceof cancel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> cancel 类拥有一个 message 公共属性。 iscancel 方法通过 insanceof 来判断传入的值是不是一个 cancel 对象。\n\n然后对 canceltoken 类中的 reason 类型做修改，把它变成一个 cancel 类型的实例。\n\n修改定义： src/types/index.ts ：\n\nexport interface canceltoken {\n  promise: promise<cancel>\n  reason?: cancel\n}\n\n\n1\n2\n3\n4\n\n\n然后修改实现部分， src/cancel/canceltoken.ts ：\n\ninterface resolvepromise {\n  (reason?: cancel): void\n}\n\n\n1\n2\n3\n\n\nexport default class canceltoken {\n  promise: promise<cancel>\n  reason?: cancel\n\n  constructor(executor: cancelexecutor) {\n    let resolvepromise: resolvepromise\n    this.promise = new promise<cancel>(resolve => {\n      resolvepromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) return\n\n      this.reason = new cancel(message)\n      resolvepromise(this.reason)\n    })\n  }\n  \n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n然后给 aixos 拓展静态方法，提供用户使用：\n\nsrc/axios ：\n\nimport canceltoken from './cancel/canceltoken'\nimport cancel, { iscancel } from './cancel/cancel'\n\naxios.canceltoken = canceltoken\naxios.cancel = cancel\naxios.iscancel = iscancel\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 额外逻辑实现\n\n除此之外，还需要实现一些额外逻辑，比如当一个请求携带的 canceltoken 已经被使用过，那么甚至都可以不发送这个请求，直接跑出一个异常即可，并且抛异常的信息就是取消的原因，所以需要给 canceltoken 拓展一个方法。\n\n首先修改定义部分。\n\nsrc/types/index.ts ：\n\nexport interface canceltoken {\n  promise: promise<cancel>\n  reason?: cancel\n\n  throwifrequested(): void\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n然后实现这个方法：\n\nsrc/cancel/canceltoken.ts ：\n\nexport default class canceltoken {\n  // ... \n\n  throwifrequested():void {\n    if(this.reason) throw this.reason\n  }\n  \n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 判断如果存在 this.reason ，说明这个 token 已经被使用过了，直接抛出错误即可。\n\n接下来在发送请求之前增加一段逻辑：\n\nsrc/core/dispatchrequest.ts ：\n\nexport default function dispatchrequest(config: axiosrequestconfig): axiospromise {\n  throwifcancellationrequested(config)\n  processconfig(config)\n\n  // ...\n}\n\nfunction throwifcancellationrequested(config: axiosrequestconfig): void {\n  if (config.canceltoken) {\n    config.canceltoken.throwifrequested()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 发送请求之前，需要检查一下配置的 canceltoken 是否被使用过了，如果被使用过就不用发送请求，直接抛出异常即可。\n\n\n# 编写测试 demo\n\nexamples/server.js 添加 router ：\n\nrouter.get('/cancel/get',function(req,res){\n  settimeout(()=>{\n    res.json('hello')\n  },1000)\n})\n\nrouter.post('/cancel/post',function(req,res){\n  settimeout(()=>{\n    res.json(req.body)\n  },1000)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\napp.ts ：\n\nimport axios, { canceler } from '../../src'\n\nconst canceltoken = axios.canceltoken\nconst source = canceltoken.source()\n\naxios.get('/cancel/get', {\n  canceltoken: source.token\n}).catch(function(e) {\n  if (axios.iscancel(e)) {\n    console.log('request canceled', e.message)\n  }\n})\n\n\nsettimeout(() => {\n  source.cancel('operation canceled by the user.')\n\n  axios.post('/cancel/post', { a: 1 }, { canceltoken: source.token }).catch(function(e) {\n    if (axios.iscancel(e)) {\n      console.log(e.message)\n    }\n  })\n}, 100)\n\n\nlet cancel: canceler\n\naxios.get('/cancel/get', {\n  canceltoken: new canceltoken(c => {\n    cancel = c\n  })\n}).catch(function(e) {\n  if (axios.iscancel(e)) {\n    console.log('request canceled')\n  }\n})\n\nsettimeout(() => {\n  cancel()\n}, 200)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现权限相关功能",frontmatter:{title:"🌗 实现权限相关功能",date:"2022-06-17T13:02:46.000Z",permalink:"/pages/211982/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/44.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD.html",relativePath:"801. 💽 TypeScript-Axios/44. 🌗 实现权限相关功能.md",key:"v-d427c83c",path:"/pages/211982/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:287},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:808}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\n有时候需要发送一些跨域请求。默认情况下，浏览器会根据同源策略限制这种跨域请求，但是可以通过 CORS 技术解决跨域问题。\n\n在同域的情况下，发送请求会默认携带当前域下的 Cookie，但是在跨域的情况下，默认下不会携带请求域下的 Cookie。\n\n> 例如， http://domain-a.com 发送一个 http://api.domain-b.com/get 的请求，默认是不会携带 api.domain-b.com 域下的 Cookie。\n\n如果想携带，只需要设置请求的 xhr 对象的 withCredentials 为 true 即可。\n\n\n# 代码实现\n\n修改 AxiosRequestConfig 的类型定义，在 src/types/index.ts 中：\n\nexport interface AxiosRequestConfig {\n  // ...\n  \n  withCredentials?: boolean\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 添加一个 withCredentials 的标志。\n\n修改请求发送前的逻辑， src/core/xhr.ts ：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const { /* ... */ withCredentials} = config\n\n    //...\n    \n    if(withCredentials) {\n      request.withCredentials = true\n    }\n    \n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 编写测试 DEMO\n\n/examples/more/app.ts ：\n\nimport axios from '../../src'\n\naxios.get('/more/get').then(res => {\n  console.log(res)\n})\n\naxios\n  .post(\n    'http://127.0.0.1:8088/more/server2',\n    {},\n    {\n      withCredentials: true\n    }\n  )\n  .then(res => {\n    console.log(res)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n配置 examples/server.js 的 router ：\n\nrouter.get('/more/get',function(req,res){\n  res.json(req.cookies)\n})\n\n\n1\n2\n3\n\n\n为了测试跨域发送请求，创建新的一个 server2.js 跨域服务。\n\nconst express = require('express')\nconst bodyParser = require('body-parser')\nconst cookieParser = require('cookie-parser')\n\nconst app = express()\n\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\napp.use(cookieParser())\n\nconst router = express.Router()\n\nconst cors = {\n  'Access-Control-Allow-Origin': 'http://localhost:8080',\n  'Access-Control-Allow-Credentials': true,\n  'Access-Control-Allow-Methods': 'POST, GET, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type'\n}\n\nrouter.post('/more/server2', function(req,res) {\n  res.set(cors)\n  res.json(req.cookies)\n})\n\nrouter.options('/more/server2', function(req,res){\n  res.set(cors)\n  res.end()\n})\n\napp.use(router)\n\nconst port = 8080\nmodule.exports = app.listen(port)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> 为了携带 cookie，需要安装 cookie-parser 。\n> \n> 通过 demo 演示可以发现，对于同域请求，会携带 cookie；而对于跨域请求，只有配置了 withCredentials 为 true，才会携带 cookie。",normalizedContent:"# 需求分析\n\n有时候需要发送一些跨域请求。默认情况下，浏览器会根据同源策略限制这种跨域请求，但是可以通过 cors 技术解决跨域问题。\n\n在同域的情况下，发送请求会默认携带当前域下的 cookie，但是在跨域的情况下，默认下不会携带请求域下的 cookie。\n\n> 例如， http://domain-a.com 发送一个 http://api.domain-b.com/get 的请求，默认是不会携带 api.domain-b.com 域下的 cookie。\n\n如果想携带，只需要设置请求的 xhr 对象的 withcredentials 为 true 即可。\n\n\n# 代码实现\n\n修改 axiosrequestconfig 的类型定义，在 src/types/index.ts 中：\n\nexport interface axiosrequestconfig {\n  // ...\n  \n  withcredentials?: boolean\n}\n\n\n1\n2\n3\n4\n5\n\n\n> 添加一个 withcredentials 的标志。\n\n修改请求发送前的逻辑， src/core/xhr.ts ：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const { /* ... */ withcredentials} = config\n\n    //...\n    \n    if(withcredentials) {\n      request.withcredentials = true\n    }\n    \n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 编写测试 demo\n\n/examples/more/app.ts ：\n\nimport axios from '../../src'\n\naxios.get('/more/get').then(res => {\n  console.log(res)\n})\n\naxios\n  .post(\n    'http://127.0.0.1:8088/more/server2',\n    {},\n    {\n      withcredentials: true\n    }\n  )\n  .then(res => {\n    console.log(res)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n配置 examples/server.js 的 router ：\n\nrouter.get('/more/get',function(req,res){\n  res.json(req.cookies)\n})\n\n\n1\n2\n3\n\n\n为了测试跨域发送请求，创建新的一个 server2.js 跨域服务。\n\nconst express = require('express')\nconst bodyparser = require('body-parser')\nconst cookieparser = require('cookie-parser')\n\nconst app = express()\n\napp.use(bodyparser.json())\napp.use(bodyparser.urlencoded({ extended: true }))\napp.use(cookieparser())\n\nconst router = express.router()\n\nconst cors = {\n  'access-control-allow-origin': 'http://localhost:8080',\n  'access-control-allow-credentials': true,\n  'access-control-allow-methods': 'post, get, put, delete, options',\n  'access-control-allow-headers': 'content-type'\n}\n\nrouter.post('/more/server2', function(req,res) {\n  res.set(cors)\n  res.json(req.cookies)\n})\n\nrouter.options('/more/server2', function(req,res){\n  res.set(cors)\n  res.end()\n})\n\napp.use(router)\n\nconst port = 8080\nmodule.exports = app.listen(port)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> 为了携带 cookie，需要安装 cookie-parser 。\n> \n> 通过 demo 演示可以发现，对于同域请求，会携带 cookie；而对于跨域请求，只有配置了 withcredentials 为 true，才会携带 cookie。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现 XSRF 防御",frontmatter:{title:"🌗 实现 XSRF 防御",date:"2022-06-17T13:48:49.000Z",permalink:"/pages/767314/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/45.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%20XSRF%20%E9%98%B2%E5%BE%A1.html",relativePath:"801. 💽 TypeScript-Axios/45. 🌗 实现 XSRF 防御.md",key:"v-66e5c5d4",path:"/pages/767314/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:797},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:3482}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\n> XSRF 又名 CSRF，跨站请求伪造，它是前端常见的一种攻击方式。\n\nXSRF 防御的手段有很多。\n\n> 比如验证请求的 referer，但是 referer 也是可以伪造的；所以杜绝此类攻击的一种方式是服务器端要求每次请求都包含一个 token ，这个 token 不在前端生成，而是在我们每次访问站点的时候生成，并通过 set-cookie 的方式种到客户端，然后客户端发送请求的时候，从 cookie 中对应的字段读取出 token ，然后添加到请求 headers 中。这样服务端就可以从请求 headers 中读取这个 token 并验证，由于这个 token 是很难伪造的，所以就能区分这个请求是否是用户正常发起的。\n\n要自动实现完成这个操作，每次发送请求的时候，从 cookie 中读取相应的 token 值，然后添加到请求 headers 中。允许用户配置 xsrfCookieName 和 xsrfHeaderName ，其中 xsrfCookieName 表示存储 token 的 cookie 的名称； xsrfHeaderName 表示请求 headers 中 token 对应的 header 名称。\n\naxios.get('/more/get', {\n  xsrfCookieName: 'XSRF-TOKEN', // default\n  xsrfHeaderName: 'X-XSRF-TOKEN' // default\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以提供 xsrfCookieName 和 xsrfHeaderName 的默认值，当然用户也可以根据自己的需求在请求中去配置 xsrfCookieName 和 xsrfHeaderName 。\n\n\n# 代码实现\n\n首先修改 AxiosRequestConfig 的类型定义， src/types/index.ts ：\n\nexport interface AxiosRequestConfig {\n  url?: string\n  method?: Method\n  data?: any\n  params?: any\n  headers?: any\n  responseType?: XMLHttpRequestResponseType\n  timeout?: number\n  transformRequest?: AxiosTransformer | AxiosTransformer[]\n  transformResponse?: AxiosTransformer | AxiosTransformer[]\n\n  [propName: string]: any\n\n  cancelToken?: CancelToken\n  withCredentials?: boolean\n  xsrfCookieName?: string\n  xsrfHeaderName?: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n接着修改默认配置， src/defaults.ts ：\n\nconst defaults: AxiosRequestConfig = {\n  // ...\n  \n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN'\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n接着要完成三件事：\n\n * 首先判断如果是 withCredentials 为 true ，或者同域请求，才会在请求 headers 中添加 xsrf 相关的字段；\n * 如果判断成功，尝试从 cookie 中读取 xsrf 的 token 值；\n * 如果能读取到，则把它添加到请求 headers 中的 xsrf 字段中；\n\n首先实现同域请求的判断，在 src/helpers/url.ts ：\n\ninterface URLOrigin {\n  protocol: string\n  host: string\n}\n\nconst urlParsingNode = document.createElement('a')\nconst currentOrigin = resolveURL(window.location.href)\n\nfunction resolveURL(url: string): URLOrigin {\n  urlParsingNode.setAttribute('href', url)\n  const { protocol, host } = urlParsingNode\n\n  return {\n    protocol,\n    host\n  }\n}\n\nexport function isURLSameOrigin(requestURL: string): boolean {\n  const parsedOrigin = resolveURL(requestURL)\n\n  return parsedOrigin.protocol === currentOrigin.protocol && parsedOrigin.host === currentOrigin.host\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 先创建一个 a 标签的 DOM，然后设置 href 属性为传入的 URL ，然后可以获取该 DOM 的 protocol 、 host 。当前页面的 url 和请求的 url 都通过这种方式获取，然后对比它们的 protocol 和 host 即可判断是否同域。\n\n然后实现 cookie 的读取， src/helpers/cookie.ts ：\n\nconst cookie = {\n  read(name: string): string | null {\n    const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'))\n    return match ? decodeURIComponent(match[3]) : null\n  }\n}\n\nexport default cookie\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 实现 cookie 的读取，利用了 正则表达式 可以解析到 name 对应的 值。\n\n最后实现完整的逻辑， src/core/xhr.ts ：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const {\n      data = null,\n      url,\n      method = 'get',\n      headers,\n      responseType,\n      timeout,\n      cancelToken,\n      withCredentials,\n      xsrfCookieName,\n      xsrfHeaderName\n    } = config\n\n  \t// ...\n\n    if ((withCredentials || isURLSameOrigin(url!)) && xsrfCookieName) {\n      const xsrfValue = cookie.read(xsrfCookieName)\n      if (xsrfValue) headers[xsrfHeaderName!] = xsrfValue\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 要同时检测是否携带 withCredentials 以及是否同域，是否存在 xsrfCookieName 。\n\n\n# 编写测试 DEMO\n\n在 examples/server.js 中添加：\n\napp.use(express.static(__dirname, {\n  setHeaders(res) {\n    res.cookie('XSRF-TOKEN-D', '1234abc')\n  }\n}))\n\n\n1\n2\n3\n4\n5\n\n\n然后在 exmample/more/app.ts 中添加：\n\nconst instance = axios.create({\n  xsrfCookieName: 'XSRF-TOKEN-D',\n  xsrfHeaderName: 'X-XSRF-TOKEN-D'\n})\n\ninstance.get('/more/get').then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 在访问页面的时候，服务端通过 set-cookie 往客户端种了 key 为 XSRF-TOKEN ，值为 1234abc 的 cookie ，作为 xsrf 的 token 值。\n> \n> 然后在前端发送请求的时候，就能从 cookie 中读出 key 为 XSRF-TOKEN 的值，然后把它添加到 key 为 X-XSRF-TOKEN 的请求 headers 中。",normalizedContent:"# 需求分析\n\n> xsrf 又名 csrf，跨站请求伪造，它是前端常见的一种攻击方式。\n\nxsrf 防御的手段有很多。\n\n> 比如验证请求的 referer，但是 referer 也是可以伪造的；所以杜绝此类攻击的一种方式是服务器端要求每次请求都包含一个 token ，这个 token 不在前端生成，而是在我们每次访问站点的时候生成，并通过 set-cookie 的方式种到客户端，然后客户端发送请求的时候，从 cookie 中对应的字段读取出 token ，然后添加到请求 headers 中。这样服务端就可以从请求 headers 中读取这个 token 并验证，由于这个 token 是很难伪造的，所以就能区分这个请求是否是用户正常发起的。\n\n要自动实现完成这个操作，每次发送请求的时候，从 cookie 中读取相应的 token 值，然后添加到请求 headers 中。允许用户配置 xsrfcookiename 和 xsrfheadername ，其中 xsrfcookiename 表示存储 token 的 cookie 的名称； xsrfheadername 表示请求 headers 中 token 对应的 header 名称。\n\naxios.get('/more/get', {\n  xsrfcookiename: 'xsrf-token', // default\n  xsrfheadername: 'x-xsrf-token' // default\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 可以提供 xsrfcookiename 和 xsrfheadername 的默认值，当然用户也可以根据自己的需求在请求中去配置 xsrfcookiename 和 xsrfheadername 。\n\n\n# 代码实现\n\n首先修改 axiosrequestconfig 的类型定义， src/types/index.ts ：\n\nexport interface axiosrequestconfig {\n  url?: string\n  method?: method\n  data?: any\n  params?: any\n  headers?: any\n  responsetype?: xmlhttprequestresponsetype\n  timeout?: number\n  transformrequest?: axiostransformer | axiostransformer[]\n  transformresponse?: axiostransformer | axiostransformer[]\n\n  [propname: string]: any\n\n  canceltoken?: canceltoken\n  withcredentials?: boolean\n  xsrfcookiename?: string\n  xsrfheadername?: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n接着修改默认配置， src/defaults.ts ：\n\nconst defaults: axiosrequestconfig = {\n  // ...\n  \n  xsrfcookiename: 'xsrf-token',\n  xsrfheadername: 'x-xsrf-token'\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n接着要完成三件事：\n\n * 首先判断如果是 withcredentials 为 true ，或者同域请求，才会在请求 headers 中添加 xsrf 相关的字段；\n * 如果判断成功，尝试从 cookie 中读取 xsrf 的 token 值；\n * 如果能读取到，则把它添加到请求 headers 中的 xsrf 字段中；\n\n首先实现同域请求的判断，在 src/helpers/url.ts ：\n\ninterface urlorigin {\n  protocol: string\n  host: string\n}\n\nconst urlparsingnode = document.createelement('a')\nconst currentorigin = resolveurl(window.location.href)\n\nfunction resolveurl(url: string): urlorigin {\n  urlparsingnode.setattribute('href', url)\n  const { protocol, host } = urlparsingnode\n\n  return {\n    protocol,\n    host\n  }\n}\n\nexport function isurlsameorigin(requesturl: string): boolean {\n  const parsedorigin = resolveurl(requesturl)\n\n  return parsedorigin.protocol === currentorigin.protocol && parsedorigin.host === currentorigin.host\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 先创建一个 a 标签的 dom，然后设置 href 属性为传入的 url ，然后可以获取该 dom 的 protocol 、 host 。当前页面的 url 和请求的 url 都通过这种方式获取，然后对比它们的 protocol 和 host 即可判断是否同域。\n\n然后实现 cookie 的读取， src/helpers/cookie.ts ：\n\nconst cookie = {\n  read(name: string): string | null {\n    const match = document.cookie.match(new regexp('(^|;\\\\s*)(' + name + ')=([^;]*)'))\n    return match ? decodeuricomponent(match[3]) : null\n  }\n}\n\nexport default cookie\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 实现 cookie 的读取，利用了 正则表达式 可以解析到 name 对应的 值。\n\n最后实现完整的逻辑， src/core/xhr.ts ：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const {\n      data = null,\n      url,\n      method = 'get',\n      headers,\n      responsetype,\n      timeout,\n      canceltoken,\n      withcredentials,\n      xsrfcookiename,\n      xsrfheadername\n    } = config\n\n  \t// ...\n\n    if ((withcredentials || isurlsameorigin(url!)) && xsrfcookiename) {\n      const xsrfvalue = cookie.read(xsrfcookiename)\n      if (xsrfvalue) headers[xsrfheadername!] = xsrfvalue\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 要同时检测是否携带 withcredentials 以及是否同域，是否存在 xsrfcookiename 。\n\n\n# 编写测试 demo\n\n在 examples/server.js 中添加：\n\napp.use(express.static(__dirname, {\n  setheaders(res) {\n    res.cookie('xsrf-token-d', '1234abc')\n  }\n}))\n\n\n1\n2\n3\n4\n5\n\n\n然后在 exmample/more/app.ts 中添加：\n\nconst instance = axios.create({\n  xsrfcookiename: 'xsrf-token-d',\n  xsrfheadername: 'x-xsrf-token-d'\n})\n\ninstance.get('/more/get').then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 在访问页面的时候，服务端通过 set-cookie 往客户端种了 key 为 xsrf-token ，值为 1234abc 的 cookie ，作为 xsrf 的 token 值。\n> \n> 然后在前端发送请求的时候，就能从 cookie 中读出 key 为 xsrf-token 的值，然后把它添加到 key 为 x-xsrf-token 的请求 headers 中。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现上传和下载进度监控",frontmatter:{title:"🌗 实现上传和下载进度监控",date:"2022-06-17T14:43:23.000Z",permalink:"/pages/2871e0/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/46.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6%E7%9B%91%E6%8E%A7.html",relativePath:"801. 💽 TypeScript-Axios/46. 🌗 实现上传和下载进度监控.md",key:"v-8ca31366",path:"/pages/2871e0/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:492},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:5754}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\n当需要上传文件或者请求一个大体积数据时，希望知道实时的进度，或者一个进度条展示。\n\n可以给 axios 的请求配置提供一个 onDownloadProgress 和 onUploadProgress 两个函数属性，用户通过这两个函数实现对下载进度和上传进度的监控。\n\n> 例如：\n> \n> axios.get('/more/get',{\n>   onDownloadProgress(progressEvent) {\n>     // 监听下载进度\n>   }\n> })\n> \n> axios.post('/more/post',{\n>   onUploadProgress(progressEvent) {\n>     // 监听上传进度\n>   }\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\nxhr 对象提供了一个 progress 事件，可以通过监听这个事件对数据的下载进度做监控。另外， xhr.upload 对象也提供了 progress 事件，可以基于此对上传进度做监控。\n\n\n# 代码实现\n\n修改 AxiosRequestConfig 的类型定义， src/types/index.ts ：\n\nexport interface AxiosRequestConfig {\n \t// ... \n  onDownloadProgress?: (e: ProgressEvent) => void\n  onUploadProgress?: (e: ProgressEvent) => void\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后修改 src/core/xhr.ts ，在发送请求之前，给 xhr 对象添加属性：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const {\n      // ...\n      onDownloadProgress,\n      onUploadProgress\n    } = config\n\n    // ...\n    \n    if(onDownloadProgress) {\n      request.onprogress = onDownloadProgress\n    }\n    \n    if(onUploadProgress) {\n      request.onprogress = onUploadProgress\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n另外，如果请求的数据是 FormData 类型，应该主动删除请求 headers 中的 Content-Type 字段，让浏览器自动根据请求数据设置 Content-Type 。比如当通过 FormData 上传文件的时候，浏览器会把请求 headers 中的 Content-Type 设置为 multipart/form-data 。\n\n先添加一个判断 FormData 的方法，在 src/helpers/util.ts ：\n\nexport function isFormData(val: any): boolean {\n  return typeof val !== 'undefined' && val instanceof FormData\n}\n\n\n1\n2\n3\n\n\n然后再添加逻辑到 src/core/xhr.ts ：\n\nif(isFormData(data)) {\n  delete headers['Content-Type']\n}\n\n\n1\n2\n3\n\n\nxhr.ts 随着需求越来越多，代码越来越臃肿，可以把逻辑梳理一下，把内部代码做一层封装优化。\n\n点击查看\n\nimport { AxiosPromise, AxiosRequestConfig, AxiosResponse } from '../types'\nimport { parseHeaders } from '../helpers/headers'\nimport { createError } from '../helpers/error'\nimport { isURLSameOrigin } from '../helpers/url'\nimport cookie from '../helpers/cookie'\nimport { isFormData } from '../helpers/util'\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const {\n      data = null,\n      url,\n      method = 'get',\n      headers,\n      responseType,\n      timeout,\n      cancelToken,\n      withCredentials,\n      xsrfCookieName,\n      xsrfHeaderName,\n      onDownloadProgress,\n      onUploadProgress\n    } = config\n\n    const request = new XMLHttpRequest()\n\n    request.open(method.toUpperCase(), url, true)\n\n    configureRequest()\n    addEvents()\n    processHeaders()\n    processCancel()\n\n    request.send(data)\n\n    function configureRequest(): void {\n      if (responseType) {\n        request.responseType = responseType\n      }\n\n      if (timeout) {\n        request.timeout = timeout\n      }\n\n      if (withCredentials) {\n        request.withCredentials = true\n      }\n    }\n\n    function addEvents(): void {\n      request.onreadystatechange = function handleLoad() {\n        if (request.readyState !== 4) return\n        if (request.status === 0) return\n\n        const responseHeaders = parseHeaders(request.getAllResponseHeaders())\n        const responseData =\n          responseType && responseType !== 'text' ? request.response : request.responseText\n        const response: AxiosResponse = {\n          data: responseData,\n          status: request.status,\n          statusText: request.statusText,\n          headers: responseHeaders,\n          config,\n          request\n        }\n\n        handleResponse(response)\n      }\n\n      request.onerror = function handleError() {\n        reject(createError('Network Error', config, null, request))\n      }\n\n      request.ontimeout = function handleTimeout() {\n        reject(createError(`Timeout of ${timeout} ms exceeded`, config, 'ECONNABORTED', request))\n      }\n\n      if (onDownloadProgress) {\n        request.onprogress = onDownloadProgress\n      }\n\n      if (onUploadProgress) {\n        request.onprogress = onUploadProgress\n      }\n    }\n\n    function processHeaders(): void {\n      if (isFormData(data)) {\n        delete headers['Content-Type']\n      }\n\n      if ((withCredentials || isURLSameOrigin(url!)) && xsrfCookieName) {\n        const xsrfValue = cookie.read(xsrfCookieName)\n        if (xsrfValue) headers[xsrfHeaderName!] = xsrfValue\n      }\n\n      Object.keys(headers).forEach(name => {\n        if (data === null && name.toLowerCase() === 'content-type') {\n          delete headers[name]\n        } else {\n          request.setRequestHeader(name, headers[name])\n        }\n      })\n    }\n\n    function processCancel(): void {\n      if (cancelToken) {\n        cancelToken.promise.then(reason => {\n          request.abort()\n          reject(reason)\n        })\n      }\n    }\n\n    function handleResponse(response: AxiosResponse) {\n      if (response.status >= 200 && response.status < 300) {\n        resolve(response)\n      } else {\n        reject(\n          createError(\n            `Request failed with status code ${response.status}`,\n            config,\n            null,\n            request,\n            response\n          )\n        )\n      }\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n\n\n> 把整个流程分为 7 部：\n> \n>  * 创建一个 request 实例。\n>  * 执行 request.open 方法初始化。\n>  * 执行 configureRequest 配置 request 对象。\n>  * 执行 addEvents 给 request 添加事件处理函数。\n>  * 执行 processHeaders 处理请求 headers 。\n>  * 执行 processCancel 处理请求取消逻辑。\n>  * 执行 request.send 方法发送请求。\n\n\n# 编写测试 DEMO\n\nexamples/more/index.html ：\n\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n  <meta charset='UTF-8'>\n  <title>more example</title>\n  <link rel='stylesheet' type='text/css'\n        href='//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' />\n</head>\n<body>\n<h1>file download</h1>\n<div>\n  <button id='download' class='btn btn-primary'>download</button>\n</div>\n\n<h1>file upload</h1>\n<div>\n  <form role='form' class='form' onsubmit='return false'>\n    <input type='file' id='title' class='form-control'>\n    <button id='upload' class='btn btn-primary'>upload</button>\n  </form>\n</div>\n<script src='/__build__/more.js'><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 添加下载按钮和上传表单。\n\nexamples/more/app.ts ，为了展示上传和下载的进度，引入 nprogress ，在页面的顶部展示进度条：\n\nconst instance = axios.create()\n\nfunction calculatePercentage(loaded: number, total: number) {\n  return Math.floor(loaded * 1.0) / total\n}\n\nfunction loadProgressbar() {\n  const setupStartProgress = () => {\n    instance.interceptors.request.use(config => {\n      NProgress.start()\n      return config\n    })\n  }\n\n  const setupUpdateProgress = () => {\n    const update = (e: ProgressEvent) => {\n      console.log(e)\n      NProgress.set(calculatePercentage(e.loaded, e.total))\n    }\n\n    instance.defaults.onDownloadProgress = update\n    instance.defaults.onUploadProgress = update\n  }\n\n  const setupStopProgress = () => {\n    instance.interceptors.response.use(response => {\n      NProgress.done()\n      return response\n    }, error => {\n      NProgress.done()\n      return Promise.reject(error)\n    })\n  }\n\n  setupStartProgress()\n  setupUpdateProgress()\n  setupStopProgress()\n}\n\nloadProgressbar()\n\nconst downloadEl = document.getElementById('download')\ndownloadEl!.addEventListener('click', e => {\n  instance.get('https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/jSQm90.jpeg')\n})\n\nconst uploadEl = document.getElementById('upload')\nuploadEl!.addEventListener('click', e => {\n  const data = new FormData()\n  const fileEl = document.getElementById('file') as HTMLInputElement\n  if(fileEl.files) {\n    data.append('file', fileEl.files[0])\n\n    instance.post('/more/upload', data)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n> 对于 progress 事件参数 e ，会有 e.total 和 e.loaded 属性，表示进程总体的工作量和已经执行的工作量，可以根据这 2 个值算出当前进度，然后通过 Nprogess.set 设置。另外，通过配置请求拦截器和响应拦截器执行 NProgress.start() 和 NProgress.done() 。\n> \n> 给下载按钮绑定了一个 click 事件，请求一张图片，可以看到实时的进度；另外也给上传按钮绑定了一个 click 事件，上传选择的文件，同样也能看到实时进度。\n\n为了处理上传请求，需要下载安装一个 express 的中间件 connect-multiparty ，然后使用它。\n\nexamples/server.js ：\n\nconst multipart = require('connect-multiparty')\napp.use(multipart({\n  uploadDir: path.resolve(__dirname, 'upload-file')\n}))\n\nrouter.post('more/upload', function(req, res) {\n  console.log(req.body, req.files)\n  res.end('upload success!')\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 需要在 examples 目录下创建一个文件夹 upload-file 作为上传文件的存储目录。通过这个中间件，就可以处理上传请求并且可以把上传的文件存储在 upload-file 目录下。\n> \n> 为了保证代码正常运行，我们还需要在 examples/webpack.config.js 中添加 css-loader 和 css-loader ，不要忘记先安装它们。\n> \n> {\n>   test: /\\.css?$/,\n>   use: [\n>     {\n>       loader: ['style-loader', 'css-loader']\n>     }\n>   ]\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8",normalizedContent:"# 需求分析\n\n当需要上传文件或者请求一个大体积数据时，希望知道实时的进度，或者一个进度条展示。\n\n可以给 axios 的请求配置提供一个 ondownloadprogress 和 onuploadprogress 两个函数属性，用户通过这两个函数实现对下载进度和上传进度的监控。\n\n> 例如：\n> \n> axios.get('/more/get',{\n>   ondownloadprogress(progressevent) {\n>     // 监听下载进度\n>   }\n> })\n> \n> axios.post('/more/post',{\n>   onuploadprogress(progressevent) {\n>     // 监听上传进度\n>   }\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\nxhr 对象提供了一个 progress 事件，可以通过监听这个事件对数据的下载进度做监控。另外， xhr.upload 对象也提供了 progress 事件，可以基于此对上传进度做监控。\n\n\n# 代码实现\n\n修改 axiosrequestconfig 的类型定义， src/types/index.ts ：\n\nexport interface axiosrequestconfig {\n \t// ... \n  ondownloadprogress?: (e: progressevent) => void\n  onuploadprogress?: (e: progressevent) => void\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后修改 src/core/xhr.ts ，在发送请求之前，给 xhr 对象添加属性：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const {\n      // ...\n      ondownloadprogress,\n      onuploadprogress\n    } = config\n\n    // ...\n    \n    if(ondownloadprogress) {\n      request.onprogress = ondownloadprogress\n    }\n    \n    if(onuploadprogress) {\n      request.onprogress = onuploadprogress\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n另外，如果请求的数据是 formdata 类型，应该主动删除请求 headers 中的 content-type 字段，让浏览器自动根据请求数据设置 content-type 。比如当通过 formdata 上传文件的时候，浏览器会把请求 headers 中的 content-type 设置为 multipart/form-data 。\n\n先添加一个判断 formdata 的方法，在 src/helpers/util.ts ：\n\nexport function isformdata(val: any): boolean {\n  return typeof val !== 'undefined' && val instanceof formdata\n}\n\n\n1\n2\n3\n\n\n然后再添加逻辑到 src/core/xhr.ts ：\n\nif(isformdata(data)) {\n  delete headers['content-type']\n}\n\n\n1\n2\n3\n\n\nxhr.ts 随着需求越来越多，代码越来越臃肿，可以把逻辑梳理一下，把内部代码做一层封装优化。\n\n点击查看\n\nimport { axiospromise, axiosrequestconfig, axiosresponse } from '../types'\nimport { parseheaders } from '../helpers/headers'\nimport { createerror } from '../helpers/error'\nimport { isurlsameorigin } from '../helpers/url'\nimport cookie from '../helpers/cookie'\nimport { isformdata } from '../helpers/util'\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const {\n      data = null,\n      url,\n      method = 'get',\n      headers,\n      responsetype,\n      timeout,\n      canceltoken,\n      withcredentials,\n      xsrfcookiename,\n      xsrfheadername,\n      ondownloadprogress,\n      onuploadprogress\n    } = config\n\n    const request = new xmlhttprequest()\n\n    request.open(method.touppercase(), url, true)\n\n    configurerequest()\n    addevents()\n    processheaders()\n    processcancel()\n\n    request.send(data)\n\n    function configurerequest(): void {\n      if (responsetype) {\n        request.responsetype = responsetype\n      }\n\n      if (timeout) {\n        request.timeout = timeout\n      }\n\n      if (withcredentials) {\n        request.withcredentials = true\n      }\n    }\n\n    function addevents(): void {\n      request.onreadystatechange = function handleload() {\n        if (request.readystate !== 4) return\n        if (request.status === 0) return\n\n        const responseheaders = parseheaders(request.getallresponseheaders())\n        const responsedata =\n          responsetype && responsetype !== 'text' ? request.response : request.responsetext\n        const response: axiosresponse = {\n          data: responsedata,\n          status: request.status,\n          statustext: request.statustext,\n          headers: responseheaders,\n          config,\n          request\n        }\n\n        handleresponse(response)\n      }\n\n      request.onerror = function handleerror() {\n        reject(createerror('network error', config, null, request))\n      }\n\n      request.ontimeout = function handletimeout() {\n        reject(createerror(`timeout of ${timeout} ms exceeded`, config, 'econnaborted', request))\n      }\n\n      if (ondownloadprogress) {\n        request.onprogress = ondownloadprogress\n      }\n\n      if (onuploadprogress) {\n        request.onprogress = onuploadprogress\n      }\n    }\n\n    function processheaders(): void {\n      if (isformdata(data)) {\n        delete headers['content-type']\n      }\n\n      if ((withcredentials || isurlsameorigin(url!)) && xsrfcookiename) {\n        const xsrfvalue = cookie.read(xsrfcookiename)\n        if (xsrfvalue) headers[xsrfheadername!] = xsrfvalue\n      }\n\n      object.keys(headers).foreach(name => {\n        if (data === null && name.tolowercase() === 'content-type') {\n          delete headers[name]\n        } else {\n          request.setrequestheader(name, headers[name])\n        }\n      })\n    }\n\n    function processcancel(): void {\n      if (canceltoken) {\n        canceltoken.promise.then(reason => {\n          request.abort()\n          reject(reason)\n        })\n      }\n    }\n\n    function handleresponse(response: axiosresponse) {\n      if (response.status >= 200 && response.status < 300) {\n        resolve(response)\n      } else {\n        reject(\n          createerror(\n            `request failed with status code ${response.status}`,\n            config,\n            null,\n            request,\n            response\n          )\n        )\n      }\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n\n\n> 把整个流程分为 7 部：\n> \n>  * 创建一个 request 实例。\n>  * 执行 request.open 方法初始化。\n>  * 执行 configurerequest 配置 request 对象。\n>  * 执行 addevents 给 request 添加事件处理函数。\n>  * 执行 processheaders 处理请求 headers 。\n>  * 执行 processcancel 处理请求取消逻辑。\n>  * 执行 request.send 方法发送请求。\n\n\n# 编写测试 demo\n\nexamples/more/index.html ：\n\n<!doctype html>\n<html lang='en'>\n<head>\n  <meta charset='utf-8'>\n  <title>more example</title>\n  <link rel='stylesheet' type='text/css'\n        href='//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' />\n</head>\n<body>\n<h1>file download</h1>\n<div>\n  <button id='download' class='btn btn-primary'>download</button>\n</div>\n\n<h1>file upload</h1>\n<div>\n  <form role='form' class='form' onsubmit='return false'>\n    <input type='file' id='title' class='form-control'>\n    <button id='upload' class='btn btn-primary'>upload</button>\n  </form>\n</div>\n<script src='/__build__/more.js'><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 添加下载按钮和上传表单。\n\nexamples/more/app.ts ，为了展示上传和下载的进度，引入 nprogress ，在页面的顶部展示进度条：\n\nconst instance = axios.create()\n\nfunction calculatepercentage(loaded: number, total: number) {\n  return math.floor(loaded * 1.0) / total\n}\n\nfunction loadprogressbar() {\n  const setupstartprogress = () => {\n    instance.interceptors.request.use(config => {\n      nprogress.start()\n      return config\n    })\n  }\n\n  const setupupdateprogress = () => {\n    const update = (e: progressevent) => {\n      console.log(e)\n      nprogress.set(calculatepercentage(e.loaded, e.total))\n    }\n\n    instance.defaults.ondownloadprogress = update\n    instance.defaults.onuploadprogress = update\n  }\n\n  const setupstopprogress = () => {\n    instance.interceptors.response.use(response => {\n      nprogress.done()\n      return response\n    }, error => {\n      nprogress.done()\n      return promise.reject(error)\n    })\n  }\n\n  setupstartprogress()\n  setupupdateprogress()\n  setupstopprogress()\n}\n\nloadprogressbar()\n\nconst downloadel = document.getelementbyid('download')\ndownloadel!.addeventlistener('click', e => {\n  instance.get('https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/jsqm90.jpeg')\n})\n\nconst uploadel = document.getelementbyid('upload')\nuploadel!.addeventlistener('click', e => {\n  const data = new formdata()\n  const fileel = document.getelementbyid('file') as htmlinputelement\n  if(fileel.files) {\n    data.append('file', fileel.files[0])\n\n    instance.post('/more/upload', data)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n> 对于 progress 事件参数 e ，会有 e.total 和 e.loaded 属性，表示进程总体的工作量和已经执行的工作量，可以根据这 2 个值算出当前进度，然后通过 nprogess.set 设置。另外，通过配置请求拦截器和响应拦截器执行 nprogress.start() 和 nprogress.done() 。\n> \n> 给下载按钮绑定了一个 click 事件，请求一张图片，可以看到实时的进度；另外也给上传按钮绑定了一个 click 事件，上传选择的文件，同样也能看到实时进度。\n\n为了处理上传请求，需要下载安装一个 express 的中间件 connect-multiparty ，然后使用它。\n\nexamples/server.js ：\n\nconst multipart = require('connect-multiparty')\napp.use(multipart({\n  uploaddir: path.resolve(__dirname, 'upload-file')\n}))\n\nrouter.post('more/upload', function(req, res) {\n  console.log(req.body, req.files)\n  res.end('upload success!')\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 需要在 examples 目录下创建一个文件夹 upload-file 作为上传文件的存储目录。通过这个中间件，就可以处理上传请求并且可以把上传的文件存储在 upload-file 目录下。\n> \n> 为了保证代码正常运行，我们还需要在 examples/webpack.config.js 中添加 css-loader 和 css-loader ，不要忘记先安装它们。\n> \n> {\n>   test: /\\.css?$/,\n>   use: [\n>     {\n>       loader: ['style-loader', 'css-loader']\n>     }\n>   ]\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现 HTTP 授权",frontmatter:{title:"🌗 实现 HTTP 授权",date:"2022-06-17T16:08:44.000Z",permalink:"/pages/441f8f/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/47.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%20HTTP%20%E6%8E%88%E6%9D%83.html",relativePath:"801. 💽 TypeScript-Axios/47. 🌗 实现 HTTP 授权.md",key:"v-0d7e111b",path:"/pages/441f8f/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:540},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:1384}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\n在 HTTP 协议中的 Authorization 请求 header 会包含服务器用于验证用户代理身份的凭证，通常会在服务器返回 401 （Unauthorized 状态码） 以及 WWW-Authenticate 消息头之后在后续请求中发送此消息头。\n\naxios 库允许在请求配置中配置 auth 属性， auth 是一个对象结构，包含 username 和 password 两个属性。一旦用户在请求的时候配置这两个属性，就会自动往 HTTP 的请求 header 中添加一个 Authorization 属性，它的值为 Basic 加密串（ username:password base64 加密后的结果）。\n\n> 🌰 使用例子：\n> \n> axios.post('/more/post', {\n>   a: 1\n> }, {\n>   auth: {\n>     username: 'Yee',\n>     password: '123456'\n>   }\n> }).then(res => {\n>   console.log(res)\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n\n# 代码实现\n\n修改 AxiosRequestConfig 类型定义， src/types/index.ts ：\n\nexport interface AxiosRequestConfig {\n  // ...\n  auth?: AxiosBasicCredentials\n}\n\nexport interface AxiosBasicCredentials {\n  username: string\n  password: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n修改合并规则，因为 auth 是一个对象格式，它的合并规则应该是 deepMergeStrat ，添加到 stratKeysDeepMerge ：\n\n（ src/core/mergeConfig.ts ）\n\nconst stratKeysDeepMerge = ['headers', 'auth']\n\n\n1\n\n\n然后修改发送请求之前的逻辑（ src/core/xhr.ts ）：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const {\n\t\t\t// ...\n      auth\n    } = config\n\n    // ...\n    \n    function configureRequest(): void {\n      // ...\n\n      if (auth) {\n        headers['Authorization'] = 'Basic' + btoa(auth.username + ':' + auth.password)\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 编写测试 DEMO\n\nexamples/server.js ：\n\nrouter.post('/more/post',function(req,res){\n  const auth = req.headers.authorization\n  const [type,credentials] = auth.split(' ')\n  console.log(atob(credentials))\n  const [username,password] = atob(credentials).split(':')\n  if(type === 'Basic' && username === 'sunib' && password === '123456'){\n    res.json(req.body)\n  }else{\n    res.status(401)\n    res.end('UnAuthorization')\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 需要安装 atob 实现 base64 串的解码。\n\nexamples/more/app.ts ：\n\naxios\n  .post(\n    '/more/post',\n    {\n      a: 1\n    },\n    {\n      auth: {\n        username: 'simon',\n        password: '123456'\n      }\n    }\n  )\n  .then(res => {\n    console.log(res)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# 需求分析\n\n在 http 协议中的 authorization 请求 header 会包含服务器用于验证用户代理身份的凭证，通常会在服务器返回 401 （unauthorized 状态码） 以及 www-authenticate 消息头之后在后续请求中发送此消息头。\n\naxios 库允许在请求配置中配置 auth 属性， auth 是一个对象结构，包含 username 和 password 两个属性。一旦用户在请求的时候配置这两个属性，就会自动往 http 的请求 header 中添加一个 authorization 属性，它的值为 basic 加密串（ username:password base64 加密后的结果）。\n\n> 🌰 使用例子：\n> \n> axios.post('/more/post', {\n>   a: 1\n> }, {\n>   auth: {\n>     username: 'yee',\n>     password: '123456'\n>   }\n> }).then(res => {\n>   console.log(res)\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n\n# 代码实现\n\n修改 axiosrequestconfig 类型定义， src/types/index.ts ：\n\nexport interface axiosrequestconfig {\n  // ...\n  auth?: axiosbasiccredentials\n}\n\nexport interface axiosbasiccredentials {\n  username: string\n  password: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n修改合并规则，因为 auth 是一个对象格式，它的合并规则应该是 deepmergestrat ，添加到 stratkeysdeepmerge ：\n\n（ src/core/mergeconfig.ts ）\n\nconst stratkeysdeepmerge = ['headers', 'auth']\n\n\n1\n\n\n然后修改发送请求之前的逻辑（ src/core/xhr.ts ）：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const {\n\t\t\t// ...\n      auth\n    } = config\n\n    // ...\n    \n    function configurerequest(): void {\n      // ...\n\n      if (auth) {\n        headers['authorization'] = 'basic' + btoa(auth.username + ':' + auth.password)\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 编写测试 demo\n\nexamples/server.js ：\n\nrouter.post('/more/post',function(req,res){\n  const auth = req.headers.authorization\n  const [type,credentials] = auth.split(' ')\n  console.log(atob(credentials))\n  const [username,password] = atob(credentials).split(':')\n  if(type === 'basic' && username === 'sunib' && password === '123456'){\n    res.json(req.body)\n  }else{\n    res.status(401)\n    res.end('unauthorization')\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 需要安装 atob 实现 base64 串的解码。\n\nexamples/more/app.ts ：\n\naxios\n  .post(\n    '/more/post',\n    {\n      a: 1\n    },\n    {\n      auth: {\n        username: 'simon',\n        password: '123456'\n      }\n    }\n  )\n  .then(res => {\n    console.log(res)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现自定义合法状态码",frontmatter:{title:"🌗 实现自定义合法状态码",date:"2022-06-17T16:09:07.000Z",permalink:"/pages/97d131/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/48.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%88%E6%B3%95%E7%8A%B6%E6%80%81%E7%A0%81.html",relativePath:"801. 💽 TypeScript-Axios/48. 🌗 实现自定义合法状态码.md",key:"v-75371f4a",path:"/pages/97d131/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:457},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:1622}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\n在之前处理响应结果中， 认为 HTTP 响应码在 200 - 300 之间是一个合法值，在这个区间之外创建一个错误。有时候想自定义这个规则，比如认为 304 也是一个合法的状态码。所以希望能提供一个配置，允许自定义合法状态码的规则。\n\n> 如下：\n> \n> axios.get('/more/304', {\n>   validateStatus(status) {\n>     return status >= 200 && status < 400\n>   }\n> }).then(res => {\n>   console.log(res)\n> }).catch((e: AxiosError) => {\n>   console.log(e.message)\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> \n> \n> 通过在请求配置中配置一个 validateStatus 函数，可以根据参数 status 来自定义合法状态码的规则。\n\n\n# 代码实现\n\n修改 AxiosRequestConfig 类型定义：\n\nexport interface AxiosRequestConfig {\n  // ...\n  \n  validateStatus?: (status: number) => boolean\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后修改默认配置规则， src/defaults.ts ：\n\nconst defaults: AxiosRequestConfig = {\n  \n  // ...\n  \n  validateStatus(status: number): boolean {\n    return status >= 200 && status < 300\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 添加一个默认的合法状态码的校验规则，然后再请求后对相应数据的处理逻辑。\n\n修改 src/core/xhr.ts ：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const {\n      // ...\n      validateStatus\n    } = config\n\n    function handleResponse(response: AxiosResponse) {\n      if (!validateStatus || validateStatus(response.status)) {\n        resolve(response)\n      } else {\n        reject(\n          createError(\n            `Request failed with status code ${response.status}`,\n            config,\n            null,\n            request,\n            response\n          )\n        )\n      }\n    }\n\t)}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 将 validateStatus 用于响应状态判断。如果没有配置 validateStatus 以及 validateStatus 函数返回值为 true 的时候，都认为是合法的，正常 resolve(response) ，否则创建一个错误。\n\n\n# 编写测试 DEMO\n\nexamples/more/app.ts ：\n\naxios\n  .get('/more/304')\n  .then(res => {\n    console.log(res)\n  })\n  .catch((e: AxiosError) => {\n    console.log(e.message)\n  })\n\naxios\n  .get('/more/304', {\n    validateStatus(status) {\n      return status >= 200 && status < 400\n    }\n  })\n  .then(res => {\n    console.log(res)\n  })\n  .catch((e: AxiosError) => {\n    console.log(e.message)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nexamples/server.js ：\n\nrouter.get('/more/304', function(req,res){\n  res.status(304)\n  res.end\n})\n\n\n1\n2\n3\n4\n\n\n> 接口返回 304 状态码。对于默认的请求会输出一条错误信息。在配置了自定义合法状态码的规则后，成功响应状态码的区间在 200 ~ 400 之间，这样不会报错，可以正常输出响应对象。",normalizedContent:"# 需求分析\n\n在之前处理响应结果中， 认为 http 响应码在 200 - 300 之间是一个合法值，在这个区间之外创建一个错误。有时候想自定义这个规则，比如认为 304 也是一个合法的状态码。所以希望能提供一个配置，允许自定义合法状态码的规则。\n\n> 如下：\n> \n> axios.get('/more/304', {\n>   validatestatus(status) {\n>     return status >= 200 && status < 400\n>   }\n> }).then(res => {\n>   console.log(res)\n> }).catch((e: axioserror) => {\n>   console.log(e.message)\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> \n> \n> 通过在请求配置中配置一个 validatestatus 函数，可以根据参数 status 来自定义合法状态码的规则。\n\n\n# 代码实现\n\n修改 axiosrequestconfig 类型定义：\n\nexport interface axiosrequestconfig {\n  // ...\n  \n  validatestatus?: (status: number) => boolean\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后修改默认配置规则， src/defaults.ts ：\n\nconst defaults: axiosrequestconfig = {\n  \n  // ...\n  \n  validatestatus(status: number): boolean {\n    return status >= 200 && status < 300\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 添加一个默认的合法状态码的校验规则，然后再请求后对相应数据的处理逻辑。\n\n修改 src/core/xhr.ts ：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const {\n      // ...\n      validatestatus\n    } = config\n\n    function handleresponse(response: axiosresponse) {\n      if (!validatestatus || validatestatus(response.status)) {\n        resolve(response)\n      } else {\n        reject(\n          createerror(\n            `request failed with status code ${response.status}`,\n            config,\n            null,\n            request,\n            response\n          )\n        )\n      }\n    }\n\t)}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 将 validatestatus 用于响应状态判断。如果没有配置 validatestatus 以及 validatestatus 函数返回值为 true 的时候，都认为是合法的，正常 resolve(response) ，否则创建一个错误。\n\n\n# 编写测试 demo\n\nexamples/more/app.ts ：\n\naxios\n  .get('/more/304')\n  .then(res => {\n    console.log(res)\n  })\n  .catch((e: axioserror) => {\n    console.log(e.message)\n  })\n\naxios\n  .get('/more/304', {\n    validatestatus(status) {\n      return status >= 200 && status < 400\n    }\n  })\n  .then(res => {\n    console.log(res)\n  })\n  .catch((e: axioserror) => {\n    console.log(e.message)\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nexamples/server.js ：\n\nrouter.get('/more/304', function(req,res){\n  res.status(304)\n  res.end\n})\n\n\n1\n2\n3\n4\n\n\n> 接口返回 304 状态码。对于默认的请求会输出一条错误信息。在配置了自定义合法状态码的规则后，成功响应状态码的区间在 200 ~ 400 之间，这样不会报错，可以正常输出响应对象。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现 baseURL",frontmatter:{title:"🌗 实现 baseURL",date:"2022-06-17T16:09:40.000Z",permalink:"/pages/206979/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/50.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%20baseURL.html",relativePath:"801. 💽 TypeScript-Axios/50. 🌗 实现 baseURL.md",key:"v-1240e29a",path:"/pages/206979/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:367},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:1120}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\n有些时候，需要请求某个域名下的多个接口，不想每次都在发送请求的时候都填写完整的 URL，所以可以配置一个 baseURL 之后可以穿相对的路径。\n\n> 🌰 使用例子：\n> \n> const instance = axios.create({\n>   baseURL: 'https://some-domain.com/api'\n> })\n> \n> instance.get('/get')\n> \n> instance.post('/post')\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 一旦配置了 baseURL ，之后传入的请求 URL 都会与 baseURL 拼接成完成的绝对地址，除非传入的 URL 是绝对地址。\n\n所以要检验请求 URL 是否为绝对地址。\n\n\n# 代码实现\n\n修改 AxiosRequestConfig 的类型定义：\n\nexport interface AxiosRequestConfig {\n  // ...\n  baseURL?: string\n}\n\n\n1\n2\n3\n4\n\n\n在 src/helpers/url.ts 中实现两个辅助函数：\n\nexport function isAbsoluteURL(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n\nexport function combineURL(baseURL: string, relativeURL?: string): string {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在 core/dispatchRequest.ts 中调用：\n\nfunction transformURL(config: AxiosRequestConfig): any {\n  let { url, params, paramsSerializer, baseURL } = config\n  if(baseURL && !isAbsoluteURL(url!)) {\n    url = combineURL(baseURL, url)\n  }\n  return buildURL(url!, params, paramsSerializer)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 编写测试 DEMO\n\nexamples/more/app.ts ：\n\nconst instance = axios.create({\n  baseURL: 'https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/'\n})\n\ninstance.get('D4kLn9.png')\n\ninstance.get('https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/EGVR9A.png')\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 需求分析\n\n有些时候，需要请求某个域名下的多个接口，不想每次都在发送请求的时候都填写完整的 url，所以可以配置一个 baseurl 之后可以穿相对的路径。\n\n> 🌰 使用例子：\n> \n> const instance = axios.create({\n>   baseurl: 'https://some-domain.com/api'\n> })\n> \n> instance.get('/get')\n> \n> instance.post('/post')\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 一旦配置了 baseurl ，之后传入的请求 url 都会与 baseurl 拼接成完成的绝对地址，除非传入的 url 是绝对地址。\n\n所以要检验请求 url 是否为绝对地址。\n\n\n# 代码实现\n\n修改 axiosrequestconfig 的类型定义：\n\nexport interface axiosrequestconfig {\n  // ...\n  baseurl?: string\n}\n\n\n1\n2\n3\n4\n\n\n在 src/helpers/url.ts 中实现两个辅助函数：\n\nexport function isabsoluteurl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n\nexport function combineurl(baseurl: string, relativeurl?: string): string {\n  return relativeurl ? baseurl.replace(/\\/+$/, '') + '/' + relativeurl.replace(/^\\/+/, '') : baseurl\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在 core/dispatchrequest.ts 中调用：\n\nfunction transformurl(config: axiosrequestconfig): any {\n  let { url, params, paramsserializer, baseurl } = config\n  if(baseurl && !isabsoluteurl(url!)) {\n    url = combineurl(baseurl, url)\n  }\n  return buildurl(url!, params, paramsserializer)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 编写测试 demo\n\nexamples/more/app.ts ：\n\nconst instance = axios.create({\n  baseurl: 'https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/'\n})\n\ninstance.get('d4kln9.png')\n\ninstance.get('https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/egvr9a.png')\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌗 实现自定义参数序列化",frontmatter:{title:"🌗 实现自定义参数序列化",date:"2022-06-17T16:09:27.000Z",permalink:"/pages/d6c1c4/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/49.%20%F0%9F%8C%97%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E5%BA%8F%E5%88%97%E5%8C%96.html",relativePath:"801. 💽 TypeScript-Axios/49. 🌗 实现自定义参数序列化.md",key:"v-7a859bad",path:"/pages/d6c1c4/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:542},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:2554}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\n目前为止，对于请求的 URL 的参数做了处理，可以解析传入的 params 对象，根据一定的规则把它们解析成字符串，然后添加到 URL 后面。在解析的过程中，会对字符串 encode ，但是对于一些特殊字符却不会转义，这时 axios 默认的解析规则。\n\n当给定自定义的解析规则，希望能在请求配置中允许配置一个 paramsSerializer 函数来自定义参数的解析规则，该函数接受 params 参数，返回值作为解析后的结果。\n\n> 🌰 使用例子：\n> \n> axios.get('/more/get', {\n>   params: {\n>     a: 1,\n>     b: 2,\n>     c: ['a', 'b', 'c']\n>   },\n>   paramsSerializer(params) {\n>     return qs.stringify(params, { arrayFormat: 'brackets' })\n>   }\n> }).then(res => {\n>   console.log(res)\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n\n\n# 代码实现\n\n修改 AxiosRequestConfig\n\nexport interface AxiosRequestConfig {\n  // ...\n  paramsSerializer?: (params: any) => string\n}\n\n\n1\n2\n3\n4\n\n\n然后修改 src/helpers/url.ts 中 buildURL 函数的实现：\n\nexport function buildURL(\n  url: string,\n  params?: any,\n  paramsSerializer?: (params: any) => string\n): string {\n  if (!params) return url\n\n  let serializedParams\n  if(paramsSerializer) {\n    serializedParams = paramsSerializer(params)\n  } else if (isURLSearchParams(params)) {\n    serializedParams = params.toString()\n  } else {\n    const parts: string[] = []\n\n    Object.keys(params).forEach(key => {\n      const val = params[key]\n      if (val === null || typeof val === 'undefined') {\n        return\n      }\n      let values = []\n      if (Array.isArray(val)) {\n        values = val\n        key += '[]'\n      } else {\n        values = [val]\n      }\n      values.forEach(val => {\n        if (isDate(val)) {\n          val = val.toISOString()\n        } else if (isPlainObject(val)) {\n          val = JSON.stringify(val)\n        }\n        parts.push(`${encode(key)}=${encode(val)}`)\n      })\n    })\n\n    serializedParams = parts.join('&')\n  }\n\n  if(serializedParams) {\n    const markIndex = url.indexOf('#')\n    if(markIndex !== -1) {\n      url = url.slice(0, markIndex)\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams\n  }\n  \n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n> 给 buildURL 函数新增了 paramsSerializer 可选参数。另外还对 params 的类型进行判断，如果是一个 URLSearchParams 对象实例的话， 直接返回它 toString 之后的结果。\n\n在 src/helpers/util.ts 中：\n\nexport function isURLSearchParams(val: any): val is URLSearchParams {\n  return typeof val !== 'undefined' && val instanceof URLSearchParams\n}\n\n\n1\n2\n3\n\n\n最后在 src/core/dispatchRequest.ts 中修改 buildURL 的逻辑：\n\nfunction transformURL(config: AxiosRequestConfig): any {\n  const { url, params, paramsSerializer } = config\n  return buildURL(url, params, paramsSerializer)\n}\n\n\n1\n2\n3\n4\n\n\n\n# 编写测试 DEMO\n\nexamples/more/app.ts ：\n\naxios.get('/more/get', {\n  params: new URLSearchParams('a=b&c=d')\n}).then(res => {\n  console.log(res)\n})\n\naxios.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\nconst instance = axios.create({\n  paramsSerializer(params) {\n    return qs.stringify(params, { arrayFormat: 'brackets' })\n  }\n})\n\ninstance.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> 分别是三种情况，首先第一种满足请求的 params 参数是 URLSearchParams 对象类型的。后两种请求的结果区别在于前者没有对 [] 特殊符号进行转义。",normalizedContent:"# 需求分析\n\n目前为止，对于请求的 url 的参数做了处理，可以解析传入的 params 对象，根据一定的规则把它们解析成字符串，然后添加到 url 后面。在解析的过程中，会对字符串 encode ，但是对于一些特殊字符却不会转义，这时 axios 默认的解析规则。\n\n当给定自定义的解析规则，希望能在请求配置中允许配置一个 paramsserializer 函数来自定义参数的解析规则，该函数接受 params 参数，返回值作为解析后的结果。\n\n> 🌰 使用例子：\n> \n> axios.get('/more/get', {\n>   params: {\n>     a: 1,\n>     b: 2,\n>     c: ['a', 'b', 'c']\n>   },\n>   paramsserializer(params) {\n>     return qs.stringify(params, { arrayformat: 'brackets' })\n>   }\n> }).then(res => {\n>   console.log(res)\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n\n\n# 代码实现\n\n修改 axiosrequestconfig\n\nexport interface axiosrequestconfig {\n  // ...\n  paramsserializer?: (params: any) => string\n}\n\n\n1\n2\n3\n4\n\n\n然后修改 src/helpers/url.ts 中 buildurl 函数的实现：\n\nexport function buildurl(\n  url: string,\n  params?: any,\n  paramsserializer?: (params: any) => string\n): string {\n  if (!params) return url\n\n  let serializedparams\n  if(paramsserializer) {\n    serializedparams = paramsserializer(params)\n  } else if (isurlsearchparams(params)) {\n    serializedparams = params.tostring()\n  } else {\n    const parts: string[] = []\n\n    object.keys(params).foreach(key => {\n      const val = params[key]\n      if (val === null || typeof val === 'undefined') {\n        return\n      }\n      let values = []\n      if (array.isarray(val)) {\n        values = val\n        key += '[]'\n      } else {\n        values = [val]\n      }\n      values.foreach(val => {\n        if (isdate(val)) {\n          val = val.toisostring()\n        } else if (isplainobject(val)) {\n          val = json.stringify(val)\n        }\n        parts.push(`${encode(key)}=${encode(val)}`)\n      })\n    })\n\n    serializedparams = parts.join('&')\n  }\n\n  if(serializedparams) {\n    const markindex = url.indexof('#')\n    if(markindex !== -1) {\n      url = url.slice(0, markindex)\n    }\n\n    url += (url.indexof('?') === -1 ? '?' : '&') + serializedparams\n  }\n  \n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n> 给 buildurl 函数新增了 paramsserializer 可选参数。另外还对 params 的类型进行判断，如果是一个 urlsearchparams 对象实例的话， 直接返回它 tostring 之后的结果。\n\n在 src/helpers/util.ts 中：\n\nexport function isurlsearchparams(val: any): val is urlsearchparams {\n  return typeof val !== 'undefined' && val instanceof urlsearchparams\n}\n\n\n1\n2\n3\n\n\n最后在 src/core/dispatchrequest.ts 中修改 buildurl 的逻辑：\n\nfunction transformurl(config: axiosrequestconfig): any {\n  const { url, params, paramsserializer } = config\n  return buildurl(url, params, paramsserializer)\n}\n\n\n1\n2\n3\n4\n\n\n\n# 编写测试 demo\n\nexamples/more/app.ts ：\n\naxios.get('/more/get', {\n  params: new urlsearchparams('a=b&c=d')\n}).then(res => {\n  console.log(res)\n})\n\naxios.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\nconst instance = axios.create({\n  paramsserializer(params) {\n    return qs.stringify(params, { arrayformat: 'brackets' })\n  }\n})\n\ninstance.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> 分别是三种情况，首先第一种满足请求的 params 参数是 urlsearchparams 对象类型的。后两种请求的结果区别在于前者没有对 [] 特殊符号进行转义。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 单元测试 Jest 的使用",frontmatter:{title:"🌖 单元测试 Jest 的使用",date:"2022-06-17T23:57:07.000Z",permalink:"/pages/4b46b1/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/70.%20%F0%9F%8C%96%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20Jest%20%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"801. 💽 TypeScript-Axios/70. 🌖 单元测试 Jest 的使用.md",key:"v-6f3304ca",path:"/pages/4b46b1/",headers:[{level:2,title:"安装使用 Jest",slug:"安装使用-jest",normalizedTitle:"安装使用 jest",charIndex:91},{level:3,title:"Jest 配置",slug:"jest-配置",normalizedTitle:"jest 配置",charIndex:198}],headersStr:"安装使用 Jest Jest 配置",content:'>  * Jest 官网。它是 Facebook 出品的一个测试框架，相对其他测试框架，它的一大特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n\n# 安装使用 Jest\n\n> 由于 typescript-library-starter 已经内置 jest 。可以使用以下命令重新安装更新到新的版本：\n> \n> $ npm i jest\n> \n> \n> 1\n\n\n# Jest 配置\n\n点击查看\n\n在 package.json 中的 jest 相关配置：\n\n"jest": {\n  "transform": {\n    ".(ts|tsx)": "ts-jest"\n  },\n  "testEnvironment": "node",\n  "testRegex": "(/__tests__/.*|\\\\.(test|spec))\\\\.(ts|tsx|js)$",\n  "moduleFileExtensions": [\n    "ts",\n    "tsx",\n    "js"\n  ],\n  "coveragePathIgnorePatterns": [\n    "/node_modules/",\n    "/test/"\n  ],\n  "coverageThreshold": {\n    "global": {\n      "branches": 90,\n      "functions": 95,\n      "lines": 95,\n      "statements": 95\n    }\n  },\n  "collectCoverageFrom": [\n    "src/*.{js,ts}"\n  ]\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n相关配置的含义：\n\n * transform ：转换器配置。这里表示的就是使用 ts-jest 工具把 .ts 和 .tsx 文件内容转换成 JavaScript，因为使用 TypeScript 编写测试代码，而 Node.js 是不能直接支持 TypeScript 的，所以需要配置转换器。\n\n * testEnvironment ：测试环境。表示它是一个类浏览器的测试环境，可以使用浏览器环境中的一些 API。\n\n * testRegex ：测试文件的正则表达式。包含的文件格式。\n\n * moduleFileExtensions ：模块文件扩展名，当去引入一个模块并没有指定扩展名的时候，它会依次尝试去添加这些扩展名去找你引入的模块文件。\n\n * coverageThreshold ：测试覆盖率的阈值设定。当测试覆盖率达不到阈值的时候，测试会失败。\n\n * collectCoverageFrom ：收集指定文件的测试覆盖率 (即使你没为这些文件编写测试)，它的值为 glob patterns 类型。\n\n额外配置：\n\n"setupFilesAfterEnv": [\n  "<rootDir>/test/boot.ts"\n]\n\n\n1\n2\n3\n\n * setupFilesAfterEnv ：测试框架安装后立即执行的代码文件列表。表示每次跑具体测试代码之前会先运行 <rootDir>/test/boot.ts 中的代码， <rootDir> 表示当前项目的根目录。',normalizedContent:'>  * jest 官网。它是 facebook 出品的一个测试框架，相对其他测试框架，它的一大特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n\n# 安装使用 jest\n\n> 由于 typescript-library-starter 已经内置 jest 。可以使用以下命令重新安装更新到新的版本：\n> \n> $ npm i jest\n> \n> \n> 1\n\n\n# jest 配置\n\n点击查看\n\n在 package.json 中的 jest 相关配置：\n\n"jest": {\n  "transform": {\n    ".(ts|tsx)": "ts-jest"\n  },\n  "testenvironment": "node",\n  "testregex": "(/__tests__/.*|\\\\.(test|spec))\\\\.(ts|tsx|js)$",\n  "modulefileextensions": [\n    "ts",\n    "tsx",\n    "js"\n  ],\n  "coveragepathignorepatterns": [\n    "/node_modules/",\n    "/test/"\n  ],\n  "coveragethreshold": {\n    "global": {\n      "branches": 90,\n      "functions": 95,\n      "lines": 95,\n      "statements": 95\n    }\n  },\n  "collectcoveragefrom": [\n    "src/*.{js,ts}"\n  ]\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n相关配置的含义：\n\n * transform ：转换器配置。这里表示的就是使用 ts-jest 工具把 .ts 和 .tsx 文件内容转换成 javascript，因为使用 typescript 编写测试代码，而 node.js 是不能直接支持 typescript 的，所以需要配置转换器。\n\n * testenvironment ：测试环境。表示它是一个类浏览器的测试环境，可以使用浏览器环境中的一些 api。\n\n * testregex ：测试文件的正则表达式。包含的文件格式。\n\n * modulefileextensions ：模块文件扩展名，当去引入一个模块并没有指定扩展名的时候，它会依次尝试去添加这些扩展名去找你引入的模块文件。\n\n * coveragethreshold ：测试覆盖率的阈值设定。当测试覆盖率达不到阈值的时候，测试会失败。\n\n * collectcoveragefrom ：收集指定文件的测试覆盖率 (即使你没为这些文件编写测试)，它的值为 glob patterns 类型。\n\n额外配置：\n\n"setupfilesafterenv": [\n  "<rootdir>/test/boot.ts"\n]\n\n\n1\n2\n3\n\n * setupfilesafterenv ：测试框架安装后立即执行的代码文件列表。表示每次跑具体测试代码之前会先运行 <rootdir>/test/boot.ts 中的代码， <rootdir> 表示当前项目的根目录。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌓 静态方法拓展",frontmatter:{title:"🌓 静态方法拓展",date:"2022-06-17T16:09:56.000Z",permalink:"/pages/9850cb/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/60.%20%F0%9F%8C%93%20%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%8B%93%E5%B1%95.html",relativePath:"801. 💽 TypeScript-Axios/60. 🌓 静态方法拓展.md",key:"v-032678fa",path:"/pages/9850cb/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:1548},{level:2,title:"编写测试 DEMO",slug:"编写测试-demo",normalizedTitle:"编写测试 demo",charIndex:2477}],headersStr:"需求分析 代码实现 编写测试 DEMO",content:"# 需求分析\n\naxios 还有 axios.all 、 axios.spread 等方法。\n\n> 🌰 使用例子：\n> \n> function getUserAccount() {\n>   return axios.get('/user/12345');\n> }\n> \n> function getUserPermissions() {\n>   return axios.get('/user/12345/permissions');\n> }\n> \n> axios.all([getUserAccount(), getUserPermissions()])\n>   .then(axios.spread(function (acct, perms) {\n>     // Both requests are now complete\n>   }));\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 实际上， axios.all 就是 Promise.all 的封装，它返回的是一个 Promise 数组， then 函数的参数本应是一个参数为 Promise resolves （数组）的函数，在这里使用了 axios.spread 方法。所以 axios.spread 方法是接收一个函数，返回一个新的函数，新函数的结构满足 then 函数的参数结构。\n\n> 其实使用 Promise 依旧可以完成这个需求。\n> \n> function getUserAccount() {\n>   return axios.get('/user/12345');\n> }\n> \n> function getUserPermissions() {\n>   return axios.get('/user/12345/permissions');\n> }\n> \n> Promise.all([getUserAccount(), getUserPermissions()])\n>   .then(([acct,perms]) {\n>     // Both requests are now complete\n>   }));\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 在 Promise.all 的 resolve 函数中，可以直接通过数组的解构拿到每个请求对应的响应对象。\n\n为了与 axios 库能保持一致，所以要实现这两个方法。并且 axios 库中通过 axios.Axios 对外暴露了 Axios 类。还有提供 getUri 方法在不发送请求的前提下根据传入的配置返回一个 url ：\n\n> 🌰 使用例子：\n> \n> const fakeConfig = {\n>   baseURL: 'https://www.baidu.com/',\n>   url: '/user/12345',\n>   params: {\n>     idClient: 1,\n>     idTest: 2,\n>     testString: 'thisIsATest'\n>   }\n> }\n> console.log(axios.getUri(fakeConfig))\n> // https://www.baidu.com/user/12345?idClient=1&idTest=2&testString=thisIsATest\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n\n# 代码实现\n\n修改类型定义（ types/index.ts ）：\n\nexport interface AxiosClassStatic {\n  new (config: AxiosRequestConfig): Axios\n}\n\nexport interface AxiosStatic extends AxiosInstance {\n  // ...\n\n  all<T>(promises: Array<T | Promise<T>>): Promise<T[]>\n\n  spread<T, R>(callback: (...args: T[]) => R): (arr: T[]) => R\n\n  Axios: AxiosClassStatic\n}\n\nexport interface Axios {\n  // ...\n\n  getUri(config?: AxiosRequestConfig): string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n然后实现这几个静态方法：\n\naxios.all = function all(promises) {\n  return Promise.all(promises)\n}\n\naxios.spread = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr)\n  }\n}\n\naxios.Axios = axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后给 Axios 添加实例方法 getUri ：\n\ngetUri(config?: AxiosRequestConfig): string {\n  config = mergeConfig(this.defaults, config)\n  return transformURL(config)\n}\n\n\n1\n2\n3\n4\n\n\n> 先使 config 与默认配置合并，然后再通过 transformURL 返回完整的 URL。\n\n\n# 编写测试 DEMO\n\nexamples/more/app.ts ：\n\nfunction getA() {\n  return axios.get('/more/A')\n}\n\nfunction getB() {\n  return axios.get('/more/B')\n}\n\naxios.all([getA(), getB()]).then(([resA, resB]) => {\n  console.log(resA.data)\n  console.log(resB.data)\n})\n\nconst fakeConfig = {\n  baseURL: 'https://www.baidu.com/',\n  url: '/user/12345',\n  params: {\n    idClient: 1,\n    idTest: 2,\n    testString: 'thisIsATest'\n  }\n}\nconsole.log(axios.getUri(fakeConfig))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 通过 axios.all 同时发出两个请求，返回了 Promise 数组，可以在 axios.spread 参数函数中获得结果，也可直接在 then 函数中拿到结果。",normalizedContent:"# 需求分析\n\naxios 还有 axios.all 、 axios.spread 等方法。\n\n> 🌰 使用例子：\n> \n> function getuseraccount() {\n>   return axios.get('/user/12345');\n> }\n> \n> function getuserpermissions() {\n>   return axios.get('/user/12345/permissions');\n> }\n> \n> axios.all([getuseraccount(), getuserpermissions()])\n>   .then(axios.spread(function (acct, perms) {\n>     // both requests are now complete\n>   }));\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 实际上， axios.all 就是 promise.all 的封装，它返回的是一个 promise 数组， then 函数的参数本应是一个参数为 promise resolves （数组）的函数，在这里使用了 axios.spread 方法。所以 axios.spread 方法是接收一个函数，返回一个新的函数，新函数的结构满足 then 函数的参数结构。\n\n> 其实使用 promise 依旧可以完成这个需求。\n> \n> function getuseraccount() {\n>   return axios.get('/user/12345');\n> }\n> \n> function getuserpermissions() {\n>   return axios.get('/user/12345/permissions');\n> }\n> \n> promise.all([getuseraccount(), getuserpermissions()])\n>   .then(([acct,perms]) {\n>     // both requests are now complete\n>   }));\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> \n> \n> 在 promise.all 的 resolve 函数中，可以直接通过数组的解构拿到每个请求对应的响应对象。\n\n为了与 axios 库能保持一致，所以要实现这两个方法。并且 axios 库中通过 axios.axios 对外暴露了 axios 类。还有提供 geturi 方法在不发送请求的前提下根据传入的配置返回一个 url ：\n\n> 🌰 使用例子：\n> \n> const fakeconfig = {\n>   baseurl: 'https://www.baidu.com/',\n>   url: '/user/12345',\n>   params: {\n>     idclient: 1,\n>     idtest: 2,\n>     teststring: 'thisisatest'\n>   }\n> }\n> console.log(axios.geturi(fakeconfig))\n> // https://www.baidu.com/user/12345?idclient=1&idtest=2&teststring=thisisatest\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n\n# 代码实现\n\n修改类型定义（ types/index.ts ）：\n\nexport interface axiosclassstatic {\n  new (config: axiosrequestconfig): axios\n}\n\nexport interface axiosstatic extends axiosinstance {\n  // ...\n\n  all<t>(promises: array<t | promise<t>>): promise<t[]>\n\n  spread<t, r>(callback: (...args: t[]) => r): (arr: t[]) => r\n\n  axios: axiosclassstatic\n}\n\nexport interface axios {\n  // ...\n\n  geturi(config?: axiosrequestconfig): string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n然后实现这几个静态方法：\n\naxios.all = function all(promises) {\n  return promise.all(promises)\n}\n\naxios.spread = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr)\n  }\n}\n\naxios.axios = axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后给 axios 添加实例方法 geturi ：\n\ngeturi(config?: axiosrequestconfig): string {\n  config = mergeconfig(this.defaults, config)\n  return transformurl(config)\n}\n\n\n1\n2\n3\n4\n\n\n> 先使 config 与默认配置合并，然后再通过 transformurl 返回完整的 url。\n\n\n# 编写测试 demo\n\nexamples/more/app.ts ：\n\nfunction geta() {\n  return axios.get('/more/a')\n}\n\nfunction getb() {\n  return axios.get('/more/b')\n}\n\naxios.all([geta(), getb()]).then(([resa, resb]) => {\n  console.log(resa.data)\n  console.log(resb.data)\n})\n\nconst fakeconfig = {\n  baseurl: 'https://www.baidu.com/',\n  url: '/user/12345',\n  params: {\n    idclient: 1,\n    idtest: 2,\n    teststring: 'thisisatest'\n  }\n}\nconsole.log(axios.geturi(fakeconfig))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 通过 axios.all 同时发出两个请求，返回了 promise 数组，可以在 axios.spread 参数函数中获得结果，也可直接在 then 函数中拿到结果。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 辅助模块单元测试",frontmatter:{title:"🌖 辅助模块单元测试",date:"2022-06-17T20:15:29.000Z",permalink:"/pages/73c2b6/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/71.%20%F0%9F%8C%96%20%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/71. 🌖 辅助模块单元测试.md",key:"v-29a02ce2",path:"/pages/73c2b6/",headers:[{level:2,title:"准备工作",slug:"准备工作",normalizedTitle:"准备工作",charIndex:2},{level:2,title:"各个模块测试代码编写",slug:"各个模块测试代码编写",normalizedTitle:"各个模块测试代码编写",charIndex:256},{level:3,title:"util 模块测试",slug:"util-模块测试",normalizedTitle:"util 模块测试",charIndex:271},{level:3,title:"cookie 模块测试",slug:"cookie-模块测试",normalizedTitle:"cookie 模块测试",charIndex:3632},{level:3,title:"data 模块测试",slug:"data-模块测试",normalizedTitle:"data 模块测试",charIndex:4139},{level:3,title:"error 模块测试",slug:"error-模块测试",normalizedTitle:"error 模块测试",charIndex:5294},{level:3,title:"headers 模块测试",slug:"headers-模块测试",normalizedTitle:"headers 模块测试",charIndex:6317},{level:3,title:"url 模块测试",slug:"url-模块测试",normalizedTitle:"url 模块测试",charIndex:10462}],headersStr:"准备工作 各个模块测试代码编写 util 模块测试 cookie 模块测试 data 模块测试 error 模块测试 headers 模块测试 url 模块测试",content:"# 准备工作\n\n通常会优先为一个库的辅助方法编写测试。\n\n在这辅助方法为 src/helpers 目录下的模块。在 test 目录下创建一个 helpers 目录下，创建一个 boot.ts 空文件。给 Jest 配置了 setupFilesAfterEnv 指向了这个文件，之后会编写这个文件。\n\n然后可以在控制台运行命令 npm test ，实际上执行了 jest --coverage 进行单元测试。此时运行会报错，因为没有匹配的测试文件（ test 目录下没有 .spec.ts 结尾的文件）。\n\n\n# 各个模块测试代码编写\n\n\n# util 模块测试\n\n创建文件 test/helpers/util.spec.ts ：\n\n点击查看\n\nimport {\n  deepMerge,\n  extend,\n  isDate,\n  isFormData,\n  isPlainObject,\n  isURLSearchParams\n} from '../../src/helpers/util'\n\ndescribe('helpers:util', () => {\n  describe('isXX', () => {\n    test('should validate Date', () => {\n      expect(isDate(new Date())).toBeTruthy()\n      expect(isDate(Date.now())).toBeFalsy()\n    })\n\n    test('should validate PlainObject', () => {\n      expect(isPlainObject({})).toBeTruthy()\n      expect(isPlainObject(new Date())).toBeFalsy()\n    })\n\n    test('should validate FormData', () => {\n      expect(isFormData(new FormData())).toBeTruthy()\n      expect(isFormData({})).toBeFalsy()\n    })\n\n    test('should validate URLSearchParams', () => {\n      expect(isURLSearchParams(new URLSearchParams())).toBeTruthy()\n      expect(isURLSearchParams('foo=2&bar=2')).toBeFalsy()\n    })\n  })\n})\n\ndescribe('extend', () => {\n  test('should be mutable', () => {\n    const a = Object.create(null)\n    const b = { foo: 123 }\n\n    extend(a, b)\n    expect(a.foo).toBe(123)\n  })\n\n  test('should extend properties', function() {\n    const a = {foo: 123, bar: 456}\n    const b = { bar: 789}\n    const c= extend(a, b)\n\n    expect(c.foo).toBe(123)\n    expect(c.bar).toBe(789)\n  })\n})\n\ndescribe('deepMerge', () => {\n  test('should be immutable', () => {\n    const a = Object.create(null)\n    const b: any = { foo: 123 }\n    const c: any = { bar: 456 }\n\n    deepMerge(a, b, c)\n\n    expect(typeof a.foo).toBe('undefined')\n    expect(typeof a.bar).toBe('undefined')\n    expect(typeof b.bar).toBe('undefined')\n    expect(typeof c.foo).toBe('undefined')\n  })\n\n  test('should deepMerge properties', () => {\n    const a = { foo: 123 }\n    const b = { bar: 456 }\n    const c = { foo: 789 }\n    const d = deepMerge(a, b, c)\n\n    expect(d.foo).toBe(789)\n    expect(d.bar).toBe(456)\n  })\n\n  test('should deepMerge recursively', function() {\n    const a = { foo: { bar: 123 } }\n    const b = { foo: { baz: 456 }, bar: { qux: 789 } }\n    const c = deepMerge(a, b)\n\n    expect(c).toEqual({\n      foo: {\n        bar: 123,\n        baz: 456\n      },\n      bar: {\n        qux: 789\n      }\n    })\n  })\n\n  test('should remove all references from nested objects', () => {\n    const a = { foo: { bar: 123 } }\n    const b = {}\n    const c = deepMerge(a, b)\n\n    expect(c).toEqual({\n      foo: {\n        bar: 123\n      }\n    })\n\n    expect(c.foo).not.toBe(a.foo)\n  })\n\n  test('should handle null and undefined arguments', () => {\n    expect(deepMerge(undefined, undefined)).toEqual({})\n    expect(deepMerge(undefined, { foo: 123 })).toEqual({ foo: 123 })\n    expect(deepMerge({ foo: 123 }, undefined)).toEqual({ foo: 123 })\n\n    expect(deepMerge(null, null)).toEqual({})\n    expect(deepMerge(null, { foo: 123 })).toEqual({ foo: 123 })\n    expect(deepMerge({ foo: 123 }, null)).toEqual({ foo: 123 })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n> 其中使用 describe 方法定义一组测试，支持嵌套， test 函数用来定义单个测试用例，是测试的最小单元； expect 是断言函数，判断代码的实际结果与预期结果是否一致，如果不一致就抛出错误。\n> \n> 测试文件编写好后可以单个测试用例运行；也可以运行命令 npm test 运行测试。\n\n\n# cookie 模块测试\n\n创建文件： test/helpers/cookie.spec.ts ：\n\n点击查看\n\nimport cookie from '../../src/helpers/cookie'\n\ndescribe('helpers:cookie', () => {\n  test('should read cookies', () => {\n    document.cookie = 'foo=bar'\n    expect(cookie.read('foo')).toBe('bar')\n  })\n\n  test('should return null if cookie name is not exist', () => {\n    document.cookie = 'foo=bar'\n    expect(cookie.read('bar')).toBeNull()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 一般 jest 测试环境配置了 jsdom 能操作 DOM。如果不行需要加上 --env=jsdom 的配置（命令配置中）。\n\n\n# data 模块测试\n\n创建文件 test/helpers/data.spec.ts ：\n\n点击查看\n\nimport { transformRequest, transformResponse } from '../../src/helpers/data'\n\ndescribe('helpers:data', () => {\n  describe('transformRequest', () => {\n    test('should transform request data to string if data is a PlainObject', () => {\n      const a = { a: 1 }\n      expect(transformRequest(a)).toBe('{\"a\":1}')\n    })\n\n    test('should do nothing if data is not a PlainObject', () => {\n      const a = new URLSearchParams('a=b')\n      expect(transformRequest(a)).toBe(a)\n    })\n  })\n\n  describe('transformResponse', () => {\n    test('should transform response data to Object if data is a JSON string', () => {\n      const a = '{\"a\": 2}'\n      expect(transformResponse(a)).toEqual({ a: 2 })\n    })\n\n    test('should do nothing if data is a string but not a JSON string', () => {\n      const a = '{a: 2}'\n      expect(transformResponse(a)).toEqual('{a: 2}')\n    })\n\n    test('should do nothing if data is not a string', () => {\n      const a = {a: 2}\n      expect(transformResponse(a)).toBe(a)\n    })\n\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# error 模块测试\n\n创建文件 test/helpers/test.spec.ts ：\n\n点击查看\n\nimport { AxiosRequestConfig, AxiosResponse } from '../../src'\nimport { createError } from '../../src/helpers/error'\n\ndescribe('helpers:error', () => {\n  test('should create an Error with message, config, code, request, response and isAxiosError', () => {\n    const request = new XMLHttpRequest()\n    const config: AxiosRequestConfig = { method: 'post' }\n    const response: AxiosResponse = {\n      status: 200,\n      statusText: 'OK',\n      headers: null,\n      request,\n      config,\n      data: { foo: 'bar' }\n    }\n    const error = createError('Boom!', config, 'SOMETHING', request, response)\n    expect(error instanceof Error).toBeTruthy()\n    expect(error.message).toBe('Boom!')\n    expect(error.config).toBe(config)\n    expect(error.code).toBe('SOMETHING')\n    expect(error.request).toBe(request)\n    expect(error.response).toBe(response)\n    expect(error.isAxiosError).toBeTruthy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# headers 模块测试\n\n创建文件 test/helpers/headers.spec.ts ：\n\n点击查看\n\nimport { flattenHeaders, parseHeaders, processHeaders } from '../../src/helpers/headers'\n\ndescribe('helpers:header', () => {\n  describe('parseHeaders', () => {\n    test('should parse headers', () => {\n      const parsed = parseHeaders(\n        'Content-Type: application/json\\r\\n' +\n        'Connection: keep-alive\\r\\n' +\n        'Transfer-Encoding: chunked\\r\\n' +\n        'Date: Tue, 21 May 2019 09:23:44 GMT\\r\\n' +\n        ':aa\\r\\n' +\n        'key:'\n      )\n\n      expect(parsed['content-type']).toBe('application/json')\n      expect(parsed['connection']).toBe('keep-alive')\n      expect(parsed['transfer-encoding']).toBe('chunked')\n      expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT')\n      expect(parsed['key']).toBe('')\n    })\n\n    test('should return empty object if headers is empty string', () => {\n      expect(parseHeaders('')).toEqual({})\n    })\n  })\n\n  describe('processHeades', () => {\n    test('should normalize Content-Type header name', () => {\n      const headers: any = {\n        'conTenT-Type': 'foo/bar',\n        'Content-length': 1024\n      }\n\n      processHeaders(headers, {})\n      expect(headers['Content-Type']).toBe('foo/bar')\n      expect(headers['conTenT-Type']).toBeUndefined()\n      expect(headers['Content-length']).toBe(1024)\n    })\n\n    test('should set Content-Type if not set and data is PlainObject', () => {\n      const headers: any = {}\n      processHeaders(headers, { a: 1 })\n      expect(headers['Content-Type']).toBe('application/json;charset=utf-8')\n    })\n\n    test('should set not Content-Type if not set and data is not PlainObject', () => {\n      const headers: any = {}\n      processHeaders(headers, new URLSearchParams('a=b'))\n      expect(headers['Content-Type']).toBeUndefined()\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(processHeaders(undefined, {})).toBeUndefined()\n      expect(processHeaders(null, {})).toBeNull()\n    })\n  })\n\n  describe('flattenHeaders', () => {\n    test('should flatten the headers and include common headers', () => {\n      const headers = {\n        Accept: 'application/json',\n        common: {\n          'X-COMMON-HEADER': 'commonHeaderValue'\n        },\n        get: {\n          'X-GET-HEADER': 'getHeaderValue'\n        },\n        post: {\n          'X-POST-HEADER': 'postHeaderValue'\n        }\n      }\n\n      expect(flattenHeaders(headers, 'get')).toEqual({\n        Accept: 'application/json',\n        'X-COMMON-HEADER': 'commonHeaderValue',\n        'X-GET-HEADER': 'getHeaderValue'\n      })\n    })\n\n    test('should flatten the headers without common headers', () => {\n      const headers = {\n        Accept: 'application/json',\n        get: {\n          'X-GET-HEADER': 'getHeaderValue'\n        }\n      }\n\n      expect(flattenHeaders(headers, 'patch')).toEqual({\n        Accept: 'application/json'\n      })\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(flattenHeaders(undefined, 'get')).toBeUndefined()\n      expect(flattenHeaders(null, 'post')).toBeNull()\n    })\n\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n> 此处测试发现错误。 测试组的 should parse headers 测试没通过， expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT') 我们期望解析后的 date 字段是 Tue, 21 May 2019 09:23:44 GMT ，而实际的值是 Tue, 21 May 2019 09 。\n> \n> 说明 parseHeaders 的代码逻辑有漏洞，只考虑了第一个 : 符号，没有考虑后半部分也可能有 : 符号，因为现有逻辑会把字符串中 : 后面部分都截断。\n> \n> 修改后的 parasedHeaders ：\n> \n> export function parseHeaders(headers: string): any {\n>   let parsed = Object.create(null)\n>   if (!headers) return parsed\n> \n>   headers.split('\\r\\n').forEach(line => {\n>     let [key, ...vals] = line.split(':')\n>     key = key.trim().toLowerCase()\n>     if (!key) return\n>     let val = vals.join(':').trim()\n>     parsed[key] = val\n>   })\n> \n>   return parsed\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n\n\n# url 模块测试\n\n创建文件 test/helpers/url.spec.ts :\n\n点击查看\n\nimport { buildURL, combineURL, isAbsoluteURL, isURLSameOrigin } from '../../src/helpers/url'\n\ndescribe('helpers:url', () => {\n  describe('buildURL', () => {\n    test('should support null params', () => {\n      expect(buildURL('/foo')).toBe('/foo')\n    })\n\n    test('should support params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: 'bar'\n        })\n      ).toBe('/foo?foo=bar')\n    })\n\n    test('should ignore if some param value is null', () => {\n      expect(\n        buildURL('/foo', {\n          foo: 'bar',\n          baz: null\n        })\n      ).toBe('/foo?foo=bar')\n    })\n\n    test('should ignore if the only param value is null', () => {\n      expect(\n        buildURL('/foo', {\n          foo: null\n        })\n      ).toBe('/foo')\n    })\n\n    test('should support object params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: {\n            bar: 'baz'\n          }\n        })\n      ).toBe('/foo?foo=' + encodeURI('{\"bar\":\"baz\"}'))\n    })\n\n    test('should support date params', () => {\n      const date = new Date()\n\n      expect(\n        buildURL('/foo', {\n          date\n        })\n      ).toBe('/foo?date=' + date.toISOString())\n    })\n\n    test('should support array params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: ['bar', 'baz']\n        })\n      ).toBe('/foo?foo[]=bar&foo[]=baz')\n    })\n\n    test('should support special char params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: '@:$'\n        })\n      ).toBe('/foo?foo=@:$')\n    })\n\n    test('should support existing params', () => {\n      expect(\n        buildURL('/foo?foo=bar', {\n          bar: 'baz'\n        })\n      ).toBe('/foo?foo=bar&bar=baz')\n    })\n\n    test('should correct discard url hash mark', () => {\n      expect(\n        buildURL('/foo?foo=bar#hash', {\n          query: 'baz'\n        })\n      ).toBe('/foo?foo=bar&query=baz')\n    })\n\n    test('should use serializer if provided', () => {\n      const serializer = jest.fn(() => {\n        return 'bar=baz'\n      })\n      const params = { foo: 'bar' }\n      expect(buildURL('/foo?foo=bar#hash', params, serializer)).toBe('/foo?foo=bar&bar=baz')\n      expect(serializer).toHaveBeenCalled()\n      expect(serializer).toHaveBeenCalledWith(params)\n    })\n\n    test('should support URLSearchParams', () => {\n      expect(buildURL('/foo', new URLSearchParams('bar=baz'))).toBe('/foo?bar=baz')\n    })\n  })\n\n  describe('isAbsoluteURL', () => {\n    test('should return true if URL begins with valid scheme name', () => {\n      expect(isAbsoluteURL('https://api.github.com/users')).toBeTruthy()\n      expect(isAbsoluteURL('custom-scheme-v1.0://example.com/')).toBeTruthy()\n      expect(isAbsoluteURL('HTTP://example.com/')).toBeTruthy()\n    })\n\n    test('should return false if URL begins with invalid scheme name', () => {\n      expect(isAbsoluteURL('123://api.github.com/users')).toBeFalsy()\n      expect(isAbsoluteURL('!valid://api.github.com/users')).toBeFalsy()\n    })\n\n    test('should return true if URL is protocol-relative', () => {\n      expect(isAbsoluteURL('//example.com/')).toBeTruthy()\n    })\n\n    test('should return false if URL is relative', () => {\n      expect(isAbsoluteURL('/foo')).toBeFalsy()\n      expect(isAbsoluteURL('foo')).toBeFalsy()\n    })\n  })\n\n  describe('combineURL', () => {\n    test('should combine URL', () => {\n      expect(combineURL('https://api.github.com', '/users')).toBe('https://api.github.com/users')\n    })\n\n    test('should remove duplicate slashes', () => {\n      expect(combineURL('https://api.github.com/', '/users')).toBe('https://api.github.com/users')\n    })\n\n    test('should insert missing URL', () => {\n      expect(combineURL('https://api.github.com', 'users')).toBe('https://api.github.com/users')\n    })\n\n    test('should not insert slash when relative url missing/empty', () => {\n      expect(combineURL('https://api.github.com/users', '')).toBe('https://api.github.com/users')\n    })\n\n    test('should allow a single slash for relative url', () => {\n      expect(combineURL('https://api.github.com/users', '/')).toBe('https://api.github.com/users/')\n    })\n  })\n\n  describe('isURLSameOrigin', () => {\n    test('should detect same origin', () => {\n      expect(isURLSameOrigin(window.location.href)).toBeTruthy()\n    })\n\n    test('should detect same origin', () => {\n      expect(isURLSameOrigin('https://api.github.com/users')).toBeFalsy()\n    })\n\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n\n\n> 使用了 jest.fn 去模拟了一个函数，这个也是在编写 Jest 测试中非常常用的一个 API。",normalizedContent:"# 准备工作\n\n通常会优先为一个库的辅助方法编写测试。\n\n在这辅助方法为 src/helpers 目录下的模块。在 test 目录下创建一个 helpers 目录下，创建一个 boot.ts 空文件。给 jest 配置了 setupfilesafterenv 指向了这个文件，之后会编写这个文件。\n\n然后可以在控制台运行命令 npm test ，实际上执行了 jest --coverage 进行单元测试。此时运行会报错，因为没有匹配的测试文件（ test 目录下没有 .spec.ts 结尾的文件）。\n\n\n# 各个模块测试代码编写\n\n\n# util 模块测试\n\n创建文件 test/helpers/util.spec.ts ：\n\n点击查看\n\nimport {\n  deepmerge,\n  extend,\n  isdate,\n  isformdata,\n  isplainobject,\n  isurlsearchparams\n} from '../../src/helpers/util'\n\ndescribe('helpers:util', () => {\n  describe('isxx', () => {\n    test('should validate date', () => {\n      expect(isdate(new date())).tobetruthy()\n      expect(isdate(date.now())).tobefalsy()\n    })\n\n    test('should validate plainobject', () => {\n      expect(isplainobject({})).tobetruthy()\n      expect(isplainobject(new date())).tobefalsy()\n    })\n\n    test('should validate formdata', () => {\n      expect(isformdata(new formdata())).tobetruthy()\n      expect(isformdata({})).tobefalsy()\n    })\n\n    test('should validate urlsearchparams', () => {\n      expect(isurlsearchparams(new urlsearchparams())).tobetruthy()\n      expect(isurlsearchparams('foo=2&bar=2')).tobefalsy()\n    })\n  })\n})\n\ndescribe('extend', () => {\n  test('should be mutable', () => {\n    const a = object.create(null)\n    const b = { foo: 123 }\n\n    extend(a, b)\n    expect(a.foo).tobe(123)\n  })\n\n  test('should extend properties', function() {\n    const a = {foo: 123, bar: 456}\n    const b = { bar: 789}\n    const c= extend(a, b)\n\n    expect(c.foo).tobe(123)\n    expect(c.bar).tobe(789)\n  })\n})\n\ndescribe('deepmerge', () => {\n  test('should be immutable', () => {\n    const a = object.create(null)\n    const b: any = { foo: 123 }\n    const c: any = { bar: 456 }\n\n    deepmerge(a, b, c)\n\n    expect(typeof a.foo).tobe('undefined')\n    expect(typeof a.bar).tobe('undefined')\n    expect(typeof b.bar).tobe('undefined')\n    expect(typeof c.foo).tobe('undefined')\n  })\n\n  test('should deepmerge properties', () => {\n    const a = { foo: 123 }\n    const b = { bar: 456 }\n    const c = { foo: 789 }\n    const d = deepmerge(a, b, c)\n\n    expect(d.foo).tobe(789)\n    expect(d.bar).tobe(456)\n  })\n\n  test('should deepmerge recursively', function() {\n    const a = { foo: { bar: 123 } }\n    const b = { foo: { baz: 456 }, bar: { qux: 789 } }\n    const c = deepmerge(a, b)\n\n    expect(c).toequal({\n      foo: {\n        bar: 123,\n        baz: 456\n      },\n      bar: {\n        qux: 789\n      }\n    })\n  })\n\n  test('should remove all references from nested objects', () => {\n    const a = { foo: { bar: 123 } }\n    const b = {}\n    const c = deepmerge(a, b)\n\n    expect(c).toequal({\n      foo: {\n        bar: 123\n      }\n    })\n\n    expect(c.foo).not.tobe(a.foo)\n  })\n\n  test('should handle null and undefined arguments', () => {\n    expect(deepmerge(undefined, undefined)).toequal({})\n    expect(deepmerge(undefined, { foo: 123 })).toequal({ foo: 123 })\n    expect(deepmerge({ foo: 123 }, undefined)).toequal({ foo: 123 })\n\n    expect(deepmerge(null, null)).toequal({})\n    expect(deepmerge(null, { foo: 123 })).toequal({ foo: 123 })\n    expect(deepmerge({ foo: 123 }, null)).toequal({ foo: 123 })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n> 其中使用 describe 方法定义一组测试，支持嵌套， test 函数用来定义单个测试用例，是测试的最小单元； expect 是断言函数，判断代码的实际结果与预期结果是否一致，如果不一致就抛出错误。\n> \n> 测试文件编写好后可以单个测试用例运行；也可以运行命令 npm test 运行测试。\n\n\n# cookie 模块测试\n\n创建文件： test/helpers/cookie.spec.ts ：\n\n点击查看\n\nimport cookie from '../../src/helpers/cookie'\n\ndescribe('helpers:cookie', () => {\n  test('should read cookies', () => {\n    document.cookie = 'foo=bar'\n    expect(cookie.read('foo')).tobe('bar')\n  })\n\n  test('should return null if cookie name is not exist', () => {\n    document.cookie = 'foo=bar'\n    expect(cookie.read('bar')).tobenull()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 一般 jest 测试环境配置了 jsdom 能操作 dom。如果不行需要加上 --env=jsdom 的配置（命令配置中）。\n\n\n# data 模块测试\n\n创建文件 test/helpers/data.spec.ts ：\n\n点击查看\n\nimport { transformrequest, transformresponse } from '../../src/helpers/data'\n\ndescribe('helpers:data', () => {\n  describe('transformrequest', () => {\n    test('should transform request data to string if data is a plainobject', () => {\n      const a = { a: 1 }\n      expect(transformrequest(a)).tobe('{\"a\":1}')\n    })\n\n    test('should do nothing if data is not a plainobject', () => {\n      const a = new urlsearchparams('a=b')\n      expect(transformrequest(a)).tobe(a)\n    })\n  })\n\n  describe('transformresponse', () => {\n    test('should transform response data to object if data is a json string', () => {\n      const a = '{\"a\": 2}'\n      expect(transformresponse(a)).toequal({ a: 2 })\n    })\n\n    test('should do nothing if data is a string but not a json string', () => {\n      const a = '{a: 2}'\n      expect(transformresponse(a)).toequal('{a: 2}')\n    })\n\n    test('should do nothing if data is not a string', () => {\n      const a = {a: 2}\n      expect(transformresponse(a)).tobe(a)\n    })\n\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# error 模块测试\n\n创建文件 test/helpers/test.spec.ts ：\n\n点击查看\n\nimport { axiosrequestconfig, axiosresponse } from '../../src'\nimport { createerror } from '../../src/helpers/error'\n\ndescribe('helpers:error', () => {\n  test('should create an error with message, config, code, request, response and isaxioserror', () => {\n    const request = new xmlhttprequest()\n    const config: axiosrequestconfig = { method: 'post' }\n    const response: axiosresponse = {\n      status: 200,\n      statustext: 'ok',\n      headers: null,\n      request,\n      config,\n      data: { foo: 'bar' }\n    }\n    const error = createerror('boom!', config, 'something', request, response)\n    expect(error instanceof error).tobetruthy()\n    expect(error.message).tobe('boom!')\n    expect(error.config).tobe(config)\n    expect(error.code).tobe('something')\n    expect(error.request).tobe(request)\n    expect(error.response).tobe(response)\n    expect(error.isaxioserror).tobetruthy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# headers 模块测试\n\n创建文件 test/helpers/headers.spec.ts ：\n\n点击查看\n\nimport { flattenheaders, parseheaders, processheaders } from '../../src/helpers/headers'\n\ndescribe('helpers:header', () => {\n  describe('parseheaders', () => {\n    test('should parse headers', () => {\n      const parsed = parseheaders(\n        'content-type: application/json\\r\\n' +\n        'connection: keep-alive\\r\\n' +\n        'transfer-encoding: chunked\\r\\n' +\n        'date: tue, 21 may 2019 09:23:44 gmt\\r\\n' +\n        ':aa\\r\\n' +\n        'key:'\n      )\n\n      expect(parsed['content-type']).tobe('application/json')\n      expect(parsed['connection']).tobe('keep-alive')\n      expect(parsed['transfer-encoding']).tobe('chunked')\n      expect(parsed['date']).tobe('tue, 21 may 2019 09:23:44 gmt')\n      expect(parsed['key']).tobe('')\n    })\n\n    test('should return empty object if headers is empty string', () => {\n      expect(parseheaders('')).toequal({})\n    })\n  })\n\n  describe('processheades', () => {\n    test('should normalize content-type header name', () => {\n      const headers: any = {\n        'content-type': 'foo/bar',\n        'content-length': 1024\n      }\n\n      processheaders(headers, {})\n      expect(headers['content-type']).tobe('foo/bar')\n      expect(headers['content-type']).tobeundefined()\n      expect(headers['content-length']).tobe(1024)\n    })\n\n    test('should set content-type if not set and data is plainobject', () => {\n      const headers: any = {}\n      processheaders(headers, { a: 1 })\n      expect(headers['content-type']).tobe('application/json;charset=utf-8')\n    })\n\n    test('should set not content-type if not set and data is not plainobject', () => {\n      const headers: any = {}\n      processheaders(headers, new urlsearchparams('a=b'))\n      expect(headers['content-type']).tobeundefined()\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(processheaders(undefined, {})).tobeundefined()\n      expect(processheaders(null, {})).tobenull()\n    })\n  })\n\n  describe('flattenheaders', () => {\n    test('should flatten the headers and include common headers', () => {\n      const headers = {\n        accept: 'application/json',\n        common: {\n          'x-common-header': 'commonheadervalue'\n        },\n        get: {\n          'x-get-header': 'getheadervalue'\n        },\n        post: {\n          'x-post-header': 'postheadervalue'\n        }\n      }\n\n      expect(flattenheaders(headers, 'get')).toequal({\n        accept: 'application/json',\n        'x-common-header': 'commonheadervalue',\n        'x-get-header': 'getheadervalue'\n      })\n    })\n\n    test('should flatten the headers without common headers', () => {\n      const headers = {\n        accept: 'application/json',\n        get: {\n          'x-get-header': 'getheadervalue'\n        }\n      }\n\n      expect(flattenheaders(headers, 'patch')).toequal({\n        accept: 'application/json'\n      })\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(flattenheaders(undefined, 'get')).tobeundefined()\n      expect(flattenheaders(null, 'post')).tobenull()\n    })\n\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n> 此处测试发现错误。 测试组的 should parse headers 测试没通过， expect(parsed['date']).tobe('tue, 21 may 2019 09:23:44 gmt') 我们期望解析后的 date 字段是 tue, 21 may 2019 09:23:44 gmt ，而实际的值是 tue, 21 may 2019 09 。\n> \n> 说明 parseheaders 的代码逻辑有漏洞，只考虑了第一个 : 符号，没有考虑后半部分也可能有 : 符号，因为现有逻辑会把字符串中 : 后面部分都截断。\n> \n> 修改后的 parasedheaders ：\n> \n> export function parseheaders(headers: string): any {\n>   let parsed = object.create(null)\n>   if (!headers) return parsed\n> \n>   headers.split('\\r\\n').foreach(line => {\n>     let [key, ...vals] = line.split(':')\n>     key = key.trim().tolowercase()\n>     if (!key) return\n>     let val = vals.join(':').trim()\n>     parsed[key] = val\n>   })\n> \n>   return parsed\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n\n\n# url 模块测试\n\n创建文件 test/helpers/url.spec.ts :\n\n点击查看\n\nimport { buildurl, combineurl, isabsoluteurl, isurlsameorigin } from '../../src/helpers/url'\n\ndescribe('helpers:url', () => {\n  describe('buildurl', () => {\n    test('should support null params', () => {\n      expect(buildurl('/foo')).tobe('/foo')\n    })\n\n    test('should support params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: 'bar'\n        })\n      ).tobe('/foo?foo=bar')\n    })\n\n    test('should ignore if some param value is null', () => {\n      expect(\n        buildurl('/foo', {\n          foo: 'bar',\n          baz: null\n        })\n      ).tobe('/foo?foo=bar')\n    })\n\n    test('should ignore if the only param value is null', () => {\n      expect(\n        buildurl('/foo', {\n          foo: null\n        })\n      ).tobe('/foo')\n    })\n\n    test('should support object params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: {\n            bar: 'baz'\n          }\n        })\n      ).tobe('/foo?foo=' + encodeuri('{\"bar\":\"baz\"}'))\n    })\n\n    test('should support date params', () => {\n      const date = new date()\n\n      expect(\n        buildurl('/foo', {\n          date\n        })\n      ).tobe('/foo?date=' + date.toisostring())\n    })\n\n    test('should support array params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: ['bar', 'baz']\n        })\n      ).tobe('/foo?foo[]=bar&foo[]=baz')\n    })\n\n    test('should support special char params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: '@:$'\n        })\n      ).tobe('/foo?foo=@:$')\n    })\n\n    test('should support existing params', () => {\n      expect(\n        buildurl('/foo?foo=bar', {\n          bar: 'baz'\n        })\n      ).tobe('/foo?foo=bar&bar=baz')\n    })\n\n    test('should correct discard url hash mark', () => {\n      expect(\n        buildurl('/foo?foo=bar#hash', {\n          query: 'baz'\n        })\n      ).tobe('/foo?foo=bar&query=baz')\n    })\n\n    test('should use serializer if provided', () => {\n      const serializer = jest.fn(() => {\n        return 'bar=baz'\n      })\n      const params = { foo: 'bar' }\n      expect(buildurl('/foo?foo=bar#hash', params, serializer)).tobe('/foo?foo=bar&bar=baz')\n      expect(serializer).tohavebeencalled()\n      expect(serializer).tohavebeencalledwith(params)\n    })\n\n    test('should support urlsearchparams', () => {\n      expect(buildurl('/foo', new urlsearchparams('bar=baz'))).tobe('/foo?bar=baz')\n    })\n  })\n\n  describe('isabsoluteurl', () => {\n    test('should return true if url begins with valid scheme name', () => {\n      expect(isabsoluteurl('https://api.github.com/users')).tobetruthy()\n      expect(isabsoluteurl('custom-scheme-v1.0://example.com/')).tobetruthy()\n      expect(isabsoluteurl('http://example.com/')).tobetruthy()\n    })\n\n    test('should return false if url begins with invalid scheme name', () => {\n      expect(isabsoluteurl('123://api.github.com/users')).tobefalsy()\n      expect(isabsoluteurl('!valid://api.github.com/users')).tobefalsy()\n    })\n\n    test('should return true if url is protocol-relative', () => {\n      expect(isabsoluteurl('//example.com/')).tobetruthy()\n    })\n\n    test('should return false if url is relative', () => {\n      expect(isabsoluteurl('/foo')).tobefalsy()\n      expect(isabsoluteurl('foo')).tobefalsy()\n    })\n  })\n\n  describe('combineurl', () => {\n    test('should combine url', () => {\n      expect(combineurl('https://api.github.com', '/users')).tobe('https://api.github.com/users')\n    })\n\n    test('should remove duplicate slashes', () => {\n      expect(combineurl('https://api.github.com/', '/users')).tobe('https://api.github.com/users')\n    })\n\n    test('should insert missing url', () => {\n      expect(combineurl('https://api.github.com', 'users')).tobe('https://api.github.com/users')\n    })\n\n    test('should not insert slash when relative url missing/empty', () => {\n      expect(combineurl('https://api.github.com/users', '')).tobe('https://api.github.com/users')\n    })\n\n    test('should allow a single slash for relative url', () => {\n      expect(combineurl('https://api.github.com/users', '/')).tobe('https://api.github.com/users/')\n    })\n  })\n\n  describe('isurlsameorigin', () => {\n    test('should detect same origin', () => {\n      expect(isurlsameorigin(window.location.href)).tobetruthy()\n    })\n\n    test('should detect same origin', () => {\n      expect(isurlsameorigin('https://api.github.com/users')).tobefalsy()\n    })\n\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n\n\n> 使用了 jest.fn 去模拟了一个函数，这个也是在编写 jest 测试中非常常用的一个 api。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 请求模块单元测试",frontmatter:{title:"🌖 请求模块单元测试",date:"2022-06-17T23:57:36.000Z",permalink:"/pages/169950/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/72.%20%F0%9F%8C%96%20%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/72. 🌖 请求模块单元测试.md",key:"v-60b82d43",path:"/pages/169950/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:633}],headersStr:"测试代码编写",content:"为了测试请求模块相关的业务逻辑，需要用到工具 jasmine 。\n\n> jasmine-ajax：\n> \n>  * Jasmine (opens new window) 是一个 BDD (行为驱动开发) 的测试框架，它有很多成熟的插件，比如我们要用到的 jasmine-ajax ，它会为我们发出的 Ajax 请求根据规范定义一组假的响应，并跟踪我们发出的 Ajax 请求，可以让我们方便的为结果做断言。\n>  * jasmine-ajax 依赖 jasmine-core ，因此首先我们要安装几个依赖包， jasmine-ajax 、 jasmine-core 和 @types/jasmine-ajax 。\n\n要使用 jasmine-ajax 插件能全局运行，需要手动台那集全局的方法（参考 ReferenceError: getJasmineRequireObj is not defined · Issue #178 · jasmine/jasmine-ajax (github.com)）：\n\ntest/boot.ts ：\n\nconst JasmineCore = require('jasmine-core')\n// @ts-ignore\nglobal.getJasmineRequireObj = function() {\n  return JasmineCore\n}\n\nrequire('jasmine')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 测试代码编写\n\n创建文件 test/helper.ts ， getAjaxRequest ：\n\nrequire('jasmine-ajax')\n\nexport function getAjaxRequest(): Promise<JasmineAjaxRequest> {\n  return new Promise(function(resolve) {\n    setTimeout(() => {\n      return resolve(jasmine.Ajax.requests.mostRecent())\n    }, 0)\n  })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 一个辅助方法，通过 jasmine.Ajax.requests.mostRecent() 拿到最近一次请求的 request 对象，这个 request 对象是 jasmine-ajax 库伪造的 xhr 对象，它模拟了 xhr 对象上的方法，并且提供一些 api 让我们使用，比如 request.respondWith 方法返回一个响应。\n> \n> > 🤯 踩坑预警：前前后后调试 jest 的配置 setupFilesAfterEnv ；最后把这个字段换成了 setUpFiles ，仍然设置为 <rootDir>/test/boot.ts 。也不知道这个配置是不是被弃用了，反正就莫名的换完之后就能成功使用 jasmine 了。\n\n创建文件 test/requests.spec.ts ：\n\nimport axios, { AxiosResponse, AxiosError } from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('requests', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should treat single string arg as url', () => {\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n      expect(request.method).toBe('GET')\n    })\n  })\n\n  test('should treat method value as lowercase string', done => {\n    axios({\n      url: '/foo',\n      method: 'POST'\n    }).then(response => {\n      expect(response.config.method).toBe('post')\n      done()\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200\n      })\n    })\n  })\n\n  test('should reject on network errors', done => {\n    const resolveSpy = jest.fn((res: AxiosResponse) => {\n      return res\n    })\n\n    const rejectSpy = jest.fn((e: AxiosError) => {\n      return e\n    })\n\n    jasmine.Ajax.uninstall()\n\n    axios('/foo')\n      .then(resolveSpy)\n      .catch(rejectSpy)\n      .then(next)\n\n    function next(reason: AxiosResponse | AxiosError) {\n      expect(resolveSpy).not.toHaveBeenCalled()\n      expect(rejectSpy).toHaveBeenCalled()\n      expect(reason instanceof Error).toBeTruthy()\n      expect((reason as AxiosError).message).toBe('Network Error')\n      expect(reason.request).toEqual(expect.any(XMLHttpRequest))\n\n      jasmine.Ajax.install()\n\n      done()\n    }\n  })\n\n  test('should reject when request timeout', done => {\n    let err: AxiosError\n\n    axios('/foo', {\n      timeout: 2000,\n      method: 'post'\n    }).catch(error => {\n      err = error\n    })\n\n    getAjaxRequest().then(request => {\n      // @ts-ignore\n      request.eventBus.trigger('timeout')\n\n      setTimeout(() => {\n        expect(err instanceof Error).toBeTruthy()\n        expect(err.message).toBe('Timeout of 2000 ms exceeded')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should reject when validateStatus returns false', done => {\n    const resolveSpy = jest.fn((res: AxiosResponse) => {\n      return res\n    })\n\n    const rejectSpy = jest.fn((e: AxiosError) => {\n      return e\n    })\n\n    axios('/foo', {\n      validateStatus(status) {\n        return status !== 500\n      }\n    })\n      .then(resolveSpy)\n      .catch(rejectSpy)\n      .then(next)\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 500\n      })\n    })\n\n    function next(reason: AxiosError | AxiosResponse) {\n      expect(resolveSpy).not.toHaveBeenCalled()\n      expect(rejectSpy).toHaveBeenCalled()\n      expect(reason instanceof Error).toBeTruthy()\n      expect((reason as AxiosError).message).toBe('Request failed with status code 500')\n      expect((reason as AxiosError).response!.status).toBe(500)\n\n      done()\n    }\n  })\n\n  test('should resolve when validateStatus returns true', done => {\n    const resolveSpy = jest.fn((res: AxiosResponse) => {\n      return res\n    })\n\n    const rejectSpy = jest.fn((e: AxiosError) => {\n      return e\n    })\n\n    axios('/foo', {\n      validateStatus(status) {\n        return status === 500\n      }\n    })\n      .then(resolveSpy)\n      .catch(rejectSpy)\n      .then(next)\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 500\n      })\n    })\n\n    function next(res: AxiosResponse | AxiosError) {\n      expect(resolveSpy).toHaveBeenCalled()\n      expect(rejectSpy).not.toHaveBeenCalled()\n      expect(res.config.url).toBe('/foo')\n\n      done()\n    }\n  })\n\n  test('should return JSON when resolved', done => {\n    let response: AxiosResponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        Accept: 'application/json'\n      }\n    }).then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        statusText: 'OK',\n        responseText: '{\"a\": 1}'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toEqual({ a: 1 })\n        done()\n      }, 100)\n    })\n  })\n\n  test('should return JSON when rejecting', done => {\n    let response: AxiosResponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        Accept: 'application/json'\n      }\n    }).catch(error => {\n      response = error.response\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 400,\n        statusText: 'Bad Request',\n        responseText: '{\"error\": \"BAD USERNAME\", \"code\": 1}'\n      })\n\n      setTimeout(() => {\n        expect(typeof response.data).toBe('object')\n        expect(response.data.error).toBe('BAD USERNAME')\n        expect(response.data.code).toBe(1)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should supply correct response', done => {\n    let response: AxiosResponse\n\n    axios.post('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        statusText: 'OK',\n        responseText: '{\"foo\": \"bar\"}',\n        responseHeaders: {\n          'Content-Type': 'application/json'\n        }\n      })\n\n      setTimeout(() => {\n        expect(response.data.foo).toBe('bar')\n        expect(response.status).toBe(200)\n        expect(response.statusText).toBe('OK')\n        expect(response.headers['content-type']).toBe('application/json')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow overriding Content-Type header case-insensitive', () => {\n    let response: AxiosResponse\n\n    axios\n      .post(\n        '/foo',\n        { prop: 'value' },\n        {\n          headers: {\n            'content-type': 'application/json'\n          }\n        }\n      )\n      .then(res => {\n        response = res\n      })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['Content-Type']).toBe('application/json')\n    })\n  })\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n\n\n测试相关的配置：\n\n * beforeEach() & afterEach() ：表示每个测试用例前后运行的狗子函数。\n\n * 异步测试。在这个测试中，几乎都是用的是异步的测试代码。通常 Jest 有两种解决方案：\n   \n   * 第一种是利用 done 参数，每个测试用例函数有一个 done 参数，一旦使用这个参数，只有当 done 函数执行的时候表示这个测试用例结束。\n   * 第二种是测试函数返回一个 Promise 对象，一旦这个 Promise 对象 resolve 了，表示这个测试结束。\n\n * expect.any(constructor) ： constructor 是要匹配的对象实例的构造器。\n\n * request.eventBus.trigger ：由于 request.responseTimeout 方法内部依赖了 jasmine.clock 方法会导致运行失败。这里直接使用 request.eventBus.trigger('timeout') 方法触发 timeout 事件。这个方法不在接口中定义，所以需要忽略语法警告 // @ts-ignore 。\n\n测试中发现的问题：\n\n * should treat method value as lowercase string 断言有误：测试用例中，发送请求的 method 需要转换成小写字符串，这样做的目的是为了之后的 flattenHeaders 能正常处理 method ，所以需要增加一个添加转换为小写字符串的逻辑：\n   \n   （ src/core/Axios.ts ）：\n   \n   request(url: any, config?: any): AxiosPromise {\n     if (typeof url === 'string') {\n       if (!config) {\n         config = {}\n       }\n       config.url = url\n     } else {\n       config = url\n     }\n   \n     config = mergeConfig(this.defaults, config)\n     config.method = config.method.toLowerCase()\n   \n     // ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 合并配置后，将 config.method 转换为小写。\n\n * should return JSON when rejecting 断言有误：这个测试用例是要测试发送请求失败之后，也能把相应数据转换为 JSON 格式。而原来的代码并没有这个操作，所以需要修改源码。\n   \n   export default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {\n     throwIfCancellationRequested(config)\n     processConfig(config)\n     return xhr(config).then(\n       res => {\n         return transformResponseData(res)\n       },\n       e => {\n         if (e && e.response) {\n           e.response = transformResponseData(e.response)\n         }\n         return Promise.reject(e)\n       }\n     )\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 除了正常情况的响应数据需要作转换，错误情况的相应数据也需要作转换。",normalizedContent:"为了测试请求模块相关的业务逻辑，需要用到工具 jasmine 。\n\n> jasmine-ajax：\n> \n>  * jasmine (opens new window) 是一个 bdd (行为驱动开发) 的测试框架，它有很多成熟的插件，比如我们要用到的 jasmine-ajax ，它会为我们发出的 ajax 请求根据规范定义一组假的响应，并跟踪我们发出的 ajax 请求，可以让我们方便的为结果做断言。\n>  * jasmine-ajax 依赖 jasmine-core ，因此首先我们要安装几个依赖包， jasmine-ajax 、 jasmine-core 和 @types/jasmine-ajax 。\n\n要使用 jasmine-ajax 插件能全局运行，需要手动台那集全局的方法（参考 referenceerror: getjasminerequireobj is not defined · issue #178 · jasmine/jasmine-ajax (github.com)）：\n\ntest/boot.ts ：\n\nconst jasminecore = require('jasmine-core')\n// @ts-ignore\nglobal.getjasminerequireobj = function() {\n  return jasminecore\n}\n\nrequire('jasmine')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 测试代码编写\n\n创建文件 test/helper.ts ， getajaxrequest ：\n\nrequire('jasmine-ajax')\n\nexport function getajaxrequest(): promise<jasmineajaxrequest> {\n  return new promise(function(resolve) {\n    settimeout(() => {\n      return resolve(jasmine.ajax.requests.mostrecent())\n    }, 0)\n  })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 一个辅助方法，通过 jasmine.ajax.requests.mostrecent() 拿到最近一次请求的 request 对象，这个 request 对象是 jasmine-ajax 库伪造的 xhr 对象，它模拟了 xhr 对象上的方法，并且提供一些 api 让我们使用，比如 request.respondwith 方法返回一个响应。\n> \n> > 🤯 踩坑预警：前前后后调试 jest 的配置 setupfilesafterenv ；最后把这个字段换成了 setupfiles ，仍然设置为 <rootdir>/test/boot.ts 。也不知道这个配置是不是被弃用了，反正就莫名的换完之后就能成功使用 jasmine 了。\n\n创建文件 test/requests.spec.ts ：\n\nimport axios, { axiosresponse, axioserror } from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('requests', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should treat single string arg as url', () => {\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n      expect(request.method).tobe('get')\n    })\n  })\n\n  test('should treat method value as lowercase string', done => {\n    axios({\n      url: '/foo',\n      method: 'post'\n    }).then(response => {\n      expect(response.config.method).tobe('post')\n      done()\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200\n      })\n    })\n  })\n\n  test('should reject on network errors', done => {\n    const resolvespy = jest.fn((res: axiosresponse) => {\n      return res\n    })\n\n    const rejectspy = jest.fn((e: axioserror) => {\n      return e\n    })\n\n    jasmine.ajax.uninstall()\n\n    axios('/foo')\n      .then(resolvespy)\n      .catch(rejectspy)\n      .then(next)\n\n    function next(reason: axiosresponse | axioserror) {\n      expect(resolvespy).not.tohavebeencalled()\n      expect(rejectspy).tohavebeencalled()\n      expect(reason instanceof error).tobetruthy()\n      expect((reason as axioserror).message).tobe('network error')\n      expect(reason.request).toequal(expect.any(xmlhttprequest))\n\n      jasmine.ajax.install()\n\n      done()\n    }\n  })\n\n  test('should reject when request timeout', done => {\n    let err: axioserror\n\n    axios('/foo', {\n      timeout: 2000,\n      method: 'post'\n    }).catch(error => {\n      err = error\n    })\n\n    getajaxrequest().then(request => {\n      // @ts-ignore\n      request.eventbus.trigger('timeout')\n\n      settimeout(() => {\n        expect(err instanceof error).tobetruthy()\n        expect(err.message).tobe('timeout of 2000 ms exceeded')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should reject when validatestatus returns false', done => {\n    const resolvespy = jest.fn((res: axiosresponse) => {\n      return res\n    })\n\n    const rejectspy = jest.fn((e: axioserror) => {\n      return e\n    })\n\n    axios('/foo', {\n      validatestatus(status) {\n        return status !== 500\n      }\n    })\n      .then(resolvespy)\n      .catch(rejectspy)\n      .then(next)\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 500\n      })\n    })\n\n    function next(reason: axioserror | axiosresponse) {\n      expect(resolvespy).not.tohavebeencalled()\n      expect(rejectspy).tohavebeencalled()\n      expect(reason instanceof error).tobetruthy()\n      expect((reason as axioserror).message).tobe('request failed with status code 500')\n      expect((reason as axioserror).response!.status).tobe(500)\n\n      done()\n    }\n  })\n\n  test('should resolve when validatestatus returns true', done => {\n    const resolvespy = jest.fn((res: axiosresponse) => {\n      return res\n    })\n\n    const rejectspy = jest.fn((e: axioserror) => {\n      return e\n    })\n\n    axios('/foo', {\n      validatestatus(status) {\n        return status === 500\n      }\n    })\n      .then(resolvespy)\n      .catch(rejectspy)\n      .then(next)\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 500\n      })\n    })\n\n    function next(res: axiosresponse | axioserror) {\n      expect(resolvespy).tohavebeencalled()\n      expect(rejectspy).not.tohavebeencalled()\n      expect(res.config.url).tobe('/foo')\n\n      done()\n    }\n  })\n\n  test('should return json when resolved', done => {\n    let response: axiosresponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        accept: 'application/json'\n      }\n    }).then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        statustext: 'ok',\n        responsetext: '{\"a\": 1}'\n      })\n\n      settimeout(() => {\n        expect(response.data).toequal({ a: 1 })\n        done()\n      }, 100)\n    })\n  })\n\n  test('should return json when rejecting', done => {\n    let response: axiosresponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        accept: 'application/json'\n      }\n    }).catch(error => {\n      response = error.response\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 400,\n        statustext: 'bad request',\n        responsetext: '{\"error\": \"bad username\", \"code\": 1}'\n      })\n\n      settimeout(() => {\n        expect(typeof response.data).tobe('object')\n        expect(response.data.error).tobe('bad username')\n        expect(response.data.code).tobe(1)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should supply correct response', done => {\n    let response: axiosresponse\n\n    axios.post('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        statustext: 'ok',\n        responsetext: '{\"foo\": \"bar\"}',\n        responseheaders: {\n          'content-type': 'application/json'\n        }\n      })\n\n      settimeout(() => {\n        expect(response.data.foo).tobe('bar')\n        expect(response.status).tobe(200)\n        expect(response.statustext).tobe('ok')\n        expect(response.headers['content-type']).tobe('application/json')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow overriding content-type header case-insensitive', () => {\n    let response: axiosresponse\n\n    axios\n      .post(\n        '/foo',\n        { prop: 'value' },\n        {\n          headers: {\n            'content-type': 'application/json'\n          }\n        }\n      )\n      .then(res => {\n        response = res\n      })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['content-type']).tobe('application/json')\n    })\n  })\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n\n\n测试相关的配置：\n\n * beforeeach() & aftereach() ：表示每个测试用例前后运行的狗子函数。\n\n * 异步测试。在这个测试中，几乎都是用的是异步的测试代码。通常 jest 有两种解决方案：\n   \n   * 第一种是利用 done 参数，每个测试用例函数有一个 done 参数，一旦使用这个参数，只有当 done 函数执行的时候表示这个测试用例结束。\n   * 第二种是测试函数返回一个 promise 对象，一旦这个 promise 对象 resolve 了，表示这个测试结束。\n\n * expect.any(constructor) ： constructor 是要匹配的对象实例的构造器。\n\n * request.eventbus.trigger ：由于 request.responsetimeout 方法内部依赖了 jasmine.clock 方法会导致运行失败。这里直接使用 request.eventbus.trigger('timeout') 方法触发 timeout 事件。这个方法不在接口中定义，所以需要忽略语法警告 // @ts-ignore 。\n\n测试中发现的问题：\n\n * should treat method value as lowercase string 断言有误：测试用例中，发送请求的 method 需要转换成小写字符串，这样做的目的是为了之后的 flattenheaders 能正常处理 method ，所以需要增加一个添加转换为小写字符串的逻辑：\n   \n   （ src/core/axios.ts ）：\n   \n   request(url: any, config?: any): axiospromise {\n     if (typeof url === 'string') {\n       if (!config) {\n         config = {}\n       }\n       config.url = url\n     } else {\n       config = url\n     }\n   \n     config = mergeconfig(this.defaults, config)\n     config.method = config.method.tolowercase()\n   \n     // ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 合并配置后，将 config.method 转换为小写。\n\n * should return json when rejecting 断言有误：这个测试用例是要测试发送请求失败之后，也能把相应数据转换为 json 格式。而原来的代码并没有这个操作，所以需要修改源码。\n   \n   export default function dispatchrequest(config: axiosrequestconfig): axiospromise {\n     throwifcancellationrequested(config)\n     processconfig(config)\n     return xhr(config).then(\n       res => {\n         return transformresponsedata(res)\n       },\n       e => {\n         if (e && e.response) {\n           e.response = transformresponsedata(e.response)\n         }\n         return promise.reject(e)\n       }\n     )\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   > 除了正常情况的响应数据需要作转换，错误情况的相应数据也需要作转换。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 Axios 实例模块单元测试",frontmatter:{title:"🌖 Axios 实例模块单元测试",date:"2022-06-17T23:58:20.000Z",permalink:"/pages/528987/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/74.%20%F0%9F%8C%96%20Axios%20%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/74. 🌖 Axios 实例模块单元测试.md",key:"v-b87222ae",path:"/pages/528987/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:2}],headersStr:"测试代码编写",content:"# 测试代码编写\n\n创建文件 test/instance.spec.ts ：\n\nimport axios, { AxiosRequestConfig, AxiosResponse } from '../src'\nimport { getAjaxRequest } from './helper'\n\ndescribe('instance', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should make a http request without verb helper', () => {\n    const instance = axios.create()\n    instance('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n    })\n  })\n\n  test('should make a http request', () => {\n    const instance = axios.create()\n    instance.get('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n      expect(request.method).toBe('GET')\n    })\n  })\n\n  test('should make a post request', () => {\n    const instance = axios.create()\n    instance.post('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('POST')\n    })\n  })\n\n  test('should make a put request', () => {\n    const instance = axios.create()\n    instance.put('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('PUT')\n    })\n  })\n\n  test('should make a patch request', () => {\n    const instance = axios.create()\n    instance.patch('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('PATCH')\n    })\n  })\n\n  test('should make a options request', () => {\n    const instance = axios.create()\n    instance.options('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('OPTIONS')\n    })\n  })\n\n  test('should make a delete request', () => {\n    const instance = axios.create()\n    instance.delete('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('DELETE')\n    })\n  })\n\n  test('should make a head request', () => {\n    const instance = axios.create()\n    instance.head('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('HEAD')\n    })\n  })\n\n  test('should use instance options', () => {\n    const instance = axios.create({ timeout: 1000 })\n    instance.delete('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.timeout).toBe(1000)\n    })\n  })\n\n  test('should have defaults headers', () => {\n    const instance = axios.create({ baseURL: 'https://api.example.com' })\n    expect(typeof instance.defaults.headers).toBe('object')\n    expect(typeof instance.defaults.headers.common).toBe('object')\n  })\n\n  test('should have interceptors on the instance', done => {\n    axios.interceptors.request.use(config => {\n      config.timeout = 2000\n      return config\n    })\n\n    const instance = axios.create()\n    instance.interceptors.request.use(config => {\n      config.withCredentials = true\n      return config\n    })\n\n    let response: AxiosResponse\n    instance.get('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200\n      })\n\n      setTimeout(() => {\n        expect(response.config.timeout).toEqual(0)\n        expect(response.config.withCredentials).toEqual(true)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should get the computed uri', () => {\n    const fakeConfig: AxiosRequestConfig = {\n      baseURL: 'https://www.baidu.com/',\n      url: '/user/12345',\n      params: {\n        idClient: 1,\n        idTest: 2,\n        testString: 'thisIsATest'\n      }\n    }\n\n    expect(axios.getUri(fakeConfig)).toBe(\n      'https://www.baidu.com/user/12345?idClient=1&idTest=2&testString=thisIsATest'\n    )\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n",normalizedContent:"# 测试代码编写\n\n创建文件 test/instance.spec.ts ：\n\nimport axios, { axiosrequestconfig, axiosresponse } from '../src'\nimport { getajaxrequest } from './helper'\n\ndescribe('instance', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should make a http request without verb helper', () => {\n    const instance = axios.create()\n    instance('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n    })\n  })\n\n  test('should make a http request', () => {\n    const instance = axios.create()\n    instance.get('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n      expect(request.method).tobe('get')\n    })\n  })\n\n  test('should make a post request', () => {\n    const instance = axios.create()\n    instance.post('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('post')\n    })\n  })\n\n  test('should make a put request', () => {\n    const instance = axios.create()\n    instance.put('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('put')\n    })\n  })\n\n  test('should make a patch request', () => {\n    const instance = axios.create()\n    instance.patch('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('patch')\n    })\n  })\n\n  test('should make a options request', () => {\n    const instance = axios.create()\n    instance.options('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('options')\n    })\n  })\n\n  test('should make a delete request', () => {\n    const instance = axios.create()\n    instance.delete('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('delete')\n    })\n  })\n\n  test('should make a head request', () => {\n    const instance = axios.create()\n    instance.head('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('head')\n    })\n  })\n\n  test('should use instance options', () => {\n    const instance = axios.create({ timeout: 1000 })\n    instance.delete('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.timeout).tobe(1000)\n    })\n  })\n\n  test('should have defaults headers', () => {\n    const instance = axios.create({ baseurl: 'https://api.example.com' })\n    expect(typeof instance.defaults.headers).tobe('object')\n    expect(typeof instance.defaults.headers.common).tobe('object')\n  })\n\n  test('should have interceptors on the instance', done => {\n    axios.interceptors.request.use(config => {\n      config.timeout = 2000\n      return config\n    })\n\n    const instance = axios.create()\n    instance.interceptors.request.use(config => {\n      config.withcredentials = true\n      return config\n    })\n\n    let response: axiosresponse\n    instance.get('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200\n      })\n\n      settimeout(() => {\n        expect(response.config.timeout).toequal(0)\n        expect(response.config.withcredentials).toequal(true)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should get the computed uri', () => {\n    const fakeconfig: axiosrequestconfig = {\n      baseurl: 'https://www.baidu.com/',\n      url: '/user/12345',\n      params: {\n        idclient: 1,\n        idtest: 2,\n        teststring: 'thisisatest'\n      }\n    }\n\n    expect(axios.geturi(fakeconfig)).tobe(\n      'https://www.baidu.com/user/12345?idclient=1&idtest=2&teststring=thisisatest'\n    )\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 headers 模块单元测试",frontmatter:{title:"🌖 headers 模块单元测试",date:"2022-06-17T23:57:54.000Z",permalink:"/pages/f4e917/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/73.%20%F0%9F%8C%96%20headers%20%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/73. 🌖 headers 模块单元测试.md",key:"v-0bb0b492",path:"/pages/f4e917/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:2}],headersStr:"测试代码编写",content:"# 测试代码编写\n\n创建文件 test/headers.spec.ts ：\n\nfunction testHeaderValue(headers: any, key: string, val?: string): void {\n  let found = false\n\n  for (let k in headers) {\n    if (k.toLowerCase() === key.toLowerCase()) {\n      found = true\n      expect(headers[k]).toBe(val)\n      break\n    }\n  }\n\n  if (!found) {\n    if (typeof val === 'undefined') {\n      expect(headers.hasOwnProperty(key)).toBeFalsy()\n    } else {\n      throw new Error(key + ' was not found in headers')\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 定义这个辅助函数，用于测试 headers 是否存在某个 header 下的某个值。\n\nimport axios from '../src'\nimport { getAjaxRequest } from './helper'\n\n\ndescribe('headers', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should use default common headers', () => {\n    const headers = axios.defaults.headers.common\n\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          expect(request.requestHeaders[key]).toEqual(headers[key])\n        }\n      }\n    })\n  })\n\n  test('should add extra headers for post', () => {\n    axios.post('/foo', 'fizz=buzz')\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should use application/json when posting an object', () => {\n    axios.post('/foo', {\n      firstName: 'foo',\n      lastName: 'bar'\n    })\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', 'application/json;charset=utf-8')\n    })\n  })\n\n  test('should remove content-type if data is empty', () => {\n    axios.post('/foo')\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', undefined)\n    })\n  })\n\n  it('should preserve content-type if data is false', () => {\n    axios.post('/foo', false)\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should remove content-type if data is FormData', () => {\n    const data = new FormData()\n    data.append('foo', 'bar')\n    axios.post('/foo', data)\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', undefined)\n    })\n  })\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n",normalizedContent:"# 测试代码编写\n\n创建文件 test/headers.spec.ts ：\n\nfunction testheadervalue(headers: any, key: string, val?: string): void {\n  let found = false\n\n  for (let k in headers) {\n    if (k.tolowercase() === key.tolowercase()) {\n      found = true\n      expect(headers[k]).tobe(val)\n      break\n    }\n  }\n\n  if (!found) {\n    if (typeof val === 'undefined') {\n      expect(headers.hasownproperty(key)).tobefalsy()\n    } else {\n      throw new error(key + ' was not found in headers')\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 定义这个辅助函数，用于测试 headers 是否存在某个 header 下的某个值。\n\nimport axios from '../src'\nimport { getajaxrequest } from './helper'\n\n\ndescribe('headers', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should use default common headers', () => {\n    const headers = axios.defaults.headers.common\n\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      for (let key in headers) {\n        if (headers.hasownproperty(key)) {\n          expect(request.requestheaders[key]).toequal(headers[key])\n        }\n      }\n    })\n  })\n\n  test('should add extra headers for post', () => {\n    axios.post('/foo', 'fizz=buzz')\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should use application/json when posting an object', () => {\n    axios.post('/foo', {\n      firstname: 'foo',\n      lastname: 'bar'\n    })\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', 'application/json;charset=utf-8')\n    })\n  })\n\n  test('should remove content-type if data is empty', () => {\n    axios.post('/foo')\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', undefined)\n    })\n  })\n\n  it('should preserve content-type if data is false', () => {\n    axios.post('/foo', false)\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should remove content-type if data is formdata', () => {\n    const data = new formdata()\n    data.append('foo', 'bar')\n    axios.post('/foo', data)\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', undefined)\n    })\n  })\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 拦截器模块单元测试",frontmatter:{title:"🌖 拦截器模块单元测试",date:"2022-06-18T14:47:30.000Z",permalink:"/pages/7e14c7/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/75.%20%F0%9F%8C%96%20%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/75. 🌖 拦截器模块单元测试.md",key:"v-58999b90",path:"/pages/7e14c7/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:2}],headersStr:"测试代码编写",content:"# 测试代码编写\n\n创建文件 test/interceptor.spec.ts ：\n\nimport axios, { AxiosRequestConfig, AxiosResponse } from '../src'\nimport { getAjaxRequest } from './helper'\n\ndescribe('interceptors', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should add a request interceptor', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use((config: AxiosRequestConfig) => {\n      config.headers.test = 'added By interceptor'\n      return config\n    })\n\n    instance('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders.test).toBe('added By interceptor')\n    })\n  })\n\n  test('should add a request interceptor that returns a new config object', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use(() => {\n      return {\n        url: '/bar',\n        method: 'post'\n      }\n    })\n\n    instance('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('POST')\n      expect(request.url).toBe('/bar')\n    })\n  })\n\n  test('should add a request interceptor that returns a promise', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use((config: AxiosRequestConfig) => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          config.headers.async = 'promise'\n          resolve(config)\n        }, 10)\n      })\n    })\n\n    instance('/foo')\n    setTimeout(() => {\n      getAjaxRequest().then(request => {\n        expect(request.requestHeaders.async).toBe('promise')\n      })\n    }, 100)\n  })\n\n  test('should add multiple request interceptors', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use(config => {\n      config.headers.test1 = '1'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test2 = '2'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test3 = '3'\n      return config\n    })\n\n    instance('/foo')\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders.test1).toBe('1')\n      expect(request.requestHeaders.test2).toBe('2')\n      expect(request.requestHeaders.test3).toBe('3')\n    })\n  })\n\n  test('should add a response interceptor', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + ' - modified by interceptor'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('OK - modified by interceptor')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add a response interceptor that returns a new data object', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(() => {\n      return {\n        data: 'stuff',\n        headers: null,\n        status: 500,\n        statusText: 'ERR',\n        request: null,\n        config: {}\n      }\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('stuff')\n        expect(response.headers).toBeNull()\n        expect(response.status).toBe(500)\n        expect(response.statusText).toBe('ERR')\n        expect(response.request).toBeNull()\n        expect(response.config).toEqual({})\n        done()\n      }, 100)\n    })\n  })\n\n\n  test('should add a response interceptor that returns a promise', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      return new Promise(resolve => {\n        // do something async\n        setTimeout(() => {\n          data.data = 'you have been promised!'\n          resolve(data)\n        }, 10)\n      })\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('you have been promised!')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add multiple response interceptors', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('OK123')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow removing interceptors', done => {\n    let response: AxiosResponse\n    let intercept\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    intercept = instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance.interceptors.response.eject(intercept)\n    instance.interceptors.response.eject(5)\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('OK13')\n        done()\n      }, 100)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n\n\n测试发现的问题：\n\n * should add a request interceptor that returns a new config object ：发现执行到 processHeaders 中的 Object.keys(headers).forEach 代码报错，因为在拦截器对请求配置做了修改，导致 headers 为空，所以报错。\n   \n   （ src/core/xhr.ts ）：\n   \n   const {\n     // ...\n     headers = {}\n   } = config\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 给 headers 添加一个默认值。",normalizedContent:"# 测试代码编写\n\n创建文件 test/interceptor.spec.ts ：\n\nimport axios, { axiosrequestconfig, axiosresponse } from '../src'\nimport { getajaxrequest } from './helper'\n\ndescribe('interceptors', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should add a request interceptor', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use((config: axiosrequestconfig) => {\n      config.headers.test = 'added by interceptor'\n      return config\n    })\n\n    instance('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders.test).tobe('added by interceptor')\n    })\n  })\n\n  test('should add a request interceptor that returns a new config object', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use(() => {\n      return {\n        url: '/bar',\n        method: 'post'\n      }\n    })\n\n    instance('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('post')\n      expect(request.url).tobe('/bar')\n    })\n  })\n\n  test('should add a request interceptor that returns a promise', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use((config: axiosrequestconfig) => {\n      return new promise(resolve => {\n        settimeout(() => {\n          config.headers.async = 'promise'\n          resolve(config)\n        }, 10)\n      })\n    })\n\n    instance('/foo')\n    settimeout(() => {\n      getajaxrequest().then(request => {\n        expect(request.requestheaders.async).tobe('promise')\n      })\n    }, 100)\n  })\n\n  test('should add multiple request interceptors', () => {\n    const instance = axios.create()\n    instance.interceptors.request.use(config => {\n      config.headers.test1 = '1'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test2 = '2'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test3 = '3'\n      return config\n    })\n\n    instance('/foo')\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders.test1).tobe('1')\n      expect(request.requestheaders.test2).tobe('2')\n      expect(request.requestheaders.test3).tobe('3')\n    })\n  })\n\n  test('should add a response interceptor', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + ' - modified by interceptor'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('ok - modified by interceptor')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add a response interceptor that returns a new data object', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(() => {\n      return {\n        data: 'stuff',\n        headers: null,\n        status: 500,\n        statustext: 'err',\n        request: null,\n        config: {}\n      }\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('stuff')\n        expect(response.headers).tobenull()\n        expect(response.status).tobe(500)\n        expect(response.statustext).tobe('err')\n        expect(response.request).tobenull()\n        expect(response.config).toequal({})\n        done()\n      }, 100)\n    })\n  })\n\n\n  test('should add a response interceptor that returns a promise', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      return new promise(resolve => {\n        // do something async\n        settimeout(() => {\n          data.data = 'you have been promised!'\n          resolve(data)\n        }, 10)\n      })\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('you have been promised!')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add multiple response interceptors', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('ok123')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow removing interceptors', done => {\n    let response: axiosresponse\n    let intercept\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    intercept = instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance.interceptors.response.eject(intercept)\n    instance.interceptors.response.eject(5)\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('ok13')\n        done()\n      }, 100)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n\n\n测试发现的问题：\n\n * should add a request interceptor that returns a new config object ：发现执行到 processheaders 中的 object.keys(headers).foreach 代码报错，因为在拦截器对请求配置做了修改，导致 headers 为空，所以报错。\n   \n   （ src/core/xhr.ts ）：\n   \n   const {\n     // ...\n     headers = {}\n   } = config\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   > 给 headers 添加一个默认值。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 合并配置模块单元测试",frontmatter:{title:"🌖 合并配置模块单元测试",date:"2022-06-18T15:31:03.000Z",permalink:"/pages/f2e77e/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/76.%20%F0%9F%8C%96%20%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/76. 🌖 合并配置模块单元测试.md",key:"v-5f8b8f7b",path:"/pages/f2e77e/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:2}],headersStr:"测试代码编写",content:"# 测试代码编写\n\n创建文件 test/mergeConfig.spect.ts ：\n\nimport axios from '../src/index'\nimport mergeConfig from '../src/core/mergeConfig'\n\ndescribe('mergeConfig', () => {\n  const defaults = axios.defaults\n\n  test('should accept undefined for second argument', () => {\n    expect(mergeConfig(defaults, undefined)).toEqual(defaults)\n  })\n\n  test('should accept an object for second argument', () => {\n    expect(mergeConfig(defaults, {})).toEqual(defaults)\n  })\n\n  test('should not leave references', () => {\n    const merged = mergeConfig(defaults, {})\n    expect(merged).not.toBe(defaults)\n    expect(merged.headers).not.toBe(defaults.headers)\n  })\n\n  test('should allow setting request options', () => {\n    const config = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeConfig(defaults, config)\n    expect(merged.url).toBe(config.url)\n    expect(merged.params).toBe(config.params)\n    expect(merged.data).toEqual(config.data)\n  })\n\n  test('should not inherit request options', () => {\n    const localDefaults = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeConfig(localDefaults, {})\n    expect(merged.url).toBeUndefined()\n    expect(merged.params).toBeUndefined()\n    expect(merged.data).toBeUndefined()\n  })\n\n  test('should return default headers if pass config2 with undefined', () => {\n    expect(\n      mergeConfig(\n        {\n          headers: 'x-mock-header'\n        },\n        undefined\n      )\n    ).toEqual({\n      headers: 'x-mock-header'\n    })\n  })\n\n  test('should merge auth, headers with defaults', () => {\n    expect(\n      mergeConfig(\n        {\n          auth: undefined\n        },\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        }\n      )\n    ).toEqual({\n      auth: {\n        username: 'foo',\n        password: 'test'\n      }\n    })\n    expect(\n      mergeConfig(\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        },\n        {\n          auth: {\n            username: 'baz',\n            password: 'foobar'\n          }\n        }\n      )\n    ).toEqual({\n      auth: {\n        username: 'baz',\n        password: 'foobar'\n      }\n    })\n  })\n\n  test('should overwrite auth, headers with a non-object value', () => {\n    expect(\n      mergeConfig(\n        {\n          headers: {\n            common: {\n              Accept: 'application/json, text/plain, */*'\n            }\n          }\n        },\n        {\n          headers: null\n        }\n      )\n    ).toEqual({\n      headers: null\n    })\n  })\n\n  test('should allow setting other options', () => {\n    const merged = mergeConfig(defaults, {\n      timeout: 123\n    })\n    expect(merged.timeout).toBe(123)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n测试发现的问题：\n\n * mergeConfig.ts 文件的分支覆盖率并未达到 100%，提示是 23 行，打开文件后发现最后一个 else 逻辑并未走到，也就是 val1 为 undefined 的情况。但实际上即使 val1 为 undefined ，也是返回 undefined ，也就是返回 val1 ，所以这块代码的逻辑可以优化。\n   \n   （ src/core/mergeConfig.ts ）：\n   \n   function deepMergeStrat(val1: any, val2: any): any {\n     if (isPlainObject(val2)) {\n       return deepMerge(val1, val2)\n     } else if (typeof val2 !== 'undefined') {\n       return val2\n     } else if (isPlainObject(val1)) {\n       return deepMerge(val1)\n     } else if (typeof val1 !== 'undefined') {\n       return val1\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   ",normalizedContent:"# 测试代码编写\n\n创建文件 test/mergeconfig.spect.ts ：\n\nimport axios from '../src/index'\nimport mergeconfig from '../src/core/mergeconfig'\n\ndescribe('mergeconfig', () => {\n  const defaults = axios.defaults\n\n  test('should accept undefined for second argument', () => {\n    expect(mergeconfig(defaults, undefined)).toequal(defaults)\n  })\n\n  test('should accept an object for second argument', () => {\n    expect(mergeconfig(defaults, {})).toequal(defaults)\n  })\n\n  test('should not leave references', () => {\n    const merged = mergeconfig(defaults, {})\n    expect(merged).not.tobe(defaults)\n    expect(merged.headers).not.tobe(defaults.headers)\n  })\n\n  test('should allow setting request options', () => {\n    const config = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeconfig(defaults, config)\n    expect(merged.url).tobe(config.url)\n    expect(merged.params).tobe(config.params)\n    expect(merged.data).toequal(config.data)\n  })\n\n  test('should not inherit request options', () => {\n    const localdefaults = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeconfig(localdefaults, {})\n    expect(merged.url).tobeundefined()\n    expect(merged.params).tobeundefined()\n    expect(merged.data).tobeundefined()\n  })\n\n  test('should return default headers if pass config2 with undefined', () => {\n    expect(\n      mergeconfig(\n        {\n          headers: 'x-mock-header'\n        },\n        undefined\n      )\n    ).toequal({\n      headers: 'x-mock-header'\n    })\n  })\n\n  test('should merge auth, headers with defaults', () => {\n    expect(\n      mergeconfig(\n        {\n          auth: undefined\n        },\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        }\n      )\n    ).toequal({\n      auth: {\n        username: 'foo',\n        password: 'test'\n      }\n    })\n    expect(\n      mergeconfig(\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        },\n        {\n          auth: {\n            username: 'baz',\n            password: 'foobar'\n          }\n        }\n      )\n    ).toequal({\n      auth: {\n        username: 'baz',\n        password: 'foobar'\n      }\n    })\n  })\n\n  test('should overwrite auth, headers with a non-object value', () => {\n    expect(\n      mergeconfig(\n        {\n          headers: {\n            common: {\n              accept: 'application/json, text/plain, */*'\n            }\n          }\n        },\n        {\n          headers: null\n        }\n      )\n    ).toequal({\n      headers: null\n    })\n  })\n\n  test('should allow setting other options', () => {\n    const merged = mergeconfig(defaults, {\n      timeout: 123\n    })\n    expect(merged.timeout).tobe(123)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n测试发现的问题：\n\n * mergeconfig.ts 文件的分支覆盖率并未达到 100%，提示是 23 行，打开文件后发现最后一个 else 逻辑并未走到，也就是 val1 为 undefined 的情况。但实际上即使 val1 为 undefined ，也是返回 undefined ，也就是返回 val1 ，所以这块代码的逻辑可以优化。\n   \n   （ src/core/mergeconfig.ts ）：\n   \n   function deepmergestrat(val1: any, val2: any): any {\n     if (isplainobject(val2)) {\n       return deepmerge(val1, val2)\n     } else if (typeof val2 !== 'undefined') {\n       return val2\n     } else if (isplainobject(val1)) {\n       return deepmerge(val1)\n     } else if (typeof val1 !== 'undefined') {\n       return val1\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   ",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 请求取消模块单元测试",frontmatter:{title:"🌖 请求取消模块单元测试",date:"2022-06-18T15:31:33.000Z",permalink:"/pages/4877d8/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/77.%20%F0%9F%8C%96%20%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/77. 🌖 请求取消模块单元测试.md",key:"v-5464c35d",path:"/pages/4877d8/",headers:[{level:2,title:"编写测试代码",slug:"编写测试代码",normalizedTitle:"编写测试代码",charIndex:2},{level:3,title:"Cancel 类单元测试",slug:"cancel-类单元测试",normalizedTitle:"cancel 类单元测试",charIndex:13},{level:3,title:"CancelToken 类单元测试",slug:"canceltoken-类单元测试",normalizedTitle:"canceltoken 类单元测试",charIndex:642},{level:3,title:"Cancel 业务逻辑测试",slug:"cancel-业务逻辑测试",normalizedTitle:"cancel 业务逻辑测试",charIndex:3957}],headersStr:"编写测试代码 Cancel 类单元测试 CancelToken 类单元测试 Cancel 业务逻辑测试",content:"# 编写测试代码\n\n\n# Cancel 类单元测试\n\n创建文件 test/cancel/Cancel.spec.ts ：\n\nimport Cancel, { isCancel } from '../../src/cancel/Cancel'\n\ndescribe('cancel:Cancel', () => {\n  test('should returns correct result when message is specified', () => {\n    const cancel = new Cancel('Operation has been canceled.')\n    expect(cancel.message).toBe('Operation has been canceled.')\n  })\n\n  test('should returns true if value is a Cancel', () => {\n    expect(isCancel(new Cancel())).toBeTruthy()\n  })\n\n  test('should returns false if value is not a Cancel', () => {\n    expect(isCancel({ foo: 'bar' })).toBeFalsy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# CancelToken 类单元测试\n\n创建文件 test/cancel/CancelToken.spec.ts ：\n\nimport { Canceler } from '../../src'\nimport CancelToken from '../../src/cancel/CancelToken'\nimport Cancel from '../../src/cancel/Cancel'\n\ndescribe('CancelToken', () => {\n  describe('reason', () => {\n    test('should returns a Cancel if cancellation has been requested', () => {\n      let cancel: Canceler\n      let token = new CancelToken(c => {\n        cancel = c\n      })\n      cancel!('Operation has been canceled.')\n      expect(token.reason).toEqual(expect.any(Cancel))\n      expect(token.reason!.message).toBe('Operation has been canceled.')\n    })\n\n    test('should has no side effect if call cancellation for multi times', () => {\n      let cancel: Canceler\n      let token = new CancelToken(c => {\n        cancel = c\n      })\n      cancel!('Operation has been canceled.')\n      cancel!('Operation has been canceled.')\n      expect(token.reason).toEqual(expect.any(Cancel))\n      expect(token.reason!.message).toBe('Operation has been canceled.')\n    })\n\n    test('should returns undefined if cancellation has not been requested', () => {\n      const token = new CancelToken(() => {\n        // do nothing\n      })\n      expect(token.reason).toBeUndefined()\n    })\n  })\n\n  describe('promise', () => {\n    test('should returns a Promise that resolves when cancellation is requested', done => {\n      let cancel: Canceler\n      const token = new CancelToken(c => {\n        cancel = c\n      })\n      token.promise.then(value => {\n        expect(value).toEqual(expect.any(Cancel))\n        expect(value.message).toBe('Operation has been canceled.')\n        done()\n      })\n      cancel!('Operation has been canceled.')\n    })\n  })\n\n  describe('throwIfRequested', () => {\n    test('should throws if cancellation has been requested', () => {\n      let cancel: Canceler\n      const token = new CancelToken(c => {\n        cancel = c\n      })\n      cancel!('Operation has been canceled.')\n      try {\n        token.throwIfRequested()\n        fail('Expected throwIfRequested to throw.')\n      } catch (thrown) {\n        if (!(thrown instanceof Cancel)) {\n          fail('Expected throwIfRequested to throw a Cancel, but test threw ' + thrown + '.')\n        }\n        expect(thrown.message).toBe('Operation has been canceled.')\n      }\n    })\n\n    test('should does not throw if cancellation has not been requested', () => {\n      const token = new CancelToken(() => {\n        // do nothing\n      })\n      token.throwIfRequested()\n    })\n  })\n\n  describe('source', () => {\n    test('should returns an object containing token and cancel function', () => {\n      const source = CancelToken.source()\n      expect(source.token).toEqual(expect.any(CancelToken))\n      expect(source.cancel).toEqual(expect.any(Function))\n      expect(source.token.reason).toBeUndefined()\n      source.cancel('Operation has been canceled.')\n      expect(source.token.reason).toEqual(expect.any(Cancel))\n      expect(source.token.reason!.message).toBe('Operation has been canceled.')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n> 使用了 fail 函数表示一个测试的失败。\n\n\n# Cancel 业务逻辑测试\n\n创建文件 test/cancel.spec.ts ：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('cancel', () => {\n  const CancelToken = axios.CancelToken\n  const Cancel = axios.Cancel\n\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  describe('when called before sending request', () => {\n    test('should rejects Promise with a Cancel object', () => {\n      const source = CancelToken.source()\n      source.cancel('Operation has been canceled.')\n\n      return axios\n        .get('/foo', {\n          cancelToken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toEqual(expect.any(Cancel))\n          expect(reason.message).toBe('Operation has been canceled.')\n        })\n    })\n  })\n\n  describe('when called after request has been sent', () => {\n    test('should rejects Promise with a Cancel object', done => {\n      const source = CancelToken.source()\n      axios\n        .get('/foo/bar', {\n          cancelToken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toEqual(expect.any(Cancel))\n          expect(reason.message).toBe('Operation has been canceled.')\n          done()\n        })\n\n      getAjaxRequest().then(request => {\n        source.cancel('Operation has been canceled.')\n        setTimeout(() => {\n          request.respondWith({\n            status: 200,\n            responseText: 'OK'\n          })\n        }, 100)\n      })\n    })\n\n    test('calls abort on request object', done => {\n      const source = CancelToken.source()\n      let request: any\n      axios\n        .get('/foo/bar', {\n          cancelToken: source.token\n        })\n        .catch(() => {\n          expect(request.statusText).toBe('abort')\n          done()\n        })\n\n      getAjaxRequest().then(req => {\n        source.cancel()\n        request = req\n      })\n    })\n  })\n\n  describe('when called after response has been received', () => {\n    test('should not cause unhandled rejection', done => {\n      const source = CancelToken.source()\n      axios\n        .get('/foo', {\n          cancelToken: source.token\n        })\n        .then(() => {\n          window.addEventListener('unhandledrejection', () => {\n            done.fail('Unhandled rejection.')\n          })\n          source.cancel()\n          setTimeout(done, 100)\n        })\n\n      getAjaxRequest().then(request => {\n        request.respondWith({\n          status: 200,\n          responseText: 'OK'\n        })\n      })\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n> 使用了 done.fail 表示了一个异常的结束。",normalizedContent:"# 编写测试代码\n\n\n# cancel 类单元测试\n\n创建文件 test/cancel/cancel.spec.ts ：\n\nimport cancel, { iscancel } from '../../src/cancel/cancel'\n\ndescribe('cancel:cancel', () => {\n  test('should returns correct result when message is specified', () => {\n    const cancel = new cancel('operation has been canceled.')\n    expect(cancel.message).tobe('operation has been canceled.')\n  })\n\n  test('should returns true if value is a cancel', () => {\n    expect(iscancel(new cancel())).tobetruthy()\n  })\n\n  test('should returns false if value is not a cancel', () => {\n    expect(iscancel({ foo: 'bar' })).tobefalsy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# canceltoken 类单元测试\n\n创建文件 test/cancel/canceltoken.spec.ts ：\n\nimport { canceler } from '../../src'\nimport canceltoken from '../../src/cancel/canceltoken'\nimport cancel from '../../src/cancel/cancel'\n\ndescribe('canceltoken', () => {\n  describe('reason', () => {\n    test('should returns a cancel if cancellation has been requested', () => {\n      let cancel: canceler\n      let token = new canceltoken(c => {\n        cancel = c\n      })\n      cancel!('operation has been canceled.')\n      expect(token.reason).toequal(expect.any(cancel))\n      expect(token.reason!.message).tobe('operation has been canceled.')\n    })\n\n    test('should has no side effect if call cancellation for multi times', () => {\n      let cancel: canceler\n      let token = new canceltoken(c => {\n        cancel = c\n      })\n      cancel!('operation has been canceled.')\n      cancel!('operation has been canceled.')\n      expect(token.reason).toequal(expect.any(cancel))\n      expect(token.reason!.message).tobe('operation has been canceled.')\n    })\n\n    test('should returns undefined if cancellation has not been requested', () => {\n      const token = new canceltoken(() => {\n        // do nothing\n      })\n      expect(token.reason).tobeundefined()\n    })\n  })\n\n  describe('promise', () => {\n    test('should returns a promise that resolves when cancellation is requested', done => {\n      let cancel: canceler\n      const token = new canceltoken(c => {\n        cancel = c\n      })\n      token.promise.then(value => {\n        expect(value).toequal(expect.any(cancel))\n        expect(value.message).tobe('operation has been canceled.')\n        done()\n      })\n      cancel!('operation has been canceled.')\n    })\n  })\n\n  describe('throwifrequested', () => {\n    test('should throws if cancellation has been requested', () => {\n      let cancel: canceler\n      const token = new canceltoken(c => {\n        cancel = c\n      })\n      cancel!('operation has been canceled.')\n      try {\n        token.throwifrequested()\n        fail('expected throwifrequested to throw.')\n      } catch (thrown) {\n        if (!(thrown instanceof cancel)) {\n          fail('expected throwifrequested to throw a cancel, but test threw ' + thrown + '.')\n        }\n        expect(thrown.message).tobe('operation has been canceled.')\n      }\n    })\n\n    test('should does not throw if cancellation has not been requested', () => {\n      const token = new canceltoken(() => {\n        // do nothing\n      })\n      token.throwifrequested()\n    })\n  })\n\n  describe('source', () => {\n    test('should returns an object containing token and cancel function', () => {\n      const source = canceltoken.source()\n      expect(source.token).toequal(expect.any(canceltoken))\n      expect(source.cancel).toequal(expect.any(function))\n      expect(source.token.reason).tobeundefined()\n      source.cancel('operation has been canceled.')\n      expect(source.token.reason).toequal(expect.any(cancel))\n      expect(source.token.reason!.message).tobe('operation has been canceled.')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n> 使用了 fail 函数表示一个测试的失败。\n\n\n# cancel 业务逻辑测试\n\n创建文件 test/cancel.spec.ts ：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('cancel', () => {\n  const canceltoken = axios.canceltoken\n  const cancel = axios.cancel\n\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  describe('when called before sending request', () => {\n    test('should rejects promise with a cancel object', () => {\n      const source = canceltoken.source()\n      source.cancel('operation has been canceled.')\n\n      return axios\n        .get('/foo', {\n          canceltoken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toequal(expect.any(cancel))\n          expect(reason.message).tobe('operation has been canceled.')\n        })\n    })\n  })\n\n  describe('when called after request has been sent', () => {\n    test('should rejects promise with a cancel object', done => {\n      const source = canceltoken.source()\n      axios\n        .get('/foo/bar', {\n          canceltoken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toequal(expect.any(cancel))\n          expect(reason.message).tobe('operation has been canceled.')\n          done()\n        })\n\n      getajaxrequest().then(request => {\n        source.cancel('operation has been canceled.')\n        settimeout(() => {\n          request.respondwith({\n            status: 200,\n            responsetext: 'ok'\n          })\n        }, 100)\n      })\n    })\n\n    test('calls abort on request object', done => {\n      const source = canceltoken.source()\n      let request: any\n      axios\n        .get('/foo/bar', {\n          canceltoken: source.token\n        })\n        .catch(() => {\n          expect(request.statustext).tobe('abort')\n          done()\n        })\n\n      getajaxrequest().then(req => {\n        source.cancel()\n        request = req\n      })\n    })\n  })\n\n  describe('when called after response has been received', () => {\n    test('should not cause unhandled rejection', done => {\n      const source = canceltoken.source()\n      axios\n        .get('/foo', {\n          canceltoken: source.token\n        })\n        .then(() => {\n          window.addeventlistener('unhandledrejection', () => {\n            done.fail('unhandled rejection.')\n          })\n          source.cancel()\n          settimeout(done, 100)\n        })\n\n      getajaxrequest().then(request => {\n        request.respondwith({\n          status: 200,\n          responsetext: 'ok'\n        })\n      })\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n> 使用了 done.fail 表示了一个异常的结束。",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌖 更多模块单元测试",frontmatter:{title:"🌖 更多模块单元测试",date:"2022-06-18T15:43:13.000Z",permalink:"/pages/b58e50/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/78.%20%F0%9F%8C%96%20%E6%9B%B4%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"801. 💽 TypeScript-Axios/78. 🌖 更多模块单元测试.md",key:"v-444484c2",path:"/pages/b58e50/",headers:[{level:2,title:"编写测试代码",slug:"编写测试代码",normalizedTitle:"编写测试代码",charIndex:2},{level:3,title:"defaults 模块单元测试",slug:"defaults-模块单元测试",normalizedTitle:"defaults 模块单元测试",charIndex:13},{level:3,title:"transform 模块单元测试",slug:"transform-模块单元测试",normalizedTitle:"transform 模块单元测试",charIndex:4988},{level:3,title:"XSRF 模块单元测试",slug:"xsrf-模块单元测试",normalizedTitle:"xsrf 模块单元测试",charIndex:7377},{level:3,title:"上传下载模块单元测试",slug:"上传下载模块单元测试",normalizedTitle:"上传下载模块单元测试",charIndex:9084},{level:3,title:"HTTP 授权模块单元测试",slug:"http-授权模块单元测试",normalizedTitle:"http 授权模块单元测试",charIndex:10214},{level:3,title:"静态方法模块单元测试",slug:"静态方法模块单元测试",normalizedTitle:"静态方法模块单元测试",charIndex:11413},{level:3,title:"补充未覆盖部分测试",slug:"补充未覆盖部分测试",normalizedTitle:"补充未覆盖部分测试",charIndex:12375}],headersStr:"编写测试代码 defaults 模块单元测试 transform 模块单元测试 XSRF 模块单元测试 上传下载模块单元测试 HTTP 授权模块单元测试 静态方法模块单元测试 补充未覆盖部分测试",content:"# 编写测试代码\n\n\n# defaults 模块单元测试\n\n> defaults 模块提供默认的属性和方法。\n\n创建文件 test/defaults.spec.ts ：\n\nimport axios, { AxiosTransformer } from '../src/index'\nimport { getAjaxRequest } from './helper'\nimport { deepMerge } from '../src/helpers/util'\n\ndescribe('defaults', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should transform request json', () => {\n    expect((axios.defaults.transformRequest as AxiosTransformer[])[0]({ foo: 'bar' })).toBe('{\"foo\":\"bar\"}')\n  })\n\n  test('should do nothing to request string', () => {\n    expect((axios.defaults.transformRequest as AxiosTransformer[])[0]('foo=bar')).toBe('foo=bar')\n  })\n\n  test('should transform response json', () => {\n    const data = (axios.defaults.transformResponse as AxiosTransformer[])[0]('{\"foo\":\"bar\"}')\n\n    expect(typeof data).toBe('object')\n    expect(data.foo).toBe('bar')\n  })\n\n  test('should do nothing to response string', () => {\n    expect((axios.defaults.transformResponse as AxiosTransformer[])[0]('foo=bar')).toBe('foo=bar')\n  })\n\n  test('should use global defaults config', () => {\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n    })\n  })\n\n  test('should use modified defaults config', () => {\n    axios.defaults.baseURL = 'http://example.com/'\n\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('http://example.com/foo')\n      delete axios.defaults.baseURL\n    })\n  })\n\n  test('should use request config', () => {\n    axios('/foo', {\n      baseURL: 'http://www.example.com'\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('http://www.example.com/foo')\n    })\n  })\n\n  test('should use default config for custom instance', () => {\n    const instance = axios.create({\n      xsrfCookieName: 'CUSTOM-XSRF-TOKEN',\n      xsrfHeaderName: 'X-CUSTOM-XSRF-TOKEN'\n    })\n    document.cookie = instance.defaults.xsrfCookieName + '=foobarbaz'\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[instance.defaults.xsrfHeaderName!]).toBe('foobarbaz')\n      document.cookie =\n        instance.defaults.xsrfCookieName +\n        '=;expires=' +\n        new Date(Date.now() - 86400000).toUTCString()\n    })\n  })\n\n  test('should use GET headers', () => {\n    axios.defaults.headers.get['X-CUSTOM-HEADER'] = 'foo'\n    axios.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['X-CUSTOM-HEADER']).toBe('foo')\n      delete axios.defaults.headers.get['X-CUSTOM-HEADER']\n    })\n  })\n\n  test('should use POST headers', () => {\n    axios.defaults.headers.post['X-CUSTOM-HEADER'] = 'foo'\n    axios.post('/foo', {})\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['X-CUSTOM-HEADER']).toBe('foo')\n      delete axios.defaults.headers.post['X-CUSTOM-HEADER']\n    })\n  })\n\n  test('should use header config', () => {\n    const instance = axios.create({\n      headers: {\n        common: {\n          'X-COMMON-HEADER': 'commonHeaderValue'\n        },\n        get: {\n          'X-GET-HEADER': 'getHeaderValue'\n        },\n        post: {\n          'X-POST-HEADER': 'postHeaderValue'\n        }\n      }\n    })\n\n    instance.get('/foo', {\n      headers: {\n        'X-FOO-HEADER': 'fooHeaderValue',\n        'X-BAR-HEADER': 'barHeaderValue'\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders).toEqual(\n        deepMerge(axios.defaults.headers.common, axios.defaults.headers.get, {\n          'X-COMMON-HEADER': 'commonHeaderValue',\n          'X-GET-HEADER': 'getHeaderValue',\n          'X-FOO-HEADER': 'fooHeaderValue',\n          'X-BAR-HEADER': 'barHeaderValue'\n        })\n      )\n    })\n  })\n\n  test('should be used by custom instance if set before instance created', () => {\n    axios.defaults.baseURL = 'http://example.org/'\n    const instance = axios.create()\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('http://example.org/foo')\n      delete axios.defaults.baseURL\n    })\n  })\n\n  test('should not be used by custom instance if set after instance created', () => {\n    const instance = axios.create()\n    axios.defaults.baseURL = 'http://example.org/'\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n\n\n\n# transform 模块单元测试\n\n创建文件 test/transform.spec.ts ：\n\nimport axios, { AxiosResponse, AxiosTransformer } from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('transform', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should transform JSON to string', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data)\n\n    return getAjaxRequest().then(request => {\n      expect(request.params).toBe('{\"foo\":\"bar\"}')\n    })\n  })\n\n  test('should transform string to JSON', done => {\n    let response: AxiosResponse\n\n    axios('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: '{\"foo\": \"bar\"}'\n      })\n\n      setTimeout(() => {\n        expect(typeof response.data).toBe('object')\n        expect(response.data.foo).toBe('bar')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should override default transform', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformRequest(data) {\n        return data\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.params).toEqual({ foo: 'bar' })\n    })\n  })\n\n  test('should allow an Array of transformers', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformRequest: (axios.defaults.transformRequest as AxiosTransformer[]).concat(function(\n        data\n      ) {\n        return data.replace('bar', 'baz')\n      })\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.params).toBe('{\"foo\":\"baz\"}')\n    })\n  })\n\n  test('should allowing mutating headers', () => {\n    const token = Math.floor(Math.random() * Math.pow(2, 64)).toString(36)\n\n    axios('/foo', {\n      transformRequest: (data, headers) => {\n        headers['X-Authorization'] = token\n        return data\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['X-Authorization']).toEqual(token)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n# XSRF 模块单元测试\n\n创建文件 test/xsrf.spec.ts ：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('xsrf', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n    document.cookie =\n      axios.defaults.xsrfCookieName + '=;expires=' + new Date(Date.now() - 86400000).toUTCString()\n  })\n\n  test('should not set xsrf header if cookie is null', () => {\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBeUndefined()\n    })\n  })\n\n  test('should set xsrf header if cookie is set', () => {\n    document.cookie = axios.defaults.xsrfCookieName + '=12345'\n\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBe('12345')\n    })\n  })\n\n  test('should not set xsrf header for cross origin', () => {\n    document.cookie = axios.defaults.xsrfCookieName + '=12345'\n\n    axios('http://example.com/')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBeUndefined()\n    })\n  })\n\n  test('should set xsrf header for cross origin when using withCredentials', () => {\n    document.cookie = axios.defaults.xsrfCookieName + '=12345'\n\n    axios('http://example.com/', {\n      withCredentials: true\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBe('12345')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 上传下载模块单元测试\n\n创建文件 test/progress.spec.ts ：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('progress', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should add a download progress handler', () => {\n    const progressSpy = jest.fn()\n\n    axios('/foo', { onDownloadProgress: progressSpy })\n\n    return getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: '{\"foo\": \"bar\"}'\n      })\n      expect(progressSpy).toHaveBeenCalled()\n    })\n  })\n\n  test('should add a upload progress handler', () => {\n    const progressSpy = jest.fn()\n\n    axios('/foo', { onUploadProgress: progressSpy })\n\n    return getAjaxRequest().then(request => {\n      // Jasmine AJAX doesn't trigger upload events.Waiting for jest-ajax fix\n      // expect(progressSpy).toHaveBeenCalled()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 由于由于 jasmine-ajax 插件不会派发 upload 事件，这个未来可以通过自己编写的 jest-ajax 插件来解决，目前不写断言的情况它会直接通过。\n\n\n# HTTP 授权模块单元测试\n\n创建文件 test/auth.spec.ts ：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('auth', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should accept HTTP Basic auth with username/password', () => {\n    axios('/foo', {\n      auth: {\n        username: 'Aladdin',\n        password: 'open sesame'\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['Authorization']).toBe('Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==')\n    })\n  })\n\n  test('should fail to encode HTTP Basic auth credentials with non-Latin1 characters', () => {\n    return axios('/foo', {\n      auth: {\n        username: 'Aladßç£☃din',\n        password: 'open sesame'\n      }\n    })\n      .then(() => {\n        throw new Error(\n          'Should not succeed to make a HTTP Basic auth request with non-latin1 chars in credentials.'\n        )\n      })\n      .catch(error => {\n        expect(/character/i.test(error.message)).toBeTruthy()\n      })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 静态方法模块单元测试\n\n创建文件 test/static.spec.ts ：\n\nimport axios from '../src/index'\n\ndescribe('promise', () => {\n  test('should support all', done => {\n    let fulfilled = false\n\n    axios.all([true, false]).then(arg => {\n      fulfilled = arg[0]\n    })\n\n    setTimeout(() => {\n      expect(fulfilled).toBeTruthy()\n      done()\n    }, 100)\n  })\n\n  test('should support spread', done => {\n    let sum = 0\n    let fulfilled = false\n    let result: any\n\n    axios\n      .all([123, 456])\n      .then(\n        axios.spread((a, b) => {\n          sum = a + b\n          fulfilled = true\n          return 'hello world'\n        })\n      )\n      .then(res => {\n        result = res\n      })\n\n    setTimeout(() => {\n      expect(fulfilled).toBeTruthy()\n      expect(sum).toBe(123 + 456)\n      expect(result).toBe('hello world')\n      done()\n    }, 100)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 补充未覆盖部分测试\n\n\n\n根据上表：\n\n * xhr.ts 中的 40 行：\n   \n   function configureRequest(): void {\n     if (responseType) {\n       request.responseType = responseType\n     }\n   \t// ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   发现并没有在测试中设置过 responseType ，因此需要在 test/request.spec.ts 中补充：\n   \n   \n\n * 接着发现 xhr.ts 的 13 行中：\n   \n   method = 'get',\n   \n   \n   1\n   \n   \n   > 分支没有测试完全。因为实际上代码执行到这的时候 method 是一定会有的，所以不必为其指定默认值，另外还需要在 method!.toUpperCase() 的时候使用非空断言。\n\n * xhr.ts 中：\n   \n   const responseData = responseType !== 'text' ? request.response : request.responseText\n   \n   \n   1\n   \n   \n   > 应该先判断存在 responseType 存在的情况下再去和 text 做对比，需要修改逻辑。\n   \n   const responseData = responseType && responseType !== 'text' ? request.response : request.responseText\n   \n   \n   1\n   \n\n * 再整理一下没有用到的代码将它们注释掉，在除了 helpers/error.ts 模块中对于 super 的测试的分支覆盖率没达到 100%，其它模块均达到 100% 的测试覆盖率。\n\n\n\n> 至此，测试完结撒花啦 🎉。\n\n> /* istanbul ignore next */ 在去阅读一些开源代码的时候经常会遇到，主要用途就是用来忽略测试用的。可以用来忽略了整个构造函数的测试，要想测试覆盖率达到 100 % ，可以使用这个方法。但没有必要，除非明确知道这段代码不需要测试否则不要使用！",normalizedContent:"# 编写测试代码\n\n\n# defaults 模块单元测试\n\n> defaults 模块提供默认的属性和方法。\n\n创建文件 test/defaults.spec.ts ：\n\nimport axios, { axiostransformer } from '../src/index'\nimport { getajaxrequest } from './helper'\nimport { deepmerge } from '../src/helpers/util'\n\ndescribe('defaults', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should transform request json', () => {\n    expect((axios.defaults.transformrequest as axiostransformer[])[0]({ foo: 'bar' })).tobe('{\"foo\":\"bar\"}')\n  })\n\n  test('should do nothing to request string', () => {\n    expect((axios.defaults.transformrequest as axiostransformer[])[0]('foo=bar')).tobe('foo=bar')\n  })\n\n  test('should transform response json', () => {\n    const data = (axios.defaults.transformresponse as axiostransformer[])[0]('{\"foo\":\"bar\"}')\n\n    expect(typeof data).tobe('object')\n    expect(data.foo).tobe('bar')\n  })\n\n  test('should do nothing to response string', () => {\n    expect((axios.defaults.transformresponse as axiostransformer[])[0]('foo=bar')).tobe('foo=bar')\n  })\n\n  test('should use global defaults config', () => {\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n    })\n  })\n\n  test('should use modified defaults config', () => {\n    axios.defaults.baseurl = 'http://example.com/'\n\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('http://example.com/foo')\n      delete axios.defaults.baseurl\n    })\n  })\n\n  test('should use request config', () => {\n    axios('/foo', {\n      baseurl: 'http://www.example.com'\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('http://www.example.com/foo')\n    })\n  })\n\n  test('should use default config for custom instance', () => {\n    const instance = axios.create({\n      xsrfcookiename: 'custom-xsrf-token',\n      xsrfheadername: 'x-custom-xsrf-token'\n    })\n    document.cookie = instance.defaults.xsrfcookiename + '=foobarbaz'\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[instance.defaults.xsrfheadername!]).tobe('foobarbaz')\n      document.cookie =\n        instance.defaults.xsrfcookiename +\n        '=;expires=' +\n        new date(date.now() - 86400000).toutcstring()\n    })\n  })\n\n  test('should use get headers', () => {\n    axios.defaults.headers.get['x-custom-header'] = 'foo'\n    axios.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['x-custom-header']).tobe('foo')\n      delete axios.defaults.headers.get['x-custom-header']\n    })\n  })\n\n  test('should use post headers', () => {\n    axios.defaults.headers.post['x-custom-header'] = 'foo'\n    axios.post('/foo', {})\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['x-custom-header']).tobe('foo')\n      delete axios.defaults.headers.post['x-custom-header']\n    })\n  })\n\n  test('should use header config', () => {\n    const instance = axios.create({\n      headers: {\n        common: {\n          'x-common-header': 'commonheadervalue'\n        },\n        get: {\n          'x-get-header': 'getheadervalue'\n        },\n        post: {\n          'x-post-header': 'postheadervalue'\n        }\n      }\n    })\n\n    instance.get('/foo', {\n      headers: {\n        'x-foo-header': 'fooheadervalue',\n        'x-bar-header': 'barheadervalue'\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders).toequal(\n        deepmerge(axios.defaults.headers.common, axios.defaults.headers.get, {\n          'x-common-header': 'commonheadervalue',\n          'x-get-header': 'getheadervalue',\n          'x-foo-header': 'fooheadervalue',\n          'x-bar-header': 'barheadervalue'\n        })\n      )\n    })\n  })\n\n  test('should be used by custom instance if set before instance created', () => {\n    axios.defaults.baseurl = 'http://example.org/'\n    const instance = axios.create()\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('http://example.org/foo')\n      delete axios.defaults.baseurl\n    })\n  })\n\n  test('should not be used by custom instance if set after instance created', () => {\n    const instance = axios.create()\n    axios.defaults.baseurl = 'http://example.org/'\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n\n\n\n# transform 模块单元测试\n\n创建文件 test/transform.spec.ts ：\n\nimport axios, { axiosresponse, axiostransformer } from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('transform', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should transform json to string', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data)\n\n    return getajaxrequest().then(request => {\n      expect(request.params).tobe('{\"foo\":\"bar\"}')\n    })\n  })\n\n  test('should transform string to json', done => {\n    let response: axiosresponse\n\n    axios('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: '{\"foo\": \"bar\"}'\n      })\n\n      settimeout(() => {\n        expect(typeof response.data).tobe('object')\n        expect(response.data.foo).tobe('bar')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should override default transform', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformrequest(data) {\n        return data\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.params).toequal({ foo: 'bar' })\n    })\n  })\n\n  test('should allow an array of transformers', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformrequest: (axios.defaults.transformrequest as axiostransformer[]).concat(function(\n        data\n      ) {\n        return data.replace('bar', 'baz')\n      })\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.params).tobe('{\"foo\":\"baz\"}')\n    })\n  })\n\n  test('should allowing mutating headers', () => {\n    const token = math.floor(math.random() * math.pow(2, 64)).tostring(36)\n\n    axios('/foo', {\n      transformrequest: (data, headers) => {\n        headers['x-authorization'] = token\n        return data\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['x-authorization']).toequal(token)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n# xsrf 模块单元测试\n\n创建文件 test/xsrf.spec.ts ：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('xsrf', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n    document.cookie =\n      axios.defaults.xsrfcookiename + '=;expires=' + new date(date.now() - 86400000).toutcstring()\n  })\n\n  test('should not set xsrf header if cookie is null', () => {\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobeundefined()\n    })\n  })\n\n  test('should set xsrf header if cookie is set', () => {\n    document.cookie = axios.defaults.xsrfcookiename + '=12345'\n\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobe('12345')\n    })\n  })\n\n  test('should not set xsrf header for cross origin', () => {\n    document.cookie = axios.defaults.xsrfcookiename + '=12345'\n\n    axios('http://example.com/')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobeundefined()\n    })\n  })\n\n  test('should set xsrf header for cross origin when using withcredentials', () => {\n    document.cookie = axios.defaults.xsrfcookiename + '=12345'\n\n    axios('http://example.com/', {\n      withcredentials: true\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobe('12345')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 上传下载模块单元测试\n\n创建文件 test/progress.spec.ts ：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('progress', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should add a download progress handler', () => {\n    const progressspy = jest.fn()\n\n    axios('/foo', { ondownloadprogress: progressspy })\n\n    return getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: '{\"foo\": \"bar\"}'\n      })\n      expect(progressspy).tohavebeencalled()\n    })\n  })\n\n  test('should add a upload progress handler', () => {\n    const progressspy = jest.fn()\n\n    axios('/foo', { onuploadprogress: progressspy })\n\n    return getajaxrequest().then(request => {\n      // jasmine ajax doesn't trigger upload events.waiting for jest-ajax fix\n      // expect(progressspy).tohavebeencalled()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 由于由于 jasmine-ajax 插件不会派发 upload 事件，这个未来可以通过自己编写的 jest-ajax 插件来解决，目前不写断言的情况它会直接通过。\n\n\n# http 授权模块单元测试\n\n创建文件 test/auth.spec.ts ：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('auth', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should accept http basic auth with username/password', () => {\n    axios('/foo', {\n      auth: {\n        username: 'aladdin',\n        password: 'open sesame'\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['authorization']).tobe('basic qwxhzgrpbjpvcgvuihnlc2ftzq==')\n    })\n  })\n\n  test('should fail to encode http basic auth credentials with non-latin1 characters', () => {\n    return axios('/foo', {\n      auth: {\n        username: 'aladßc£☃din',\n        password: 'open sesame'\n      }\n    })\n      .then(() => {\n        throw new error(\n          'should not succeed to make a http basic auth request with non-latin1 chars in credentials.'\n        )\n      })\n      .catch(error => {\n        expect(/character/i.test(error.message)).tobetruthy()\n      })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 静态方法模块单元测试\n\n创建文件 test/static.spec.ts ：\n\nimport axios from '../src/index'\n\ndescribe('promise', () => {\n  test('should support all', done => {\n    let fulfilled = false\n\n    axios.all([true, false]).then(arg => {\n      fulfilled = arg[0]\n    })\n\n    settimeout(() => {\n      expect(fulfilled).tobetruthy()\n      done()\n    }, 100)\n  })\n\n  test('should support spread', done => {\n    let sum = 0\n    let fulfilled = false\n    let result: any\n\n    axios\n      .all([123, 456])\n      .then(\n        axios.spread((a, b) => {\n          sum = a + b\n          fulfilled = true\n          return 'hello world'\n        })\n      )\n      .then(res => {\n        result = res\n      })\n\n    settimeout(() => {\n      expect(fulfilled).tobetruthy()\n      expect(sum).tobe(123 + 456)\n      expect(result).tobe('hello world')\n      done()\n    }, 100)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 补充未覆盖部分测试\n\n\n\n根据上表：\n\n * xhr.ts 中的 40 行：\n   \n   function configurerequest(): void {\n     if (responsetype) {\n       request.responsetype = responsetype\n     }\n   \t// ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   发现并没有在测试中设置过 responsetype ，因此需要在 test/request.spec.ts 中补充：\n   \n   \n\n * 接着发现 xhr.ts 的 13 行中：\n   \n   method = 'get',\n   \n   \n   1\n   \n   \n   > 分支没有测试完全。因为实际上代码执行到这的时候 method 是一定会有的，所以不必为其指定默认值，另外还需要在 method!.touppercase() 的时候使用非空断言。\n\n * xhr.ts 中：\n   \n   const responsedata = responsetype !== 'text' ? request.response : request.responsetext\n   \n   \n   1\n   \n   \n   > 应该先判断存在 responsetype 存在的情况下再去和 text 做对比，需要修改逻辑。\n   \n   const responsedata = responsetype && responsetype !== 'text' ? request.response : request.responsetext\n   \n   \n   1\n   \n\n * 再整理一下没有用到的代码将它们注释掉，在除了 helpers/error.ts 模块中对于 super 的测试的分支覆盖率没达到 100%，其它模块均达到 100% 的测试覆盖率。\n\n\n\n> 至此，测试完结撒花啦 🎉。\n\n> /* istanbul ignore next */ 在去阅读一些开源代码的时候经常会遇到，主要用途就是用来忽略测试用的。可以用来忽略了整个构造函数的测试，要想测试覆盖率达到 100 % ，可以使用这个方法。但没有必要，除非明确知道这段代码不需要测试否则不要使用！",charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🌕 部署与发布",frontmatter:{title:"🌕 部署与发布",date:"2022-06-18T16:05:56.000Z",permalink:"/pages/2b07f0/",categories:["🚶🏻 前端巩固基础","🚟 axios","💽 使用 TypeScript 重构 axios 库"],tags:[null]},regularPath:"/801.%20%F0%9F%92%BD%20TypeScript-Axios/80.%20%F0%9F%8C%95%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%91%E5%B8%83.html",relativePath:"801. 💽 TypeScript-Axios/80. 🌕 部署与发布.md",key:"v-5c3b871e",path:"/pages/2b07f0/",headers:[{level:2,title:"编译与打包",slug:"编译与打包",normalizedTitle:"编译与打包",charIndex:222},{level:2,title:"自定义部署",slug:"自定义部署",normalizedTitle:"自定义部署",charIndex:1225},{level:3,title:"编写部署脚本",slug:"编写部署脚本",normalizedTitle:"编写部署脚本",charIndex:2076}],headersStr:"编译与打包 自定义部署 编写部署脚本",content:'> 至此，所有的 axios 重构的代码编写和单元测试都完成了。这已经是一个几乎成熟可供使用的 TypeScript 库了。\n> \n> 在目前，并不是所有人都会使用 TypeScript 开发，仍然有大量的 JavaScript 用户，它们是不能直接引用 TypeScript 代码的，因此我们需要先对源码做编译和打包，然后再发布。\n> \n> 如果要将这个包发布到 npm 源，需要注册账号，并且在终端使用 npm login 登录。\n\n\n# 编译与打包\n\n利用 rollup 来打包\n\n> 它是一个非常著名的编译打包工具，Vue.js 也是利用 rollup 编译打包的。相比 webpack，它非常适合去编译和打包一些 JS 库。\n\n> 由于使用 typescript-library-starter 初始化我们的项目，我们已经拥有了 rollup 打包的相关配置和相关插件的安装。\n\n对生成的 rollup.config.ts 做小小的修改：\n\n * 将 libraryName 修改为项目名称；\n * input 修改为 src/index.ts 。\n\n>  * input ： 表示打包入口文件。\n>  * output ：表示输出的目标文件，它是一个对象数组，可以指定输出的格式，比如 umd 格式、 es 模式等。\n>  * external ：外部依赖，可以不被打包进去。\n>  * watch ：监听文件的变化，重新编译，只有在编译的时候开启 --watch 才生效。\n>  * plugins ：\n>  * 编译过程中使用的插件，其中 rollup-plugin-typescript2 就是用来编译 TypeScript 文件， useTsconfigDeclarationDir 表示使用 tsconfig.json 文件中定义的 declarationDir 。更多插件可以查阅文档。\n\n修改 package.json ，确保一下：\n\n"main": "dist/axios-typescript.umd.js",\n"module": "dist/axios-typescript.es5.js",\n"typings": "dist/types/axios-typescript.d.ts",\n\n\n1\n2\n3\n\n\n为项目名称。\n\n然后在在控制台执行 npm run build ，会编译输出 dist 目录，其中 ：\n\n * lib 目录是单个 .ts 文件编译后的 .js 文件。\n * types 目录是所有 .ts 文件编译后生产的 .d.ts 声明文件。\n * axios.es5.js 是编译后生成的 es 模式的入口文件，用在 package.json 的 module 字段， axios.umd.js 文件是编译后生成的 umd 模式的入口文件，用在 package.json 的 main 字段。\n\n\n# 自定义部署\n\n> 由于 semantic-release 插件过于黑盒也略微重量，自己编写自动化部署脚本更加灵活意义更大。\n\n首先修改 package.json ：\n\n> 需要为这个包命名一个 npm 中没有被占用的名字。可以使用 npm view 搜索包名是否存在。\n\n如果要关联这个发布的包对应的仓库，可以配置 repository 字段。\n\n添加两个 npm scripts ：\n\n{\n  "prepub": "npm run test:prod && npm run build",\n  "pub": "sh release.sh"\n}\n\n\n1\n2\n3\n4\n\n>  * 当运行 npm run pub 的时候，会优先执行 prepub 脚本，在 prepub 中运行了 test:prod 和 build 2 个脚本。 && 符号表示前面一个命令执行成功后才会执行后面的任务。\n>  * npm run test:prod 实际上运行了 npm run lint && npm run test -- --no-cache 。 先运行 lint 去校验的源码和测试文件是否遵循 tslint 规范，再运行 test 去跑测试。\n>  * npm run build 实际上运行了 tsc --module commonjs 、 rollup -c rollup.config.ts 和 typedoc --out docs --target es6 --theme minimal --mode file src 。先运行 tsc 去编译的 TypeScript 文件， dist/lib 和 dist/types 下的文件就是该命令产生的，然后运行 rollup 去构建 axios.umd.js 及 axios.es.js ，最后运行 typedoc 去构建项目的文档。\n>  * 运行完 prepub 后就会再运行 pub 命令，实际上执行了 sh release.sh 命令。\n\n\n# 编写部署脚本\n\n创建文件 release.sh ：\n\n#!/usr/bin/env sh\nset -e\necho "Enter release version: "\nread VERSION\nread -p "Releasing $VERSION - are you sure? (y/n)" -n 1 -r\necho  # (optional) move to a new line\nif [[ $REPLY =~ ^[Yy]$ ]]\nthen\n  echo "Releasing $VERSION ..."\n\n  # commit\n  git add -A\n  git commit -m "[build] $VERSION"\n  npm version $VERSION --message "[release] $VERSION"\n  git push origin master\n\n  # publish\n  npm publish\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n>  * #!/usr/bin/env sh 用来表示它是一个 shell 脚本。\n> \n>  * set -e 告诉脚本如果执行结果不为 true 则退出。\n> \n>  * read VERSION 表示从标准输入读取值，并赋值给 $VERSION 变量。\n> \n>  * read -p "Releasing $VERSION - are you sure? (y/n)" -n 1 -r ，其中 read -p 表示给出提示符，后面接着 Releasing $VERSION - are you sure? (y/n) 提示符； -n 1 表示限定最多可以有 1 个字符可以作为有效读入； -r 表示禁止反斜线的转义功能。因为 read 并没有指定变量名，那么默认这个输入读取值会赋值给 $REPLY 变量。\n> \n>  * if [[ $REPLY =~ ^[Yy]$ ]] 表示 shell 脚本中的流程控制语句，判断 $REPLY 是不是大小写的 y ，如果满足，则走到后面的 then 逻辑。\n> \n>  * git add -A 表示把代码所有变化提交到暂存区。\n>    \n>    git commit -m "[build] $VERSION" 表示提交代码，提交注释是 [build] $VERSION 。\n>    \n>    npm version $VERSION --message "[release] $VERSION" 是修改 package.json 中的 version 字段到 $VERSION ，并且提交一条修改记录，提交注释是 [release] $VERSION 。\n>    \n>    git push origin master 是把代码发布到主干分支。\n>    \n>    npm publish 是把仓库发布到 npm 上，我们会把 dist 目录下的代码都发布到 npm 上，因为我们在 package.json 中配置的是 files 是 ["dist"]',normalizedContent:'> 至此，所有的 axios 重构的代码编写和单元测试都完成了。这已经是一个几乎成熟可供使用的 typescript 库了。\n> \n> 在目前，并不是所有人都会使用 typescript 开发，仍然有大量的 javascript 用户，它们是不能直接引用 typescript 代码的，因此我们需要先对源码做编译和打包，然后再发布。\n> \n> 如果要将这个包发布到 npm 源，需要注册账号，并且在终端使用 npm login 登录。\n\n\n# 编译与打包\n\n利用 rollup 来打包\n\n> 它是一个非常著名的编译打包工具，vue.js 也是利用 rollup 编译打包的。相比 webpack，它非常适合去编译和打包一些 js 库。\n\n> 由于使用 typescript-library-starter 初始化我们的项目，我们已经拥有了 rollup 打包的相关配置和相关插件的安装。\n\n对生成的 rollup.config.ts 做小小的修改：\n\n * 将 libraryname 修改为项目名称；\n * input 修改为 src/index.ts 。\n\n>  * input ： 表示打包入口文件。\n>  * output ：表示输出的目标文件，它是一个对象数组，可以指定输出的格式，比如 umd 格式、 es 模式等。\n>  * external ：外部依赖，可以不被打包进去。\n>  * watch ：监听文件的变化，重新编译，只有在编译的时候开启 --watch 才生效。\n>  * plugins ：\n>  * 编译过程中使用的插件，其中 rollup-plugin-typescript2 就是用来编译 typescript 文件， usetsconfigdeclarationdir 表示使用 tsconfig.json 文件中定义的 declarationdir 。更多插件可以查阅文档。\n\n修改 package.json ，确保一下：\n\n"main": "dist/axios-typescript.umd.js",\n"module": "dist/axios-typescript.es5.js",\n"typings": "dist/types/axios-typescript.d.ts",\n\n\n1\n2\n3\n\n\n为项目名称。\n\n然后在在控制台执行 npm run build ，会编译输出 dist 目录，其中 ：\n\n * lib 目录是单个 .ts 文件编译后的 .js 文件。\n * types 目录是所有 .ts 文件编译后生产的 .d.ts 声明文件。\n * axios.es5.js 是编译后生成的 es 模式的入口文件，用在 package.json 的 module 字段， axios.umd.js 文件是编译后生成的 umd 模式的入口文件，用在 package.json 的 main 字段。\n\n\n# 自定义部署\n\n> 由于 semantic-release 插件过于黑盒也略微重量，自己编写自动化部署脚本更加灵活意义更大。\n\n首先修改 package.json ：\n\n> 需要为这个包命名一个 npm 中没有被占用的名字。可以使用 npm view 搜索包名是否存在。\n\n如果要关联这个发布的包对应的仓库，可以配置 repository 字段。\n\n添加两个 npm scripts ：\n\n{\n  "prepub": "npm run test:prod && npm run build",\n  "pub": "sh release.sh"\n}\n\n\n1\n2\n3\n4\n\n>  * 当运行 npm run pub 的时候，会优先执行 prepub 脚本，在 prepub 中运行了 test:prod 和 build 2 个脚本。 && 符号表示前面一个命令执行成功后才会执行后面的任务。\n>  * npm run test:prod 实际上运行了 npm run lint && npm run test -- --no-cache 。 先运行 lint 去校验的源码和测试文件是否遵循 tslint 规范，再运行 test 去跑测试。\n>  * npm run build 实际上运行了 tsc --module commonjs 、 rollup -c rollup.config.ts 和 typedoc --out docs --target es6 --theme minimal --mode file src 。先运行 tsc 去编译的 typescript 文件， dist/lib 和 dist/types 下的文件就是该命令产生的，然后运行 rollup 去构建 axios.umd.js 及 axios.es.js ，最后运行 typedoc 去构建项目的文档。\n>  * 运行完 prepub 后就会再运行 pub 命令，实际上执行了 sh release.sh 命令。\n\n\n# 编写部署脚本\n\n创建文件 release.sh ：\n\n#!/usr/bin/env sh\nset -e\necho "enter release version: "\nread version\nread -p "releasing $version - are you sure? (y/n)" -n 1 -r\necho  # (optional) move to a new line\nif [[ $reply =~ ^[yy]$ ]]\nthen\n  echo "releasing $version ..."\n\n  # commit\n  git add -a\n  git commit -m "[build] $version"\n  npm version $version --message "[release] $version"\n  git push origin master\n\n  # publish\n  npm publish\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n>  * #!/usr/bin/env sh 用来表示它是一个 shell 脚本。\n> \n>  * set -e 告诉脚本如果执行结果不为 true 则退出。\n> \n>  * read version 表示从标准输入读取值，并赋值给 $version 变量。\n> \n>  * read -p "releasing $version - are you sure? (y/n)" -n 1 -r ，其中 read -p 表示给出提示符，后面接着 releasing $version - are you sure? (y/n) 提示符； -n 1 表示限定最多可以有 1 个字符可以作为有效读入； -r 表示禁止反斜线的转义功能。因为 read 并没有指定变量名，那么默认这个输入读取值会赋值给 $reply 变量。\n> \n>  * if [[ $reply =~ ^[yy]$ ]] 表示 shell 脚本中的流程控制语句，判断 $reply 是不是大小写的 y ，如果满足，则走到后面的 then 逻辑。\n> \n>  * git add -a 表示把代码所有变化提交到暂存区。\n>    \n>    git commit -m "[build] $version" 表示提交代码，提交注释是 [build] $version 。\n>    \n>    npm version $version --message "[release] $version" 是修改 package.json 中的 version 字段到 $version ，并且提交一条修改记录，提交注释是 [release] $version 。\n>    \n>    git push origin master 是把代码发布到主干分支。\n>    \n>    npm publish 是把仓库发布到 npm 上，我们会把 dist 目录下的代码都发布到 npm 上，因为我们在 package.json 中配置的是 files 是 ["dist"]',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-47d644e5",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-f689eb36",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-b7a2df76",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"Home",frontmatter:{home:!0,postList:"simple",simplePostListLength:15},regularPath:"/",relativePath:"index.md",key:"v-309ec2fe",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍥 JavaScript DOM 操作",frontmatter:{title:"🍥 JavaScript DOM 操作",date:"2022-05-27T13:16:15.000Z",permalink:"/pages/cae956/",categories:["🚶🏻 前端巩固基础","📓 JavaScript DOM"],tags:[null]},regularPath:"/101.%20%F0%9F%9A%B6%F0%9F%8F%BB%20%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80/36.%20%F0%9F%93%93%20JavaScript%20DOM/02.%20%F0%9F%8D%A5%20JavaScript%20DOM%20%E6%93%8D%E4%BD%9C.html",relativePath:"101. 🚶🏻 前端巩固基础/36. 📓 JavaScript DOM/02. 🍥 JavaScript DOM 操作.md",key:"v-43cefae9",path:"/pages/cae956/",headers:[{level:2,title:"操作 DOM",slug:"操作-dom",normalizedTitle:"操作 dom",charIndex:2},{level:3,title:"读取 DOM 元素属性",slug:"读取-dom-元素属性",normalizedTitle:"读取 dom 元素属性",charIndex:1759},{level:3,title:"写入 HTML",slug:"写入-html",normalizedTitle:"写入 html",charIndex:2078},{level:4,title:"innerHTML",slug:"innerhtml",normalizedTitle:"innerhtml",charIndex:2089},{level:4,title:"outerHTML",slug:"outerhtml",normalizedTitle:"outerhtml",charIndex:2892},{level:4,title:"nodeValue / data 文本节点",slug:"nodevalue-data-文本节点",normalizedTitle:"nodevalue /data 文本节点",charIndex:null},{level:4,title:"textContent 纯文本",slug:"textcontent-纯文本",normalizedTitle:"textcontent 纯文本",charIndex:4045},{level:4,title:"hidden 属性",slug:"hidden-属性",normalizedTitle:"hidden 属性",charIndex:4626},{level:3,title:"区分 Atrributes 与 properties",slug:"区分-atrributes-与-properties",normalizedTitle:"区分 atrributes 与 properties",charIndex:4964},{level:4,title:"DOM 属性 Property",slug:"dom-属性-property",normalizedTitle:"dom 属性 property",charIndex:5160},{level:4,title:"HTML 特性 Attribute",slug:"html-特性-attribute",normalizedTitle:"html 特性 attribute",charIndex:5701},{level:4,title:"属性与特性同步",slug:"属性与特性同步",normalizedTitle:"属性与特性同步",charIndex:7218},{level:4,title:"DOM 属性的类型",slug:"dom-属性的类型",normalizedTitle:"dom 属性的类型",charIndex:7984},{level:4,title:"非标准 HTML 特性",slug:"非标准-html-特性",normalizedTitle:"非标准 html 特性",charIndex:8916},{level:4,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:10867},{level:3,title:"修改 DOM 文档",slug:"修改-dom-文档",normalizedTitle:"修改 dom 文档",charIndex:10980},{level:4,title:"创建元素",slug:"创建元素",normalizedTitle:"创建元素",charIndex:11345},{level:4,title:"完善元素内容",slug:"完善元素内容",normalizedTitle:"完善元素内容",charIndex:11616},{level:4,title:"插入元素",slug:"插入元素",normalizedTitle:"插入元素",charIndex:11817},{level:4,title:"移除节点",slug:"移除节点",normalizedTitle:"移除节点",charIndex:14008},{level:4,title:"移动节点",slug:"移动节点",normalizedTitle:"移动节点",charIndex:14328},{level:4,title:"克隆节点",slug:"克隆节点",normalizedTitle:"克隆节点",charIndex:14600},{level:4,title:"节点片段 DocumentFragment",slug:"节点片段-documentfragment",normalizedTitle:"节点片段 documentfragment",charIndex:14993},{level:4,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:10867}],headersStr:"操作 DOM 读取 DOM 元素属性 写入 HTML innerHTML outerHTML nodeValue / data 文本节点 textContent 纯文本 hidden 属性 区分 Atrributes 与 properties DOM 属性 Property HTML 特性 Attribute 属性与特性同步 DOM 属性的类型 非标准 HTML 特性 总结 修改 DOM 文档 创建元素 完善元素内容 插入元素 移除节点 移动节点 克隆节点 节点片段 DocumentFragment 总结",content:'# 操作 DOM\n\n每一个 DOM 元素节点都属于一个特定的类。这些类形成层次结构。\n\n> 例如，标签 <a> 相对应的元素节点具有链接相关的（link-related）属性，标签 <input> 相对应的元素节点具有与输入相关的属性；\n> \n> 文本节点与元素节点不同。但是所有这些标签节点之间也存在共有的属性和方法，因为所有类型的 DOM 节点都形成了一个单一层次的结构。\n> \n> 最终 层次结构 的根节点是 EventTarget 类， Node 节点类继承自它，其他 DOM 节点继承自 Node 类。\n\n点击查看\n * EventTarget ：根「抽象」类。它作为一个基础，让所有的节点都支持 事件行为。（没有实现对象）\n * Node ：抽象类。是 DOM 节点的基础，提供了 DOM 树的核心功能（ parentNode 、 nextSibling 、 childNodes 等 getter ）（没有实现对象）但是有继承自它的具体节点类， Text 文本节点、 Element 元素节点、注释节点等。\n * Element ：DOM 元素节点的基础类。提供了 元素级导航的 getter 。特殊的元素基础节点类继承自它， SVGElement 、 XMLElement 、 HTMLElement 等。\n * HTMLElement ：是所有的 HTML 元素基础类。各类的 HTML 元素继承自它：\n   * HTMLInputElement ： <input> 元素的类；\n   * HTMLBodyElement 、 HTMLAnchorElement … 等。\n\n> 一些元素没有特定的属性，例如 <span> 、 <section> 、 <article> ，都是 HTMLElement 的实例。\n\n> 从一个 DOM 元素角度出发，例如 <input> 的全部属性和方法的来源（都是来自继承下列的类）：\n> \n>  * HTMLInputElement ：该类提供特定于输入的属性；\n>  * HTMLElement ：提供了通用的 HTML 元素方法（以及 getter 和 setter）；\n>  * Element ：提供通用泛型元素方法；\n>  * Node ：提供通用 DOM 节点属性；\n>  * EventTarget ： 为事件（包括事件本身）提供支持；\n>  * 最后包括 Object 普通对象的方法。\n\n对于 对象 是适用的属性和方法，DOM 节点也适用：\n\n * 获取名称：\n   \n   以获取引用类的名称为例，通过 constructor 获取：\n   \n   console.log(document.body.constructor.name) // HTMLBodyElement\n   \n   \n   1\n   \n   \n   toString 方法：\n   \n   console.log(document.body) // [object HTMLBodyElement]\n   \n   \n   1\n   \n\n * 检查继承 instanceof :\n   \n   console.log(document.body instanceof HTMLBodyElement) // true\n   console.log(document.body instanceof HTMLElement) // true\n   console.log(document.body instanceof Element) // true\n   console.log(document.body instanceof Node) // true\n   console.log(document.body instanceof EventTarget) // true\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n> console... 开发者命令行输出 DOM 元素：\n> \n>  * console.log ：显示元素的 DOM 树。\n>  * console.dir ：显示为 DOM 对象，展示属性和方法。\n\n\n# 读取 DOM 元素属性\n\n * 获取 DOM 节点的节点 / 标签名称：\n   * tagName ：仅适用于 Element 元素节点。\n   * nodeName ：适用于任意的 Node 节点。\n\n> 标签名称的大小写问题：\n> \n>  * 在浏览器 HTML 模式文档中， tagName/nodeName 始终是大写的：它是 BODY ，而不是 <body> 或 <BoDy> 。\n>  * 在 XML 模式中，大小写保持为原样。\n\n * 获取元素名称： ele.name\n * 获取元素 id ： ele.id\n * 获取元素值 value ： ele.value\n * 获取元素的类名： ele.className\n\n\n# 写入 HTML\n\n# innerHTML\n\ninnerHTML 允许将元素中的 HTML 获取为字符串形式，并且可以修改它。是更改页面最有效的方法之一。\n\n🌰 例子 / 获取 body 的内容，完全替换：\n\n<body>\n  <p>A paragraph</p>\n  <div>A div</div>\n\n  <script>\n    consoel.log(document.body.innerHTML); // 读取当前内容\n    document.body.innerHTML = \'The new BODY!\'; // 替换它\n  <\/script>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子 / 插入无效的 HTML 会被修复（未闭合的标签）：\n\n<body>\n\n  <script>\n    document.body.innerHTML = \'<b>test\'; // 忘记闭合标签\n    console.log( document.body.innerHTML ); // <b>test</b>（被修复了）\n  <\/script>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 对于脚本标签 <script> 无效，可以插入但是不会执行。\n\n注意\n\n使用 innerHTML+= 会完全重写掉原来的内容并且附加的内容。\n\n例如：\n\nchatDiv.innerHTML += "<div>Hello<img src=\'smile.gif\'/> !</div>";\nchatDiv.innerHTML += "How goes?";\n\n\n1\n2\n\n\n> 技术上， innerHTML 完成了两项工作：移除原来的内容；写入新的内容。\n\n因为内容被重写，所以所有的图片和资源都会重新加载；这对于一些输入、选中等类型的元素是致命的，这会丢失原来的数据。\n\n# outerHTML\n\nouterHTML 属性包含了元素的 完整 HTML。 innerHTML 的内容加上元素标签。\n\n🌰 例子：\n\n<div id="elem">Hello <b>World</b></div>\n\n<script>\n  console.log(elem.outerHTML); // <div id="elem">Hello <b>World</b></div>\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n注意：与 innerHTML 不同，写入 outerHTML 不会改变元素。而是在 DOM 中替换它。\n\n🌰 例子 / 选中一个 DOM 元素，使用 outerHTML 替换：\n\n<div>\n  hello world!\n</div>\n\n\n1\n2\n3\n\n\nlet div = querySelector("div")\ndiv.outerHTML = \'<p>new world</p>\'\nconsole.log(div.outerHTML) // <div> hello world! </div>\n\n\n1\n2\n3\n\n\n> 尽管第二行中，使用了 outerHTML 替换掉原来的内容，在外部 HTML 文档可以看到原来的内容被替换。但是原来的 outerHTML 内容不会改变。\n\n说明， outerHTML 赋值不会修改 DOM 元素， 而是将其从 DOM 中删除并在其位置插入新的 HTML。\n\n所以，上面的例子 outerHTML 完成了：将 div 从文档中移除；另一个 HTML 文档片段被插入到其位置； div 仍然拥有旧的值，新的 HTML 没有被赋值给任何变量。\n\n> 仍然可以通过 选择器 获取新的元素的引用；并且原来的获取的元素仍然保留。\n\n注意\n\ninnerHTML 与 outerHTML 只对 元素节点 有效。\n\n# nodeValue / data 文本节点\n\n对于其他节点类型，例如文本节点类型，具有它们的对应项： nodeValue 和 data 属性。两种属性只有细微的差异。\n\n🌰 例子 / 使用 data 获取节点的内容：\n\n<body>\n  Hello\n  \x3c!-- Comment --\x3e\n  <script>\n    let text = document.body.firstChild;\n    console.log(text.data); // Hello\n\n    let comment = text.nextSibling;\n    console.log(comment.data); // Comment\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# textContent 纯文本\n\ntextContent 提供了对元素内的 文本 的访问权限：仅文本，去掉所有 标签。\n\n🌰 例子 / 读取纯文本内容：\n\n<div id="news">\n  <h1>Headline!</h1>\n  <p>Martians attack people!</p>\n</div>\n\n\n1\n2\n3\n4\n\n\nconsole.log(news.textContent); // Headline! Martians attack people!\n\n\n1\n\n>  * 使用 innerHTML ，将其 作为 HTML 插入，带有所有 HTML 标签会被作为 HTML 处理。\n>  * 使用 textContent ，将其 作为文本 插入，所有符号均按字面意义处理。\n\n🌰 例子 / 安全方式写入文本：\n\n<div id="elem1"></div>\n<div id="elem2"></div>\n\n\n1\n2\n\n\n<script>\n  let name = prompt("What\'s your name?", "<b>Winnie-the-Pooh!</b>");\n\n  elem1.innerHTML = name;\n  elem2.textContent = name;\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# hidden 属性\n\n用于 指定 DOM 元素是否可见。\n\n🌰 例子：\n\n<div>Both divs below are hidden</div>\n\n<div hidden>With the attribute "hidden"</div>\n\n<div id="elem">JavaScript assigned the property "hidden"</div>\n\n<script>\n  let elem = document.querySelector(\'#elem\')\n  elem.hidden = true;\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 实现的效果与 style="display: none" 相同。\n\n\n# 区分 Atrributes 与 properties\n\n在浏览器页面加载时，会解析 HTML 从中生成 DOM 对象。对于元素节点 的大多数 HTML Attributes 特性 会自动变成 DOM 对象节点的 properties 属性。但是特性和属性映射不是一一对应的。\n\n🌰 例如： <body id="page"> 中 id 特性会对应属性 body.id=“page” 。\n\n# DOM 属性 Property\n\n由于 DOM 元素对象也是 JavaScript 常规对象，所以可以更改它们。\n\n * 可以有很多值。\n * 键大小写敏感。\n\n🌰 例子：\n\ndocument.body.myData = {\n  name: "name",\n  title: "title"\n}\n\nconsole.log(document.body.myData.name) // "name"\n\n\n1\n2\n3\n4\n5\n6\n\n\n添加一个方法：\n\ndocument.body.sayTagName = function () {\n  console.log(this.tagName)\n}\n\ndocument.body.sayTagName() // BODY\n\n\n1\n2\n3\n4\n5\n\n\n修改原型：\n\nElement.prototype.sayHi = funciton () {\n  console.log(`HI, IAM ${this.tagName}`)\n}\n\ndocument.documentElement.sayHi() // HI, IAM HTML\ndocument.body.sayHi() // HI, IAM BODY\n\n\n1\n2\n3\n4\n5\n6\n\n\n# HTML 特性 Attribute\n\n指的是 HTML 标签中的 标准特性 并且以此创建 DOM 属性。\n\nHTML 特性有以下几个特征：\n\n * 它们的名字是大小写不敏感的（ id 与 ID 相同）。\n * 它们的值总是字符串类型的。\n\n🌰 例子：\n\n<body id="test" something="non-standard">\n  <script>\n    alert(document.body.id); // test\n    // 非标准的特性没有获得对应的属性\n    alert(document.body.something); // undefined\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 可以看出：对应的 标准特性 id 才会创建 DOM 属性。非标准的特性不会。\n> \n> 但是不同的标签，标准的特性可能会不同。例如 type 特性是 <input> 的一个标准的特性（HTMLInputElement），但对于 <body> （HTMLBodyElement）来说则不是。规范中对相应元素类的标准的属性进行了详细的描述。\n> \n> <body id="body" type="...">\n> <input id="input" type="text">\n> <script>\n>  alert(input.type); // text\n>  alert(body.type); // undefined：DOM 属性没有被创建，因为它不是一个标准的特性\n> <\/script>\n> </body>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n所有特性（包含非标准特性）都可以通过使用以下方法进行访问：\n\n * element.hasAttribute(name) ： 检查特性是否存在。\n * element.getAttribute(name) ：获取这个特性值。\n * element.setAttribute(name, value) ： 设置这个特性值。\n * element.removeAttribute(name) ： 移除这个特性。\n\n🌰 例子 / 使用特性：\n\n<body>\n  <div id="elem" about="Elephant"></div>\n\n  <script>\n    alert( elem.getAttribute(\'About\') ); // (1) \'Elephant\'，读取\n\n    elem.setAttribute(\'Test\', 123); // (2) 写入\n\n    alert( elem.outerHTML ); // (3) 查看特性是否在 HTML 中（在）\n\n    for (let attr of elem.attributes) { // (4) 列出所有\n      alert( `${attr.name} = ${attr.value}` );\n    }\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n>  * 特性的名称是大小写不敏感的。\n>  * 可以将任何东西赋值给特性，但是这些东西会变成 字符串类型。所以这里的值为 "123" 。\n>  * 所有特性，包括自己设置的那个特性，在 outerHTML 中都是可见的。\n>  * attributes 集合是可迭代对象，该对象将所有元素的特性（标准和非标准的）作为 name 和 value 属性存储在对象中。\n\n# 属性与特性同步\n\n当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。\n\n🌰 例子：\n\n<input>\n\n<script>\n  let input = document.querySelector(\'input\');\n\n  // 特性 => 属性\n  input.setAttribute(\'id\', \'id\');\n  alert(input.id); // id（被更新了）\n\n  // 属性 => 特性\n  input.id = \'newId\';\n  alert(input.getAttribute(\'id\')); // newId（被更新了）\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> id 被修改为特性，对应的属性也会发生变化。反之亦然。\n\n🌰 例子 / 例外：\n\n<input>\n\n<script>\n  let input = document.querySelector(\'input\');\n\n  // 特性 => 属性\n  input.setAttribute(\'value\', \'text\');\n  alert(input.value); // text\n\n  // 这个操作无效，属性 => 特性\n  input.value = \'newValue\';\n  alert(input.getAttribute(\'value\')); // text（没有被更新！）\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 这个例子中：\n> \n>  * 改变特性值 value 会更新属性。\n>  * 但是属性的更改不会影响特性。意味着 特性的 value 会被保留在特性中。（之后想要原始值可用）\n\n# DOM 属性的类型\n\nDOM 属性不总是 字符串类型，但是大多是都是字符串。\n\n🌰 例子 / checked 属性是布尔型：\n\n<input id="input" type="checkbox" checked> checkbox\n\n<script>\n  console.log(input.getAttribute(\'checked\')); // 特性值是：空字符串\n  console.log(input.checked); // 属性值是：true\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / style 特性是字符串，但是 style 属性是一个对象：\n\n<div id="div" style="color:red;font-size:120%">Hello</div>\n\n<script>\n  // 特性字符串\n  alert(div.getAttribute(\'style\')); // color:red;font-size:120%\n\n  // 属性对象\n  alert(div.style); // [object CSSStyleDeclaration]\n  alert(div.style.color); // red\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子 / 即使一个 DOM 属性是字符串类型的，但它可能和 HTML 特性也是不同的，例如 href 路径 DOM 属性一直是一个 完整的 URL，即使该特性包含一个相对路径或者包含一个 #hash 。：\n\n<a id="a" href="#hello">link</a>\n<script>\n  // 特性\n  alert(a.getAttribute(\'href\')); // #hello\n\n  // 属性\n  alert(a.href ); // http://site.com/page#hello 形式的完整 URL\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 所以要使用完整的路径 href 或者其他与 HTML 中所写的完全相同的特性，则可以使用 getAttribute 。\n\n# 非标准 HTML 特性\n\n🌰 例子 / 非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript 标记 HTML 元素。\n\n!-- 标记这个 div 以在这显示 "name" --\x3e\n<div show-info="name"></div>\n\x3c!-- 标记这个 div 以在这显示 "age" --\x3e\n<div show-info="age"></div>\n\n<script>\n  // 这段代码找到带有标记的元素，并显示需要的内容\n  let user = {\n    name: "Pete",\n    age: 25\n  };\n\n  for(let div of document.querySelectorAll(\'[show-info]\')) {\n    // 在字段中插入相应的信息\n    let field = div.getAttribute(\'show-info\');\n    div.innerHTML = user[field]; \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / 设置元素的样式：\n\n<style>\n  /* 样式依赖于自定义特性 "order-state" */\n  .order[order-state="new"] {\n    color: green;\n  }\n\n  .order[order-state="pending"] {\n    color: blue;\n  }\n\n  .order[order-state="canceled"] {\n    color: red;\n  }\n</style>\n\n<div class="order" order-state="new">\n  A new order.\n</div>\n\n<div class="order" order-state="pending">\n  A pending order.\n</div>\n\n<div class="order" order-state="canceled">\n  A canceled order.\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 使用特性值比使用特定的类名更好管理，可以轻松改变状态。\n> \n> div.setAttribute(\'order-state\', \'canceled\');\n> \n> \n> 1\n\n自定义特性存在的问题：如果处于目的使用非标准特性，之后它被引入到了标准中并有了其自己的用途。HTML 语言是在不断发展的，并且更多的特性出现在了标准中，以满足开发者的需求。在这种情况下，自定义的属性可能会产生意料不到的影响。\n\n为了避免冲突，保留以 data-* 开头命名的特性，供程序员使用。它们可在 dataset 属性中使用。\n\n使用 data-* 特性是一种合法且安全的传递自定义数据的方式。不仅可以直接读取数据，还可以修改数据属性。\n\n🌰 例子：\n\n<body data-about="Elephants">\n<script>\n  console.log(document.body.dataset.about); // Elephants\n<\/script>\n\n\n1\n2\n3\n4\n\n\n🌰 例子：\n\n<style>\n  .order[data-order-state="new"] {\n    color: green;\n  }\n\n  .order[data-order-state="pending"] {\n    color: blue;\n  }\n\n  .order[data-order-state="canceled"] {\n    color: red;\n  }\n</style>\n\n<div id="order" class="order" data-order-state="new">\n  A new order.\n</div>\n\n<script>\n  // 读取\n  console.log(order.dataset.orderState); // new\n\n  // 修改\n  order.dataset.orderState = "pending"; // (*)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 总结\n\n * 大多数情况下，最好使用 DOM 属性。仅当 DOM 属性无法满足开发需求，并且真的需要特性时，才使用特性。\n   * 需要一个非标准的特性。它应该以 data- 开头，使用 dataset 获取、修改。\n\n\n# 修改 DOM 文档\n\n动态创建新元素并修改现有页面内容。\n\n🌰 例子 / 向用户展示新的信息：\n\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<div class="alert">\n  <strong>Hi there!</strong> You\'ve read an important message.\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n要使用 JavaScript 创建这个相同的 div 元素内容（CSS 样式已存在）。\n\n# 创建元素\n\n创建 DOM 元素节点的两种方法：\n\n * document.createElement(tag) ：用给定的标签创建一个新 元素节点：\n   \n   let div = document.createElement(\'div\');\n   \n   \n   1\n   \n\n * document.createTextNode(text) ：用给定的文本创建一个文本节点：\n   \n   let textNode = document.createTextNode(\'Here I am\');\n   \n   \n   1\n   \n\n# 完善元素内容\n\n * 创建元素节点 ✅\n * 设置类名\n * 填充内容\n\nlet div = document.createElement(\'div\');\n\ndiv.className = "alert";\n\ndiv.innerHTML = "<strong>Hi there!</strong> You\'ve read an important message.";\n\n\n1\n2\n3\n4\n5\n\n\n# 插入元素\n\n为了让 div 显示出来，需要将其插入到 document 文档中的某处。\n\n使用特殊的方法 append ：可以在其他任何元素上调用 append 方法，以将另外一个元素放入到里面。\n\ndocument.body.append(div)\ndiv.append(anotherElement)\n\n\n1\n2\n\n\n🌰 例子 / 完整的代码：\n\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement(\'div\');\n  div.className = "alert";\n  div.innerHTML = "<strong>Hi there!</strong> You\'ve read an important message.";\n\n  document.body.append(div);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 对 document.body 调用了 append 方法。\n\n更多的插入元素的方法，对应不同的插入位置：\n\n * node.append() 在 node 末尾 插入节点或字符串，\n * node.prepend() 在 node 开头 插入节点或字符串，\n * node.before() ：在 node 前面 插入节点或字符串，\n * node.after() —— 在 node 后面 插入节点或字符串，\n * node.replaceWith() 将 node 替换为给定的节点或字符串。\n\n🌰 例子：\n\n<ol id="ol">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  ol.before(\'before\'); // 将字符串 "before" 插入到 <ol> 前面\n  ol.after(\'after\'); // 将字符串 "after" 插入到 <ol> 后面\n\n  let liFirst = document.createElement(\'li\');\n  liFirst.innerHTML = \'prepend\';\n  ol.prepend(liFirst); // 将 liFirst 插入到 <ol> 的最开始\n\n  let liLast = document.createElement(\'li\');\n  liLast.innerHTML = \'append\';\n  ol.append(liLast); // 将 liLast 插入到 <ol> 的最末尾\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n最终列表为：\n\nbefore\n<ol id="ol">\n  <li>prepend</li>\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n  <li>append</li>\n</ol>\nafter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 以上的插入元素的方法只能插入 带有内容节点 或者字符串内容。对于 HTML 代码的字符串，并不能被 浏览器解析，而是作为文本片段插入到页面。\n\n通用的插入元素方法： elem.insertAdjacentHTML(where, html)\n\n * beforebegin ： 将 html 插入到 elem 前插入，\n * afterbegin ：将 html 插入到 elem 开头，\n * beforeend ：将 html 插入到 elem 末尾，\n * afterend ： 将 html 插入到 elem 后。\n\n第二个参数 html ，是 HTML 字符串，该字符串会被「作为 HTML」 插入。\n\n🌰 例子：\n\n<div id="div"></div>\n<script>\n  div.insertAdjacentHTML(\'beforebegin\', \'<p>Hello</p>\');\n  div.insertAdjacentHTML(\'afterend\', \'<p>Bye</p>\');\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n结果：\n\n<p>Hello</p>\n<div id="div"></div>\n<p>Bye</p>\n\n\n1\n2\n3\n\n\n衍生的兄弟方法：\n\n * elem.insertAdjacentText(where, text) ：语法一样，但是将 text 字符串 作为文本 插入而不是作为 HTML，\n * elem.insertAdjacentElement(where, elem) 语法一样，但是插入的是一个元素。\n\n（对于这些 元素和文本，一般使用 append/prepend/before/after 更加方便）\n\n# 移除节点\n\n想要移除一个节点，可以使用 node.remove() 。\n\n🌰 例子 / 将消息在一秒后移除：\n\n<script>\n  let div = document.createElement(\'div\');\n  div.className = "alert";\n  div.innerHTML = "<strong>Hi there!</strong> You\'ve read an important message.";\n\n  document.body.append(div);\n  setTimeout(() => div.remove(), 1000);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 移动节点\n\n利用 插入元素的方法 after() 或者其他方法。\n\n如果要将一个元素 移动 到另一个地方，则无需将其从原来的位置中删除。所有插入方法都会自动从旧位置删除该节点。\n\n🌰 例子 / 交换元素的位置：\n\n<div id="first">First</div>\n<div id="second">Second</div>\n<script>\n  // 无需调用 remove\n  second.after(first); // 获取 #second，并在其后面插入 #first\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 克隆节点\n\n调用 elem.cloneNode(true) 来创建元素的一个深克隆：具有所有特性和子元素。\n\n调用 elem.cloneNode(false) ，那克隆就不包括子元素。\n\n🌰 例子：\n\n<div class="alert" id="div">\n  <strong>Hi there!</strong> You\'ve read an important message.\n</div>\n\n<script>\n  let div2 = div.cloneNode(true); // 克隆消息\n  div2.querySelector(\'strong\').innerHTML = \'Bye there!\'; // 修改克隆\n\n  div.after(div2); // 在已有的 div 后显示克隆\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 节点片段 DocumentFragment\n\n这是一个特殊的 DOM 节点，用来传递节点列表的 包装器。可以向其 附加其他节点；当将其插入某个位置时，则会插入其内容。\n\n🌰 例子 / 生成带有 <li> 列表项目的片段，并将它插入到 <ul> 当中：\n\n<ul id="ul"></ul>\n\n<script>\nfunction getListContent() {\n  let fragment = new DocumentFragment();\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement(\'li\');\n    li.append(i);\n    fragment.append(li);\n  }\n\n  return fragment;\n}\n  \nul.append(getListCount())\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n> 一般 DocumentFragment 很少被显式使用。直接写成返回一个节点数组即可：\n> \n> function getListContent() {\n>   let result = [];\n> \n>   for(let i=1; i<=3; i++) {\n>     let li = document.createElement(\'li\');\n>     li.append(i);\n>     result.push(li);\n>   }\n> \n>   return result;\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n# 总结\n\n * 创建新节点的方法：\n   \n   * document.createElement(tag) ：用给定的 tag 标签创建新的元素节点。\n   * document.createTextNode(value) ：创建文本节点。\n   * element.cloneNode(deep) ：克隆 element 节点元素。\n\n * 插入和移除节点的方法：\n   \n   * node.append() — 在 node 末尾插入，\n   * node.prepend() — 在 node 开头插入，\n   * node.before() — 在 node 之前插入，\n   * node.after() — 在 node 之后插入，\n   * node.replaceWith() — 替换 node 。\n   * node.remove() — 移除 node 。',normalizedContent:'# 操作 dom\n\n每一个 dom 元素节点都属于一个特定的类。这些类形成层次结构。\n\n> 例如，标签 <a> 相对应的元素节点具有链接相关的（link-related）属性，标签 <input> 相对应的元素节点具有与输入相关的属性；\n> \n> 文本节点与元素节点不同。但是所有这些标签节点之间也存在共有的属性和方法，因为所有类型的 dom 节点都形成了一个单一层次的结构。\n> \n> 最终 层次结构 的根节点是 eventtarget 类， node 节点类继承自它，其他 dom 节点继承自 node 类。\n\n点击查看\n * eventtarget ：根「抽象」类。它作为一个基础，让所有的节点都支持 事件行为。（没有实现对象）\n * node ：抽象类。是 dom 节点的基础，提供了 dom 树的核心功能（ parentnode 、 nextsibling 、 childnodes 等 getter ）（没有实现对象）但是有继承自它的具体节点类， text 文本节点、 element 元素节点、注释节点等。\n * element ：dom 元素节点的基础类。提供了 元素级导航的 getter 。特殊的元素基础节点类继承自它， svgelement 、 xmlelement 、 htmlelement 等。\n * htmlelement ：是所有的 html 元素基础类。各类的 html 元素继承自它：\n   * htmlinputelement ： <input> 元素的类；\n   * htmlbodyelement 、 htmlanchorelement … 等。\n\n> 一些元素没有特定的属性，例如 <span> 、 <section> 、 <article> ，都是 htmlelement 的实例。\n\n> 从一个 dom 元素角度出发，例如 <input> 的全部属性和方法的来源（都是来自继承下列的类）：\n> \n>  * htmlinputelement ：该类提供特定于输入的属性；\n>  * htmlelement ：提供了通用的 html 元素方法（以及 getter 和 setter）；\n>  * element ：提供通用泛型元素方法；\n>  * node ：提供通用 dom 节点属性；\n>  * eventtarget ： 为事件（包括事件本身）提供支持；\n>  * 最后包括 object 普通对象的方法。\n\n对于 对象 是适用的属性和方法，dom 节点也适用：\n\n * 获取名称：\n   \n   以获取引用类的名称为例，通过 constructor 获取：\n   \n   console.log(document.body.constructor.name) // htmlbodyelement\n   \n   \n   1\n   \n   \n   tostring 方法：\n   \n   console.log(document.body) // [object htmlbodyelement]\n   \n   \n   1\n   \n\n * 检查继承 instanceof :\n   \n   console.log(document.body instanceof htmlbodyelement) // true\n   console.log(document.body instanceof htmlelement) // true\n   console.log(document.body instanceof element) // true\n   console.log(document.body instanceof node) // true\n   console.log(document.body instanceof eventtarget) // true\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n> console... 开发者命令行输出 dom 元素：\n> \n>  * console.log ：显示元素的 dom 树。\n>  * console.dir ：显示为 dom 对象，展示属性和方法。\n\n\n# 读取 dom 元素属性\n\n * 获取 dom 节点的节点 / 标签名称：\n   * tagname ：仅适用于 element 元素节点。\n   * nodename ：适用于任意的 node 节点。\n\n> 标签名称的大小写问题：\n> \n>  * 在浏览器 html 模式文档中， tagname/nodename 始终是大写的：它是 body ，而不是 <body> 或 <body> 。\n>  * 在 xml 模式中，大小写保持为原样。\n\n * 获取元素名称： ele.name\n * 获取元素 id ： ele.id\n * 获取元素值 value ： ele.value\n * 获取元素的类名： ele.classname\n\n\n# 写入 html\n\n# innerhtml\n\ninnerhtml 允许将元素中的 html 获取为字符串形式，并且可以修改它。是更改页面最有效的方法之一。\n\n🌰 例子 / 获取 body 的内容，完全替换：\n\n<body>\n  <p>a paragraph</p>\n  <div>a div</div>\n\n  <script>\n    consoel.log(document.body.innerhtml); // 读取当前内容\n    document.body.innerhtml = \'the new body!\'; // 替换它\n  <\/script>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子 / 插入无效的 html 会被修复（未闭合的标签）：\n\n<body>\n\n  <script>\n    document.body.innerhtml = \'<b>test\'; // 忘记闭合标签\n    console.log( document.body.innerhtml ); // <b>test</b>（被修复了）\n  <\/script>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 对于脚本标签 <script> 无效，可以插入但是不会执行。\n\n注意\n\n使用 innerhtml+= 会完全重写掉原来的内容并且附加的内容。\n\n例如：\n\nchatdiv.innerhtml += "<div>hello<img src=\'smile.gif\'/> !</div>";\nchatdiv.innerhtml += "how goes?";\n\n\n1\n2\n\n\n> 技术上， innerhtml 完成了两项工作：移除原来的内容；写入新的内容。\n\n因为内容被重写，所以所有的图片和资源都会重新加载；这对于一些输入、选中等类型的元素是致命的，这会丢失原来的数据。\n\n# outerhtml\n\nouterhtml 属性包含了元素的 完整 html。 innerhtml 的内容加上元素标签。\n\n🌰 例子：\n\n<div id="elem">hello <b>world</b></div>\n\n<script>\n  console.log(elem.outerhtml); // <div id="elem">hello <b>world</b></div>\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n注意：与 innerhtml 不同，写入 outerhtml 不会改变元素。而是在 dom 中替换它。\n\n🌰 例子 / 选中一个 dom 元素，使用 outerhtml 替换：\n\n<div>\n  hello world!\n</div>\n\n\n1\n2\n3\n\n\nlet div = queryselector("div")\ndiv.outerhtml = \'<p>new world</p>\'\nconsole.log(div.outerhtml) // <div> hello world! </div>\n\n\n1\n2\n3\n\n\n> 尽管第二行中，使用了 outerhtml 替换掉原来的内容，在外部 html 文档可以看到原来的内容被替换。但是原来的 outerhtml 内容不会改变。\n\n说明， outerhtml 赋值不会修改 dom 元素， 而是将其从 dom 中删除并在其位置插入新的 html。\n\n所以，上面的例子 outerhtml 完成了：将 div 从文档中移除；另一个 html 文档片段被插入到其位置； div 仍然拥有旧的值，新的 html 没有被赋值给任何变量。\n\n> 仍然可以通过 选择器 获取新的元素的引用；并且原来的获取的元素仍然保留。\n\n注意\n\ninnerhtml 与 outerhtml 只对 元素节点 有效。\n\n# nodevalue / data 文本节点\n\n对于其他节点类型，例如文本节点类型，具有它们的对应项： nodevalue 和 data 属性。两种属性只有细微的差异。\n\n🌰 例子 / 使用 data 获取节点的内容：\n\n<body>\n  hello\n  \x3c!-- comment --\x3e\n  <script>\n    let text = document.body.firstchild;\n    console.log(text.data); // hello\n\n    let comment = text.nextsibling;\n    console.log(comment.data); // comment\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# textcontent 纯文本\n\ntextcontent 提供了对元素内的 文本 的访问权限：仅文本，去掉所有 标签。\n\n🌰 例子 / 读取纯文本内容：\n\n<div id="news">\n  <h1>headline!</h1>\n  <p>martians attack people!</p>\n</div>\n\n\n1\n2\n3\n4\n\n\nconsole.log(news.textcontent); // headline! martians attack people!\n\n\n1\n\n>  * 使用 innerhtml ，将其 作为 html 插入，带有所有 html 标签会被作为 html 处理。\n>  * 使用 textcontent ，将其 作为文本 插入，所有符号均按字面意义处理。\n\n🌰 例子 / 安全方式写入文本：\n\n<div id="elem1"></div>\n<div id="elem2"></div>\n\n\n1\n2\n\n\n<script>\n  let name = prompt("what\'s your name?", "<b>winnie-the-pooh!</b>");\n\n  elem1.innerhtml = name;\n  elem2.textcontent = name;\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# hidden 属性\n\n用于 指定 dom 元素是否可见。\n\n🌰 例子：\n\n<div>both divs below are hidden</div>\n\n<div hidden>with the attribute "hidden"</div>\n\n<div id="elem">javascript assigned the property "hidden"</div>\n\n<script>\n  let elem = document.queryselector(\'#elem\')\n  elem.hidden = true;\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 实现的效果与 style="display: none" 相同。\n\n\n# 区分 atrributes 与 properties\n\n在浏览器页面加载时，会解析 html 从中生成 dom 对象。对于元素节点 的大多数 html attributes 特性 会自动变成 dom 对象节点的 properties 属性。但是特性和属性映射不是一一对应的。\n\n🌰 例如： <body id="page"> 中 id 特性会对应属性 body.id=“page” 。\n\n# dom 属性 property\n\n由于 dom 元素对象也是 javascript 常规对象，所以可以更改它们。\n\n * 可以有很多值。\n * 键大小写敏感。\n\n🌰 例子：\n\ndocument.body.mydata = {\n  name: "name",\n  title: "title"\n}\n\nconsole.log(document.body.mydata.name) // "name"\n\n\n1\n2\n3\n4\n5\n6\n\n\n添加一个方法：\n\ndocument.body.saytagname = function () {\n  console.log(this.tagname)\n}\n\ndocument.body.saytagname() // body\n\n\n1\n2\n3\n4\n5\n\n\n修改原型：\n\nelement.prototype.sayhi = funciton () {\n  console.log(`hi, iam ${this.tagname}`)\n}\n\ndocument.documentelement.sayhi() // hi, iam html\ndocument.body.sayhi() // hi, iam body\n\n\n1\n2\n3\n4\n5\n6\n\n\n# html 特性 attribute\n\n指的是 html 标签中的 标准特性 并且以此创建 dom 属性。\n\nhtml 特性有以下几个特征：\n\n * 它们的名字是大小写不敏感的（ id 与 id 相同）。\n * 它们的值总是字符串类型的。\n\n🌰 例子：\n\n<body id="test" something="non-standard">\n  <script>\n    alert(document.body.id); // test\n    // 非标准的特性没有获得对应的属性\n    alert(document.body.something); // undefined\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 可以看出：对应的 标准特性 id 才会创建 dom 属性。非标准的特性不会。\n> \n> 但是不同的标签，标准的特性可能会不同。例如 type 特性是 <input> 的一个标准的特性（htmlinputelement），但对于 <body> （htmlbodyelement）来说则不是。规范中对相应元素类的标准的属性进行了详细的描述。\n> \n> <body id="body" type="...">\n> <input id="input" type="text">\n> <script>\n>  alert(input.type); // text\n>  alert(body.type); // undefined：dom 属性没有被创建，因为它不是一个标准的特性\n> <\/script>\n> </body>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n所有特性（包含非标准特性）都可以通过使用以下方法进行访问：\n\n * element.hasattribute(name) ： 检查特性是否存在。\n * element.getattribute(name) ：获取这个特性值。\n * element.setattribute(name, value) ： 设置这个特性值。\n * element.removeattribute(name) ： 移除这个特性。\n\n🌰 例子 / 使用特性：\n\n<body>\n  <div id="elem" about="elephant"></div>\n\n  <script>\n    alert( elem.getattribute(\'about\') ); // (1) \'elephant\'，读取\n\n    elem.setattribute(\'test\', 123); // (2) 写入\n\n    alert( elem.outerhtml ); // (3) 查看特性是否在 html 中（在）\n\n    for (let attr of elem.attributes) { // (4) 列出所有\n      alert( `${attr.name} = ${attr.value}` );\n    }\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n>  * 特性的名称是大小写不敏感的。\n>  * 可以将任何东西赋值给特性，但是这些东西会变成 字符串类型。所以这里的值为 "123" 。\n>  * 所有特性，包括自己设置的那个特性，在 outerhtml 中都是可见的。\n>  * attributes 集合是可迭代对象，该对象将所有元素的特性（标准和非标准的）作为 name 和 value 属性存储在对象中。\n\n# 属性与特性同步\n\n当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。\n\n🌰 例子：\n\n<input>\n\n<script>\n  let input = document.queryselector(\'input\');\n\n  // 特性 => 属性\n  input.setattribute(\'id\', \'id\');\n  alert(input.id); // id（被更新了）\n\n  // 属性 => 特性\n  input.id = \'newid\';\n  alert(input.getattribute(\'id\')); // newid（被更新了）\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> id 被修改为特性，对应的属性也会发生变化。反之亦然。\n\n🌰 例子 / 例外：\n\n<input>\n\n<script>\n  let input = document.queryselector(\'input\');\n\n  // 特性 => 属性\n  input.setattribute(\'value\', \'text\');\n  alert(input.value); // text\n\n  // 这个操作无效，属性 => 特性\n  input.value = \'newvalue\';\n  alert(input.getattribute(\'value\')); // text（没有被更新！）\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 这个例子中：\n> \n>  * 改变特性值 value 会更新属性。\n>  * 但是属性的更改不会影响特性。意味着 特性的 value 会被保留在特性中。（之后想要原始值可用）\n\n# dom 属性的类型\n\ndom 属性不总是 字符串类型，但是大多是都是字符串。\n\n🌰 例子 / checked 属性是布尔型：\n\n<input id="input" type="checkbox" checked> checkbox\n\n<script>\n  console.log(input.getattribute(\'checked\')); // 特性值是：空字符串\n  console.log(input.checked); // 属性值是：true\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n🌰 例子 / style 特性是字符串，但是 style 属性是一个对象：\n\n<div id="div" style="color:red;font-size:120%">hello</div>\n\n<script>\n  // 特性字符串\n  alert(div.getattribute(\'style\')); // color:red;font-size:120%\n\n  // 属性对象\n  alert(div.style); // [object cssstyledeclaration]\n  alert(div.style.color); // red\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n🌰 例子 / 即使一个 dom 属性是字符串类型的，但它可能和 html 特性也是不同的，例如 href 路径 dom 属性一直是一个 完整的 url，即使该特性包含一个相对路径或者包含一个 #hash 。：\n\n<a id="a" href="#hello">link</a>\n<script>\n  // 特性\n  alert(a.getattribute(\'href\')); // #hello\n\n  // 属性\n  alert(a.href ); // http://site.com/page#hello 形式的完整 url\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 所以要使用完整的路径 href 或者其他与 html 中所写的完全相同的特性，则可以使用 getattribute 。\n\n# 非标准 html 特性\n\n🌰 例子 / 非标准的特性常常用于将自定义的数据从 html 传递到 javascript，或者用于为 javascript 标记 html 元素。\n\n!-- 标记这个 div 以在这显示 "name" --\x3e\n<div show-info="name"></div>\n\x3c!-- 标记这个 div 以在这显示 "age" --\x3e\n<div show-info="age"></div>\n\n<script>\n  // 这段代码找到带有标记的元素，并显示需要的内容\n  let user = {\n    name: "pete",\n    age: 25\n  };\n\n  for(let div of document.queryselectorall(\'[show-info]\')) {\n    // 在字段中插入相应的信息\n    let field = div.getattribute(\'show-info\');\n    div.innerhtml = user[field]; \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n🌰 例子 / 设置元素的样式：\n\n<style>\n  /* 样式依赖于自定义特性 "order-state" */\n  .order[order-state="new"] {\n    color: green;\n  }\n\n  .order[order-state="pending"] {\n    color: blue;\n  }\n\n  .order[order-state="canceled"] {\n    color: red;\n  }\n</style>\n\n<div class="order" order-state="new">\n  a new order.\n</div>\n\n<div class="order" order-state="pending">\n  a pending order.\n</div>\n\n<div class="order" order-state="canceled">\n  a canceled order.\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 使用特性值比使用特定的类名更好管理，可以轻松改变状态。\n> \n> div.setattribute(\'order-state\', \'canceled\');\n> \n> \n> 1\n\n自定义特性存在的问题：如果处于目的使用非标准特性，之后它被引入到了标准中并有了其自己的用途。html 语言是在不断发展的，并且更多的特性出现在了标准中，以满足开发者的需求。在这种情况下，自定义的属性可能会产生意料不到的影响。\n\n为了避免冲突，保留以 data-* 开头命名的特性，供程序员使用。它们可在 dataset 属性中使用。\n\n使用 data-* 特性是一种合法且安全的传递自定义数据的方式。不仅可以直接读取数据，还可以修改数据属性。\n\n🌰 例子：\n\n<body data-about="elephants">\n<script>\n  console.log(document.body.dataset.about); // elephants\n<\/script>\n\n\n1\n2\n3\n4\n\n\n🌰 例子：\n\n<style>\n  .order[data-order-state="new"] {\n    color: green;\n  }\n\n  .order[data-order-state="pending"] {\n    color: blue;\n  }\n\n  .order[data-order-state="canceled"] {\n    color: red;\n  }\n</style>\n\n<div id="order" class="order" data-order-state="new">\n  a new order.\n</div>\n\n<script>\n  // 读取\n  console.log(order.dataset.orderstate); // new\n\n  // 修改\n  order.dataset.orderstate = "pending"; // (*)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 总结\n\n * 大多数情况下，最好使用 dom 属性。仅当 dom 属性无法满足开发需求，并且真的需要特性时，才使用特性。\n   * 需要一个非标准的特性。它应该以 data- 开头，使用 dataset 获取、修改。\n\n\n# 修改 dom 文档\n\n动态创建新元素并修改现有页面内容。\n\n🌰 例子 / 向用户展示新的信息：\n\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<div class="alert">\n  <strong>hi there!</strong> you\'ve read an important message.\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n要使用 javascript 创建这个相同的 div 元素内容（css 样式已存在）。\n\n# 创建元素\n\n创建 dom 元素节点的两种方法：\n\n * document.createelement(tag) ：用给定的标签创建一个新 元素节点：\n   \n   let div = document.createelement(\'div\');\n   \n   \n   1\n   \n\n * document.createtextnode(text) ：用给定的文本创建一个文本节点：\n   \n   let textnode = document.createtextnode(\'here i am\');\n   \n   \n   1\n   \n\n# 完善元素内容\n\n * 创建元素节点 ✅\n * 设置类名\n * 填充内容\n\nlet div = document.createelement(\'div\');\n\ndiv.classname = "alert";\n\ndiv.innerhtml = "<strong>hi there!</strong> you\'ve read an important message.";\n\n\n1\n2\n3\n4\n5\n\n\n# 插入元素\n\n为了让 div 显示出来，需要将其插入到 document 文档中的某处。\n\n使用特殊的方法 append ：可以在其他任何元素上调用 append 方法，以将另外一个元素放入到里面。\n\ndocument.body.append(div)\ndiv.append(anotherelement)\n\n\n1\n2\n\n\n🌰 例子 / 完整的代码：\n\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createelement(\'div\');\n  div.classname = "alert";\n  div.innerhtml = "<strong>hi there!</strong> you\'ve read an important message.";\n\n  document.body.append(div);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 对 document.body 调用了 append 方法。\n\n更多的插入元素的方法，对应不同的插入位置：\n\n * node.append() 在 node 末尾 插入节点或字符串，\n * node.prepend() 在 node 开头 插入节点或字符串，\n * node.before() ：在 node 前面 插入节点或字符串，\n * node.after() —— 在 node 后面 插入节点或字符串，\n * node.replacewith() 将 node 替换为给定的节点或字符串。\n\n🌰 例子：\n\n<ol id="ol">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  ol.before(\'before\'); // 将字符串 "before" 插入到 <ol> 前面\n  ol.after(\'after\'); // 将字符串 "after" 插入到 <ol> 后面\n\n  let lifirst = document.createelement(\'li\');\n  lifirst.innerhtml = \'prepend\';\n  ol.prepend(lifirst); // 将 lifirst 插入到 <ol> 的最开始\n\n  let lilast = document.createelement(\'li\');\n  lilast.innerhtml = \'append\';\n  ol.append(lilast); // 将 lilast 插入到 <ol> 的最末尾\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n最终列表为：\n\nbefore\n<ol id="ol">\n  <li>prepend</li>\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n  <li>append</li>\n</ol>\nafter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 以上的插入元素的方法只能插入 带有内容节点 或者字符串内容。对于 html 代码的字符串，并不能被 浏览器解析，而是作为文本片段插入到页面。\n\n通用的插入元素方法： elem.insertadjacenthtml(where, html)\n\n * beforebegin ： 将 html 插入到 elem 前插入，\n * afterbegin ：将 html 插入到 elem 开头，\n * beforeend ：将 html 插入到 elem 末尾，\n * afterend ： 将 html 插入到 elem 后。\n\n第二个参数 html ，是 html 字符串，该字符串会被「作为 html」 插入。\n\n🌰 例子：\n\n<div id="div"></div>\n<script>\n  div.insertadjacenthtml(\'beforebegin\', \'<p>hello</p>\');\n  div.insertadjacenthtml(\'afterend\', \'<p>bye</p>\');\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n结果：\n\n<p>hello</p>\n<div id="div"></div>\n<p>bye</p>\n\n\n1\n2\n3\n\n\n衍生的兄弟方法：\n\n * elem.insertadjacenttext(where, text) ：语法一样，但是将 text 字符串 作为文本 插入而不是作为 html，\n * elem.insertadjacentelement(where, elem) 语法一样，但是插入的是一个元素。\n\n（对于这些 元素和文本，一般使用 append/prepend/before/after 更加方便）\n\n# 移除节点\n\n想要移除一个节点，可以使用 node.remove() 。\n\n🌰 例子 / 将消息在一秒后移除：\n\n<script>\n  let div = document.createelement(\'div\');\n  div.classname = "alert";\n  div.innerhtml = "<strong>hi there!</strong> you\'ve read an important message.";\n\n  document.body.append(div);\n  settimeout(() => div.remove(), 1000);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 移动节点\n\n利用 插入元素的方法 after() 或者其他方法。\n\n如果要将一个元素 移动 到另一个地方，则无需将其从原来的位置中删除。所有插入方法都会自动从旧位置删除该节点。\n\n🌰 例子 / 交换元素的位置：\n\n<div id="first">first</div>\n<div id="second">second</div>\n<script>\n  // 无需调用 remove\n  second.after(first); // 获取 #second，并在其后面插入 #first\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 克隆节点\n\n调用 elem.clonenode(true) 来创建元素的一个深克隆：具有所有特性和子元素。\n\n调用 elem.clonenode(false) ，那克隆就不包括子元素。\n\n🌰 例子：\n\n<div class="alert" id="div">\n  <strong>hi there!</strong> you\'ve read an important message.\n</div>\n\n<script>\n  let div2 = div.clonenode(true); // 克隆消息\n  div2.queryselector(\'strong\').innerhtml = \'bye there!\'; // 修改克隆\n\n  div.after(div2); // 在已有的 div 后显示克隆\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 节点片段 documentfragment\n\n这是一个特殊的 dom 节点，用来传递节点列表的 包装器。可以向其 附加其他节点；当将其插入某个位置时，则会插入其内容。\n\n🌰 例子 / 生成带有 <li> 列表项目的片段，并将它插入到 <ul> 当中：\n\n<ul id="ul"></ul>\n\n<script>\nfunction getlistcontent() {\n  let fragment = new documentfragment();\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createelement(\'li\');\n    li.append(i);\n    fragment.append(li);\n  }\n\n  return fragment;\n}\n  \nul.append(getlistcount())\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n> 一般 documentfragment 很少被显式使用。直接写成返回一个节点数组即可：\n> \n> function getlistcontent() {\n>   let result = [];\n> \n>   for(let i=1; i<=3; i++) {\n>     let li = document.createelement(\'li\');\n>     li.append(i);\n>     result.push(li);\n>   }\n> \n>   return result;\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n# 总结\n\n * 创建新节点的方法：\n   \n   * document.createelement(tag) ：用给定的 tag 标签创建新的元素节点。\n   * document.createtextnode(value) ：创建文本节点。\n   * element.clonenode(deep) ：克隆 element 节点元素。\n\n * 插入和移除节点的方法：\n   \n   * node.append() — 在 node 末尾插入，\n   * node.prepend() — 在 node 开头插入，\n   * node.before() — 在 node 之前插入，\n   * node.after() — 在 node 之后插入，\n   * node.replacewith() — 替换 node 。\n   * node.remove() — 移除 node 。',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3},{title:"🍎 Vue data 属性",frontmatter:{title:"🍎 Vue data 属性",date:"2022-06-11T23:47:17.000Z",permalink:"/pages/dcf29b/",categories:["🪞 前端面试题收集","🌠 核心框架相关","🍎 Vue"],tags:[null]},regularPath:"/200.%20%F0%9F%AA%9E%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/09.%20%F0%9F%8C%A0%20%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/01.%20%F0%9F%8D%8E%20Vue/20.%20%F0%9F%8D%8E%20Vue%20data%20%E5%B1%9E%E6%80%A7.html",relativePath:"200. 🪞 前端面试题收集/09. 🌠 核心框架相关/01. 🍎 Vue/20. 🍎 Vue data 属性.md",key:"v-1e816680",path:"/pages/dcf29b/",headers:[{level:2,title:"实例和组件定义 data 的区别",slug:"实例和组件定义-data-的区别",normalizedTitle:"实例和组件定义 data 的区别",charIndex:41},{level:2,title:"组件 data 定义为函数与对象的区别",slug:"组件-data-定义为函数与对象的区别",normalizedTitle:"组件 data 定义为函数与对象的区别",charIndex:545},{level:2,title:"原理分析",slug:"原理分析",normalizedTitle:"原理分析",charIndex:1783},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3614}],headersStr:"实例和组件定义 data 的区别 组件 data 定义为函数与对象的区别 原理分析 参考",content:'>  * 为什么 Vue 中的 data 属性是一个函数而不是一个对象？\n\n\n# 实例和组件定义 data 的区别\n\n在 Vue 实例中定义 data ，既可以是一个对象，也可以是一个函数：\n\nconst app = new Vue({\n  el: "#app",\n  // 对象格式\n    data:{\n        foo:"foo"\n    },\n    // 函数格式\n    data(){\n        return {\n             foo:"foo"\n        }\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在组件中定义 data ，只能是一个函数，否则报错警告，返回的 data 应该是一个函数在每一个组件实例中：\n\nVue.component(\'component1\',{\n    template:`<div>组件</div>`,\n    /* data:{\n        foo:"foo"\n    }*/\n  \tdata() {\n      return {\n        foo: "foo"\n      }\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 组件 data 定义为函数与对象的区别\n\n> data 为什么必须为一个函数？\n> \n> 结论：\n> \n>  * 根实例对象 data 可以是对象也可以是函数（根实例是单例），不会产生数据污染的情况；\n>  * 组件实例对象 data 必须为函数，防止多个组件实例对象之间共用一个 data ，产生数据污染。采用函数的形式， initData 时会将其作为工厂函数返回全新的 data 对象。\n\n当定义好一个组件时，Vue 最终都会通过 Vue.extend() 构成组件实例；\n\n * 模仿组件构造函数，定义 data 属性，采用对象形式：\n   \n   function Component(){\n    \n   }\n   Component.prototype.data = {\n   \tcount : 0\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   创建两个组件实例时：\n   \n   const componentA = new Component()\n   const componentB = new Component()\n   \n   \n   1\n   2\n   \n   \n   修改 componentA 组件 data 属性的值， componentB 中的值也会发生改变：\n   \n   console.log(componentB.data.count)  // 0\n   componentA.data.count = 1\n   console.log(componentB.data.count)  // 1\n   \n   \n   1\n   2\n   3\n   \n   \n   > 因为 两个组件的 data 共用了一个内存地址。\n\n * 如果采用函数形式，就不会出现这种情况（因为函数返回的对象内存地址并不相同）：\n   \n   function Component() {\n     this.data = this.data()\n   }\n   \n   Component.prototype.data = function () {\n     return {\n       count: 0\n     }\n   }\n   \n   const componentA = new Component()\n   const componentB = new Component()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   此时修改 componentA 中 data 的值， componentB 不会受到影响。\n\nVue 组件中可能会有很多个实例，采用函数返回一个全新的 data 对象形式，使得每个实例对象的数据不会受到其他实例对象的污染。\n\n\n# 原理分析\n\n在 Vue 初始化 data 时， data 的定义可以是函数，也可以是对象。\n\n> 源码位置： src/core/instance/state.js ：\n> \n> function initData (vm: Component) {\n>   let data = vm.$options.data\n>   data = vm._data = typeof data === \'function\'\n>     ? getData(data, vm)\n>     : data || {}\n>     ...\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 可以看出 data 又能为 function 又能为 object 。\n\n组件在创建的时候，会进行选项的合并。\n\n> 源码位置： src/core/util/options.js 。\n> \n> 自定义组件会进行 mergeOptions 进行选项合并：\n> \n> Vue.prototype._init = function (options?: Object) {\n>   // ...\n>   // merge options\n>   if (options && options._isComponent) {\n>     // optimize internal component instantiation\n>     // since dynamic options merging is pretty slow, and none of the\n>     // internal component options needs special treatment.\n>     initInternalComponent(vm, options)\n>   } else {\n>     vm.$options = mergeOptions(\n>       resolveConstructorOptions(vm.constructor),\n>       options || {},\n>       vm\n>     )\n>   }\n>   // ...\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n\n定义 data 时会进行数据校验。\n\n> 源码位置： src/core/instance/init.js ：\n> \n> 这时候 vm 实例为 undefined ，进入 if 判断，若 data 类型不是 function ，则出现警告提示。\n> \n> strats.data = function (\n>   parentVal: any,\n>   childVal: any,\n>   vm?: Component\n> ): ?Function {\n>   if (!vm) {\n>     if (childVal && typeof childVal !== "function") {\n>       process.env.NODE_ENV !== "production" &&\n>         warn(\n>           \'The "data" option should be a function \' +\n>             "that returns a per-instance value in component " +\n>             "definitions.",\n>           vm\n>         );\n> \n>       return parentVal;\n>     }\n>     return mergeDataOrFn(parentVal, childVal);\n>   }\n>   return mergeDataOrFn(parentVal, childVal, vm);\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n\n\n# 参考\n\n * 面试官：为什么 data 属性是一个函数而不是一个对象？ | web 前端面试 - 面试官系列 (vue3js.cn)',normalizedContent:'>  * 为什么 vue 中的 data 属性是一个函数而不是一个对象？\n\n\n# 实例和组件定义 data 的区别\n\n在 vue 实例中定义 data ，既可以是一个对象，也可以是一个函数：\n\nconst app = new vue({\n  el: "#app",\n  // 对象格式\n    data:{\n        foo:"foo"\n    },\n    // 函数格式\n    data(){\n        return {\n             foo:"foo"\n        }\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在组件中定义 data ，只能是一个函数，否则报错警告，返回的 data 应该是一个函数在每一个组件实例中：\n\nvue.component(\'component1\',{\n    template:`<div>组件</div>`,\n    /* data:{\n        foo:"foo"\n    }*/\n  \tdata() {\n      return {\n        foo: "foo"\n      }\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 组件 data 定义为函数与对象的区别\n\n> data 为什么必须为一个函数？\n> \n> 结论：\n> \n>  * 根实例对象 data 可以是对象也可以是函数（根实例是单例），不会产生数据污染的情况；\n>  * 组件实例对象 data 必须为函数，防止多个组件实例对象之间共用一个 data ，产生数据污染。采用函数的形式， initdata 时会将其作为工厂函数返回全新的 data 对象。\n\n当定义好一个组件时，vue 最终都会通过 vue.extend() 构成组件实例；\n\n * 模仿组件构造函数，定义 data 属性，采用对象形式：\n   \n   function component(){\n    \n   }\n   component.prototype.data = {\n   \tcount : 0\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   创建两个组件实例时：\n   \n   const componenta = new component()\n   const componentb = new component()\n   \n   \n   1\n   2\n   \n   \n   修改 componenta 组件 data 属性的值， componentb 中的值也会发生改变：\n   \n   console.log(componentb.data.count)  // 0\n   componenta.data.count = 1\n   console.log(componentb.data.count)  // 1\n   \n   \n   1\n   2\n   3\n   \n   \n   > 因为 两个组件的 data 共用了一个内存地址。\n\n * 如果采用函数形式，就不会出现这种情况（因为函数返回的对象内存地址并不相同）：\n   \n   function component() {\n     this.data = this.data()\n   }\n   \n   component.prototype.data = function () {\n     return {\n       count: 0\n     }\n   }\n   \n   const componenta = new component()\n   const componentb = new component()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   此时修改 componenta 中 data 的值， componentb 不会受到影响。\n\nvue 组件中可能会有很多个实例，采用函数返回一个全新的 data 对象形式，使得每个实例对象的数据不会受到其他实例对象的污染。\n\n\n# 原理分析\n\n在 vue 初始化 data 时， data 的定义可以是函数，也可以是对象。\n\n> 源码位置： src/core/instance/state.js ：\n> \n> function initdata (vm: component) {\n>   let data = vm.$options.data\n>   data = vm._data = typeof data === \'function\'\n>     ? getdata(data, vm)\n>     : data || {}\n>     ...\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 可以看出 data 又能为 function 又能为 object 。\n\n组件在创建的时候，会进行选项的合并。\n\n> 源码位置： src/core/util/options.js 。\n> \n> 自定义组件会进行 mergeoptions 进行选项合并：\n> \n> vue.prototype._init = function (options?: object) {\n>   // ...\n>   // merge options\n>   if (options && options._iscomponent) {\n>     // optimize internal component instantiation\n>     // since dynamic options merging is pretty slow, and none of the\n>     // internal component options needs special treatment.\n>     initinternalcomponent(vm, options)\n>   } else {\n>     vm.$options = mergeoptions(\n>       resolveconstructoroptions(vm.constructor),\n>       options || {},\n>       vm\n>     )\n>   }\n>   // ...\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n\n定义 data 时会进行数据校验。\n\n> 源码位置： src/core/instance/init.js ：\n> \n> 这时候 vm 实例为 undefined ，进入 if 判断，若 data 类型不是 function ，则出现警告提示。\n> \n> strats.data = function (\n>   parentval: any,\n>   childval: any,\n>   vm?: component\n> ): ?function {\n>   if (!vm) {\n>     if (childval && typeof childval !== "function") {\n>       process.env.node_env !== "production" &&\n>         warn(\n>           \'the "data" option should be a function \' +\n>             "that returns a per-instance value in component " +\n>             "definitions.",\n>           vm\n>         );\n> \n>       return parentval;\n>     }\n>     return mergedataorfn(parentval, childval);\n>   }\n>   return mergedataorfn(parentval, childval, vm);\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n\n\n# 参考\n\n * 面试官：为什么 data 属性是一个函数而不是一个对象？ | web 前端面试 - 面试官系列 (vue3js.cn)',charsets:{cjk:!0},lastUpdated:"2022/08/06, 11:50:09",lastUpdatedTimestamp:1659757809e3}],themeConfig:{nav:[{text:"🌏 首页",link:"/"},{text:"☕️ 前端笔记",link:"/front-end/",items:[{text:"🗺 前端学习路线",link:"/front-end/roadmap/"},{text:"分类",items:[{text:"🚶 前端入门基础",link:"/front-end/beginning/"},{text:"🚶🏻 前端巩固基础",link:"/front-end/stable/"},{text:"🏃 前端核心框架",link:"/front-end/core-frame/"},{text:"🪞 前端面试题收集",link:"front-end/interview/"}]}]},{text:"🚏 索引",link:"/archives/",items:[{text:"🗄归档",link:"/archives/"},{text:"🔖标签",link:"/tags/"}]},{text:"🔖 关于",link:"/about/"}],sidebarDepth:2,logo:"/assets/img/logo.png",repo:"simon1uo/notebook",searchMaxSuggestions:10,lastUpdated:"📢 上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",category:!0,tag:!0,archive:!0,titleBadge:!1,sidebarOpen:!1,sidebar:{"/01. 📚 前端笔记/":[["01. 🗺 前端学习路线.md","🗺 前端学习路线","/front-end/roadmap/"],{title:" 💻 前端学习笔记",collapsable:!0,children:[["02. 💻 前端学习笔记/100. 🚶 前端入门基础.md","🚶 前端入门基础","/front-end/beginning"],["02. 💻 前端学习笔记/101. 🚶🏻 前端巩固基础.md","🚶🏻 前端巩固基础","/front-end/stable"],["02. 💻 前端学习笔记/105. 🏃 前端核心框架.md","🏃 前端核心框架","/front-end/core-frame"],["02. 💻 前端学习笔记/120. 🕹 前端算法指北.md","🕹 前端算法指北","/front-end/algorithm"]]},{title:" 🗺️ 前端学习路线相关",collapsable:!0,children:[["03. 🗺️ 前端学习路线相关/01. 🍎 计算机网络.md","🍎 计算机网络","/pages/46470d/"]]},["20. 🪞 前端面试题收集.md","🪞 前端面试题收集","/front-end/interview"],{title:" ⚖️ 前端编码规范相关",collapsable:!0,children:[["100. ⚖️ 前端编码规范相关/10. 🛟  HTML 5 样式指南代码约定.md","🛟 HTML 5 样式指南代码约定","/pages/5bded3/"],["100. ⚖️ 前端编码规范相关/20. 🍽 JavaScript 代码规范.md","🍽 JavaScript 代码规范","/pages/176ef8/"],["100. ⚖️ 前端编码规范相关/99. 🧰 前端开发工程化.md","🧰 前端开发工程化","/pages/f582e8/"]]}],catalogue:{" 🚶 前端入门基础":"/front-end/beginning"," 🚶🏻 前端巩固基础":"/front-end/stable"," 🏃 前端核心框架":"/front-end/core-frame"," 🕹 前端算法指北":"/front-end/algorithm"," 🪞 前端面试题收集":"/front-end/interview"," 💽 使用 TypeScript 重构 axios 库":"/typescript-axios"},"/100. 🚶 前端入门基础/":[{title:" 🕸 HTML",collapsable:!0,children:[["10. 🕸 HTML/01. 📰 HTML 基础.md","📰 HTML 基础","/pages/c70272/"],["10. 🕸 HTML/03. 🍣 HTML 文本元素.md","🍣 HTML 文本元素","/pages/286aba/"],["10. 🕸 HTML/04. 🫕 HTML 结构元素.md","🫕 HTML 结构元素","/pages/64a1a7/"],["10. 🕸 HTML/05. 🥙 HTML 更多元素.md","🥙 HTML 更多元素","/pages/7acc1d/"],["10. 🕸 HTML/07. 🍱 HTML 块元素和行内元素.md","🍱 HTML 块元素和行内元素","/pages/bb41df/"],["10. 🕸 HTML/08. 🍳 HTML 类与 id.md","🍳 HTML 类与 id","/pages/3886ef/"],["10. 🕸 HTML/09. 🧅 HTML 头部元素.md","🧅 HTML 头部元素","/pages/42605a/"],["10. 🕸 HTML/10. 🧀 HTML 响应式页面.md","🧀 HTML 响应式页面","/pages/aa23b5/"],["10. 🕸 HTML/11. 🥨 HTML 表单元素.md","🥨 HTML 表单元素","/pages/1c9bbf/"],["10. 🕸 HTML/15. 🌯 HTML canvans 画布与 SVG.md","🌯 HTML canvans 画布与 SVG","/pages/3f6201/"],["10. 🕸 HTML/20. ⚡️ HTML5  语义化标签.md","⚡️ HTML5 语义化标签","/pages/6bdb29/"],["10. 🕸 HTML/40. 🍗 HTML5 API.md","🍗 HTML5 API","/pages/30c725/"]]},{title:" 🎨 CSS",collapsable:!0,children:[["20. 🎨 CSS/01. 📖 CSS 基本语法.md","📖 CSS 基本语法","/pages/7fb68c/"],["20. 🎨 CSS/02. 🥽 CSS 单位.md","🥽 CSS 单位","/pages/eb2dd9/"],["20. 🎨 CSS/20. 🎮 CSS 选择器.md","🎮 CSS 选择器","/pages/59c3c4/"],["20. 🎨 CSS/30. 🎁 CSS 盒子模型.md","🎁 CSS 盒子模型","/pages/33f36d/"],["20. 🎨 CSS/40. 🪁 CSS 浮动.md","🪁 CSS 浮动","/pages/a8f349/"],["20. 🎨 CSS/50. 🧭 CSS 定位.md","🧭 CSS 定位","/pages/3fa9cc/"],["20. 🎨 CSS/60. 🗚 CSS 字体.md","🗚 CSS 字体","/pages/27df4e/"],["20. 🎨 CSS/70. 🖼 CSS 背景.md","🖼 CSS 背景","/pages/ef3d83/"],["20. 🎨 CSS/80. 🐈 CSS 过渡与动画.md","🐈 CSS 过渡与动画","/pages/c46d43/"],["20. 🎨 CSS/90. 🔍 CSS 变形.md","🔍 CSS 变形","/pages/9de79a/"],["20. 🎨 CSS/100. 🗃 CSS 弹性盒子模型.md","🗃 CSS 弹性盒子模型","/pages/82c43f/"],{title:" 🪅 CSS 实用示例",collapsable:!0,children:[["20. 🎨 CSS/110. 🪅 CSS 实用示例/10. 🧾 CSS 列表布局示例.md","🧾 CSS 列表布局示例","/pages/8d9180/"],["20. 🎨 CSS/110. 🪅 CSS 实用示例/20. 🌬 CSS 浮动布局示例.md","🌬 CSS 浮动布局示例","/pages/a6e1ef/"],["20. 🎨 CSS/110. 🪅 CSS 实用示例/30. 🚏 CSS 定位实例.md","🚏 CSS 定位实例","/pages/bf8c69/"],["20. 🎨 CSS/110. 🪅 CSS 实用示例/40. 📦 CSS 弹性盒布局实例.md","📦 CSS 弹性盒布局实例","/pages/8f342b/"],["20. 🎨 CSS/110. 🪅 CSS 实用示例/50. 💙 使用 CSS 绘制图形.md","💙 使用 CSS 绘制图形","/pages/508db5/"],["20. 🎨 CSS/110. 🪅 CSS 实用示例/60. ❤️ CSS 动画示例.md","❤️ CSS 动画示例","/pages/74c5a0/"]]}]},{title:" 🍪 JavaScript",collapsable:!0,children:[["30. 🍪 JavaScript/01. 🌱 JavaScript 基本使用.md","🌱 JavaScript 基本使用","/pages/d84d57/"],["30. 🍪 JavaScript/02. 🗝 JavaScript 变量与数据类型.md","🗝 JavaScript 变量与数据类型","/pages/b51680/"],["30. 🍪 JavaScript/03. 🧮 JavaScript 运算符.md","🧮 JavaScript 运算符","/pages/f8003b/"],["30. 🍪 JavaScript/04. 🚰 JavaScript 流程控制.md","🚰 JavaScript 流程控制","/pages/54cab4/"],["30. 🍪 JavaScript/05. ⚙️ JavaScript 函数.md","⚙️ JavaScript Function 函数","/pages/944277/"],["30. 🍪 JavaScript/50. 🔭 JavaScript 作用域 .md","🔭 JavaScript 作用域","/pages/f88075/"],["30. 🍪 JavaScript/100. 📒 JavaScript 基础实例.md","📒 JavaScript 基础实例","/pages/93f713/"]]},{title:" 🛤 Git 版本控制",collapsable:!0,children:[["100. 🛤 Git 版本控制/01. 🚏 Git 版本控制学习路线.md","🚏 Git 版本控制学习路线","/pages/4d5e63/"],["100. 🛤 Git 版本控制/10. 🚗 VCS 版本控制系统.md","🚗 VCS 版本控制系统","/pages/3b80ae/"],["100. 🛤 Git 版本控制/20. 🚚 一些实际工作模型.md","🚚 一些实际工作模型","/pages/f2d32b/"],["100. 🛤 Git 版本控制/25. 🏎 Git 的基本使用命令.md","🏎 Git 的基本使用命令","/pages/823b22/"],["100. 🛤 Git 版本控制/30. 🚒 Git 的 HEAD、master 与 branch.md","🚒 Git 的 HEAD、master 与 branch","/pages/ffbab0/"],["100. 🛤 Git 版本控制/40. 🚕 Git 的 push .md","🚕 Git 的 push","/pages/0fa378/"]]},{title:" 👣 前端基础辅助",collapsable:!0,children:[["110. 👣 前端基础辅助/10. 🗂 JSON 笔记.md","🗂 JSON 笔记","/pages/f50277/"],["110. 👣 前端基础辅助/20. 📕 jQuery 笔记.md","📕 jQuery 笔记","/pages/3ac8a3/"],["110. 👣 前端基础辅助/40. 📐Less 笔记.md","📐 Less 笔记","/pages/bade75/"],["110. 👣 前端基础辅助/50. 🅱️ Bootstrap 使用笔记.md","🅱️ Bootstrap 使用笔记","/pages/17c13a/"]]}],"/101. 🚶🏻 前端巩固基础/":[{title:" 🍯 ES6 基本语法",collapsable:!0,children:[["01. 🍯 ES6 基本语法/10. 🥯 ES6 的变量与常量.md","🥯 ES6 的变量与常量","/pages/519b8a/"],["01. 🍯 ES6 基本语法/20. 🥖 ES6 的模版字符串.md","🥖 ES6 的模版字符串","/pages/ce93cb/"],["01. 🍯 ES6 基本语法/30. 🥐 ES6 箭头函数与函数的默认参数.md","🥐 ES6 箭头函数与函数的默认参数","/pages/4f8b56/"],["01. 🍯 ES6 基本语法/40. 🥞 ES6 对象.md","🥞 ES6 对象","/pages/876bd2/"]]},["10. 🌱 NodeJS 基本使用.md","🌱 node.js 基本使用","/pages/4e50dd/"],{title:" 📒 JavaScript 深入对象",collapsable:!0,children:[["31. 📒 JavaScript 深入对象/10. 🔐 JavaScript Object 对象基础知识.md","🔐 JavaScript Object 对象基础知识","/pages/b7cfae/"],["31. 📒 JavaScript 深入对象/11. ⌛️ JavaScript 对象的复制与引用.md","⌛️ JavaScript 对象的复制与引用","/pages/01d74c/"],["31. 📒 JavaScript 深入对象/12. 🧭  JavaScript 垃圾回收机制.md","🧭  JavaScript 垃圾回收机制","/pages/d20597/"],["31. 📒 JavaScript 深入对象/13. 📡 JavaScript 对象方法.md","📡 JavaScript 对象方法","/pages/a661c0/"],["31. 📒 JavaScript 深入对象/14. 💾 JavaScript 对象构造器.md","💾 JavaScript 对象构造器","/pages/42cfe9/"],["31. 📒 JavaScript 深入对象/15. 🔗 JavaScript 对象可选链.md","🔗 JavaScript 对象可选链","/pages/058cb5/"],["31. 📒 JavaScript 深入对象/16. 🗽 JavaScript symbol 类型.md","🗽 JavaScript symbol 类型","/pages/a17557/"],["31. 📒 JavaScript 深入对象/17. ⏳ JavaScript 对象与原始值的转换.md","⏳ JavaScript 对象与原始值的转换","/pages/5d0f4e/"],["31. 📒 JavaScript 深入对象/18. 💡 JavaScript 对象属性标志和属性描述符.md","💡 JavaScript 对象属性标志和属性描述符","/pages/1f8eeb/"],["31. 📒 JavaScript 深入对象/19. 🔦 JavaScript 对象的访问器属性和描述符.md","🔦 JavaScript 对象的访问器属性和描述符","/pages/6ea59d/"]]},{title:" 📕 JavaScript 深入数据类型",collapsable:!0,children:[["32. 📕 JavaScript 深入数据类型/20. ⏺ JavaScript 原始类型的方法.md","⏺ JavaScript 原始类型的方法","/pages/75d69a/"],["32. 📕 JavaScript 深入数据类型/21. 🔢 JavaScript 数字类型.md","🔢 JavaScript 数字类型","/pages/f89962/"],["32. 📕 JavaScript 深入数据类型/22. ♒️ JavaScript 字符串.md","♒️ JavaScript 字符串","/pages/33f8b7/"],["32. 📕 JavaScript 深入数据类型/24. 🔃 JavaScript 数组.md","🔃 JavaScript 数组","/pages/e6c21b/"],["32. 📕 JavaScript 深入数据类型/25. 🔀 JavaScript 可迭代对象.md","🔀 JavaScript 可迭代对象","/pages/2c7626/"],["32. 📕 JavaScript 深入数据类型/26. 🔂 JavaScript 映射与集合.md","🔂 JavaScript 映射与集合","/pages/ca2625/"],["32. 📕 JavaScript 深入数据类型/27. 🔄 JavaScript 弱映射与弱集合.md","🔄 JavaScript 弱映射与弱集合","/pages/5de515/"],["32. 📕 JavaScript 深入数据类型/28. 🔀 JavaScript 更多迭代方法.md","🔀 JavaScript 更多迭代方法","/pages/aa670e/"],["32. 📕 JavaScript 深入数据类型/29. 📶 JavaScript 解构赋值.md","📶 JavaScript 解构赋值","/pages/62fb3f/"],["32. 📕 JavaScript 深入数据类型/30. 🆕 JavaScript 日期和时间.md","🆕 JavaScript 日期和时间","/pages/3f5e62/"],["32. 📕 JavaScript 深入数据类型/31. 🈁 JavaScript 与 JSON.md","🈁 JavaScript 与 JSON","/pages/cf5da1/"],["32. 📕 JavaScript 深入数据类型/40. 🧭 JavaScript 数组方法应用实例.md","🧭 JavaScript 数组方法应用实例","/pages/cb7d78/"],["32. 📕 JavaScript 深入数据类型/41. 🖇 JavaScript 映射与集合应用实例.md","🖇 JavaScript 映射与集合应用实例","/pages/183c8c/"],["32. 📕 JavaScript 深入数据类型/42. 🗑 JavaScript 弱映射与弱集合应用实例.md","🗑 JavaScript 弱映射与弱集合应用实例","/pages/b5e223/"]]},{title:" 📗 JavaScript 深入函数",collapsable:!0,children:[["33. 📗 JavaScript 深入函数/01. 🚝  JavaScript 函数递归与堆栈.md","🚝  JavaScript 函数递归与堆栈","/pages/acdd55/"],["33. 📗 JavaScript 深入函数/02. 🚅 JavaScript Rest 参数与 Spread 语法.md","🚅 JavaScript Rest 参数与 Spread 语法","/pages/208b1a/"],["33. 📗 JavaScript 深入函数/03. 🚈 JavaScript 变量作用域与闭包.md","🚈 JavaScript 变量作用域与闭包","/pages/7b2364/"],["33. 📗 JavaScript 深入函数/04. 🚂 JavaScript 全局对象.md","🚂 JavaScript 全局对象","/pages/b89842/"],["33. 📗 JavaScript 深入函数/05. 🚆 JavaScript 函数对象.md","🚆 JavaScript 函数对象","/pages/577e1c/"],["33. 📗 JavaScript 深入函数/06. 🚞 JavaScript 创建函数 new Function.md","🚞 JavaScript 创建函数 new Function","/pages/b022f1/"],["33. 📗 JavaScript 深入函数/07. 🚠 JavaScript 中的调度函数.md","🚠 JavaScript 中的调度函数","/pages/222f6f/"],["33. 📗 JavaScript 深入函数/08. 🚃 JavaScript 装饰器模式和转发.md","🚃 JavaScript 装饰器模式和转发","/pages/23d75e/"],["33. 📗 JavaScript 深入函数/09. 🚡 JavaScript 函数绑定.md","🚡 JavaScript 函数绑定","/pages/9c420b/"],["33. 📗 JavaScript 深入函数/10. 🛺 JavaScript 深入箭头函数.md","🛺 JavaScript 深入箭头函数","/pages/92a793/"]]},{title:" 📘 JavaScript 原型与继承",collapsable:!0,children:[["34. 📘 JavaScript 原型与继承/10. ⛰ JavaScript 原型继承 .md","⛰ JavaScript 原型继承","/pages/0d9ae4/"],["34. 📘 JavaScript 原型与继承/20. 🗻 JavaScript 原型构造.md","🗻 JavaScript 原型构造","/pages/63877d/"],["34. 📘 JavaScript 原型与继承/30. 🏕 JavaScript 原生的原型.md","🏕 JavaScript 原生的原型","/pages/439d84/"],["34. 📘 JavaScript 原型与继承/40. 🏜 JavaScript 原型方法.md","🏜 JavaScript 原型方法","/pages/ed1ff1/"]]},{title:" 📙 JavaScript 类",collapsable:!0,children:[["35. 📙 JavaScript 类/01. ⚽️ JavaScript 类的基本语法.md","⚽️ JavaScript 类的基本语法","/pages/2864a5/"],["35. 📙 JavaScript 类/02. 🏀 JavaScript 类继承.md","🏀 JavaScript 类继承","/pages/5bccfe/"],["35. 📙 JavaScript 类/03. 🥏 JavaScript 类的静态属性和静态方法.md","🥏 JavaScript 类的静态属性和静态方法","/pages/e02f65/"],["35. 📙 JavaScript 类/04. 🪀 JavaScript 类的私有和受保护的属性和方法.md","🪀 JavaScript 类的私有和受保护的属性和方法","/pages/9fa26b/"]]},{title:" 📓 JavaScript DOM",collapsable:!0,children:[["36. 📓 JavaScript DOM/01. 🍕 JavaScript DOM 树 .md","🍕 JavaScript DOM 树","/pages/0bac3b/"],["36. 📓 JavaScript DOM/02. 🍥 JavaScript DOM 操作.md","🍥 JavaScript DOM 操作","/pages/cae956/"],["36. 📓 JavaScript DOM/03. 🥗 JavaScript DOM 样式和类.md","🥗 JavaScript DOM 样式和类","/pages/9992c4/"],["36. 📓 JavaScript DOM/04. 🥘 JavaScript 浏览器事件.md","🥘 JavaScript 浏览器事件","/pages/f3541c/"],["36. 📓 JavaScript DOM/10. 🥫 JavaScript 事件使用示例.md","🥫 JavaScript 事件使用示例","/pages/5fe7c6/"],["36. 📓 JavaScript DOM/30. 🍩 JavaScript 事件循环.md","🍩 JavaScript 事件循环","/pages/006f30/"],["36. 📓 JavaScript DOM/70. 🌲 JavaScript DOM与BOM.md","🌲 JavaScript DOM与BOM","/pages/2a600b/"],["36. 📓 JavaScript DOM/80. 🥡 JavaScript 文档和资源加载.md","🥡 JavaScript 文档和资源加载","/pages/883723/"]]},{title:" 🍯 JavaScript AJAX 网络请求",collapsable:!0,children:[["37. 🍯 JavaScript AJAX 网络请求/01. 🥢 JavaScript Fetch.md","🥢 JavaScript Fetch","/pages/e0da75/"],["37. 🍯 JavaScript AJAX 网络请求/02. 🥤 JavaScript Fetch API.md","🥤 JavaScript Fetch API","/pages/def96d/"],["37. 🍯 JavaScript AJAX 网络请求/03.🧉 JavaScript URL 对象.md","🧉 JavaScript URL 对象","/pages/162aa2/"],["37. 🍯 JavaScript AJAX 网络请求/04. 🍶 JavaScript XMLHttpRequest.md","🍶 JavaScript XMLHttpRequest","/pages/644542/"],["37. 🍯 JavaScript AJAX 网络请求/05. 🥃 JavaScript 长轮询 WebSocket.md","🥃 JavaScript 长轮询 WebSocket","/pages/527bc8/"]]},{title:" 🚇 JavaScript Promise",collapsable:!0,children:[["39. 🚇 JavaScript Promise/01. ⛴  JavaScript 回调函数引入.md","⛴  JavaScript 回调函数引入","/pages/1d9ea1/"],["39. 🚇 JavaScript Promise/02. 🚊 Promise 的基本使用.md","🚊 Promise 的基本使用","/pages/948475/"],["39. 🚇 JavaScript Promise/03. 🛞 Promise 链式调用.md","🛞 Promise 链式调用","/pages/befb4f/"],["39. 🚇 JavaScript Promise/04. 🛟 Promise 错误处理.md","🛟 Promise 错误处理","/pages/ac44b6/"],["39. 🚇 JavaScript Promise/07. 🚉 Promise 相关 API.md","🚉 Promise 相关 API","/pages/6c6065/"],["39. 🚇 JavaScript Promise/08. 🛰 Promise 的几个关键问题.md","🛰 Promise 的几个关键问题","/pages/dbb94a/"],["39. 🚇 JavaScript Promise/09. 🛫 Promise 的自定义封装.md","🛫 Promise 的自定义封装","/pages/02f98e/"],["39. 🚇 JavaScript Promise/10. 🛩 Promise 的 async 和 await.md","🛩 Promise 的 async 和 await","/pages/0eb0a7/"]]},{title:" 📔 JavaScript 其他内容",collapsable:!0,children:[["40. 📔 JavaScript 其他内容/01. 🧨 JavaScript 防抖与节流.md","🧨 JavaScript 防抖与节流","/pages/921863/"],["40. 📔 JavaScript 其他内容/02. 🗑 JavaScript 关于使用 var 声明变量.md","🗑 JavaScript 关于使用 var 声明变量","/pages/ce4056/"],["40. 📔 JavaScript 其他内容/10. 🪤JavaScript 的模块管理.md","🪤JavaScript 的模块管理","/pages/6edabb/"],["40. 📔 JavaScript 其他内容/20. 🔦 JavaScript 的错误处理.md","🔦 JavaScript 的错误处理","/pages/7c3484/"],["40. 📔 JavaScript 其他内容/30. 🎪 JavaScript Proxy 和 Reflect.md","🎪 JavaScript Proxy 和 Reflect","/pages/15a7cb/"],["40. 📔 JavaScript 其他内容/50. 📦 JavaScript 浏览器存储.md","📦 JavaScript 浏览器存储","/pages/40ee0e/"],["40. 📔 JavaScript 其他内容/60. 🎣 JavaScript 正则表达式.md","🎣 JavaScript 正则表达式","/pages/f38565/"]]},{title:" 🏃 JavaScript 进阶高级",collapsable:!0,children:[["50. 🏃 JavaScript 进阶高级/07. 🎱 JavaScript 闭包.md","🎱 JavaScript 闭包","/pages/d7055d/"],["50. 🏃 JavaScript 进阶高级/08. 🕶 JavaScript 对象高级.md","🕶 JavaScript 对象高级","/pages/502815/"],["50. 🏃 JavaScript 进阶高级/09. 🎲 JavaScript 线程机制与事件机制.md","🎲 JavaScript 线程机制与事件机制","/pages/fb7e0f/"]]},{title:" ʦ TypeScript",collapsable:!0,children:[["60. ʦ TypeScript/01. 🚛 TypeScript 前言.md","🚛 TypeScript 前言","/pages/8d9f46/"],["60. ʦ TypeScript/02. 🚌 TypeScript 变量的声明与数据类型.md","🚌 TypeScript 变量的声明与数据类型","/pages/3d1460/"],["60. ʦ TypeScript/03. 🚙 TypeScript 函数类型.md","🚙 TypeScript 函数类型","/pages/47c91c/"],["60. ʦ TypeScript/04. 🏎 TypeScript 中的类与接口.md","🏎 TypeScript 中的类与接口","/pages/f615a2/"],["60. ʦ TypeScript/05. 🚐 TypeScript 泛型.md","🚐 TypeScript 泛型","/pages/9cb8e3/"],["60. ʦ TypeScript/06. 🚕 TypeScript 模块化与类型声明.md","🚕 TypeScript 模块化与类型声明","/pages/eb9b04/"],["60. ʦ TypeScript/07. 🚠 TypeScript 的常用配置.md","🚠 TypeScript 的常用配置","/pages/48e822/"]]},{title:" 🚟 axios",collapsable:!0,children:[["90. 🚟 axios/01. 🚋 axios 理解与使用.md","🚋 axios 理解与使用","/pages/a24b1b/"],["90. 🚟 axios/02. 🚞 axios 在 Vue 项目中的封装.md","🚞 axios 在 Vue 项目中的封装","/pages/2626b9/"],["90. 🚟 axios/10. 💽 使用 TypeScript 重构 axios 库.md","💽 使用 TypeScript 重构 axios 库","/typescript-axios"]]}],"/105. 🏃 前端核心框架/":[{title:" 🎹 Web Components",collapsable:!0,children:[["01. 🎹 Web Components/01. 🧩 Web Components .md","🧩 Web Components","/pages/57c232/"],["01. 🎹 Web Components/02. 🍙 Custom Elements 自定义标签md.md","🍙 Custom Elements 自定义标签","/pages/a3a824/"],["01. 🎹 Web Components/03. 🍘 Shadow DOM 影子 DOM.md","🍘 Shadow DOM 影子 DOM","/pages/639649/"],["01. 🎹 Web Components/04. 🥮 template 模版元素.md","🥮 template 模版元素","/pages/f0961b/"]]},{title:" ☔️ 核心框架项目搭建",collapsable:!0,children:[["04. ☔️ 核心框架项目搭建/10. 🥯 Vue 2.x 脚手架创建项目.md","🥯 Vue 2.x 脚手架创建项目","/pages/1a639e/"],["04. ☔️ 核心框架项目搭建/11. 🪝  Vue 3  + TypeScript  项目搭建.md","🪝 Vue 3 + TypeScript 项目搭建","/pages/bb1311/"]]},{title:" 🌧️ Vue 基础",collapsable:!0,children:[["10. 🌧️ Vue 基础/01. 🌨 Vue 的基本使用.md","🌨 Vue 的基本使用","/pages/85a3ba/"],["10. 🌧️ Vue 基础/02. 🌕 Vue 模版语法.md","🌕 Vue 模版语法","/pages/c0d42b/"],["10. 🌧️ Vue 基础/03. 🌔 Vue 数据绑定原理.md","🌔 Vue 数据绑定原理","/pages/14aa98/"],["10. 🌧️ Vue 基础/04. 🌗 Vue 事件处理.md","🌗 Vue 事件处理","/pages/9aa1bb/"],["10. 🌧️ Vue 基础/05. 🌓 Vue 计算属性与侦听器md.md","🌓 Vue 计算属性与侦听器 watch","/pages/c10950/"],["10. 🌧️ Vue 基础/06. 🌗 Vue 样式绑定.md","🌗 Vue 样式绑定","/pages/64e761/"],["10. 🌧️ Vue 基础/07. 🌑 Vue 指令.md","🌑 Vue 指令","/pages/55d982/"],["10. 🌧️ Vue 基础/08. 🌒 Vue 条件渲染与列表渲染.md","🌒 Vue 条件渲染与列表渲染","/pages/fcee68/"],["10. 🌧️ Vue 基础/09. 🌞 Vue 生命周期.md","🌞 Vue 声明周期","/pages/021159/"],["10. 🌧️ Vue 基础/20. 🌟 Vue 关键问题.md","🌟 Vue 关键问题","/pages/701e29/"],["10. 🌧️ Vue 基础/30. ✨ Vue 实用实例.md","✨ Vue 实用实例","/pages/905c0c/"]]},{title:" ⛈ Vue 组件编程",collapsable:!0,children:[["11. ⛈ Vue 组件编程/01. 🌘 Vue 组件化编程概念.md","🌘 Vue 组件化编程概念","/pages/5935fd/"],["11. ⛈ Vue 组件编程/02.🌈 Vue 组件注册.md","🌈 Vue 组件基础","/pages/f7e44a/"],["11. ⛈ Vue 组件编程/10. 🌊 Vue Prop.md","🌊 Vue Prop","/pages/50df35/"],["11. ⛈ Vue 组件编程/15. 💫 Vue 自定义事件.md","💫 Vue 自定义事件","/pages/19709c/"],["11. ⛈ Vue 组件编程/20. ✨ Vue Slot 插槽 .md","✨ Vue Slot 插槽","/pages/914583/"],["11. ⛈ Vue 组件编程/30. ⭐️ Vue 动态组件与异步组件.md","⭐️ Vue 动态组件与异步组件","/pages/432c01/"],["11. ⛈ Vue 组件编程/41. ☀️ Vue 全局事件总线.md","☀️ Vue 全局事件总线","/pages/2a073b/"],["11. ⛈ Vue 组件编程/43. ⚡️ Vue 消息订阅与发布.md","⚡️ Vue 消息订阅与发布","/pages/e784e6/"],["11. ⛈ Vue 组件编程/50. 🌙 Vue 动画与过渡.md","🌙 Vue 动画与过渡","/pages/5a0c40/"],["11. ⛈ Vue 组件编程/60. 🛒 Vue 中的 AJAX.md","🛒 Vue 中的 AJAX","/pages/b2106c/"],["11. ⛈ Vue 组件编程/70. 🌩 Vuex 状态管理.md","🌩 Vuex 状态管理","/pages/def0ac/"],["11. ⛈ Vue 组件编程/90. ☔️ Vue Router 路由.md","☔️ Vue Router 路由","/pages/c2ae57/"],["11. ⛈ Vue 组件编程/100. 🌕 Vue 组件编程案例.md","🌕 Vue 脚手架案例","/pages/fce04e/"],["11. ⛈ Vue 组件编程/101. 🪐 Vue 浏览器本地存储.md","🪐 Vue 浏览器本地存储","/pages/8e154e/"]]},{title:" 🌨 Vue 3 组合式 API",collapsable:!0,children:[["15. 🌨 Vue 3 组合式 API/01. ☂️ Vue 3 创建项目.md","☂️ Vue 3 上手","/pages/c8dfe0/"],["15. 🌨 Vue 3 组合式 API/02. 🧊 Vue 3 的组合 API 编程.md","🧊 Vue 3 的组合 API 编程","/pages/0768ce/"],["15. 🌨 Vue 3 组合式 API/03. 🌊 Vue 3 其他更新.md","🌊 Vue 3 其他更新","/pages/f33531/"]]}],"/200. 🪞 前端面试题收集/":[{title:" ⛳️ 准备工作",collapsable:!0,children:[["01. ⛳️ 准备工作/02. 💡 面试常见问题收集.md","💡 面试常见问题收集","/pages/a2e141/"],["01. ⛳️ 准备工作/03. 🧳 面试项目经验.md","🧳 面试项目经验","/pages/fc5676/"]]},{title:" 🏙 HTTP 相关",collapsable:!0,children:[["05. 🏙 HTTP 相关/01. 🍎 HTTP 与 HTTPS .md","🍎 HTTP 与 HTTPS","/pages/f9fc1b/"],["05. 🏙 HTTP 相关/02. 🍏 HTTP 常见的请求头.md","🍏 HTTP 常见的请求头","/pages/1fc4db/"],["05. 🏙 HTTP 相关/03. 🍏 HTTP 1.0 1.1 2.0 区别.md","🍏 HTTP 1.0/1.1/2.0 的区别","/pages/f53072/"],["05. 🏙 HTTP 相关/04. 🍎 HTTP 常见的状态码.md","🍎 HTTP 常见的状态码","/pages/6caede/"],["05. 🏙 HTTP 相关/05. 🍎 HTTP 请求方法.md","🍎 HTTP 请求方法","/pages/9506f5/"],["05. 🏙 HTTP 相关/10. 🍏 TCP 与 UDP 的区别.md","🍏 TCP 与 UDP 的区别","/pages/58170b/"],["05. 🏙 HTTP 相关/11. 🍏 TCP 的三次握手与四次挥手.md","🍏 TCP 的三次握手与四次挥手","/pages/6d9faf/"],["05. 🏙 HTTP 相关/12. 🍏 TCPIP 协议.md","🍏 TCP/IP 协议","/pages/d329d0/"],["05. 🏙 HTTP 相关/30. 🍏 WebSocket 相关.md","🍏 WebSocket 相关","/pages/47ce67/"],["05. 🏙 HTTP 相关/40. 🍎 输入 URL 回车后发生的事情.md","🍎 输入 URL 回车后发生的事情","/pages/606924/"]]},{title:" 🌆 HTML 相关",collapsable:!0,children:[["06. 🌆 HTML 相关/01. 🍏 HTML 语义化标签理解.md","🍏 HTML 语义化标签理解","/pages/34b808/"],["06. 🌆 HTML 相关/02. 🍎 实现响应式设计的相关.md","🍎 实现响应式设计的相关","/pages/28d421/"]]},{title:" 🏞 CSS 相关",collapsable:!0,children:[["07. 🏞 CSS 相关/01. 🍎 CSS 的盒子模型相关 .md","🍎 CSS 的盒子模型相关","/pages/efa419/"],["07. 🏞 CSS 相关/02. 🍎 CSS 的选择器相关.md","🍎 CSS 的选择器相关","/pages/10ff5a/"],["07. 🏞 CSS 相关/03. 🍎 CSS 的计量单位相关.md","🍎 CSS 的计量单位相关","/pages/5fc469/"],["07. 🏞 CSS 相关/04. 🍏 CSS 实现隐藏元素.md","🍏 CSS 实现隐藏元素","/pages/9ca940/"],["07. 🏞 CSS 相关/05. 🍏 CSS 实现元素居中.md","🍏 CSS 实现元素居中","/pages/46067c/"],["07. 🏞 CSS 相关/06. 🍎 CSS BFC 相关.md","🍎 CSS BFC 相关","/pages/0cd1d6/"],["07. 🏞 CSS 相关/10. 🍎 CSS 弹性盒布局相关.md","🍎 CSS 弹性盒布局相关","/pages/d79434/"],["07. 🏞 CSS 相关/11. 🍎 CSS 网格布局相关.md","🍎 CSS 网格布局相关","/pages/574676/"],["07. 🏞 CSS 相关/90. 🍏 CSS 性能优化相关.md","🍏 CSS 性能优化相关","/pages/928d4e/"],["07. 🏞 CSS 相关/101. 🍎 CSS 预编语言相关.md","🍎 CSS 预编语言相关","/pages/babf64/"]]},{title:" 🗾 JavaScript 相关",collapsable:!0,children:[{title:" 🍎 JavaScript 数据类型相关",collapsable:!0,children:[["08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/01. 🍎 JavaScript 数据类型.md","🍎 JavaScript 数据类型","/pages/7f3bfc/"],["08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/02. 🍎 JavaScript 数组常用方法.md","🍎 JavaScript 数组常用方法","/pages/3cfb49/"],["08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/03. 🍎 JavaScript 字符串常用方法.md","🍎 JavaScript 字符串常用方法","/pages/d3e8df/"],["08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/04. 🍏 JavaScript typeof 与 instanceof.md","🍏 JavaScript typeof 与 instanceof","/pages/d7f372/"],["08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/05. 🍏 JavaScript 数字精度丢失相关.md","🍏 JavaScript 数字精度丢失相关","/pages/aef8c2/"],["08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/10. 🍏 JavaScript 数据变量内存.md","🍏 JavaScript 数据变量内存","/pages/6e10ef/"],["08. 🗾 JavaScript 相关/01. 🍎 JavaScript 数据类型相关/20. 🍎 JavaScript 深拷贝与浅拷贝.md","🍎 JavaScript 深拷贝与浅拷贝","/pages/99b9ce/"]]},{title:" 🍎 JavaScript 对象相关",collapsable:!0,children:[["08. 🗾 JavaScript 相关/02. 🍎 JavaScript 对象相关/02. 🍎 JavaScript new 操作符相关.md","🍎 JavaScript new 操作符相关","/pages/b0ab4c/"],["08. 🗾 JavaScript 相关/02. 🍎 JavaScript 对象相关/03. 🍏 JavaScript 对象模式.md","🍏 JavaScript 对象模式","/pages/d76014/"]]},{title:" 🍎 JavaScript 函数相关",collapsable:!0,children:[["08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/02. 🍎 JavaScript 闭包.md","🍎 JavaScript 闭包","/pages/7a9353/"],["08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/03. 🍎 JavaScript 作用域与作用域链.md","🍎 JavaScript 作用域与作用域链","/pages/8ae2cd/"],["08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/04. 🍎 JavaScript 执行上下文与执行栈.md","🍎 JavaScript 执行上下文与执行栈","/pages/b66da8/"],["08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/05. 🍎 JavaScript  this 指向问题.md","🍎 JavaScript this 指向问题","/pages/b16ce1/"],["08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/10. 🍎 JavaScript 函数式编程相关.md","🍎 JavaScript 函数式编程相关","/pages/e6af48/"],["08. 🗾 JavaScript 相关/03. 🍎 JavaScript 函数相关/11. 🍎 JavaScript 函数缓存相关.md","🍎 JavaScript 函数缓存相关","/pages/f5f615/"]]},{title:" 🍎 JavaScript 原型与继承相关",collapsable:!0,children:[["08. 🗾 JavaScript 相关/04. 🍎 JavaScript 原型与继承相关/01. 🍎 JavaScript 原型与原型链.md","🍎 JavaScript 原型与原型链","/pages/a78536/"],["08. 🗾 JavaScript 相关/04. 🍎 JavaScript 原型与继承相关/02. 🍎 JavaScript 继承相关.md","🍎 JavaScript 继承相关","/pages/bc77a3/"]]},{title:" 🍎 ES6 相关",collapsable:!0,children:[["08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/02. 🍏 ES6 新增特性.md","🍏 ES6 新增特性","/pages/104705/"],["08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/03. 🍎 ES6 Promise 相关.md","🍎 ES6 Promise 相关","/pages/c14014/"],["08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/04. 🍏 ES6 Generator 相关.md","🍏 ES6 Generator 相关","/pages/f1fa30/"],["08. 🗾 JavaScript 相关/10. 🍎 ES6 相关/05. 🍏 ES6 Module 模块化相关.md","🍏 ES6 Module 模块化相关","/pages/0e8ab8/"]]},["08. 🗾 JavaScript 相关/11. 🍎 JavaScript 事件模型.md","🍎 JavaScript 事件模型","/pages/2f3265/"],["08. 🗾 JavaScript 相关/12. 🍎 JavaScript 事件循环相关.md","🍎 JavaScript 事件循环相关","/pages/a30824/"],["08. 🗾 JavaScript 相关/13. 🍏 JavaScript 线程机制相关.md","🍏 JavaScript 线程机制相关","/pages/a50766/"],["08. 🗾 JavaScript 相关/20. 🍏 JavaScript BOM 相关问题.md","🎱 JavaScript BOM 相关问题","/pages/b84b16/"],["08. 🗾 JavaScript 相关/30. 🍎 JavaScript 本地存储相关.md","🍎 JavaScript 本地存储相关","/pages/cc4083/"],["08. 🗾 JavaScript 相关/40. 🍎 JavaScript 防抖与节流相关.md","🍎 JavaScript 防抖与节流相关","/pages/0a56d1/"]]},{title:" 🌠 核心框架相关",collapsable:!0,children:[["09. 🌠 核心框架相关/01. 🍎 虚拟 DOM 的理解.md","🍎 虚拟 DOM 的理解","/pages/f561af/"]]},{title:" 📦  Webpack 相关",collapsable:!0,children:[["10. 📦  Webpack 相关/01. 🍎 对 Webpack 的理解相关.md","🍎 对 Webpack 的理解相关","/pages/96c489/"],["10. 📦  Webpack 相关/02. 🍏 Webpack 的构建流程.md","🍏 Webpack 的构建流程","/pages/6e40af/"]]},{title:" 📦 NodeJS 相关",collapsable:!0,children:[["20. 📦 NodeJS 相关/01. 🍎 NodeJS 理解相关.md","🍎 NodeJS 理解相关","/pages/7bb20b/"],["20. 📦 NodeJS 相关/02. 🍎 NodeJS 前端模块化开发相关.md","🍎 NodeJS 前端模块化开发相关","/pages/d38a08/"]]},{title:" 📦 设计模式相关",collapsable:!0,children:[["60. 📦 设计模式相关/01. 🍎 设计模式的理解.md","🍎 设计模式的理解","/pages/ce7138/"]]},{title:" 📦 前端工程化",collapsable:!0,children:[["70. 📦 前端工程化/01. 🍏 前端项目使用脚手架.md","🍏 前端项目使用脚手架","/pages/003555/"]]}],"/400. 🚪 其他文章收集/":[["10. 📡 关于本笔记的搭建.md","📡 关于本笔记的搭建","/pages/99638b/"]],"/801. 💽 TypeScript-Axios/":[["01. 🌑 初始化 TypeScript 库项目.md","🌑 初始化 TypeScript 库项目","/pages/a07897/"],{title:" 🌒 实现基础功能",collapsable:!0,children:[["02. 🌒 实现基础功能/02. 🌒 实现基础请求.md","🌒 实现基础请求","/pages/a6d7da/"],["02. 🌒 实现基础功能/03. 🌒 实现处理请求 URL 参数.md","🌒 实现处理请求 URL 参数","/pages/2c5ed7/"],["02. 🌒 实现基础功能/04. 🌒 实现处理请求 body 数据.md","🌒 实现处理请求 body 数据","/pages/fa5bf4/"],["02. 🌒 实现基础功能/05. 🌒 实现处理请求 head.md","🌒 实现处理请求 head","/pages/1d2040/"],["02. 🌒 实现基础功能/06. 🌒 获取响应数据.md","🌒 获取响应数据","/pages/f3a9f8/"],["02. 🌒 实现基础功能/07. 🌒 实现处理响应 header 和 data.md","🌒 实现处理响应 header 和 data","/pages/e463f4/"]]},["10. 🌘 实现异常情况处理.md","🌘 实现异常情况处理","/pages/3de0b0/"],["20. 🌘 实现接口拓展.md","🌘 实现接口拓展","/pages/8fff17/"],["30. 🌘 实现拦截器.md","🌘 实现拦截器","/pages/291f04/"],["40. 🌓 实现合并默认配置.md","🌓 实现合并默认配置","/pages/1e5c77/"],["41. 🌓 实现请求和响应配置化.md","🌓 实现请求和响应配置化","/pages/4c10b2/"],["42. 🌓 拓展创建axios静态接口.md","🌓 拓展创建axios静态接口","/pages/87b8ba/"],["43. 🌗 实现取消功能.md","🌗 实现取消功能","/pages/0a6e3d/"],["44. 🌗 实现权限相关功能.md","🌗 实现权限相关功能","/pages/211982/"],["45. 🌗 实现 XSRF 防御.md","🌗 实现 XSRF 防御","/pages/767314/"],["46. 🌗 实现上传和下载进度监控.md","🌗 实现上传和下载进度监控","/pages/2871e0/"],["47. 🌗 实现 HTTP 授权.md","🌗 实现 HTTP 授权","/pages/441f8f/"],["48. 🌗 实现自定义合法状态码.md","🌗 实现自定义合法状态码","/pages/97d131/"],["49. 🌗 实现自定义参数序列化.md","🌗 实现自定义参数序列化","/pages/d6c1c4/"],["50. 🌗 实现 baseURL.md","🌗 实现 baseURL","/pages/206979/"],["60. 🌓 静态方法拓展.md","🌓 静态方法拓展","/pages/9850cb/"],["70. 🌖 单元测试 Jest 的使用.md","🌖 单元测试 Jest 的使用","/pages/4b46b1/"],["71. 🌖 辅助模块单元测试.md","🌖 辅助模块单元测试","/pages/73c2b6/"],["72. 🌖 请求模块单元测试.md","🌖 请求模块单元测试","/pages/169950/"],["73. 🌖 headers 模块单元测试.md","🌖 headers 模块单元测试","/pages/f4e917/"],["74. 🌖 Axios 实例模块单元测试.md","🌖 Axios 实例模块单元测试","/pages/528987/"],["75. 🌖 拦截器模块单元测试.md","🌖 拦截器模块单元测试","/pages/7e14c7/"],["76. 🌖 合并配置模块单元测试.md","🌖 合并配置模块单元测试","/pages/f2e77e/"],["77. 🌖 请求取消模块单元测试.md","🌖 请求取消模块单元测试","/pages/4877d8/"],["78. 🌖 更多模块单元测试.md","🌖 更多模块单元测试","/pages/b58e50/"],["80. 🌕 部署与发布.md","🌕 部署与发布","/pages/2b07f0/"]]},updateBar:{showToArticle:!1,moreArticle:"/archives"},author:{name:"Simon Luo",link:"https://github.com/simon1uo"},footer:{createYear:2020,copyrightInfo:'wrote with ❤️ by <a href="https://simon1uo.github.io">Simon</a></br>'}}};var vl=t(94),bl=t(95),yl=t(11);var xl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:o}}=n;return!(e||!1===t||!0===o)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,o=e.frontmatter.sticky;return t&&o?t==o?Object(yl.a)(n,e):t-o:t&&!o?-1:!t&&o?1:Object(yl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(yl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let o=0,r=n.length;o<r;o++){const{frontmatter:{categories:r,tags:a}}=n[o];"array"===Object(yl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[o]))}),"array"===Object(yl.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[o]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Rt.component(vl.default),Rt.component(bl.default);function wl(n){return n.toString().padStart(2,"0")}t(237);Rt.component("Badge",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,620))),Rt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),Rt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95)));t(238),t(239);var El=t(93),Sl=t.n(El),kl=t(25);let jl,Tl,Al;var Bl;"valine"===(Bl="waline")?t.e(292).then(t.t.bind(null,331,7)).then(n=>Tl=n.default):"gitalk"===Bl?Promise.all([t.e(0),t.e(291)]).then(t.t.bind(null,332,7)).then(()=>t.e(290).then(t.t.bind(null,333,7))).then(n=>jl=n.default):"waline"===Bl&&t.e(6).then(t.t.bind(null,334,7)).then(n=>Al=n.default);function Fl(n,e){const t={};return Reflect.ownKeys(n).forEach(o=>{if("string"==typeof n[o])try{t[o]=Sl.a.render(n[o],e)}catch(e){console.warn(`Comment config option error at key named "${o}"`),console.warn("More info: "+e.message),t[o]=n[o]}else t[o]=n[o]}),t}console.log(`How to use "waline" in ${kl.name}@v${kl.version}:`,kl.homepage);const Cl={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new jl(Fl({el:"#valine-vuepress-comment",serverURL:"https://waline-comment-container-rjrabjk7j-simon1uo.vercel.app/",path:"<%- frontmatter.permalink %>",dark:"body.theme-mode-dark",login:"force",emoji:["//unpkg.com/@waline/emojis@1.0.1/alus","//unpkg.com/@waline/emojis@1.0.1/tw-emoji"]},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Tl({...Fl({el:"#valine-vuepress-comment",serverURL:"https://waline-comment-container-rjrabjk7j-simon1uo.vercel.app/",path:"<%- frontmatter.permalink %>",dark:"body.theme-mode-dark",login:"force",emoji:["//unpkg.com/@waline/emojis@1.0.1/alus","//unpkg.com/@waline/emojis@1.0.1/tw-emoji"]},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},waline:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Al({...Fl({el:"#valine-vuepress-comment",serverURL:"https://waline-comment-container-rjrabjk7j-simon1uo.vercel.app/",path:"<%- frontmatter.permalink %>",dark:"body.theme-mode-dark",login:"force",emoji:["//unpkg.com/@waline/emojis@1.0.1/alus","//unpkg.com/@waline/emojis@1.0.1/tw-emoji"]},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}};let Pl=null;function zl(n){let e="#valine-vuepress-comment";return e.startsWith("#")&&(e=e.slice(1)),console.log(e),Cl.waline.clear(e)}function Il(n){return!1!==n.comment&&!1!==n.comments}function Jl(n){clearTimeout(Pl);if(!document.querySelector("main.page"))return void(Pl=setTimeout(()=>Jl(n),200));let e="#valine-vuepress-comment";return e.startsWith("#")&&(e=e.slice(1)),Cl.waline.render(n,e)}var ql={mounted(){Pl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};zl()&&Il(n)&&Jl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};zl()&&Il(t)&&Jl(t)})}},Dl=Object(ml.a)(ql,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Ml=[({Vue:n,options:e,router:t,siteData:o})=>{o.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${wl(n.getUTCMonth()+1)}-${wl(n.getUTCDate())} ${wl(n.getUTCHours())}:${wl(n.getUTCMinutes())}:${wl(n.getUTCSeconds())}`}(e)),t?n.author=t:o.themeConfig.author&&(n.author=o.themeConfig.author)}),n.mixin(xl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({Vue:n})=>{n.component("Comment",Dl)}],_l=["Comment"];class Ol extends class{constructor(){this.store=new Rt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Rt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Ol.prototype,{getPageAsyncComponent:ti,getLayoutAsyncComponent:oi,getAsyncComponent:ri,getVueComponent:ai});var Ll={install(n){const e=new Ol;n.$vuepress=e,n.prototype.$vuepress=e}};function Hl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Rl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ii("pageKey",e),Rt.component(e)||Rt.component(e,ti(e)),Rt.component(e)?n(e):n("")}},Ul={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},$l={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Vl=(t(245),t(246),Object(ml.a)($l,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Nl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Rt.config.productionTip=!1,Rt.use(Hs),Rt.use(Ll),Rt.mixin(function(n,e,t=Rt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const o=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),a={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const o in n)"/"===o?t=n[o]:0===this.$page.path.indexOf(o)&&(e=n[o]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,o=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?o?o+" | "+t:t:o||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const o=n[t];if(o.path.toLowerCase()===e.toLowerCase())return o}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},gl)),Rt.component("Content",Rl),Rt.component("ContentSlotsDistributor",Ul),Rt.component("OutboundLink",Vl),Rt.component("ClientOnly",Nl),Rt.component("Layout",oi("Layout")),Rt.component("NotFound",oi("NotFound")),Rt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"317e153"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:gl.routerBase||gl.base,t=new Hs({base:e,mode:"history",fallback:!1,routes:fl,scrollBehavior:(n,e,t)=>t||(n.hash?!Rt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,o)=>{if(Hl(n,e.path))o();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Hl(n,t)?o(t):o()}else o();else{const t=e.path+"/",r=e.path+".html";Hl(n,r)?o(r):Hl(n,t)?o(t):o()}})}(t);const o={};try{await Promise.all(Ml.filter(n=>"function"==typeof n).map(e=>e({Vue:Rt,options:o,router:t,siteData:gl,isServer:n})))}catch(n){console.error(n)}return{app:new Rt(Object.assign(o,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},_l.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);