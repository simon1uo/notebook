(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{629:function(v,_,e){"use strict";e.r(_);var o=e(29),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"内置指令-v"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内置指令-v"}},[v._v("#")]),v._v(" 内置指令  "),e("code",[v._v("v-*")])]),v._v(" "),e("blockquote",[e("p",[v._v("已经提到过的内置指令：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("v-bind：单向绑定解析表达式，可简写为  "),e("code",[v._v(":")]),v._v(" ；")])]),v._v(" "),e("li",[e("p",[v._v("v-model：双向数据绑定；")])]),v._v(" "),e("li",[e("p",[v._v("v-for：遍历数组 / 对象 / 字符串；")])]),v._v(" "),e("li",[e("p",[v._v("v-on：绑定事件监听，可简写为  "),e("code",[v._v("@")]),v._v("  ；")])]),v._v(" "),e("li",[e("p",[v._v("v-if：条件渲染（动态控制节点是否存存在）")]),v._v(" "),e("p",[v._v("v-else：条件渲染（动态控制节点是否存存在）")])]),v._v(" "),e("li",[e("p",[v._v("v-show：条件渲染（动态控制节点是否展示）")])])])]),v._v(" "),e("p",[e("code",[v._v("v-text")]),v._v("  ：向其所在的节点中渲染文本内容；")]),v._v(" "),e("p",[v._v("（与插值语法的区别： "),e("code",[v._v("v-text")]),v._v("  会替换掉节点中的内容， 插值语法则不会）")]),v._v(" "),e("p",[e("code",[v._v("v-html")]),v._v(" ：与  "),e("code",[v._v("v-text")]),v._v("  相似，但是  "),e("code",[v._v("v-html")]),v._v("  可以支持结构的解析渲染（文本内容可以包含 HTML 标签）；")]),v._v(" "),e("p",[v._v("（⚠️：安全性问题： 在网站上任意渲染 HTML 内容非常危险，容易导致 XSS 攻击；一定要在可信的内容上使用  "),e("code",[v._v("v-html")]),v._v(" ，永远不要使用在用户可提交的内容中）")]),v._v(" "),e("p",[e("code",[v._v("v-cloak")]),v._v(" ： 一个特殊的没有值的属性，Vue 实例创建完毕并且接管容器后会删掉  "),e("code",[v._v("v-cloak")]),v._v("  属性；所以可以使用 CSS 配合  "),e("code",[v._v("v-cloak")]),v._v("  解决网速慢网页延迟显示未经渲染的 Vue 内容问题。")]),v._v(" "),e("p",[e("code",[v._v("v-once")]),v._v(" ：一个特殊的没有值的属性，在  "),e("code",[v._v("v-once")]),v._v("  所在的节点在初次渲染之后就视为静态内容。（只会被渲染一次）之后数据的改变不会引起  "),e("code",[v._v("v-once")]),v._v("  属性所在的结构更新，"),e("strong",[v._v("可用于优化性能")]),v._v("。（区别开事件中的  "),e("code",[v._v("once")]),v._v("  特性）")]),v._v(" "),e("p",[e("code",[v._v("v-pre")]),v._v(" ：一个特殊的没有值的属性，可以让 Vue "),e("strong",[v._v("跳过")]),v._v(" "),e("code",[v._v("v-pre")]),v._v("  属性所在节点的"),e("strong",[v._v("编译")]),v._v("过程。可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快容器中内容的编译。")]),v._v(" "),e("h2",{attrs:{id:"自定义指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[v._v("#")]),v._v(" 自定义指令")]),v._v(" "),e("p",[v._v("使用  "),e("code",[v._v("new Vue({directives: {...}})")]),v._v("  配置自定义指令，")]),v._v(" "),e("p",[v._v("⚠️：原理不靠返回的值。")]),v._v(" "),e("h3",{attrs:{id:"函数式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式"}},[v._v("#")]),v._v(" 函数式")]),v._v(" "),e("p",[v._v("语法： "),e("code",[v._v("new Vue({directives: { 指令名(){ … } }})")])]),v._v(" "),e("h3",{attrs:{id:"对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[v._v("#")]),v._v(" 对象")]),v._v(" "),e("p",[v._v("语法： "),e("code",[v._v("new Vue({directives: {指令名:{配置对象...}}})")]),v._v(" ；")]),v._v(" "),e("p",[v._v("常用的三个回调函数：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("bind")]),v._v(" ：指令与元素成功绑定时调用；")]),v._v(" "),e("li",[e("code",[v._v("inserted")]),v._v(" ：指令所在元素被插入页面时调用；")]),v._v(" "),e("li",[e("code",[v._v("update")]),v._v(" ：指令所在模版结构被重新解析时调用；")])]),v._v(" "),e("p",[v._v("其他问题注意：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("指令定义时不加  "),e("code",[v._v("v-")]),v._v(" ，使用时需要加  "),e("code",[v._v("v-")])])]),v._v(" "),e("li",[e("p",[v._v("指令名称使用多个名字时要用  "),e("code",[v._v("-")]),v._v("  分隔开来（kebab-cab 命名），在  "),e("code",[v._v("directives")]),v._v("  中定义该指令时要使用字符串的形式  "),e("code",[v._v("word-word(){}")]),v._v(" ；")])]),v._v(" "),e("li",[e("p",[v._v("指令中回调函数的  "),e("code",[v._v("this")]),v._v("  问题：不论是函数式还是对象式， "),e("code",[v._v("this")]),v._v("  都会指向  "),e("code",[v._v("window")]),v._v("  对象。")])]),v._v(" "),e("li",[e("p",[v._v("全局指令使用  "),e("code",[v._v("Vue.directive('xxx', function(element, binding){})")]),v._v("  或者   "),e("code",[v._v("Vue.directive(‘xxx’, { xxx })")]),v._v("  配置。")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);