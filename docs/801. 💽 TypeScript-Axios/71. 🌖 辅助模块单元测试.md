---
title:  ğŸŒ– è¾…åŠ©æ¨¡å—å•å…ƒæµ‹è¯•
date: 2022-06-17 20:15:29
permalink: /pages/73c2b6/
categories:
  -  ğŸš¶ğŸ» å‰ç«¯å·©å›ºåŸºç¡€
  -  ğŸšŸ axios
  -  ğŸ’½ ä½¿ç”¨ TypeScript é‡æ„ axios åº“
tags:
  - 
---
## å‡†å¤‡å·¥ä½œ

é€šå¸¸ä¼šä¼˜å…ˆä¸ºä¸€ä¸ªåº“çš„è¾…åŠ©æ–¹æ³•ç¼–å†™æµ‹è¯•ã€‚

åœ¨è¿™è¾…åŠ©æ–¹æ³•ä¸º `src/helpers` ç›®å½•ä¸‹çš„æ¨¡å—ã€‚åœ¨ `test` ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ª `helpers` ç›®å½•ä¸‹ï¼Œåˆ›å»ºä¸€ä¸ª `boot.ts` ç©ºæ–‡ä»¶ã€‚ç»™ Jest é…ç½®äº† `setupFilesAfterEnv` æŒ‡å‘äº†è¿™ä¸ªæ–‡ä»¶ï¼Œä¹‹åä¼šç¼–å†™è¿™ä¸ªæ–‡ä»¶ã€‚

ç„¶åå¯ä»¥åœ¨æ§åˆ¶å°è¿è¡Œå‘½ä»¤ `npm test`ï¼Œå®é™…ä¸Šæ‰§è¡Œäº† `jest --coverage` è¿›è¡Œå•å…ƒæµ‹è¯•ã€‚æ­¤æ—¶è¿è¡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºæ²¡æœ‰åŒ¹é…çš„æµ‹è¯•æ–‡ä»¶ï¼ˆ`test` ç›®å½•ä¸‹æ²¡æœ‰ `.spec.ts` ç»“å°¾çš„æ–‡ä»¶ï¼‰ã€‚



## å„ä¸ªæ¨¡å—æµ‹è¯•ä»£ç ç¼–å†™

### `util` æ¨¡å—æµ‹è¯•

åˆ›å»ºæ–‡ä»¶ `test/helpers/util.spec.ts`ï¼š

::: details

```typescript
import {
  deepMerge,
  extend,
  isDate,
  isFormData,
  isPlainObject,
  isURLSearchParams
} from '../../src/helpers/util'

describe('helpers:util', () => {
  describe('isXX', () => {
    test('should validate Date', () => {
      expect(isDate(new Date())).toBeTruthy()
      expect(isDate(Date.now())).toBeFalsy()
    })

    test('should validate PlainObject', () => {
      expect(isPlainObject({})).toBeTruthy()
      expect(isPlainObject(new Date())).toBeFalsy()
    })

    test('should validate FormData', () => {
      expect(isFormData(new FormData())).toBeTruthy()
      expect(isFormData({})).toBeFalsy()
    })

    test('should validate URLSearchParams', () => {
      expect(isURLSearchParams(new URLSearchParams())).toBeTruthy()
      expect(isURLSearchParams('foo=2&bar=2')).toBeFalsy()
    })
  })
})

describe('extend', () => {
  test('should be mutable', () => {
    const a = Object.create(null)
    const b = { foo: 123 }

    extend(a, b)
    expect(a.foo).toBe(123)
  })

  test('should extend properties', function() {
    const a = {foo: 123, bar: 456}
    const b = { bar: 789}
    const c= extend(a, b)

    expect(c.foo).toBe(123)
    expect(c.bar).toBe(789)
  })
})

describe('deepMerge', () => {
  test('should be immutable', () => {
    const a = Object.create(null)
    const b: any = { foo: 123 }
    const c: any = { bar: 456 }

    deepMerge(a, b, c)

    expect(typeof a.foo).toBe('undefined')
    expect(typeof a.bar).toBe('undefined')
    expect(typeof b.bar).toBe('undefined')
    expect(typeof c.foo).toBe('undefined')
  })

  test('should deepMerge properties', () => {
    const a = { foo: 123 }
    const b = { bar: 456 }
    const c = { foo: 789 }
    const d = deepMerge(a, b, c)

    expect(d.foo).toBe(789)
    expect(d.bar).toBe(456)
  })

  test('should deepMerge recursively', function() {
    const a = { foo: { bar: 123 } }
    const b = { foo: { baz: 456 }, bar: { qux: 789 } }
    const c = deepMerge(a, b)

    expect(c).toEqual({
      foo: {
        bar: 123,
        baz: 456
      },
      bar: {
        qux: 789
      }
    })
  })

  test('should remove all references from nested objects', () => {
    const a = { foo: { bar: 123 } }
    const b = {}
    const c = deepMerge(a, b)

    expect(c).toEqual({
      foo: {
        bar: 123
      }
    })

    expect(c.foo).not.toBe(a.foo)
  })

  test('should handle null and undefined arguments', () => {
    expect(deepMerge(undefined, undefined)).toEqual({})
    expect(deepMerge(undefined, { foo: 123 })).toEqual({ foo: 123 })
    expect(deepMerge({ foo: 123 }, undefined)).toEqual({ foo: 123 })

    expect(deepMerge(null, null)).toEqual({})
    expect(deepMerge(null, { foo: 123 })).toEqual({ foo: 123 })
    expect(deepMerge({ foo: 123 }, null)).toEqual({ foo: 123 })
  })
})
```

:::

> å…¶ä¸­ä½¿ç”¨ `describe` æ–¹æ³•å®šä¹‰ä¸€ç»„æµ‹è¯•ï¼Œæ”¯æŒåµŒå¥—ï¼Œ`test` å‡½æ•°ç”¨æ¥å®šä¹‰å•ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ˜¯æµ‹è¯•çš„æœ€å°å•å…ƒï¼›`expect` æ˜¯æ–­è¨€å‡½æ•°ï¼Œ**åˆ¤æ–­ä»£ç çš„å®é™…ç»“æœä¸é¢„æœŸç»“æœæ˜¯å¦ä¸€è‡´**ï¼Œå¦‚æœä¸ä¸€è‡´å°±æŠ›å‡ºé”™è¯¯ã€‚
>
> æµ‹è¯•æ–‡ä»¶ç¼–å†™å¥½åå¯ä»¥å•ä¸ªæµ‹è¯•ç”¨ä¾‹è¿è¡Œï¼›ä¹Ÿå¯ä»¥è¿è¡Œå‘½ä»¤ `npm test` è¿è¡Œæµ‹è¯•ã€‚



### `cookie` æ¨¡å—æµ‹è¯•

åˆ›å»ºæ–‡ä»¶ï¼š`test/helpers/cookie.spec.ts`ï¼š

::: details

```typescript
import cookie from '../../src/helpers/cookie'

describe('helpers:cookie', () => {
  test('should read cookies', () => {
    document.cookie = 'foo=bar'
    expect(cookie.read('foo')).toBe('bar')
  })

  test('should return null if cookie name is not exist', () => {
    document.cookie = 'foo=bar'
    expect(cookie.read('bar')).toBeNull()
  })
})
```

> ä¸€èˆ¬ jest æµ‹è¯•ç¯å¢ƒé…ç½®äº† `jsdom` èƒ½æ“ä½œ DOMã€‚å¦‚æœä¸è¡Œéœ€è¦åŠ ä¸Š `--env=jsdom` çš„é…ç½®ï¼ˆå‘½ä»¤é…ç½®ä¸­ï¼‰ã€‚

::: 



### `data` æ¨¡å—æµ‹è¯•

åˆ›å»ºæ–‡ä»¶ `test/helpers/data.spec.ts`ï¼š

::: details

```typescript
import { transformRequest, transformResponse } from '../../src/helpers/data'

describe('helpers:data', () => {
  describe('transformRequest', () => {
    test('should transform request data to string if data is a PlainObject', () => {
      const a = { a: 1 }
      expect(transformRequest(a)).toBe('{"a":1}')
    })

    test('should do nothing if data is not a PlainObject', () => {
      const a = new URLSearchParams('a=b')
      expect(transformRequest(a)).toBe(a)
    })
  })

  describe('transformResponse', () => {
    test('should transform response data to Object if data is a JSON string', () => {
      const a = '{"a": 2}'
      expect(transformResponse(a)).toEqual({ a: 2 })
    })

    test('should do nothing if data is a string but not a JSON string', () => {
      const a = '{a: 2}'
      expect(transformResponse(a)).toEqual('{a: 2}')
    })

    test('should do nothing if data is not a string', () => {
      const a = {a: 2}
      expect(transformResponse(a)).toBe(a)
    })

  })
})
```

:::



### `error` æ¨¡å—æµ‹è¯•

åˆ›å»ºæ–‡ä»¶ `test/helpers/test.spec.ts`ï¼š

::: details

```typescript
import { AxiosRequestConfig, AxiosResponse } from '../../src'
import { createError } from '../../src/helpers/error'

describe('helpers:error', () => {
  test('should create an Error with message, config, code, request, response and isAxiosError', () => {
    const request = new XMLHttpRequest()
    const config: AxiosRequestConfig = { method: 'post' }
    const response: AxiosResponse = {
      status: 200,
      statusText: 'OK',
      headers: null,
      request,
      config,
      data: { foo: 'bar' }
    }
    const error = createError('Boom!', config, 'SOMETHING', request, response)
    expect(error instanceof Error).toBeTruthy()
    expect(error.message).toBe('Boom!')
    expect(error.config).toBe(config)
    expect(error.code).toBe('SOMETHING')
    expect(error.request).toBe(request)
    expect(error.response).toBe(response)
    expect(error.isAxiosError).toBeTruthy()
  })
})
```

::: 



### `headers` æ¨¡å—æµ‹è¯•

åˆ›å»ºæ–‡ä»¶ `test/helpers/headers.spec.ts`ï¼š

::: details

```typescript
import { flattenHeaders, parseHeaders, processHeaders } from '../../src/helpers/headers'

describe('helpers:header', () => {
  describe('parseHeaders', () => {
    test('should parse headers', () => {
      const parsed = parseHeaders(
        'Content-Type: application/json\r\n' +
        'Connection: keep-alive\r\n' +
        'Transfer-Encoding: chunked\r\n' +
        'Date: Tue, 21 May 2019 09:23:44 GMT\r\n' +
        ':aa\r\n' +
        'key:'
      )

      expect(parsed['content-type']).toBe('application/json')
      expect(parsed['connection']).toBe('keep-alive')
      expect(parsed['transfer-encoding']).toBe('chunked')
      expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT')
      expect(parsed['key']).toBe('')
    })

    test('should return empty object if headers is empty string', () => {
      expect(parseHeaders('')).toEqual({})
    })
  })

  describe('processHeades', () => {
    test('should normalize Content-Type header name', () => {
      const headers: any = {
        'conTenT-Type': 'foo/bar',
        'Content-length': 1024
      }

      processHeaders(headers, {})
      expect(headers['Content-Type']).toBe('foo/bar')
      expect(headers['conTenT-Type']).toBeUndefined()
      expect(headers['Content-length']).toBe(1024)
    })

    test('should set Content-Type if not set and data is PlainObject', () => {
      const headers: any = {}
      processHeaders(headers, { a: 1 })
      expect(headers['Content-Type']).toBe('application/json;charset=utf-8')
    })

    test('should set not Content-Type if not set and data is not PlainObject', () => {
      const headers: any = {}
      processHeaders(headers, new URLSearchParams('a=b'))
      expect(headers['Content-Type']).toBeUndefined()
    })

    test('should do nothing if headers is undefined or null', () => {
      expect(processHeaders(undefined, {})).toBeUndefined()
      expect(processHeaders(null, {})).toBeNull()
    })
  })

  describe('flattenHeaders', () => {
    test('should flatten the headers and include common headers', () => {
      const headers = {
        Accept: 'application/json',
        common: {
          'X-COMMON-HEADER': 'commonHeaderValue'
        },
        get: {
          'X-GET-HEADER': 'getHeaderValue'
        },
        post: {
          'X-POST-HEADER': 'postHeaderValue'
        }
      }

      expect(flattenHeaders(headers, 'get')).toEqual({
        Accept: 'application/json',
        'X-COMMON-HEADER': 'commonHeaderValue',
        'X-GET-HEADER': 'getHeaderValue'
      })
    })

    test('should flatten the headers without common headers', () => {
      const headers = {
        Accept: 'application/json',
        get: {
          'X-GET-HEADER': 'getHeaderValue'
        }
      }

      expect(flattenHeaders(headers, 'patch')).toEqual({
        Accept: 'application/json'
      })
    })

    test('should do nothing if headers is undefined or null', () => {
      expect(flattenHeaders(undefined, 'get')).toBeUndefined()
      expect(flattenHeaders(null, 'post')).toBeNull()
    })

  })
})
```

> æ­¤å¤„æµ‹è¯•å‘ç°é”™è¯¯ã€‚ æµ‹è¯•ç»„çš„ `should parse headers` æµ‹è¯•æ²¡é€šè¿‡ï¼Œ`expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT')` æˆ‘ä»¬æœŸæœ›è§£æåçš„ `date` å­—æ®µæ˜¯ `Tue, 21 May 2019 09:23:44 GMT`ï¼Œè€Œå®é™…çš„å€¼æ˜¯ `Tue, 21 May 2019 09`ã€‚
>
> è¯´æ˜ `parseHeaders` çš„ä»£ç é€»è¾‘æœ‰æ¼æ´ï¼Œåªè€ƒè™‘äº†ç¬¬ä¸€ä¸ª `:` ç¬¦å·ï¼Œæ²¡æœ‰è€ƒè™‘ååŠéƒ¨åˆ†ä¹Ÿå¯èƒ½æœ‰ `:` ç¬¦å·ï¼Œå› ä¸ºç°æœ‰é€»è¾‘ä¼šæŠŠå­—ç¬¦ä¸²ä¸­ `:` åé¢éƒ¨åˆ†éƒ½æˆªæ–­ã€‚
>
> ä¿®æ”¹åçš„ `parasedHeaders` ï¼š
>
> ```typescript
> export function parseHeaders(headers: string): any {
>   let parsed = Object.create(null)
>   if (!headers) return parsed
> 
>   headers.split('\r\n').forEach(line => {
>     let [key, ...vals] = line.split(':')
>     key = key.trim().toLowerCase()
>     if (!key) return
>     let val = vals.join(':').trim()
>     parsed[key] = val
>   })
> 
>   return parsed
> }
> ```

:::

### `url` æ¨¡å—æµ‹è¯•

åˆ›å»ºæ–‡ä»¶ `test/helpers/url.spec.ts`:

::: details

```typescript
import { buildURL, combineURL, isAbsoluteURL, isURLSameOrigin } from '../../src/helpers/url'

describe('helpers:url', () => {
  describe('buildURL', () => {
    test('should support null params', () => {
      expect(buildURL('/foo')).toBe('/foo')
    })

    test('should support params', () => {
      expect(
        buildURL('/foo', {
          foo: 'bar'
        })
      ).toBe('/foo?foo=bar')
    })

    test('should ignore if some param value is null', () => {
      expect(
        buildURL('/foo', {
          foo: 'bar',
          baz: null
        })
      ).toBe('/foo?foo=bar')
    })

    test('should ignore if the only param value is null', () => {
      expect(
        buildURL('/foo', {
          foo: null
        })
      ).toBe('/foo')
    })

    test('should support object params', () => {
      expect(
        buildURL('/foo', {
          foo: {
            bar: 'baz'
          }
        })
      ).toBe('/foo?foo=' + encodeURI('{"bar":"baz"}'))
    })

    test('should support date params', () => {
      const date = new Date()

      expect(
        buildURL('/foo', {
          date
        })
      ).toBe('/foo?date=' + date.toISOString())
    })

    test('should support array params', () => {
      expect(
        buildURL('/foo', {
          foo: ['bar', 'baz']
        })
      ).toBe('/foo?foo[]=bar&foo[]=baz')
    })

    test('should support special char params', () => {
      expect(
        buildURL('/foo', {
          foo: '@:$'
        })
      ).toBe('/foo?foo=@:$')
    })

    test('should support existing params', () => {
      expect(
        buildURL('/foo?foo=bar', {
          bar: 'baz'
        })
      ).toBe('/foo?foo=bar&bar=baz')
    })

    test('should correct discard url hash mark', () => {
      expect(
        buildURL('/foo?foo=bar#hash', {
          query: 'baz'
        })
      ).toBe('/foo?foo=bar&query=baz')
    })

    test('should use serializer if provided', () => {
      const serializer = jest.fn(() => {
        return 'bar=baz'
      })
      const params = { foo: 'bar' }
      expect(buildURL('/foo?foo=bar#hash', params, serializer)).toBe('/foo?foo=bar&bar=baz')
      expect(serializer).toHaveBeenCalled()
      expect(serializer).toHaveBeenCalledWith(params)
    })

    test('should support URLSearchParams', () => {
      expect(buildURL('/foo', new URLSearchParams('bar=baz'))).toBe('/foo?bar=baz')
    })
  })

  describe('isAbsoluteURL', () => {
    test('should return true if URL begins with valid scheme name', () => {
      expect(isAbsoluteURL('https://api.github.com/users')).toBeTruthy()
      expect(isAbsoluteURL('custom-scheme-v1.0://example.com/')).toBeTruthy()
      expect(isAbsoluteURL('HTTP://example.com/')).toBeTruthy()
    })

    test('should return false if URL begins with invalid scheme name', () => {
      expect(isAbsoluteURL('123://api.github.com/users')).toBeFalsy()
      expect(isAbsoluteURL('!valid://api.github.com/users')).toBeFalsy()
    })

    test('should return true if URL is protocol-relative', () => {
      expect(isAbsoluteURL('//example.com/')).toBeTruthy()
    })

    test('should return false if URL is relative', () => {
      expect(isAbsoluteURL('/foo')).toBeFalsy()
      expect(isAbsoluteURL('foo')).toBeFalsy()
    })
  })

  describe('combineURL', () => {
    test('should combine URL', () => {
      expect(combineURL('https://api.github.com', '/users')).toBe('https://api.github.com/users')
    })

    test('should remove duplicate slashes', () => {
      expect(combineURL('https://api.github.com/', '/users')).toBe('https://api.github.com/users')
    })

    test('should insert missing URL', () => {
      expect(combineURL('https://api.github.com', 'users')).toBe('https://api.github.com/users')
    })

    test('should not insert slash when relative url missing/empty', () => {
      expect(combineURL('https://api.github.com/users', '')).toBe('https://api.github.com/users')
    })

    test('should allow a single slash for relative url', () => {
      expect(combineURL('https://api.github.com/users', '/')).toBe('https://api.github.com/users/')
    })
  })

  describe('isURLSameOrigin', () => {
    test('should detect same origin', () => {
      expect(isURLSameOrigin(window.location.href)).toBeTruthy()
    })

    test('should detect same origin', () => {
      expect(isURLSameOrigin('https://api.github.com/users')).toBeFalsy()
    })

  })
})
```

> ä½¿ç”¨äº† [`jest.fn` ](https://jestjs.io/docs/en/jest-object#jestfnimplementation)å»æ¨¡æ‹Ÿäº†ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªä¹Ÿæ˜¯åœ¨ç¼–å†™ Jest æµ‹è¯•ä¸­éå¸¸å¸¸ç”¨çš„ä¸€ä¸ª APIã€‚

::: 

