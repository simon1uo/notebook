---
title: 🛒 Vue 商城项目小记
date: 2022-04-21 22:33:56
permalink: /pages/700099/
categories: 
  - 📚 前端笔记
  - 🏃 核心框架
  - ☔️ Vue 项目相关
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
🔗 相关链接：

+ [静态页面+静态组件+接口文档链接](https://pan.baidu.com/s/1OIVs0UNBaVTvKaxxqZP-BQ) 提取码：6666



## 创建项目相关

创建 Vue 2 webpack 版本的脚手架模版：

```
$ vue init webpack project_name
```

> 其实 Vue init 命令好像已经被 Vue 官网弃用，生成的 Vue 脚手架模版也是 Vue 2 版本的，为了学习 Vue 2 项目就先使用着吧。里面附带了适合 Vue 2 版本的 vue-router@3，并且带 eslint / babel 等工具。



## 组件划分相关

三级联动菜单（**商品分类导航**）组件在 Home、Search、Detail 中都要使用，所以可以在入口文件注册为全局组件，只引入一次即可以在多处地方使用。

```js
import TypeNav from './pages/Home/TypeNav/TypeNav'
Vue.component(TypeNav.name, TypeNav)
```



## 路由相关问题

+ **编程式路由**跳转到当前的路由（参数不变）时，**多次执行会抛出 `NavigateDuplicated` 的警告错误。**（对于声明式导航不会出现）

  vue-router 引入 Promise 后，编程式路由跳转返回的结果是一个 Promise 对象。通过给 `push` 方法传递响应的成功、失败回调函数，捕获当前的错误。

  ```js
  goSearch () {
    this.$router.push({
      name: 'search',
      params: {keyword: this.keyword},
      query: {k: this.keyword.toUpperCase()}
    }, (success) => {
      // console.log(success)
    }, (error) => {
      // console.log(error)
    })
  }
  ```

  但是这种方法治标不治本，在未来其他的编程式导航使用 `push | replace` 时也要这样的解决。从根本上解决，`push() | replace` 是 `$router` （`VueRouter` 类的实例的原型对象方法），在配置路由前时重写 `push` 方法：

  ```js
  // 先把VueRouter原型对象的push备份
  let originPush = Router.prototype.push
  // 重写push方法, 第一个参数为原来跳转传递的参数
  Router.prototype.push = function (location, resolve, reject) {
    // 判断是否传入成功和失败的回调，没有则补全
    if (resolve && reject) {
      originPush.call(this, location, resolve, reject)
    } else {
      originPush.call(this, location, () => {
      }, () => {
      })
    }
  }
  ```

  > `call | apply` 的区别：
  >
  > + 相同点：都可以调用函数一次，都可以篡改函数上下文一次。
  > + 不同点： `call` 传递参数用逗号隔开；` apply` 方法执行传递数组。

​		（对于 `replace` 方法的重写同理。）



## 请求数据接口



### axios 二次封装

+ 目的：完成对每次 axios 请求的一些预先的通用配置。配置请求拦截器、响应拦截器，在请求或响应之前完成预处理。

+ 创建 `src/api` 目录存放 axios 请求相关的配置。

```js
// 创建request是axios的实例对象
const request = axios.create({
  baseURL: '/api', // 基础路径
  timeout: 5000 // 请求超时
})

// 配置请求拦截器
// config对象获取请求的配置
request.interceptors.request.use((config) => {
  return config
})

request.interceptors.response.use((response => {
  // 响应成功回调函数
  return response.data
// eslint-disable-next-line handle-callback-err
}, (error) => {
  // 响应失败回调函数
  return Promise.reject(new Error('fale'))
}))
```



### 统一接口管理

> 小项目可以在组件内的生命周期完成发送请求的配置。大项目有多个请求可能要复用，统一管理请求发送较好。

在 `src/api` 目录下创建 `index.js` 文件，如下：

```js
// 对API接口统一管理
import request from './request'

// 三级联动（导航）接口请求 GET请求，参数无
export const reqCategoryList = () =>
  request({
    url: '/product/getBaseCategoryList',
    method: 'GET'
  })
```



## Vuex 状态管理

### 在 actions 中



### Vuex 的模块式开发

[Vue 的模块化编码笔记]() ,  🔗 [Modules | Vuex (vuejs.org)](https://vuex.vuejs.org/guide/modules.html)

⚠️ 一定要配置为 `modules` 项引入分组件的 `store` ，否则无效。

```js
export default new Vuex.Store({
   modules:{
       home,
       search,
       detail,
       shopcart,
       user
   }
});
```



### 在组件中读取 `store` 数据的一个坑

在三级联动（导航菜单中），完成请求数据、读取数据如下：

```js
mounted () {
  // 通知Vuex发送请求获取数据存储在仓库中
  this.$store.dispatch('categoryList')
},
computed: {
  ...mapState({
    categoryList: (state) => {
      return state.home.categoryList
    }
  })
}
```

在一开始没想到模块化 Vuex 直接顺手就写了：
```js
...mapState(['categoryList'])
```

但是死活读取不到，忘了这是 `home` 模块下的 `state` ，所以要写成：

```js
...mapState('home', ['categoryList'])
```

但是这样写还不够，一开始在 `home` 的 `store` 模块中是没有开启 `namespaced` （注意有 `d` ，这个又纠缠了好久）命名空间的配置。

```js
export default {
  namespaced: true,
  state,
  mutations,
  actions,
  getters
}
```

开启了命名空间后，前面的挂载时调用的 `this.$store.dispatch` 却找不到 `actions` 了，这时要写成：

```js
this.$store.dispatch('home/categoryList')
```

> **所以说折腾了这么久，数组写法还不如一开始的写法来的方便快捷。**





## 功能实现相关



### 三级联动分类菜单的节流

> 在写 `TypeNav` 三级联动分类菜单时发现的现象：
>
> + 正常情况（用户慢慢的操作）：鼠标进入，每一个一级分类 `h3`，都会触发鼠标进入事件；
> + 非正常情况（用户操作很快）：本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，**只有部分 `h3` 触发了**。
>   **就是由于用户行为过快，导致浏览器反应不过来。如果当前回调函数中有一些大量业务，有可能出现卡顿现象。**

🔗 [函数的防抖与节流]()

在 `changeIndex` 方法处实现节流：

```js
changeIndex: throttle(function (index) {
  this.currentIndex = index
}),
```

> 注意：`throttle` 不要使用箭头函数，否则上下文 `this` 指向不明。



### 三级联动分类菜单的路由跳转与传递参数

实现功能：三级联动分类菜单中，用户可以点击一级分类、二级分类、三级分类的标题链接，当点击的时候 Home 跳转到 Search ，一级会把用户选中的产品（产品的名字、产品的ID）在路由跳转的时候，进行传递。

+ 如果使用声明式导航 `router-link` ，可以实现，但是会出现卡顿。因为 `router-link` 是一个组件，当服务器数据返回之后会产生 n 个 `router-link` 组件，完成组件的渲染比较消耗内存。

+ 给所有的标题的链接绑定点击事件也并非是好的方法，此时相当于给循环出来的链接绑定了 n 个事件。

+ 最好的方法：**利用编程式导航结合事件委派**，要解决一下问题：

  + 事件委派把全部的子节点的事件委派给父亲节点，点击a标签的时候，才会进行路由跳转【怎么能确定点击的一定是a标签】：

    + 把子节点当中a标签，加上自定义属性 `data-categoryName` ，其余的子节点是没有的。**所以使用判断筛选出带有自定义属性的节点即可**。（节点有一个 `dataset` 属性获取到节点的自定义属性与属性值，**获取到的属性名称的驼峰命名会被转换为全部小写**）

      ```html
      <a :data-categoryName="c1.categoryName">{{ c1.categoryName }}</a>
      ```

      ```js
      goSearch (event) {
        let element = event.target
        let {categoryname} = element.dataset
        if (categoryname) {
          ...
        }
      }
      ```

      

  + 存在另外一个问题：即使你能确定点击的是a标签，如何区分是一级、二级、三级分类的标签。

    + 添加另外一个接收 id 的自定义属性 `category1Id`，（因为不同的级别 id 不同）：

      ```html
      :data-category1Id="c1.categoryId"
      ```

      …

      ```js
      let {categoryname, category1id, category2id, category3id} = element.dataset
      if (categoryname) {
        if (category1id) {
      
        } else if (category2id) {
      
        } else if (category3id) {
      
        }
      }
      ```

+ 最后结合路由跳转的配置、要跳转携带的参数进行整理：

```js
if (categoryname) {
  let location = {name: 'search'}
  let query = {categoryName: categoryname}
  if (category1id) {
    query.category1Id = category1id
  } else if (category2id) {
    query.category2Id = category2id
  } else if (category3id) {
    query.category3Id = category3id
  }
  // 结合跳转配置
  location.query = query
  // 路由跳转
  this.$router.push(location)
}
```



### 实现三级联动分类菜单在不同的组件中不同的现实效果

要在首页 Home 组件中显示完整的分类，在 Search 组件中只显示分类的标题「全部商品分类」，鼠标放置于「全部商品分类」时，才展示所有的分类信息并带有过渡动画。

+ 在 NavType 组件中添加一个能控制信息是否显示的数据 `isShow`。 

+ 已知每切换一次组件，NavType 组件都会重新挂载，所以在挂载钩子处入手，判断当前处在哪个组件中（从路由入手）。在要操作 `isShow` 之前进行判断即可：

  ```js
  if (this.$route.path !== '/home')
  ```

+ 实现显示过渡动画：前提组件｜元素必须要有 `v-if` / `v-show` 才可以实现过渡动画。

  使用 `<transition>` 标签包裹后，在 CSS 设定样式即可。 



### 优化发送多次请求

将共同组件中，要把发送请求的部分转移到所有组件的父组件 `App` 的生命周期挂载钩子 `mounted` 上，这样在每次运行时，只会在共同的父组件中发送一次请求并把数据保存到 `store` 中。



### 商品分类与搜索栏参数的合并

在实现了三级联动分类导航给 Search 组件页面传递参数以后，与 Header 组件搜索栏给 Search 组件页面传递参数产生冲突：两者传递的参数不能同时存在，只要一者重新传递参数，上一次传递的参数会被覆盖。

解决：在三级联动分类导航中路由跳转之前，判断路由中是否存在参数，存在则一同合并后才进行路由跳转。（在搜索框处同理）

```js
if (this.$route.params) {
  // 结合跳转配置
  location.params = this.$route.params
  location.query = query
  // console.log(location)
  // 路由跳转
  this.$router.push(location)
}
```



### 使用 mock 模拟数据

**mock 用来拦截前端的 AJAX**，返回使用 JSON 文件自定义的数据方便测试前端请求的接口。

+ 安装 mockjs 依赖： `$ npm i mockjs -S` 

+ 创建目录 `src/mock` ，创建文件 `mockServe` （命名随意，在 `main.js` 引入 `import './mock/mockServe'`）：

  ```js
  // 引入mockServe
  import Mock from 'mockjs'
  // 引入json数据
  // weboack默认对外暴露：JSON、图片
  import banner from './banner.json'
  import floor from './floor.json'
  
  Mock.mock('/mock/banner', {code: 200, data: banner})
  Mock.mock('/mock/floor', {code: 200, data: floor})
  ```

  使用 `Mock.mock` ，第一个参数为请求地址，第二个参数为请求数据。

### 首页轮播图

使用 [swiper](https://www.swiper.com.cn) 实现轮播图，（安装 `$ npm i swiper -S` ）。一般步骤：

+ 在需要使用轮播图的组件内引入 swpier 和它的css样式；
+ 在组件中创建swiper需要的 DOM 框架。
+ 创建 swiper 实例。

创建 swiper 对象时，回传第一个参数用于获取展示轮播图的 DOM 元素。官方文档中通过 `class` 名称获取（一般固定通用）。但是如果页面中有多个 `swiper` 对象，可以借助 `ref` 属性，例如：`<div class="swiper-container" id=ref="swiper1">` ， 通过 `ref` 属性值获取 DOM 元素：`new Swiper(this.$refs.swiper1)`。



另一个使用 swiper 要注意的问题：**创建 swiper 对象的时机**。

+ 首先想到的是，在组件的生命周期挂载钩子 `mounted` 上创建，因为组件一挂载就需要实现 swiper。但是要知道，轮播中的数据也是 `mounted` 请求获取的，请求数据是异步的，浏览器不会等待请求执行后再创建 swiper 对象。
+ 因为涉及到轮播图的数据变化，所以可以使用监听数据的钩子 `watch` ，使用 `watch` 监听 `bannerList` 数据，因为 `bannerList` 初始值为空，数据更新后再创建 swiper 对象。
+ 但是即便使用了 `watch` 还不够，在展示数据中使用了 `v-for` 循环，`watch` 只能监测 `bannerList` 数据获取到（变化）时，并不会监测到 `v-for` 执行完。所以在 `v-for` 循环之前创建 swiper 对象也是无效的。
+ **最终的解决方案：使用 `watch` + `this.$nextTick()`**：`nextTick` 可以将回调延迟到下次 DOM 更新循环之后再执行。所以 swiper 创建的回调函数就可以等到 `v-for` 循环完之后更新 DOM 才执行。

```js 
watch: {
  bannerList () {
    this.$nextTick(() => {
      // eslint-disable-next-line no-new
      new Swiper('.swiper-container', {
        loop: true,
        pagination: {
          el: '.swiper-pagination',
          clickable: true
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev'
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar'
        }
      })
    })
```

> 在学习 `watch` 监听数据属性时，一般监听的是 `data`  中的属性。而通过这个例子，`watch` 也可以监听 `computed` 的属性。**上述例子可以拓展为业务中通过 `computed` 从 `store` 中动态获取到数据后，在通过 `watch` 监听数据的变化执行相关的回调函数。**



### Vue 路由滚动行为

https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html

> 使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。



### 购物车功能

之前实现跳转至其他功能使用路由跳转，但是需要注意这里，点击添加购物车按钮的时候，需要发请求的： 

+ 需要通知服务器，你买了什么、买了多少个，**如果服务器存储数据成功【购物车】**，然后在进行路由跳转。
+ 跳转到购物车添加成功的页面。

在商品详情页面组件内部：点击事件的回调当中要先判断如何能知道这个加入购车是成功还是失败：

+ 如果成功，进行路由跳转，如果失败，弹出加入购物车失败
+ 当用户点击加入购物车按钮的时候，事件的回调会执行，立马派发一个action--->addShopCart
+ 起始你派发的这个action,调用仓库中Vuex，名字叫做addShopCart这个函数
+ 由于addShopCart函数，前面加上了async关键字一定返回的是promise



当想要实现两个毫无关系的组件传递数据时，首相想到的就是路由的 query 传递参数，但是 query 适合传递单个数值的简单参数，**所以如果想要传递对象之类的复杂信息**，就可以通过Web Storage实现。

sessionStorage、localStorage概念：

+ sessionStorage：为每一个给定的源维持一个独立的存储区域，该区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。
+ localStorage：同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。
+ 注意：**无论是session还是local存储的值都是字符串形式。如果我们想要存储对象，需要在存储前 `JSON.stringify()` 将对象转为字符串，在取数据后通过 `JSON.parse()` 将字符串转为对象。**



refering :https://blog.csdn.net/weixin_43424325/article/details/121684101

登录、注册以及更多功能大同小异。因为接口频繁崩坏，先完成到这里了。
