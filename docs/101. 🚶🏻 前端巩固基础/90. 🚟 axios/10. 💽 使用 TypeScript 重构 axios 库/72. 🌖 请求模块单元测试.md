---
title:  ğŸŒ– è¯·æ±‚æ¨¡å—å•å…ƒæµ‹è¯•
date: 2022-06-17 23:57:36
permalink: /pages/169950/
categories:
  -  ğŸš¶ğŸ» å‰ç«¯å·©å›ºåŸºç¡€
  -  ğŸšŸ axios
  -  ğŸ’½ ä½¿ç”¨ TypeScript é‡æ„ axios åº“
tags:
  - 
---
ä¸ºäº†æµ‹è¯•è¯·æ±‚æ¨¡å—ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘ï¼Œéœ€è¦ç”¨åˆ°å·¥å…· `jasmine`ã€‚

> jasmine-ajaxï¼š
>
> + [Jasmine (opens new window)](https://jasmine.github.io/pages/getting_started.html)æ˜¯ä¸€ä¸ª BDD(è¡Œä¸ºé©±åŠ¨å¼€å‘)çš„æµ‹è¯•æ¡†æ¶ï¼Œå®ƒæœ‰å¾ˆå¤šæˆç†Ÿçš„æ’ä»¶ï¼Œæ¯”å¦‚æˆ‘ä»¬è¦ç”¨åˆ°çš„ [`jasmine-ajax` ](https://github.com/jasmine/jasmine-ajax)ï¼Œå®ƒä¼šä¸ºæˆ‘ä»¬å‘å‡ºçš„ Ajax è¯·æ±‚æ ¹æ®è§„èŒƒå®šä¹‰ä¸€ç»„å‡çš„å“åº”ï¼Œå¹¶è·Ÿè¸ªæˆ‘ä»¬å‘å‡ºçš„Ajaxè¯·æ±‚ï¼Œå¯ä»¥è®©æˆ‘ä»¬æ–¹ä¾¿çš„ä¸ºç»“æœåšæ–­è¨€ã€‚
> + `jasmine-ajax` ä¾èµ– `jasmine-core`ï¼Œå› æ­¤é¦–å…ˆæˆ‘ä»¬è¦å®‰è£…å‡ ä¸ªä¾èµ–åŒ…ï¼Œ`jasmine-ajax`ã€`jasmine-core` å’Œ `@types/jasmine-ajax`ã€‚

è¦ä½¿ç”¨ `jasmine-ajax` æ’ä»¶èƒ½å…¨å±€è¿è¡Œï¼Œéœ€è¦æ‰‹åŠ¨å°é‚£é›†å…¨å±€çš„æ–¹æ³•ï¼ˆå‚è€ƒ [ReferenceError: getJasmineRequireObj is not defined Â· Issue #178 Â· jasmine/jasmine-ajax (github.com)](https://github.com/jasmine/jasmine-ajax/issues/178)ï¼‰ï¼š

`test/boot.ts`ï¼š

```typescript
const JasmineCore = require('jasmine-core')
// @ts-ignore
global.getJasmineRequireObj = function() {
  return JasmineCore
}

require('jasmine')
```



## æµ‹è¯•ä»£ç ç¼–å†™

åˆ›å»ºæ–‡ä»¶ `test/helper.ts` ï¼Œ  `getAjaxRequest`ï¼š

```typescript
require('jasmine-ajax')

export function getAjaxRequest(): Promise<JasmineAjaxRequest> {
  return new Promise(function(resolve) {
    setTimeout(() => {
      return resolve(jasmine.Ajax.requests.mostRecent())
    }, 0)
  })
}

```

> ä¸€ä¸ªè¾…åŠ©æ–¹æ³•ï¼Œé€šè¿‡ `jasmine.Ajax.requests.mostRecent()` æ‹¿åˆ°æœ€è¿‘ä¸€æ¬¡è¯·æ±‚çš„ `request` å¯¹è±¡ï¼Œè¿™ä¸ª `request` å¯¹è±¡æ˜¯ `jasmine-ajax` åº“ä¼ªé€ çš„ `xhr` å¯¹è±¡ï¼Œå®ƒæ¨¡æ‹Ÿäº† `xhr` å¯¹è±¡ä¸Šçš„æ–¹æ³•ï¼Œå¹¶ä¸”æä¾›ä¸€äº› `api` è®©æˆ‘ä»¬ä½¿ç”¨ï¼Œæ¯”å¦‚ `request.respondWith` æ–¹æ³•è¿”å›ä¸€ä¸ªå“åº”ã€‚
>
> > ğŸ¤¯ è¸©å‘é¢„è­¦ï¼šå‰å‰ååè°ƒè¯• `jest` çš„é…ç½® `setupFilesAfterEnv` ï¼›æœ€åæŠŠè¿™ä¸ªå­—æ®µæ¢æˆäº† `setUpFiles` ï¼Œä»ç„¶è®¾ç½®ä¸º `<rootDir>/test/boot.ts`ã€‚ä¹Ÿä¸çŸ¥é“è¿™ä¸ªé…ç½®æ˜¯ä¸æ˜¯è¢«å¼ƒç”¨äº†ï¼Œåæ­£å°±è«åçš„æ¢å®Œä¹‹åå°±èƒ½æˆåŠŸä½¿ç”¨ `jasmine` äº†ã€‚



åˆ›å»ºæ–‡ä»¶ `test/requests.spec.ts`ï¼š

```typescript
import axios, { AxiosResponse, AxiosError } from '../src/index'
import { getAjaxRequest } from './helper'

describe('requests', () => {
  beforeEach(() => {
    jasmine.Ajax.install()
  })

  afterEach(() => {
    jasmine.Ajax.uninstall()
  })

  test('should treat single string arg as url', () => {
    axios('/foo')

    return getAjaxRequest().then(request => {
      expect(request.url).toBe('/foo')
      expect(request.method).toBe('GET')
    })
  })

  test('should treat method value as lowercase string', done => {
    axios({
      url: '/foo',
      method: 'POST'
    }).then(response => {
      expect(response.config.method).toBe('post')
      done()
    })

    getAjaxRequest().then(request => {
      request.respondWith({
        status: 200
      })
    })
  })

  test('should reject on network errors', done => {
    const resolveSpy = jest.fn((res: AxiosResponse) => {
      return res
    })

    const rejectSpy = jest.fn((e: AxiosError) => {
      return e
    })

    jasmine.Ajax.uninstall()

    axios('/foo')
      .then(resolveSpy)
      .catch(rejectSpy)
      .then(next)

    function next(reason: AxiosResponse | AxiosError) {
      expect(resolveSpy).not.toHaveBeenCalled()
      expect(rejectSpy).toHaveBeenCalled()
      expect(reason instanceof Error).toBeTruthy()
      expect((reason as AxiosError).message).toBe('Network Error')
      expect(reason.request).toEqual(expect.any(XMLHttpRequest))

      jasmine.Ajax.install()

      done()
    }
  })

  test('should reject when request timeout', done => {
    let err: AxiosError

    axios('/foo', {
      timeout: 2000,
      method: 'post'
    }).catch(error => {
      err = error
    })

    getAjaxRequest().then(request => {
      // @ts-ignore
      request.eventBus.trigger('timeout')

      setTimeout(() => {
        expect(err instanceof Error).toBeTruthy()
        expect(err.message).toBe('Timeout of 2000 ms exceeded')
        done()
      }, 100)
    })
  })

  test('should reject when validateStatus returns false', done => {
    const resolveSpy = jest.fn((res: AxiosResponse) => {
      return res
    })

    const rejectSpy = jest.fn((e: AxiosError) => {
      return e
    })

    axios('/foo', {
      validateStatus(status) {
        return status !== 500
      }
    })
      .then(resolveSpy)
      .catch(rejectSpy)
      .then(next)

    getAjaxRequest().then(request => {
      request.respondWith({
        status: 500
      })
    })

    function next(reason: AxiosError | AxiosResponse) {
      expect(resolveSpy).not.toHaveBeenCalled()
      expect(rejectSpy).toHaveBeenCalled()
      expect(reason instanceof Error).toBeTruthy()
      expect((reason as AxiosError).message).toBe('Request failed with status code 500')
      expect((reason as AxiosError).response!.status).toBe(500)

      done()
    }
  })

  test('should resolve when validateStatus returns true', done => {
    const resolveSpy = jest.fn((res: AxiosResponse) => {
      return res
    })

    const rejectSpy = jest.fn((e: AxiosError) => {
      return e
    })

    axios('/foo', {
      validateStatus(status) {
        return status === 500
      }
    })
      .then(resolveSpy)
      .catch(rejectSpy)
      .then(next)

    getAjaxRequest().then(request => {
      request.respondWith({
        status: 500
      })
    })

    function next(res: AxiosResponse | AxiosError) {
      expect(resolveSpy).toHaveBeenCalled()
      expect(rejectSpy).not.toHaveBeenCalled()
      expect(res.config.url).toBe('/foo')

      done()
    }
  })

  test('should return JSON when resolved', done => {
    let response: AxiosResponse

    axios('/api/account/signup', {
      auth: {
        username: '',
        password: ''
      },
      method: 'post',
      headers: {
        Accept: 'application/json'
      }
    }).then(res => {
      response = res
    })

    getAjaxRequest().then(request => {
      request.respondWith({
        status: 200,
        statusText: 'OK',
        responseText: '{"a": 1}'
      })

      setTimeout(() => {
        expect(response.data).toEqual({ a: 1 })
        done()
      }, 100)
    })
  })

  test('should return JSON when rejecting', done => {
    let response: AxiosResponse

    axios('/api/account/signup', {
      auth: {
        username: '',
        password: ''
      },
      method: 'post',
      headers: {
        Accept: 'application/json'
      }
    }).catch(error => {
      response = error.response
    })

    getAjaxRequest().then(request => {
      request.respondWith({
        status: 400,
        statusText: 'Bad Request',
        responseText: '{"error": "BAD USERNAME", "code": 1}'
      })

      setTimeout(() => {
        expect(typeof response.data).toBe('object')
        expect(response.data.error).toBe('BAD USERNAME')
        expect(response.data.code).toBe(1)
        done()
      }, 100)
    })
  })

  test('should supply correct response', done => {
    let response: AxiosResponse

    axios.post('/foo').then(res => {
      response = res
    })

    getAjaxRequest().then(request => {
      request.respondWith({
        status: 200,
        statusText: 'OK',
        responseText: '{"foo": "bar"}',
        responseHeaders: {
          'Content-Type': 'application/json'
        }
      })

      setTimeout(() => {
        expect(response.data.foo).toBe('bar')
        expect(response.status).toBe(200)
        expect(response.statusText).toBe('OK')
        expect(response.headers['content-type']).toBe('application/json')
        done()
      }, 100)
    })
  })

  test('should allow overriding Content-Type header case-insensitive', () => {
    let response: AxiosResponse

    axios
      .post(
        '/foo',
        { prop: 'value' },
        {
          headers: {
            'content-type': 'application/json'
          }
        }
      )
      .then(res => {
        response = res
      })

    return getAjaxRequest().then(request => {
      expect(request.requestHeaders['Content-Type']).toBe('application/json')
    })
  })
})

```



æµ‹è¯•ç›¸å…³çš„é…ç½®ï¼š

+ `beforeEach()` & `afterEach()` ï¼šè¡¨ç¤ºæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å‰åè¿è¡Œçš„ç‹—å­å‡½æ•°ã€‚
+ å¼‚æ­¥æµ‹è¯•ã€‚åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œå‡ ä¹éƒ½æ˜¯ç”¨çš„æ˜¯å¼‚æ­¥çš„æµ‹è¯•ä»£ç ã€‚é€šå¸¸ Jest æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼š
  + ç¬¬ä¸€ç§æ˜¯åˆ©ç”¨ `done` å‚æ•°ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å‡½æ•°æœ‰ä¸€ä¸ª `done` å‚æ•°ï¼Œä¸€æ—¦ä½¿ç”¨è¿™ä¸ªå‚æ•°ï¼Œåªæœ‰å½“ `done` å‡½æ•°æ‰§è¡Œçš„æ—¶å€™è¡¨ç¤ºè¿™ä¸ªæµ‹è¯•ç”¨ä¾‹ç»“æŸã€‚
  + ç¬¬äºŒç§æ˜¯æµ‹è¯•å‡½æ•°è¿”å›ä¸€ä¸ª Promise å¯¹è±¡ï¼Œä¸€æ—¦è¿™ä¸ª Promise å¯¹è±¡ `resolve` äº†ï¼Œè¡¨ç¤ºè¿™ä¸ªæµ‹è¯•ç»“æŸã€‚

+ `expect.any(constructor)`ï¼š`constructor` æ˜¯è¦åŒ¹é…çš„å¯¹è±¡å®ä¾‹çš„æ„é€ å™¨ã€‚
+ `request.eventBus.trigger`ï¼šç”±äº `request.responseTimeout` æ–¹æ³•å†…éƒ¨ä¾èµ–äº† `jasmine.clock` æ–¹æ³•ä¼šå¯¼è‡´è¿è¡Œå¤±è´¥ã€‚è¿™é‡Œç›´æ¥ä½¿ç”¨ `request.eventBus.trigger('timeout')` æ–¹æ³•è§¦å‘ `timeout` äº‹ä»¶ã€‚è¿™ä¸ªæ–¹æ³•ä¸åœ¨æ¥å£ä¸­å®šä¹‰ï¼Œæ‰€ä»¥éœ€è¦å¿½ç•¥è¯­æ³•è­¦å‘Š `// @ts-ignore` ã€‚

æµ‹è¯•ä¸­å‘ç°çš„é—®é¢˜ï¼š

+ `should treat method value as lowercase string` æ–­è¨€æœ‰è¯¯ï¼šæµ‹è¯•ç”¨ä¾‹ä¸­ï¼Œå‘é€è¯·æ±‚çš„ `method` éœ€è¦è½¬æ¢æˆå°å†™å­—ç¬¦ä¸²ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†ä¹‹åçš„ `flattenHeaders` èƒ½æ­£å¸¸å¤„ç† `method`ï¼Œæ‰€ä»¥éœ€è¦å¢åŠ ä¸€ä¸ªæ·»åŠ è½¬æ¢ä¸ºå°å†™å­—ç¬¦ä¸²çš„é€»è¾‘ï¼š

  ï¼ˆ`src/core/Axios.ts`ï¼‰ï¼š

  ```typescript
  request(url: any, config?: any): AxiosPromise {
    if (typeof url === 'string') {
      if (!config) {
        config = {}
      }
      config.url = url
    } else {
      config = url
    }
  
    config = mergeConfig(this.defaults, config)
    config.method = config.method.toLowerCase()
  
    // ...
  }
  ```

  > åˆå¹¶é…ç½®åï¼Œå°† `config.method` è½¬æ¢ä¸ºå°å†™ã€‚

+ `should return JSON when rejecting` æ–­è¨€æœ‰è¯¯ï¼šè¿™ä¸ªæµ‹è¯•ç”¨ä¾‹æ˜¯è¦æµ‹è¯•å‘é€è¯·æ±‚å¤±è´¥ä¹‹åï¼Œä¹Ÿèƒ½æŠŠç›¸åº”æ•°æ®è½¬æ¢ä¸º JSON æ ¼å¼ã€‚è€ŒåŸæ¥çš„ä»£ç å¹¶æ²¡æœ‰è¿™ä¸ªæ“ä½œï¼Œæ‰€ä»¥éœ€è¦ä¿®æ”¹æºç ã€‚

  ```typescript
  export default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {
    throwIfCancellationRequested(config)
    processConfig(config)
    return xhr(config).then(
      res => {
        return transformResponseData(res)
      },
      e => {
        if (e && e.response) {
          e.response = transformResponseData(e.response)
        }
        return Promise.reject(e)
      }
    )
  }
  ```

  > é™¤äº†æ­£å¸¸æƒ…å†µçš„å“åº”æ•°æ®éœ€è¦ä½œè½¬æ¢ï¼Œé”™è¯¯æƒ…å†µçš„ç›¸åº”æ•°æ®ä¹Ÿéœ€è¦ä½œè½¬æ¢ã€‚

