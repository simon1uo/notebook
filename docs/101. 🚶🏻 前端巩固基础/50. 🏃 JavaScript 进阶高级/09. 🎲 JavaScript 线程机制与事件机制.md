
> 🔗 **相关概念**：
>
> **进程**（Process）：程序的一次执行过程，它占有一片**独有的内存空间**。
>
> **线程**（thread）：是进程内的一个独立执行单元，是程序执行的一个完整流程，是 CPU 的最小调度单位。
>
> ![image-20220326144058172](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/Mx1bBE.png)
>
> + 应用程序必须运行在某个进程的线程上。
> + 一个进程中至少有一个运行的线程：**主线程**（进程启动后会自动创建）。
> + 一个进程中也可以通行运行多个线程，即程序是多线程运行的。
> + 一个进程内的数据可以供其中的多个线程直接共享，**多个进程之间的数据是不能直接共享的**。
>
> **线程池**（Thread Pool）：**保存多个线程对象的容器**，实现对象的**反复利用**。

***

> 相关问题：
>
> + **多进程运行**：一个应用程序可以启动多个实例运行。
> + **多线程**：在一个进程内，**同时有多个线程运行**。
>
> ***
>
> 比较单线程与多线程：
>
> + 单线程：优点：顺序编程简单易懂。缺点：效率低。
> + 多线程：优点：能够有效提高 CPU 利用率；缺点：创建多线程的开销，线程间切换的开销，死锁与状态同步的问题。
>
> ***
>
> + JavaSript 是单线程运行的脚本。但是在使用 HTML5 中的 Web Workers 可以多线程运行。
>
> + 浏览器运行是都是多线程运行的。
> + 浏览器运行有的是单进程有的是**多进程**。

***

> **浏览器内核**：
>
> + 是支持浏览器运行的最核心的程序。
>
> + 不同的浏览器可能不一样。
>
>   + Chrome / Safari： Webkit 
>   + Firefox：Gecko
>   + IE ：Trident
>
> + 内核由很多模块组成：
>
>   （**主线程**）
>
>   + JS 引擎模块：负责 JavaScript 程序的编译和运行
>   + HTML / CSS 文档解析模块：负责页面文本的解析
>   + DOM / CSS 模块：负责 DOM / CSS 在内存中的相关处理
>   + 布局和渲染模块：负责页面的布局和效果的绘制（参照**内存中的对象**）
>
>   （**分线程**）
>
>   + 定时器模块：负责定时器的管理
>   + DOM 事件响应模块：负责事件的管理
>   + 网络请求模块：负责 AJAX 等的请求 



### 根据定时器引发的思考

🌰 例子： 

::: demo [vanilla]

```html
<html>
  <button id="btn">
    启动定时器
  </button>
</html>
<script>
document.getElementById("btn").onclick = function () {
  var start = Date.now();
  console.log("启动定时器前");
  setTimeout(function () {
    console.log("定时器执行了", Date.now() - start);
  });
  console.log("启动定时器后果");
};
</script>
```

:::

+ 定时器真的是定时执行吗：定时器并不能保证真正定时执行，一般会存在可以接受的延迟，但也有可能受代码量的影响带来不能接受的很长的延迟时间。
+ 定时器回调函数是在分线程执行的吗：在主线程执行的，JavaScript 是单线程的。
+ 定时器是如何实现的（事件循环模型）







## JavaScript 线程

+ 如何证明 JavaScript 是单线程的：
  + `setTimeout()` 的回调函数是在**主线程**执行的。
  + 定时器回调数只**有运行栈中的代码全部运行完**才有可能执行。
+ 为什么 JavaScript **要用单线程模式**，而不用多线程模式：
  + JavaScript 的单线程**与它的用途有关：**作为浏览器的脚本语言，JavaScript 的主要用途是与用户互动以及操作 DOM，这决定了它只能是单线程，**否则会带来很复杂的同步问题**。



***

> JavaScript 的代码分类：
>
> + 初始化代码
> + 回调代码

+ JavaScript 引擎**执行代码**的基本流程：
  1. 先执行初始化代码，包含一些特别的代码。
     + 设置定时器（回调函数异步执行）。
     + 绑定监听。
     + 发送 AJAX 请求。
  2. 后面在某个时刻才会执行**回调代码**。



🌰 例子：代码的执行顺序

```js
setTimeout(function () {
  console.log("timeout 2");
}, 2000);

setTimeout(function () {
  console.log("timeout 1");
}, 1000);

setTimeout(function (){
  console.log("timeout 0")
}, 0)  

function fn() {
  console.log("fn()");
}

fn()

console.log("alert()之前")

// alert('----') 
// 暂停当前主线程的执行，同时暂停计时，点击确定后才会恢复程序的执行和计时器
  
console.log('alert()之前')
```





## 事件机制



### 事件循环模型

（浏览器的事件轮询模型）

![image-20220327172339152](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/kI2iyq.png)

 

