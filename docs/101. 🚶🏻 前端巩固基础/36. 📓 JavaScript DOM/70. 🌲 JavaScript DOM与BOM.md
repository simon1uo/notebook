---
title: 🌲 JavaScript DOM与BOM
date: 2022-03-10 11:14:26
permalink: /pages/a2f3da/
categories: 
  - ☕️ 前端
  - 🚶 基础部分
  - 👣 JavaScript
  - 🚶‍♀️ JavaScript 基础
tags: 
  - JavaScript
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## DOM

DOM：文档对象模型（Document Object Model），通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。



### HTML DOM 树

通过这些 DOM 接口可以改变网页的**内容、结构和样式**。

+   文档：一个页面就是一个文档，DOM 中使用`document` 表示

+   元素：页面中的所有标签都是元素，DOM 中使用`element` 表示

+   节点：网页中的所有内容都是**节点（标签、属性、文本、注释等）**，`DOM` 中使用`node `表示；

    DOM 把以上内容都看做对象

当网页被加载时，浏览器会创建页面的 **DOM**。HTML DOM 会被构造为对象的树：



### DOM 获取元素

可以通过以下方式：

+   根据 `id` 获取

    ```javascript
    document.getElementById('id'); // 可以获取带有ID 的元素对象
    
    console.dir(); // 打印获取的元素对象，更好的查看对象里面的属性和方法
    ```

+   根据标签名获取：

    ```javascript
    document.getElementsByTagName('标签名');
    // 返回带有指定标签名的对象的集合
    ```

    +   注意 **返回的是一个对象的集合**(以伪数组储存)，想要操作当中的元素就需要遍历`tagname[0]等`；
    +   得到的元素对象**是动态的**；内容发生变化则会变化；

+   通过 `HTML5` 新增的方法：

    **根据元素的 `class` 属性值查询一组元素节点对象**：

    ```javascript
    // 根据类名返回元素对象集合
    document.getElementsByClassName('类名')；
    ```

    +   `getElement...` 返回的是**元素对象**，包括属性和方法；
    +   括号中的参数**大小写敏感**；

    **根据 CSS 选择器去页面中查询一个元素**/一组元素：如果匹配到的元素有多个，则它会返回查询到的第一个元素。

    ```javascript
    // 根据指定的选择器返回第一个 【元素对象】
    document.querySelector('选择器');        
    ```

    ```javascript
    // 根据指定的选择器返回所有元素对象集合
    document.querySelectorAll('选择器');
    ```

    `querySelector`和`querySelectorAll`里面的选择器**需要加符号 `.` 和 `#` **,比如:`document.querySelector('#nav');`

+   获取特殊的元素 `<body>` / `<HTML>`

    ```javascript
    // 返回 body 元素对象
    doucumnet.body
    ```

    ```javascript
    // 获取 HTML 根元素
    document.documentElement
    ```

    ```js
    // 获取页面中的所有元素
    document.all 
    ```

    

### 操作元素

+   `DOM`的操作元素可以改变网页内容、结构和样式；
+   利用`DOM`可以改变元素的内容、属性；



**HTML 元素的读取**：

```js
// 元素.属性名
ele.name
ele.id
ele.value
ele.className // 读取class元素使用 元素.className
```



#### 改变 HTML 内容

1. 改变 HTML 输出流：`document.write()` 可用于直接向 HTML 输出流写内容

   ```html
   <!DOCTYPE html>
   <html>
   <body>
   
   <script>
   document.write(Date());
   </script>
   
   </body>
   </html>
   ```

   `document.write()` 不能在文档（DOM）加载之后使用，否则会覆盖文档。

2. 改变 HTML 内容，使用 `innerHTML`属性：获取 `id` 的元素，替换原来 `id` 元素的内容；(使用该属性可以获取或设置元素内部的 HTML 代码)

3. ```js
   document.getElementById("id").innerHTML="新文本";
   ```

4. 改变 HTML 属性，使用 `attribute` 属性修改：

   ```html
   <!DOCTYPE html>
   <html>
   <body>
   
   <img id="image" src="smiley.gif">
   
   <script>
   document.getElementById("image").src="landscape.jpg";
   </script>
   
   </body>
   </html>
   ```

   

#### **改变元素内容**

+   从起始位置到终止位置的内容；（去除`HTML`标签，同时空格和换行也会去掉）

    ```javascript
    element.innerText
    ```

+   起始位置到终止位置的全部内容，(包括`HTML`标签，同时保留空格和换行)；

    +   可以修改包括`HTML`标签在内的内容

    ```javascript
    element.innerHTML
    ```

 **改变元素的步骤**

1.  选择元素；
2.  获取元素的属性；（元素是对象）
3.  修改元素的属性；`src / href / id / alt / title`



表单元素的操作

`type / value / checked / selected / disabled`



#### 改变元素样式

**读取内联样式**：

使 用`style` 属性来操作元素的内联样式：`元素.style.样式名`

```js
元素.style.width
元素.style.height
```

注：**如果样式名中带有`-`，则需要将样式名修改为驼峰命名法将`-`去掉，然后后的字母改大写**。

```
backgroundcolor -> backgroundColor
borderwidth -> borderWidth
```



**改变内联样式**：

`元素.style.样式名 = 样式值`

🌰改变标签元素的样式：

通过 `style` 修改和读取的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过 JavaScript 修改的样式，往往会立即生效，
**但是如果样式中设置了`!important`，则内联样式将不会生效。**

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<body>
 
<p id="p1">Hello World!</p>
<p id="p2">Hello World!</p>
<script>
document.getElementById("p2").style.color="blue";
document.getElementById("p2").style.fontFamily="Arial";
document.getElementById("p2").style.fontSize="larger";
</script>
 
</body>
</html>
```



**读取元素当前样式**

1. `getComputedStyle()`是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式：

   ```js
   // 获取元素的宽度
   getComputedStyle(box , null)["width"];
   ```

   通过该方法读取到样式都是**只读**的不能修改；



**循环排他思想**

+   同一组元素，实现某种样式；
    +   首先先设置其他元素为空（确保其他元素不同于目标元素）；
    +   再设定目标元素为目标样式；



### 自定义属性操作

#### 获取属性值

```javascript
element.属性 // 主要获取内置的属性
element.getAttribute('属性');  // 主要获取自定义属性
// id / class
```

#### 设定属性值

```javascript
element.属性 = '指' // 更改内置属性值
element.setAttribute('属性名','值') // 更改自定义属性
```

+   `setAttribute('class','footer')` 

    这里的 `class` 指的是 `className`

#### 移除属性值

```javascript
element.removeAttribute('属性名');
```

+   自定义属性的目的： 储存数据、调用数据；
+   有些自定义属性不容易判断是否为自定义（不能确定调用的方法）时，使用 `HTML5` 自定义属性；

#### `HTML5`自定义属性

+   在`HTML5`中，规定自定义属性必须以**`data-`**开头用作属性名，并且赋值；以便于辨识。

    ```HTML
    <div data-index='1'></div>
    ```

+   `HTML5`新增获取自定义属性的方法

    ```javascript
    element.dataset.index
    // 或者
    element.dataset['index']
    ```

    

### 节点操作

**节点操作目的**

与 DOM 提供的方法获取元素相比，利用**节点层级关系**获取元素：

+   利用**父子兄**关系获取元素；
+   逻辑性强；

**节点概念**

节点至少拥有`nodeType` (节点类型) / `nodeName` (节点名称) / `nodeValue` (节点值) 三个**基本属性**；

+   `nodeType`的值

    | 元素节点 | 1    |
    | -------- | ---- |
    | 属性节点 | 2    |
    | 文本节点 | 3    |

    文本节点包括文字、空格、换行；

+   一般操作的是**元素节点**；



**节点层级**

不同的层级关系，常见的是父子兄弟层级关系：

**父节点**

```javascript
node.parentNode
```

+   返回某个节点的**最近的**父节点;
+   如果没有找到则返回 `null`;



**子节点**

```javascript
parentNode.childNodes
```

+   返回包含指定节点的子节点的**集合**，为即时更新的集合；

    +   包含了**所有**的子级点，包括元素节点、文本节点；

        一般不建议使用`childNodes`；

        ```js
        // 可以根据节点nodeType筛选处理获取里面的元素节点
        var ul = document.querySelector('ul');
        for(var i = 0; i < ul.childNodes.length; i++){
           if(ul.childNodes[i].nodeType == 1){
        	// ...
           	// 对元素节点的操作
           }
        }
        ```

+   推荐使用: **获取当前元素所有的子元素**

```javascript
parentNode.children 
```

+   是一个**只读**属性，返回所有**子元素**的节点；

    + 只返回子**元素节点**，其余节点不返回；

      

+ 返回**第一个**子节点；

```javascript
parentNode.firstChild // 包含所有的节点
// 或者 parentNode.children[0]
parentNode.firstElementChild // 只返回元素节点
```

+ 返回**最后一个**子节点；

```javascript
parentNode.lastChild // 包含所有的节点
// 或者 parentNode.children[parentNode.children.lenth - 1]
parentNode.lastElementChild // 只返回元素节点
```



**兄弟节点**

```javascript
node.nextSibling
	// 返回当前元素的下一个兄弟节点，包含所有的节点
	// 找不到则返回null
node.previousSibling
	// 返回当前元素的上一个兄弟节点，包含所有的节点
	// 找不到则返回null
```

```js
node.nextElementSibling
	// 返回当前元素的下一个兄弟节点
node.nextElementSibling
	// 返回当前元素的下一个兄弟节点

// 这两个方法兼容
```

```js
// 解决兼容性
function getNextElemtntSibling(element){
	var el = element;
    while(el = el.nextSibling){
        return el;
    }
    return null;
}
```



#### 创建节点

```js
document.createElement('tagName');
// 创建由tagName指定的HTML元素；
```

由于这些元素原本不存在，是根据我们的需求动态生成的，所以称为**动态创建元素节点**；



#### 添加节点

```js
node.appendChild(child)
// 将一个节点添加到指定父节点的子节点列表末尾；
// 类似after伪元素(css)
```

```js
node.insertBefore(child, 指定元素)
// 将一个节点添加到父节点指定的子节点前面
// 类似Before为元素(css)
```

🌰：

```js
// 1.创建元素节点
var li = document.createElement('li');
// 2.添加节点 node父级,child自己
var ul = document.querySelector('ul');
ul.appendChild(li);


// 插入节点
var lichild = document.createElement('li');
ul.insertBefore(lichild, ul.children[0]);
	// ul.children获得父节点的子节点
	// 插入在指定节点的前面
```



#### 删除节点

```js
node.removeChild(child)
// 从DOM中删除一个子节点
// 返回删除的节点

子节点.parentNode.removeNode(子节点) // 推荐方式
```

🌰：

```js
var ul = document.querySelector('ul');
var btn = document.querySelector('button');

btn.onclick = function(){
    if(ul.children.length == 0){
        this.disabled = true;
    } else{
        ul.removeChild(ul.children[0]);
    }
}
```



#### 复制节点

```js
node.cloneNode()
// 返回调用该方法的节点的一个副本
```

+ 如果括号内的参数为空或者`false`，则是浅拷贝，只拷贝节点本身，不拷贝子节点；
+ 如果括号内的参数为`true`，则赋值节点的本身以及所有的子节点；



## BOM

BOM 即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是`window`。

其他对象：

`navigator`：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器；

+ 一般只会使用 `userAgent` 来判断浏览器的信息，`userAgent` 是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的 `userAgent`；

  ```js
  alert(navigator.appName);  
  var ua = navigator.userAgent;  
  console.log(ua);  
  ```

  

`location` ：代表当前浏览器的地址栏信息，通过 `location` 可以获取地址栏信息，或者操作浏览器跳转页面；

+ 直接打印 `location`，则可以获取到地址栏的信息（当前页面的完整路径）；

+ 如果直接将location属性修改为一个完整的路径或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录：

```js
  location.assgin(); // 跳转到其他的页面
  location.reload(); // 重新加载当前页面，作用和刷新按钮一样。参数为true时，则会强制清空缓存刷新页面
  location.replace(); // 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面。不会生成历史记录，不能使用回退按钮回退
```



`History` ：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录；由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。而且该操作只在**当次访问时有效**；
`Screen` ：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息；



**与 DOM 对比：**

| `DOM`                            | `BOM`                                      |
| -------------------------------- | ------------------------------------------ |
| 文档对象模型                     | 浏览器对象模型                             |
| 把「文档」当做一个「对象」来看待 | 把「浏览器」当做一个「对象」来看待         |
| 顶级对象是document               | 顶级对象是window                           |
| 操作页面元素                     | 浏览器==窗口交互==的一些对象               |
| 有W3C 标准规范                   | 浏览器厂商在各自浏览器上定义的，兼容性较差 |



### 构成

`window` 对象是浏览器的**顶级对象**，有双重角色；

+ 是JS 访问浏览器窗口的一个接口；
+ 是一个**全局**对象。定义在**全局作用域**中的变量、函数都会变成 `window` 对象的属性和方法；

在调用的时候**可以省略 `window`**，对话框属于 `window` 对象方法，如`alert(), prompt()`等。

+ window下的一个**特殊属性**`window.name`；



### 常见事件

**窗口加载事件**

`window.onload` 是窗口(页面）加载事件,当文档内容**完全加载完成**会触发该事件（包括图像、脚本文件、CSS 文件等）， 就调用的处理函数。

- 有了`window.onload`就可以把 JavaScript 代码写到页面元素的上方，因为`onload` 是等页面内容**全部加载完毕**，再去执行处理函数；
- `window.onload`传统注册事件方式**只能写一次**，如果有多个，会**以最后一个** `window.onload`为准；

```js
window.onload = function() {}

window.addEventListener("load", function() {});
```



`document.addEventListener` 没有限制使用：

+ `DOMContentLoaded` 事件触发时，**仅当 DOM 加载完成**，不包括样式表，图片，flash等等；
+ IE9以上才支持；
+ 如果**页面的图片很多**的话, 从用户访问到 `onload` 触发可能需要较长的时间,交互效果就不能实现，必然影响用户的体验，**此时用`DOMContentLoaded` 事件比较合适**。

```js
document.addEventListener('DOMContentLoaded',function(){})
```



窗口大小改变事件

`window.onresize` 是**调整窗口大小**加载事件,  当触发时就调用的处理函数。

- 只要**窗口大小发生像素变化**，就会触发这个事件；

- 我们经常利用这个事件完成**响应式布局**。

  `window.innerWidth` 当前屏幕的**宽度**；

```js
window.onresize = function(){}
window.addEventListener("resize",function(){});
```



**定时器** `setInterval()`：将一个函数每隔一个时间执行一次；

+ 第一个参数时回调函数；
+ 第二个参数时调用间隔的时间，单位毫秒；
+ 返回值是一个 `Number` 类型的数据，定时器的唯一标识；
+ 使用 `clearInterval()` 关闭一个定时器：接收有效的定时器的标识，则停止对应的定时器。

```js
var num = 1;  
var timer = setInterval(function() {  
	count.innerHTML = num++;  
	if(num == 11) {  
		//关闭定时器  
		clearInterval(timer);  
	}
}, 1000);  
```



**延迟调用** `setTimeout()`：一个函数不马上执行，而是隔一段时间以后在执行，而且**只会执行一次**；

```js
var timer = setTimeout(function(){
console.log(num++);
},3000);

// 使用clearTimeout()来关闭一个延时调用
clearTimeout(timer);
```

