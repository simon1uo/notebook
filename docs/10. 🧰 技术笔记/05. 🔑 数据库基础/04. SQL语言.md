---
title: 🗼 关系数据库标准查询语言SQL
date: 2021-04-14 20:09:06
permalink: /pages/af318a/
categories: 
  - 数据库基础
tags: 
  - SQL
author: 
  name: Simon
  link: https://github.com/simon1uo
---



## :one:数据定义

### 基本表的定义

```sql
CREATE TABLE <表名>
	( 约束条件 );
```

#### 数据类型

+ `NULL`是特殊值，表示缺失的值，该值可能存在或者不存在；

+ 对于`char`和`varchar`
  + `char(n)`：系统会在字符串补足空格，使其达到`n`个字符；
  + `varchar(n)`：不会在字符串后补空格，属性值长度即为输入字符数；



#### 完整性约束

存入数据字典，当操作表中的数据是由DBMS根据数据字典中的信息自动检查该操作是否违背这些完整性约束条件。

##### 实体完整性定义

通过在`CREATE TABLE`时用`PRIMARY KEY`约束；

+ 用于约束:key:主键，保证主键的**唯一性和非空性**；
+ 可作列级约束条件，也可定义为表级约束条件（视主键是由单属性还是多属性构成决定）

##### 参照完整性定义

通过在`CREATE TABLE`时：

```sql
FOREIGN KEY(<外键>) REFERENCES <被参照表名>(<与外键对应的主键名>)
```

+ 将两个表中的相应元**组联系起**来，是两个关系表之间联系的体现；
+ 当被参照表和参照表进行**更新**操作是有可能会**破坏参照完整性**；

##### 用户定义完整性

在`CREATE TABLE`中根据应用要求，定义属性以及元组以上的约束；当插入或修改数据时，RDBMS会根据约束条件进行执行；

+ `NOT NULL` ：不允许属性值**为空**；

  对关系的**主属性**必须限定为`NOT NULL`，以满足实体完整性；

+ `NULL`：允许属性值为空；（当属性没有显示声明，则默认为`NULL`）

+ `UNIQUE`：**唯一性**约束，属性中不允许出现重复的属性值；

+ `DEFAULT`：**默认值**约束。一些属性列可以讲**使用频率高的**属性定义为`DEFAULT`约束中的默认值，**减少输入的工作量**；

+ `CHECK`：**检查**约束，限定属性的取值；

  例如：**限定性别`SEX`的取值必须为`男`和`女`中的一个：**

  ```sql
  SEX CHAR(2), CHECK(SEX IN('男', '女'));
  ```

  **保证分数`GRADE`的取值范围：**

  ```sql
  CHECK(GRADE BETWEEN 0.0 AND 100.0)
  ```




🌰例：**创建 选课表**(学号, 课程号, 成绩)`SC`：

```sql
CREATE TABLE SC(
	SNO CHAR(6) NOT NULL,
  CNO CHAR(6) NOT NULL,
  GRADE DEC(4,1) DEFAULT NULL,
  PRIMARY KEY(SNO, CNO),
  FOREIGN KEY(CNO) REFERENCES C(CNO),
  FOREIGN KEY(SNO) REFERENCES S(SNO),
  CHECK(GRADE BETWEEN 0.0 AND 100.0));
```



🌰例：**从已有的数据中建表**：

用 `CREATE TABLE … AS … `语句实现把 Students 表中 1986 年后(包含1986 年)出生的学生的学号、姓名存储到一个新表 StudentBAK2。

```SQL
CREATE TABLE StudentBAK2
	AS SELECT Sno, Sname
	FROM Students
  WHERE year(Sbirthday)>=1986;
```



***

### 基本表的修改

**修改已经创建好的表**：

+ **增加列或者表的约束规则**：

  🌰例：**在学生关系表`S`中补充定义`SNO`为:key:主键：**

  ```sql
  ALTER TABLE S ADD PRIMARY KEY(SNO)
  ```

  🌰例：**增加列**：**在学生表`S`中增加一列学生所在系`SD`：**

  ```sql
  ALTER TABLE S ADD SD CHAR(16);
  ```

+ **删除原有列或约束规则**

  🌰例：**删除学生基表`S`中的性别`SEX`属性列：**

  ```sql
  ALTER TABLE S DROP COLUMN SEX:
  ```

+ **修改原有列的类型**

  🌰例：**将学生基表`S`中的学生姓名`SN`长度修改为`12`：**

  ```sql
  ALTER TABLE S ALTER COLUMN SN CHAR(12);
  ```



### 基本表的删除

+ 🌰例：**删除表**`S`：

  ```sql
  DROP TABLE S;
  ```

***

## :two:数据查询

语句格式：

```sql
SELECT <目标列表达式>
FROM <表名或视图名>
[WHERE <元组选择表达式>]
[GROUP BY <属性列名> [HAVING <组选择条件表达式>]]
[ORDER BY <目标列名>];
```



### 单表查询

+ **显示查询结果**：

  `<目标列表达式>` ：不仅仅可以是表中属性列名，也可以是与属性列有关的表达式（经过一定计算输出结果，包括函数、字符串常量）

  🌰例：**查询学生关系表`S`：**

  ```sql
  SELECT * FROM S; / 取出S表所有数据的情况
  ```

  ​	:star:`*`：**表示关系表的所有属性**，说明读取全部属性；

  
  🌰例：**查询所有女生的姓名和出生时间：**

  ```sql
  SELECT SN AS 姓名, SB AS 出生时间
  	FROM S WHERE SEX='女';
  ```
  
  `AS`：显示结果中，`SN`和`SB`的属性名名显示**列名**为姓名和出生时间；
  
  🌰例：**查询选修了课程的学生的学号：**
  
  ```sql
  SELECT DISTINCT SNO FROM SC; / 每个学号结果只会出现一次
  ```
  
  `DISTINCT`：强行删除结果中表中的**重复行**；
  
  （默认`ALL`不去出重复元组）
  
  🌰例：**查询学生的学号和学生的年龄：**
  
  ```sql
  SELECT SNO, SA=datediff(Year,SB,Getdate())+1 FROM S;
  ```
  
  `SA`赋于计算学生的年龄后的结果，然后显示；
  
  ```sql
  datediff(datepart, startdate, enddate);
  / 以datepart指定的方式计算两个日期的差值
  ```
  
  另外一种方法：
  
  ```sql
  SELECT SN, timestampdiff(year, SB, curdate())+1 as SAGE # SAGE为计算后的年龄
  	FROM S WHERE SD='计算机';
  ```
  

****

+ **查询满足条件的元组**：

  1. 运算符

  2. **使用`BETWEEN`查询：**

     🌰例：**查询出生时间在…之间的学生姓名和出生时间：**
  
  ```sql
  SELECT SN, SB
  FROM S WHERE SB BETWEEN '1990-01-01' AND '1991-12-31';
  ```
  
  3. **使用`LIKE`查询：**
  
     `LIKE`用于字符串的比较；
  
     匹配方式：
  
     + 字符`_`：代表任意一个**单字符**；
     + 字符`%`：代表长度可为`0`的**任意长**字符串；
     + 所有其他字符只表示自己；
  
     🌰例：**查询姓`王`所有学生的学号和姓名**：
  
     ```sql
     SELECT SNO,SN
     FROM S
     WHERE SN LIKE '王%';
     ```
  
     🌰例：**查询姓`李`且姓名为`3`个汉字的学生学号和姓名：**
  
     ```sql
     SELECT SN
     from s
     where SN like '李__';
     ```
  
     🌰例：**查询课程名后缀为`_Design`的课程信息**：
  
     ```sql
     SELECT *
     FROM C 
     WHERE CN LIKE '%\_Design' ESCAPE'\';
     ```
  
     当字符串中原本含有`_`，需要**转义**：`ESCAPE`表示字符串后面的`_`不再是**通配符**；
  
  4. **使用`IN`查询：**
  
     `IN`：判断一个值是否属于一个集合；
  
     🌰例：**查询非数学系和计算机系的学生的姓名、学号、所在系：**
  
     ```sql
     SELECT SN,SNO,SD
     FROM S
     WHERE SD NOT IN('数学','计算机');
     ```
  
  5. **使用`NULL`查询**
  
     测试属性值为空
     
     🌰例：查询所有缺少成绩的学生的学号和对应的课程号
     
     ```SQL
     SELECT SNO, CNO
     FROM SC
     WHERE GRADE IS NULL;
     ```

****

+ **查询结果的排序**：

  DBMS默认以元组在**表中的先后顺序**输出查询结果；

  格式：

  ```sql
  ORDER BY <目标列> [ASC | DESC] 
  ```

  + `ASC`：升序，（默认值）；

  + `DESC`降序；

  🌰例：**查询成绩，降序排列：**

  ```sql
  SELECT SNO,GRADE
  FROM SC
  WHERE SNO='C02'
  ORDER BY GRADE DESC;
  ```

  > :warning: 如果某列为`NULL`，则其值为**最小值**；

***

+ **聚集函数**

  聚集函数是以值的一个集合为输入，返回单个值的函数：
  
  ```sql
  COUNT(*) # 统计元组个数
  SUM() # 计算一属性列值的总和
  AVG() # 计算一属性列值的平均值
  MAX() # 求一属性列中的最大值
  MIN() # 求一属性列中的最小值
  ```
  
  > + 使用`DISTINCT`**去除重复值**，默认`ALL`会保留重复值；
  > + 在聚集函数遇到`NULL`时，除了`COUNT()`函数意外都只处理**非空值**；

  🌰例：**求学生表S中学生的总人数：**
  
  ```sql
  SELECT COUNT(*)
  FROM S;
  ```

  🌰例：**求选修了课程的学生人数：**
  
  ```sql
  SELECT COUNT(DISTINCT SNO)
  FROM SC;
  ```

***

+ **分组聚集**

  **进一步细分聚集函数的作用对象**，将聚集函数作用于按一个或者多个属性列的值构造的分组上。

  ```SQL
  GROUP BY <属性列名> [HAVING 条件] 
  ```

  依次按属性列名的值对满足查询条件的元组进行分组，**在所有属性上值相等的元组构成一组**。`HAVING` 子句会对分组进行筛选，**只有满足条件的分组才会产生查询结果**。

  分组后聚集函数作用与每一个分组，以每一个分组的元组为计算对象，**即每个分组都有一个函数值**。

  

  🌰例：查询平均成绩在 80 分以上的学生**学号和平均成绩**，并**按成绩降序排列**：

  ```sql
  SELECT	SNO, AVG(GRADE)
  	FROM SC
  	GROUP BY SNO
  	HAVING AVG(GRADE)>80
  	ORDER BY 2 DESC
  ```

  先对学生成绩按照学号进行排序，然后对分组的成绩计算平均值，再对平均成绩大于80的学生学号和平均成绩进行显示输出，`2`代表以**第二个目标列 **AVG(GRADE) 的值降序排列。

  🌰例：**查找男生人数超过 20 的系名**：

  ```SQL
  SELECT SD
  	FROM S
  	WHERE SEX='男'
  	GROUP BY SD
  	HAVING COUNT(*)>=20;
  ```

  > ⚠️：
  >
  > `WHERE` 作用于 `FROM`指定的数据对象，选出满足条件的元组；
  >
  > `GROUP BY`子句作用于`WHRER`的结果进行分组；
  >
  > `HAVING`对`GROUP BY`以后的分组按条件进行选择； 
  >
  > `SELECT`子句对筛选出的分组产生查询结果；
  
  🌰例：查询选修了两门以上课程的学生学号与课程数。
  
  ```SQL
  SELECT sno, COUNT(*)
  FROM SC
  GROUP BY sno
  HAVING COUNT(*)>2;
  ```

### 连接查询

+ **二表连接查询**

🌰例：查询选修课程号为C01的**学生姓名和成绩**。

```sql
SELECT S.SNAME,SC.GRAGE
	FROM S,SC
	WHERE SC.CNO='C01' AND S.SNO=SC.SNO;
```

使用左外连接可以保留来自S表的元组结果，并且在来自SC表的属性上产生空值`NULL`；

使用左外连接修改为：

```SQL
SELECT S.SN, SC.GRADE 
	FROM S LEFT OUTER JOIN SC 
	ON SC.CNO='CNO' AND S.SNO=SC.SNO;
```



**外连接的语法规则**：

```sql
FROM <左关系> LEFT | RIGHT | FULL [OUTER] JOIN <右关系>
ON <连接基于的条件>
```

+ `FULL` 全外连接，包括左右两表之间不满足条件的行，另一个表的输出列设为`NULL`；
+ `LEFT` 左外连接，包括左表中不满足条件的行，另一个表的输出列设为`NULL`；
+ `RIGHT`右外连接，包括右表中不满足条件的行，另一个表的输出列设为`NULL`；



***

+ **多表连接查询**

🌰例：查询选修“数据结构”课程的学生的姓名和成绩：

```sql
SELECT S.SN, SC.GRADE
	FROM S, SC, C
	WHERE C.CN='数据结构' AND
				C.CNO=SC.CNO AND
				S.SNO=SC.SNO;
```

使用内连接（常规连接）：

```sql
SELECT S.SN, SC.GRADE
	FROM (S INNER JOIN SC ON S.SNO=SC.SNO) INNER JOIN C ON SC.CNO=C.CNO
	WHERE SC.CNAME='数据结构';
```



***

+ **自身连接查询**

  若对一个表中的不同元组进行操作，需要使用自身连接查询。需要对要查询的表定义别名，**虚拟分成两个表**，便于区分。

🌰例：查询每门课的**间接先修课程**：

```sql
SELECT FIRST.CNO AND SECOND.PC
	FROM C FIRST, C SECOND
	WHERE FIRST.PC IS NOT NULL AND
				 SECOND.PC IS NOT NULL AND
				 FIRST.PC=SECOND.CNO;
```

***

### 嵌套查询

+ 使用 `IN` 操作符实现：

  `IN` 用于判断一个值是否属于一个集合；嵌套查询中，子查询的结果往往是一个集合；

  🌰例：查询选修“操作系统”课程的学生的学号：

  ```SQL
  SELECT SNO
  	FROM SC
  	WHERE CNO IN
  		(SELECT CNO
      FROM C
      WHERE CN='操作系统');
  ```

  🌰例：查询选修“操作系统”课程的学生的学号和姓名：需增加一层嵌套：

  ```SQL
  SELECT SN
  	FROM S
  		WHERE SNO IN
  		(SELECT SNO 
      FROM SC
      WHERE CNO IN
     		(SELECT CNO
        FROM C
      	WHERE CN='操作系统'));
  ```

  直接使用多表连接查询方法：

  ```SQL
  SELECT S.SNO, S.SNAME
  FROM S,C,SC
  WHERE S.SNO=SC.SNO AND
  			C.CNO=SC.CNO AND
  			C.CN='操作系统';
  ```

  🌰例：查询没有选择选修 C02 课程的学生姓名 （`NOT IN`）：

  ```SQL
  SELECT SN
  FROM S
  WHERE SNO NOT IN
  	(SELECT SNO 
    FROM SC
    WHERE CNO='C02');
  ```

+ **使用比较操作符实现**：

  用于一个值与多个值比较：

  🌰例：**查询 C01 课程的成绩高于王玲的学生的学号和成绩**：

  ```SQL
  SELECT SNO, GRADE
  FROM SC
  WHERE CNO='C01' AND GRADE>
  	(SELECT GRADE
    FROM SC
    WHERE CNO='C01' AND SNO=
    	(SELECT SNO
      FROM S
      WHERE S.SN='王玲'));
  ```

  🌰例：**查询每个学生所修课程成绩超过所修课程平均成绩的课程号**：

  ```SQL
  SELECT SNO, CNO
  FROM SC SC1 
  WHERE GRADE > 
  	(SELECT AVG(GRADE)
    FROM SC SC2
    WHERE SC1.SNO=SC2.SNO);
  ```

+ 使用 `ANY` 或 `ALL` 操作符实现：

  🌰例：查询**其他系**中比计算机系**某一**学生年龄大的学生：

  ```SQL
  SELECT *
  FROM S
  WHERE SD<>'计算机' AND 
  	SB<ANY(SELECT SB
    			 FROM S
  			 	 WHERE SD='计算机');
  ```

  🌰例：**查询其他系中比计算机系学生年龄都大**的学生：

  ```SQL
  SELECT *
  FROM S
  	WHERE SD<>'计算机' AND
  	SB<ALL(SELECT SB
          FROM S
          WHERE SD='计算机');
  ```

+ 使用 `EXISTS` 实现：

  `EXISTS` 谓词表示存在量词。判断一个子查询块的结果是否存在元祖，非空为逻辑真值，否则为逻辑假植；

  🌰例：查询选修课程好为 C02 的学生姓名：

  ```SQL
  SELECT SN
  FROM S
  WHERE EXISTS 
  	(SELECT *
    FROM SC
    WHERE S.SNO=SC.CNO AND CNO='C02');
  ```

  🌰例：查询没有选修课程好为 C02 的学生姓名：(`NOT EXISTS`)

  ```SQL
  SELECT SN
  FROM S
  WHERE NOT EXISTS 
  	(SELECT *
    FROM SC
    WHERE S.SNO=SC.CNO AND CNO='C02');
  ```



### 集合查询

与SELECT语句不同，集合查询的结果会自动去除重复：

**并运算** `UNION` ：

🌰例：查询选修了“C01”课程或者“C02”课程的学号：

```SQL
SELECT SNO FROM SC WHERE CNO='C01'
UNION
SELECT SNO FROM SC WHERE CNO='C02'
```

**交运算** `INTERSECT` ：

🌰例：查询选修了“C01”课程又选修了“C02”课程的学号：

```SQL
SELECT SNO FROM SC WHERE CNO='C01'
INTERSECT
SELECT SNO FROM SC WHERE CNO='C02'
```

**差运算** `MINUS` / `EXCEPT` ：

🌰例：查询选修了“C01”课程但没有选修了“C02”课程的学号：

```SQL
SELECT SNO FROM SC WHERE CNO='C01'
EXCEPT
SELECT SNO FROM SC WHERE CNO='C02'
```

## :three:数据更新

### 插入数据

+ **插入单个元组**：

  🌰例：将一个新学生记录插入到学生关系表 S 中：

  ```SQL
  INSERT INTO S(SNO,SN,SD,SB,SEX) VALUES ('S01','陈浩','计算机','1990-10-15','男');
  ```

  🌰例：插入一条选课元组到选课表 SC 中：成绩 GRADE 被自动赋为`NULL`

  ```SQL
  INSERT INTO SC(SNO,CNO) VALUES ('S01','C01');
  ```

+ 插入子查询结果：

  🌰例：插入“计算机系”学生选修“数据库”课程的选课记录：

  ```SQL
  INSERT INTO SC(SNO,CNO)
  	SELECT SNO,CNO
  	FROM S,C,SC
  	WHERE S.SD='计算机' AND 
  				S.SNO=C.SNO AND
  				C.CNO=SC.CNO AND
  				CN='数据库';
  ```

### 修改数据

🌰例：将学号为 S02 的学生所学 “高等数学” 的成绩改为 93.0：

```SQL
UPDATE SC
SET GRADE='93.0'
WHERE SNO='S02' AND
	CNO IN (SELECT CNO
         FROM C
         WHERE CN='高等数学');
```

🌰例：若课程成绩低于该课平均成绩，则将成绩提高 5% ：

```SQL
UPDATE SC
SET GRADE=GRADE*1.05
WHERE GRADE<(SELECT AVG(GRADE)
            FROM SC SC1
            WHERE SC.CNO=SC1.CNO)
```

🌰例：将选修了课程名为`数据库原理`并且有成绩的学生成绩加 5 分：

```SQL
UPDATE SC
SET grade=grade+5
WHERE grade IS NOT NULL AND
	cno IN (SELECT cno 
         FROM c
         WHERE cname='数据库原理')
```

### 删除数据

🌰例：将学号为 S07 的学生删除：

```SQL
DELETE
FROM S
WHERE SNO='S07';
```

🌰例：删除成绩低于所有课程平均成绩的选课元组：

```SQL
DELETE
FROM SC
WHERE GRADE<(SELECT AVG(GRADE) FROM SC);
```

🌰例：**多表删除**

删除`机电系`课程成绩不及格或者没有登记成绩的学生选课记录：

```SQL
DELETE
FROM SC,Students
WHERE SC.sno=Studnets.sno
	AND Sdept='机电系'
	AND (grade<60 AND grade IS NOT NULL);
```

🌰例：**删除某个表中的所有行**：

```SQL
DELETE FROM StudentBAK2;
```



## :four: 触发器

是用户定义在关系表上的一类由**事件**驱动的特殊过程：

+ 被激活时，测试触发的**条件**，一旦条件满足，DBMS 会自动执行与该触发器相连的动作，实现对数据库特定的更新操作。

与完整性约束相比，触发器可以更为复杂的检查和操作，具有更精细和更强大的数据控制能力；



**触发器的组成**（3部分）：

+ 事件； 通常是对数据库的插入、修改和删除等操作；
+ 条件；
+ 动作；可以是任何数据库操作序列，包括与触发器毫无关联的操作；



🌰例：在 学生-课程 数据库中创建触发器，保证学生表中的性别仅能为“男”或者“女”：

```SQL
CREATE TRIGGER senxins # 创建插入事件触发器
ON S
FOR INSERT, UPDATE
AS
	IF EXISTS(SELECT * FROM inserted WHERE sex NOT IN('男','女'))
	ROLLBACK;
```

创建插入触发器后，只要插入一个性别不为“男”或者“女”的元组，则会触发该触发器，终止操作；

## :five: 视图

数据库的外模式：通过定义视图来实现；

+ **视图是一个虚表**：视图是一个命名了的代数表达式，从一个或者几个基本表（或视图）导出的（虚的）关系变量；
+ **视图为用户提供了一个观察底层数据的窗口**；
+ **用户能像操作基本关系变量一样来操纵视图**；



视图的定义

🌰例：建立“数学”系学生视图：

```SQL
CREATE VIEW M_S(SNO,SN,SB)
AS SELECT SNO,SN,SB
	FROM S
	WHERE SD='数学';
```



## :six: 实验







