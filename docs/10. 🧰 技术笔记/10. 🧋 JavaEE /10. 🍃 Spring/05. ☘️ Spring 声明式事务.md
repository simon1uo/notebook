---
title: ☘️ Spring 声明式事务
date: 2022-03-30 10:52:19
permalink: /pages/9f2a81/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🍃 Spring
tags: 
  - Spring
author: 
  name: Simon
  link: https://github.com/simon1uo
---



## 事务

+ 事务是数据库操作的**最基本单元**，逻辑上是一组操作，要么都成功，如果有一个失败所有操作都失败。
+ 典型场景：银行转帐（只要有出错，交易都会中断）。



> 🔗 **事务的特性**：
>
> - 原子性（**A**tomicity）：一个事务中的所有操作，要么都成功，要么都失败，整个过程不可分割。
>
> - 一致性（**C**onsistency）：事务操作之前和操作之后，总量保持不变。
>
> - 隔离性（**I**solation）：多事务操作时，相互之间不会产生影响。
>
> - 持久性（**D**urability）：事务最终提交后，数据库表中数据才会真正发生变化。



## 事务操作

 可以按照 JavaEE 的典型三层结构实现，目前首先关注 `Service` 业务操作层和 `DAO` 数据库操作层。

### 准备事务操作

+ 主要步骤：
  + 创建数据库表 `t_account` ，添加几条交易记录。
  + 创建对应的 `Service` 和 `DAO` 类，完成对象创建和关系注入。
  + 在 `Service` 和 `DAO` 中编写相应的代码完成功能逻辑部分。



+ 创建数据库表 `t_account` ，添加几条交易记录。

```sql
create table t_account
(
    id       varchar(20) not null,
    username varchar(50) null,
    amount   int         null,
    constraint transfer_record_pk
        primary key (id)
);

INSERT INTO t_account (id, username, amount) VALUES ('1', 'Lucy', 1000);
INSERT INTO t_account (id, username, amount) VALUES ('2', 'Mary', 1000);
```



> Spring 与 Mybatis 的整合使用在上一节已经详细记录步骤，在此不再赘述。

+ 创建 `TransferRecordDAO` 抽象类。

```java
@Repository
public interface TransferDAO {
    @Select("SELECT * FROM t_account")
    List<Account> findAll();

    @Update("UPDATE t_account set amount=amount-#{amount} where username=#{username}")
    void transferOut(@Param("amount") int amount,@Param("username") String username);

    @Update("update t_account set amount=amount+#{amount} where username=#{username}")
    void transferIn(@Param("amount") int amount,@Param("username") String username);
}
```



+ 创建 `TransferRecordService` 类，并完成 `TransferRecordDAO` 的注入，调用 `TransferRecordDAO` 的方法：

```java
@Service
public class TransferRecordService {
    @Autowired
    private TransferRecordDAO transferRecordDAO;

    public void getAllAccounts(){
        List<Account> accounts = transferDAO.findAll();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }

    public void transferAccounts(int amount, String fromUser, String toUser) {
        System.out.println("transfer start ... ");
        transferDAO.transferOut(amount, fromUser);
        transferDAO.transferIn(amount, toUser);
        System.out.println("transfer end ... ");

    }
}
```



+ 编写测试方法：

```java
@Test
public void testTransferAccounts(){
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    TransferService transferService = context.getBean("transferService", TransferService.class);
    transferService.getAllAccounts();
    transferService.transferAccounts(100, "Lucy", "Mary");
    transferService.getAllAccounts();
}
```

> 以上无异常情况下， 可以完成一次交易。



### 引入事务场景

当转账中途发生异常情况（例如，网络异常），尝试模拟异常情况：

+ 修改 `TransferRecordService` 中的方法：

```java
public void transferAccounts(int amount, String fromUser, String toUser) {
    int i = 1 / 0;
    transferRecordDAO.transferOut(amount, fromUser);
    transferRecordDAO.transferIn(amount, toUser);
}
```



+ （在测试数据复原）运行测试方法，抛出无法完成操作的异常：

```
java.lang.ArithmeticException: / by zero

	at com.simon.service.TransferRecordService.transferAccounts(TransferRecordService.java:13)
	at com.simon.service.TransferRecordTest.testTransferAccounts(TransferRecordTest.java:14)
```

**此时出现致命性的问题，回看数据库的数据，发现转出账方被转出金额，而收账方却没有收到相应的金额。此时，事务的作用就在这里体现出来了。**



### 事务基本操作

1. 开启一个事务
2. 进行业务逻辑实现
3. 没有异常，则**提交事务**
4. 发生异常，则**回滚事务**



🌰 将前述转账例子 `TransferRecordService` 中的方法引入事务的基本框架：

```java
try {
    // Step1、开启一个事务
    // Step2、进行业务逻辑实现
    transferRecordDao.transferOut(amount, fromUser);
    //模拟网络异常而导致操作中断
    int i = 10 / 0;
    transferRecordDao.transferIn(amount, toUser);
    // Step3、没有异常，则提交事务
} catch (Exception e) {
    // Step4、发生异常，则回滚事务
}
```



## 声明式事务

### Spring 事务管理

在 Spring 中进行事务管理有两种方式：

+ 编程式事务管理：在前述的事务基本操作实现就是典型的编程式事务管理。这种方式虽然并不好，但是可以了解这个事务的操作过程，一般由于不方便、导致代码的臃肿、维护起来麻烦而不使用这种方式。
+ **声明式事务管理**（推荐使用）：底层原理就是 [Spring AOP](/pages/dad650/) ，在不改变原来的代码逻辑的基础上，拓展代码的功能。有两种实现方式：
  + **基于注解方式实现**（推荐使用）
  + 基于 XML 配置文件实现



### Spring 事务管理 API

Spring 提供了一个接口代表事务管理器，针对不同的 JDBC 框架存在不同的实现类：

- `PlatformTransactionManager` 接口：即事务管理器，有多个不同的抽象类和具体实现类，可满足不同的框架。

- `DataSourceTrasactionManager` 实现类：`JdbcTemplate` 和 `MyBatis` 框架使用到它。

- `HibernateTransactionManager` 实现类：`Hibernate` 框架使用到它。



### 注解实现声明式事务管理

+ 在 Spring 配置文件中配置事务管理器 `DataSourceTransactionManager`的对象创建。

```xml
<!--配置事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

> `property` 设置的属性为目前使用的 `dataSource` 对象。



+ 在 Spring 配置文件中开启事务（注解方式）：
  + 引入 `xmlns:tx` 的名称空间
  + 配置 `<tx:annotation-driven>` 标签开启事务注解驱动

```xml
<!--开启事务注解-->
<tx:annotation-driven transaction-manager="transactionManager"/>
```

> `transaction-manager` 属性配置当前的事务管理器。

（此处实现注解实现声明式事务管理依旧需要依靠 Spring 配置文件开启事务注解，要实现完整注解开发请看后处介绍。）



🌰 延续前述的例子，在 `TransferRecordService` 中添加事务注解 `@Transactional`：

```java
@Service
@Transactional
public class TransferRecordService {
	// ... 
}
```





+ 注解 `@Transactional` 中配置事务相关的参数：

  - `propagation`：事务传播行为

  - `isolation`：事务隔离级别

  - `timeout`：超时时间

  - `readOnly`：是否只读

  - `rollbackFor`：回滚

  - `noRollbackFor`：不回滚



#### 传播行为

+ **事务传播行为**：多事务方法直接进行调用，这个过程中事务是如何进行管理的。
+ **事务方法**：让数据表数据发生变化的操作。



事务的传播行为**可以有传播属性指定**。Spring 框架中定义了 7 种类传播行为：

| 传播属性        | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| `REQUIRED`      | 如果有事务在运行，当前方法就在此事务内运行；否则，就启动一个新的事务，并在自己的事务内运行 |
| `REQUIRED_NEW`  | 当前方法必须启动新事务，并在它自己的事务内运行；如果有事务正在运行，应该将它挂起 |
| `SUPPORTS`      | 如果有事务在运行，当前方法就在此事务内运行；否则，它可以不运行在事务中 |
| `NOT_SOPPORTED` | 当前方法不应该运行在事务内部，如果有运行的事务，就将它挂起   |
| `MANDATORY`     | 当前方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 |
| `NEVER`         | 当前方法不应该运行在事务中，如果有运行的事务，就抛出异常     |
| `NESTED`        | 如果有事务在运行，当前方法就应该在此事务的嵌套事务内运行；否则，就启动一个新的事务，并在它自己的事务内运行 |



🌰 例子：

+ 现有有两个方法 `add()` 和 `update()` ：

```java
@Transactional
public void add(){
    update();
}

public void update(){
    // do something
}
```



+ 按照不同的传播行为，可以有两种解释：
  + `REQUIRED` ：:one: 如果 `add()` 方法本身有事务，调用 `update()` 方法之后，`update()` 使用当前 `add()` 方法里面事务。:two: 如果 `add()` 方法本身没有事务，调用 `update()` 方法之后，创建新的事务。:warning: 是**默认事务传播行为**。
  + `REQUIRED_NEW`：使用 `add()`  方法调用 `update()` 方法，无论 `add()` **是否有事务，都创建新的事务**。



🌰 例子：

+ 为 `TransferRecordService` 设置事务传播行为：

```java
@Service
@Transactional(propagation = Propagation.REQUIRED)
public class TransferRecordService {
    //...
}
```



#### 隔离级别

当不考虑事务的四个特性之一隔离性时，在并发时会产生一系列的问题。

+ 有三个典型的「读」问题：脏读、不可重复读、虚（幻）读。
  + **脏读**：一个未提交事务读取到了另一个未提交事务修改的数据。
  + **不可重复读**：一个未提交事务读取到了另一个已提交事务**修改的数据**。
  + **虚（幻）读**：一个未提交事务读取到了另一个已提交事务**添加的数据**。



+ 通过设置隔离级别，解决上述的「读」问题：

| 事务隔离级别                       | 脏读 | 不可重复读 | 幻读 |
| ---------------------------------- | ---- | ---------- | ---- |
| `READ UNCOMMITTED`（**读未提交**） | ✅    | ✅          | ✅    |
| `READ COMMITTED`（**读已提交**）   | ❌    | ❌          | ✅    |
| `REPEATABLE READ`（**可重复读**）  | ❌    | ❌          | ✅    |
| `SERIALIZABLE`（**串行化**）       | ❌    | ❌          | ❌    |

> 在 MySQL 中的默认事务隔离级别为 `REPEATABLE READ` 可重复读。



🌰 例子：

+ 为 `TransferRecordService` 设置事务隔离级别：

```java
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class TransferRecordService {
    //...
}
```



#### 其他参数

**`timeout`**：设置事务的超时时间。

+ 事务需要在一定的时间内进行提交，若设定的时间内事务未完成提交，则对事务进行回滚。
+ 默认值为 `-1`，**设置时间以秒为单位**。



🌰 例子：

+ 在 `TransferRecordService` 设置事务超时的时间为 5 s。

```java
@Service
@Transactional(timeout = 5)
public class TransferRecordService {
    @Autowired
    private TransferRecordDao transferRecordDao;

    public void transferAccounts(int amount, String fromUser, String toUser) {
        transferRecordDao.transferOut(amount, fromUser);
        //模拟处理超时
        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        transferRecordDao.transferIn(amount, toUser);
    }
}
```

+ 此时提交的事务超过设置的时间，则会抛出 `TransactionTimedOutException` 事务超时异常。



**`readOnly`**：设置只读属性。

+ 默认值 `false` ：表示读写操作都允许，可以进行增、删、查、改的事务操作。
+ `true`：表示只允许进行读取操作（查询）。



🌰 例子：

+ 为 `TransferRecordService` 设置只读属性：

```java
@Service
@Transactional(readOnly = true)
public class TransferRecordService {
    //...
}
```

+ 设置只读后，则会抛出   `TransientDataAccessResourceException` 即**瞬态数据访问资源异常**，同时还会抛出 `SQLException` ，并指出连接是只读的，查询导致数据修改是不允许的。



**`rollbackFor`**：设置出现哪些异常才回滚。

🌰 例子：

+ 为 `TransferRecordService` 设置成只有抛出 `ArithmeticException` 异常时，才会进行事务的回滚操作。

```java
@Service
@Transactional(rollbackFor = ArithmeticException.class)
public class TransferRecordService {
    @Autowired
    private TransferRecordDao transferRecordDao;

    public void transferAccounts(int amount, String fromUser, String toUser) {
        transferRecordDao.transferOut(amount, fromUser);
        //模拟网络异常而导致操作中断
        int i = 10 / 0;
        transferRecordDao.transferIn(amount, toUser);
    }
}
```

`noRollbackFor`：与上面的属性值相反，设置出现哪些异常不进行回滚。

🌰 例子：

+ 为 `TransferRecordService` 设置成抛出 `ArithmeticException` 异常时，不会进行事务的回滚操作。

```java
@Service
@Transactional(noRollbackFor = ArithmeticException.class)
public class TransferRecordService {
    @Autowired
    private TransferRecordDao transferRecordDao;

    public void transferAccounts(int amount, String fromUser, String toUser) {
        transferRecordDao.transferOut(amount, fromUser);
        //模拟网络异常而导致操作中断
        int i = 10 / 0;
        transferRecordDao.transferIn(amount, toUser);
    }
}
```



#### 完全注解开发

+ 创建配置类 `TransactionalConfig` ：

```java
@Configuration // 表示此类为配置类
@ComponentScan(basePackages = "com.simon") // 自动扫描包
@EnableTransactionManagement // 开启事务
@PropertySource(value = {"classpath:jdbc.properties"}) // 读取外部数据库信息配置文件
public class TransactionalConfig {
    @Value(value = "${mysql.driverClassName}")
    private String driverClassName;
    @Value(value = "${mysql.url}")
    private String url;
    @Value(value = "${mysql.username}")
    private String username;
    @Value(value = "${mysql.password}")
    private String password;

		// 完整的配置数据库与SqlSession实例创建参照上一节笔记
  	// ...
  	
    // 配置事务管理器
    @Bean
    public DataSourceTransactionManager getDataSourceTransactionManger(DriverManagerDataSource dataSource) {
        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    }
}
```



🌰 测试完全注解开发：

+ 编写测试方法：

```java
ApplicationContext context = new AnnotationConfigApplicationContext(TransactionalConfig.class);
TransferRecordService transferRecordService = context.getBean("transferRecordService", TransferRecordService.class);
transferRecordService.transferAccounts(100, "Lucy", "Mary");
```



### 使用 XML 配置实现声明式事务管理

::: details

创建 Spring 配置文件用于实现声明式管理：

+ 配置事务管理器：

```xml
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"></property>
</bean>
```

+ 配置事务通知

```xml
<tx:advice id="txAdvice">
    <tx:attributes>
        <tx:method name="transferAccounts" propagation="REQUIRED" isolation="REPEATABLE_READ" read-only="false"
                   timeout="5" rollback-for="java.lang.ArithmeticException"/>
    </tx:attributes>
</tx:advice>
```

+ 配置切入点和切面：

```xml
<aop:config>
    <aop:pointcut id="p"
                  expression="execution(* com.simon.service.TransferRecordService.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="p"></aop:advisor>
</aop:config>
```
