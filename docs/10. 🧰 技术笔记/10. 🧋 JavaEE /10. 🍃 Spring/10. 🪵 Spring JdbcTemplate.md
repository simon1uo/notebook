---
title: 🪵 Spring JdbcTemplate
date: 2022-03-30 10:45:27
permalink: /pages/30b6df/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🍃 Spring
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---



## JdbcTemplate 概述

本部分有关 Spring 的 Data Acess / Integration （数据访问和集成）。Spring 既可以单独使用，也可以集成其他框架，如 Hibernate、MyBatis 等。除此之外，其中对于 JDBC 也做了封装，即本章节的 **JdbcTemplate**，用它可以比较方便地对数据库进行增删改查等操作。

即就是 Spring 框架对 JDBC 技术进行的**二次封装模板**，能够**简化对数据库的操作**。

::: warning 

⚠️ 不常用警告：由于年少无知跟着课程就学了。到后面才知道 **JdbcTemplate 仅作了解，可不深入学习。后续常用 MyBatis 与 Spring 整合**。

:::

## JdbcTemplate 使用



### 准备工作

+ 引入相关的依赖：

   - `druid`


   - `mysql-connector-java`


   - `spring-jdbc`


   - `spring-orm`


   - `spring-tx`


本处涉及到的 maven 依赖引入：

::: details

```xml
<dependencies>
    <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.2.8</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.17</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.3.17</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.springframework/spring-orm -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-orm</artifactId>
        <version>5.3.17</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.springframework/spring-tx -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-tx</artifactId>
        <version>5.3.17</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/junit/junit -->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>

    <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.28</version>
    </dependency>
</dependencies>
```

:::



+ 使用 Spring 配置文件配置 `Druid` 连接池信息（新建 Spring 配置文件 `dataSourceBean.xml` ）：

:warning: 注意头部要引入 `context` 的名称空间：

```xml
<context:property-placeholder location="jdbc.properties"/>

<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="${m ysql.driver}"/>
    <property name="url" value="${mysql.url}"/>
    <property name="username" value="${mysql.username}"/>
    <property name="password" value="${mysql.password}"/>
</bean>
```

+ 引入的 `jdbc.properties` 配置信息文件：

```properties
mysql.driver=com.mysql.jdbc.Driver
mysql.url=jdbc:mysql://localhost:3306/javaeeTest?useUnicode=true&characterEncoding=utf8
mysql.username=****
mysql.password=****
```

+ 在 Spring 配置文件中配置 `JdbcTemplate` 对象，注入 `DataSource`：

```xml
<!--JdbcTemplate对象-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <!--注入DataSource-->
    <property name="dataSource" ref="dataSource"/>
</bean>
```

+ 在 Spring 配置文件中开启组件扫描：

```xml
<!--开启组件扫描-->
<context:component-scan base-package="com.simon"/>
```

（附上整体的 Spring 配置文件）：

::: details

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-beans.xsd">

    <!--开启组件扫描-->
    <context:component-scan base-package="com.simon"/>

    <context:property-placeholder location="jdbc.properties"/>

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--JdbcTemplate对象-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <!--注入DataSource-->
        <property name="dataSource" ref="dataSource"/>
    </bean>
</beans>
```

:::

+ 创建 `Service` 类和 `DAO` 接口类与实现类，使用注解方式在 `DAO` 中注入 `JdbcTemplate` 对象（另外在 `Service` 中注入 `DAO` 对象）。

🌰 创建 `BookService` 、`BookDAO` 、`BookDAOImpl`：

```java
@Service
public class BookService {
    // 注入DAO
    @Autowired
    private BookDAO bookDAO;
}
```

```java
public interface BookDAO {
}
```

```java
@Repository
public class BookDAOImpl implements BookDAO {
    // 注入JdbcTemplate
    @Autowired
    private JdbcTemplate jdbcTemplate;
}
```



### 添加操作



🌰 例子：以添加图书功能为例

+ 主要步骤：
  + 创建数据库 `t_book` 
  + 创建数据库 `t_book` 对应的持久化层
  + 编写添加图书功能逻辑代码， `BookService` 和 `BookDAO` 
  + 编写测试类和测试方法



+ 创建数据库 `t_table` ：

::: details

```sql
create table t_book
(
    id     char(10)  not null primary key,
    name   char(100) null,
    status char(50)  null
);
```

:::



+ 编写 `Book` 实体类：

```java
public class Book {
    private String bookId;
    private String bookName;
    private String bookStatus;

    public Book(String bookId, String bookName, String bookStatus) {
        this.bookId = bookId;
        this.bookName = bookName;
        this.bookStatus = bookStatus;
    }

    public String getBookId() {
        return bookId;
    }

    public void setBookId(String bookId) {
        this.bookId = bookId;
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public String getBookStatus() {
        return bookStatus;
    }

    public void setBookStatus(String bookStatus) {
        this.bookStatus = bookStatus;
    }
}
```



+ 编写 `BookService` 和 `BookDAO` 部分，增加**添加图书**的功能逻辑：

```java
public interface BookDAO {
    int addBook(Book book);
}
```

```java
@Repository
public class BookDAOImpl implements BookDAO {
    // 注入JdbcTemplate
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public int addBook(Book book) {
        String sql = "insert into t_book(id, name, status) values(?,?,?)";
        Object[] args = {book.getId(), book.getName(), book.getStatus()};
        return jdbcTemplate.update(sql, args);
    }
}
```



> `udpate(String sql, Object ... args)` 方法：
>
> + `sql` ：字符串类型的 SQL 语句
> + `args` ：可变参数，设置 SQL 语句值

```java
@Service
public class BookService {
    // 注入DAO
    @Autowired
    private BookDAO bookDAO;

    public int addBook(Book book) {
        return bookDAO.addBook(book);
    }
}
```



+ 编写测试类和测试方法：

```java
public class BookServiceTest {
    @Test
    public void testBookServiceAdd(){
        ApplicationContext context = new ClassPathXmlApplicationContext("BookBean.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        Book book = new Book();
        book.setId("124");
        book.setName("JavaWeb");
        book.setStatus("a");
        System.out.println(bookService.addBook(book));
    }
}
```



### 修改和删除操作

修改和删除操作的代码逻辑基本上与添加操作一致。



🌰 例子：以修改图书和删除图书为例

+ 在 `BookDAO` 中添加修改图书和删除图书的方法代码：

```java
public interface BookDAO {
    int updateBook(Book book);

    int deleteBook(String id);
}
```



```java
@Repository
public class BookDAOImpl implements BookDAO {
    // 注入JdbcTemplate
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public int updateBook(Book book) {
        String sql = "update t_book set name=?,status=? where id=?";
        Object[] args = {book.getName(), book.getStatus(), book.getId()};
        return jdbcTemplate.update(sql, args);
    }

    @Override
    public int deleteBook(String id) {
        String sql = "delete from t_book where id=?";
        return jdbcTemplate.update(sql, id);
    }
}
```



+ 在 `BookService` 中添加修改图书和删除图书的方法代码：

```java
public class BookService {

    // 注入DAO
    @Autowired
    private BookDAO bookDAO;

    public int addBook(Book book) {
        return bookDAO.addBook(book);
    }

    public int updateBook(Book book) {
        return bookDAO.updateBook(book);
    }

    public int deleteBook(String id) {
        return bookDAO.deleteBook(id);
    }
}
```



+ 编写测试类和测试方法：

```java
@Test
public void testBookServiceUpdateBook(){
    ApplicationContext context = new ClassPathXmlApplicationContext("BookBean.xml");
    BookService bookService = context.getBean("bookService", BookService.class);
    Book book = new Book();
    book.setId("124");
    book.setName("JavaWeb");
    book.setStatus("b");
    System.out.println(bookService.updateBook(book));
}

@Test
public void testBookServiceDeleteBook(){
    ApplicationContext context = new ClassPathXmlApplicationContext("BookBean.xml");
    BookService bookService = context.getBean("bookService", BookService.class);
    System.out.println(bookService.deleteBook("124"));
}
```



### 查询操作

主要有三种查询操作：

+ 查询返回某个值
+ 查询返回对象
+ 查询返回集合





**使用 JdbcTemplate 查询返回某个值**：

🌰 查询表里面有多少条记录，返回的是某个值：

+ 在 `BookDAO`  添加方法：

```java
int selectCount();
```

```java
@Override
public int selectCount() {
    String sql = "select count(*) from t_book";
    return jdbcTemplate.queryForObject(sql, Integer.class);
}
```

> `queryForObject(String sql, Class<T> requiredType)`  参数说明
>
> + `sql` ：执行的 SQL 语句
> + `requiredType`：**返回类型的 `Class`**（`String.class` 、`Integer.class` 等）

+ 在 `BookService` 中添加方法：

```java
public int findCount(){
    return bookDAO.selectCount();
}
```



+ 编写测试方法：

```java
@Test
public void testBookServiceFindCount(){
     System.out.println(bookService.findCount());
}
```



**使用 JdbcTemplate 查找返回对象**：

🌰 查找表中图书的详细信息：

+ 在 `BookDAO` 中添加方法：

```java
Book selectBookById(String id);
```

```java
@Override
public Book selectBookById(String id) {
    String sql = "select * from t_book where id=?";
    // 因为需要返回值为Book类型，所以要将数据封装成Book类型
    return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);
}
```

> `queryForObject(String sql, RowMapper<T> rowMapper, Object.. args)` 参数说明： 
>
> + `sql`：执行的 SQL 语句。
> + `rowMapper`： RowMapper 类型，是接口，**返回不同类型的数据，使用这个接口实现数据的封装**。其实现类有很多，因为需要返回一个数据库实体对象，所以可以选择使用 `BeanPropertyRowMapper` 。
> + `args` ：可变参数，设置 SQL 语句值。



+ 在 `BookService` 中添加方法：

```java
public Book findBookById(String id){
    return bookDAO.selectBookById(id);
}
```



+ 编写测试方法：

```java
@Test
public void testBookServiceFindBookById(){
    Book book = bookService.findBookById("123");
    System.out.println(book);
}
```



使用 JdbcTemplate 查找返回集合

🌰 例子：查找图书列表

+ 在 `BookDAO` 中添加方法：

```java
List<Book> selectAllBook();
```

```java
@Override
public List<Book> selectAllBook() {
    String sql = "select * from t_book";
    List<Book> books = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));
    return books;
}
```

> `query(String sql, RowMapper<T> rowMapper)` JdbcTemplate 提供的返回一个集合的查询方法，参数说明： 
>
> + `sql`：执行的 SQL 语句。
> + `rowMapper`： RowMapper 类型，是接口，**返回不同类型的数据，使用这个接口实现数据的封装**。其实现类有很多，因为需要返回一个数据库实体对象，所以可以选择使用 `BeanPropertyRowMapper` 。
> + `args`：参数可有可无。



+ 在 `BookService` 中添加方法：

```java
public List<Book> findAllBook(){
    return bookDAO.selectAllBook();
}
```

+ 编写测试方法：

```java
@Test
public void testBookServiceFindAllBook(){
    List<Book> bookList = bookService.findAllBook();
    bookList.forEach(book -> System.out.println(book));
}
```



### 批量操作

JdbcTempalte 中提供了 `BatchUpdate()` 可供我们进行批量操作，例如：批量添加、批量修改、批量删除等，代码实现上大同小异。



🌰 例子：

+ 在 `BookDAO` 中添加方法：

```java
public interface BookDAO {
  int batchAddBook(List<Object[]> bookList);
  int batchUpdateBook(List<Object[]> bookList);
  int batchDeleteBook(List<Object[]> bookList);
}
```

```java
@Repository
public class BookDAOImpl implements BookDAO {
  	// 注入JdbcTemplate
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public int[] extractBatch(String sql, List<Object[]> bookList){
        int[] ints = jdbcTemplate.batchUpdate(sql, bookList);
        return ints;
    }

    @Override
    public int[] batchAddBook(List<Object[]> bookList) {
        String sql = "insert into t_book(id, name, status) values(?,?,?)";
        return extractBatch(sql, bookList);
    }

    @Override
    public int[] batchUpdateBook(List<Object[]> bookList) {
        String sql = "update t_book set name=?, status=? where id=?";
        return extractBatch(sql, bookList);
    }

    @Override
    public int[] batchDeleteBook(List<Object[]> bookList) {
        String sql = "delete from t_book where id=?";
        return extractBatch(sql, bookList);
    }
}
```

> `BatchUpdate(String sql, List<Object[]> batchArgs)` JdbcTemplate 提供的执行批量 SQL 语句的方法，参数说明：
>
> + `sql` ：执行的 SQL 语句。
> + `batchArgs` ：类型为 `List` 集合， 添加多条记录数据。



+ 在 `BookService` 中添加方法：

```java
public class BookService {
    // 注入DAO
    @Autowired
    private BookDAO bookDAO;
  
    public int[] batchAddBook(List<Object[]> bookList){
        return bookDAO.batchAddBook(bookList);
    }

    public int[] batchUpdateBook(List<Object[]> bookList){
        return bookDAO.batchUpdateBook(bookList);
    }

    public int[] batchDeleteBook(List<Object[]> bookList){
        return bookDAO.batchDeleteBook(bookList);
    }
}
```



+ 编写测试方法：

```java
@Test
public void testBookServiceBatchAddBook() {
    List<Object[]> bookList = new ArrayList<>();
    Object[] book1 = {"127", "Java", "batchAdd"};
    Object[] book2 = {"128", "Data", "batchAdd"};
    Object[] book3 = {"129", "SpringCloud", "batchAdd"};
    bookList.add(book1);
    bookList.add(book2);
    bookList.add(book3);
    int[] ints = bookService.batchAddBook(bookList);
    System.out.println(Arrays.toString(ints));
}


@Test
public void testBookServiceBatchUpdateBook() {
    List<Object[]> bookList = new ArrayList<>();
    bookList.add(new String[]{"Java++", "batchUpdate", "127"});
    bookList.add(new String[]{"Python++", "batchUpdate", "128"});
    bookList.add(new String[]{"C++", "batchUpdate", "129"});
    int[] ints = bookService.batchUpdateBook(bookList);
    System.out.println(Arrays.toString(ints));
}

@Test
public void testBookServiceBatchDeleteBook() {
    List<Object[]> bookList = new ArrayList<>();
    bookList.add(new String[]{"127"});
    bookList.add(new String[]{"128"});
    int[] ints = bookService.batchDeleteBook(bookList);
    System.out.println(Arrays.toString(ints));
}
```