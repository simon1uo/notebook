---
title: 🔍 MyBatis 进阶查询
date: 2022-03-21 10:40:56
permalink: /pages/991773/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🗺 MyBatis
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
::: warning

+ 若查询出的数据只有**一条**， 则可以通过实体类对象 / `List` 集合接收。或者用 `Map` 集合接收（没有实体类与查询结果对应时） ；
+ 若查询出的数据有**多条**，可以通过 `List` 集合接受，或者使用 `Map` 集合接收（在接口中的方法上添加上 `@MapKey` 注解），**一定不能通过实体类对象接受，否则会抛出 `TooManyResultsException` 异常。**

:::

按开发需求使用以下不同的查询方法：

### 查询一个实体类对象

🌰 例子：通过 `id` 查询用户信息：

mapper 接口 `SelectMapper` 中：

```java
public interface SelectMapper {
    User getUserById(@Param("id") Integer id);
}
```

mapper 配置 `SelectMapper.xml` ：

```xml
<!--User getUserById(@Param("id") Integer id);-->
<select id="getUserById" resultType="User">
    select *
    from user
    where id = #{id}
</select>
```

测试类：

```java
@Test
public void testGetUserById() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);
    User user = mapper.getUserById(2);
    System.out.println(user);
}
```



### 查询一个集合 `List`



🌰 例子：通过 `id` 查询用户信息：

mapper 接口 `SelectMapper` 中：

```java
public interface SelectMapper {
    List<User> getAllUser();
}
```

mapper 配置 `SelectMapper.xml` ：

```xml
<!--List<User> getAllUser();-->
<select id="getAllUser" resultType="User">
    select * from user;
</select>
```

测试类：

```java
public void testGetAllUser() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);
    List<User> userList = mapper.getAllUser();
    userList.forEach(user -> System.out.println(user));
}
```







### 查询单个数据



🌰 例子：查询用户的总记录数：mapper 接口 `SelectMapper` 中：

```java
public interface SelectMapper {
    Integer getCount();
}
```

mapper 配置 `SelectMapper.xml` ：

```xml
<!--Integer getCount();-->
<select id="getCount" resultType="Integer">
    select count(*) from user
</select>

```

返回类型为 `Integer` 。

测试类：

```java
@Test	
public void testGetCount() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);
    Integer count = mapper.getCount();
    System.out.println(count);
}
```



> 相关：[类型别名（typeAliases）](https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases)
>
> MyBatis 默认类型别名常用：
>
> + `java.lang.Integer` -> `int`, `integer`
> + `int`-> `_int`, `_integer`
> + `Map` -> `map`
> + `String` -> `string` 

### 查询一条数据为 `Map` 集合

 常用于：查询出来的结果没有任何一个实体类能与结果相对应，但可以存储在一个 `Map` 集合（以字段为键，字段的值为值）中供使用的情况。

🌰 例子：根据用户 `id` 查询用户信息为一个 `Map` 集合：

```java
public interface SelectMapper {
    Map<String, Object> getUserByIdToMap(@Param("id") Integer id);
}
```

mapper 配置 `SelectMapper.xml` ：

```xml
<!--Map<String, Object> getUserByIdToMap(@Param("id") Integer id);-->
<select id="getUserByIdToMap" resultType="Map">
    select * from user where id = #{id}
</select>
```

返回类型为 `Map` 。

测试类：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java 

```java
@Test
public void testGetUserByIdToMap() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);
    Map<String, Object> user = mapper.getUserByIdToMap(2);
    System.out.println(user);
}
```

:::

::: tab result

```
DEBUG 03-04 13:28:17,088 ==>  Preparing: select * from user where id = ? (BaseJdbcLogger.java:137) 
DEBUG 03-04 13:28:17,119 ==> Parameters: 2(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-04 13:28:17,138 <==      Total: 1 (BaseJdbcLogger.java:137) 
{password=123456, id=2, username=admin}
```

:::

::::

### 查询多条数据为 `Map` 集合

将表中的数据以 `Map` 集合的方式查询，一条数据对应一个 `Map`。此时若有**多条数据**，就会产生多个 `Map` 集合，并且最终要以一个 `Map` 集合的方式返回数据，**此时需要通过 `@MapKey` 注解设置 `Map` 集合的键，值是每条数据所对应的 `Map` 集合。 **（亦可以用以`Map` 类型的  `List` 作为结果的返回类型 ）



🌰 例子：返回所有的用户信息为一个 `Map` 集合：

```java
public interface SelectMapper {
  @MapKey("id")
  Map<String, Object> getAllUserToMap();
	// List<Map<String, Object>> getAllUserToMap();
}
```

mapper 配置 `SelectMapper.xml` ：

```xml
<!--Map<String, Object> getAllUserToMap();-->
<select id="getAllUserToMap" resultType="Map">
    select * from user
</select>
```

返回类型为 `Map` 。

测试类：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java 

```java
@Test
public void testGetAllUserToMap() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);
    Map<String, Object> user = mapper.getAllUserToMap();
    System.out.println(user);
}
```

:::

::: tab result

```sql
DEBUG 03-04 14:10:52,284 ==>  Preparing: select * from user (BaseJdbcLogger.java:137) 
DEBUG 03-04 14:10:52,312 ==> Parameters:  (BaseJdbcLogger.java:137) 
DEBUG 03-04 14:10:52,330 <==      Total: 3 (BaseJdbcLogger.java:137) 
{2={password=123456, id=2, username=admin}, 3={id=3, username=张三}, 5={password=123456, id=5, username=李四}}
```

:::

::::



### 模糊查询

::: tip

+ `${}` 不自动补单引号 `‘’`；
+ `#{}` 自动补单引号 `‘’`。

:::

+ 使用`${}`，例如：`like ‘%${username}%’ `；
+ 使用字符串拼接，例如：`like concat(‘%’, #{username},’%’)` ；
+ :star: 直接加 ，例如：`like '%'#{username}'%'`。

🌰 例子：根据用户名**模糊查询**用户信息：

mapper 接口 `SQLMapper`：

```java
public interface SQLMapper {
    List<User> getUserByLike(String username);
}
```

mapper 配置 `SQLMapper.xml` ：

```xml
<!--List<User> getUserByLike(String username);-->
<select id="getUserByLike" resultType="User">
    <!--select * from user where username like '%${username}%'-->
    <!--select * from user where username like concat('%', #{username}, '%')-->
    select * from user where username like '%' #{username} '%'
</select>
```

测试类： 

```java
@Test
public void testGetUserByLike(){
  SqlSession sqlSession = SqlSessionUtils.getSqlSession();
  SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);
  List<User> user = mapper.getUserByLike("ad");
  System.out.println(user);
}
```



## MyBatis 特殊 SQL 的执行

### 批量删除

::: tip

批量删除的 SQL 语句格式为 `delete from user in ( …  )`，`…` 中不能是字符串。所以只能通过不自动补 `‘’` 的 `${}` 获取参数。

:::

🌰 例子：根据字符串 `ids` 多个用户名进行批量删除用户：



### 动态设置表名

表中数据太多，为了提高性能，可以将一张表进行切分，看作多张表共同存储这一张表的数据，所以在查询或者操作这一张表可以看作是不一样的表，可以通过**动态设置表名**实现。（**注意只能通过 `${}` 传输动态表名参数**）



🌰 例子：根据不同的表名查询用户信息：

mapper 接口 `SQLMapper`：

```java
public interface SQLMapper {
    List<User> getUserByTableName(@Param("tableName") String tableName);
}
```

mapper 配置 `SQLMapper.xml` ：

```xml
<!--List<User> getUserByTableName(String tableName); -->
<select id="getUserByTableName" resultType="User">
    select * from ${tableName}
</select>
```

测试类： 

```java
@Test
public void testGetUserByTableName() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);
    List<User> user = mapper.getUserByTableName("user");
    System.out.println(user);
}
```



### 添加功能获取自增的主键

（主键回填：如果主键自动生成，有时候我们又需要取得刚刚添加记录的主键值。`insert` 语句中有一个开关属性 `useGeneratedKeys` ，打开它并配置 `keyProperty` 及 `keyColunm` （数据库表中第一列不是主键时才必须），则数据库生成的主键可以**回填给相应持久化类**）

🌰 例子：添加班级信息，班级分配学生例子：

有两个表：`t_class(class_id, class_name)`，`t_student(student_id, student_name, class_id)` ，班级表与学生表的关系是一对多的关系，所以学生表有班级表的 `id` 信息。要实现功能：

+ 添加班级信息；
+ 获取新添加的班级的 `id` ；
+ 以班级分配学生，即**将某学生的 `id` 修改为新添加的班级的 `id`。**



🌰 例子：添加用户并且返回主键 `id` 到对象的属性。

```java
public interface SelectMapper {   
  void insertUser(User user);
}
```

mapper 配置 `SelectMapper.xml` ：

```xml
<!--void insertUser(User user);-->
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
    insert into user values (null, #{username}, #{password}, #{age}, #{sex}, #{email});
</insert>
```

::: tip

+ `useGenerateKeys`：设置 `true` 使用自增的主键。

+ `keyProperty`：因为增删改有统一的**返回值**（受影响的行数），因此只能将获取到的自增的主键放在**传输的参数**（如上例子，为对象 `user` ）的某个属性中（如上例子，设置为 `id`）。

:::

测试类：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java 

```java
@Test
public void testInsertUser() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);
    User user = new User(null, "王五", "123456", 23, "男", "123456@qq.com");
    mapper.insertUser(user);
    System.out.println(user);
}
```

:::

::: tab result

```sql
DEBUG 03-04 15:51:30,027 ==>  Preparing: insert into user values (null, ?, ?, ?, ?, ?); (BaseJdbcLogger.java:137) 
DEBUG 03-04 15:51:30,054 ==> Parameters: 王五(String), 123456(String), 23(Integer), 男(String), 123456@qq.com(String) (BaseJdbcLogger.java:137) 
DEBUG 03-04 15:51:30,057 <==    Updates: 1 (BaseJdbcLogger.java:137) 
User{id=6, username='王五', password='123456', age=23, sex='男', email='123456@qq.com'}
```

可以看到执行之后的 `user` 对象的属性 `id` 获取到了自增的主键的值。

:::

::::