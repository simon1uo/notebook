---
title: ⛓ MyBatis 关联映射
date: 2022-03-21 09:32:02
permalink: /pages/f27918/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🗺 MyBatis
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
> 🔗 相关概念：在关系型数据库中，多表之间存在着三种关联关系：
>
> + **一对一**：在任意一方**引入对方主键作为外键**；
> + **一对多**：在「多」方添加「一」方**主键**作为**外键**；
> + **多对多**：产生中间关系表，引入两端的表的主键作为外键，两个引入进来的主键组成一个**联合主键**或使用新的字段作为主键。

> 在Java中同样也可以通过对象进行关系描述：
>
> + 一对一：在本类中定义对方类型的对象，如A类中定义B类类型的属性b，B类中定义A美类型的属性a；
> + 一对多：一个A类类型对应多个B类类型的情况，需要在A美中**以集合的方式**引入B类类型的对象，在B中定义A类类型的属性a；
> + 多对多：在A类中定义B类类型的集合，在B类中定义A类类型的集合。

## XML 实现关联映射

在 MyBatis 的映射文件中，我们可以通过在元素 `<resultMap>` 中的配置实现关联映射：

+ `association` ：从一到一联映射，比如从用户角度看身份证号，就是一种从一到一的关联映射。

- `collection`：从一到多关联映射，比如从用户角度看手机号，就是一种从一到多的关联映射。
- ~~`discriminator`：鉴别器，它是一个根据某些条件决定采用具体实现类关联映射的方案。~~

三种表间关联关系解决方案：

+ 数据库中一对一：MyBatis用两个 `association`。
+ 数据庠中一对多：MyBatis用一个 `association` ，一个 `collection`。
+ 数据库中多对多：有中间表，MyBatis用两次一对多关联映射（即两次 `association` 和 `collection` )。



### 处理字段和属性的映射关系

当字段名和实体类中的属性名不一致，但是字段名**符合数据库的命名规则（使用`_`）**，实体类中的属性名**符合 Java 的规则**（使用驼峰），此时可以通过以下两种方法：

+ 通过查询时为字段**起别名**的方法，保证字段名和属性名保持一致：
  🌰 例子：

  ```sql
  <!-- List<Emp> getAllEmp();-->
  <select id="getAllEmp" resultType="Emp">
      select eid, emp_name empName, age, sex, email
      from emp
  </select>
  ```

+ 通过在 MyBatis 的核心配置文件中设置一个全局配置信息，在`<settings>` 标签中设置属性 `mapUnderscoreToCamelCase` ，可以在查询表中数据时，自动将 `_` 类型的字段名转换为驼峰命名法的属性名：
  🌰 例子：字段名为 `user_name` 转换为 `userName`;

  在核心配置文件中：

  ```xml
  <settings>
      <!--将_自动映射为驼峰-->
      <setting name="mapUnderscoreToCamelCase" value="true"/>
  </settings>
  ```

  

+ 通过 `ResultMap` 设置自定义映射的方法：

🌰 例子：查询所有的员工信息：

```xml
<mapper namespace="com.mybatis.mapper.EmpMapper">
    <resultMap id="empResultMap" type="Emp">
        <id property="eid" column="eid"></id>
        <id property="empName" column="emp_name"></id>
        <id property="age" column="age"></id>
        <id property="sex" column="sex"></id>
        <id property="email" column="email"></id>
    </resultMap>
    <!-- List<Emp> getAllEmp();-->
    <select id="getAllEmp" resultMap="empResultMap">
        select *
        from emp
    </select>
    <!--<select id="getAllEmp" resultType="Emp">
        select eid, emp_name, age, sex, email
        from emp
    </select>-->
</mapper>
```

> `resultMap` 下的属性：
>
> + `id` ：表示自定义映射的唯一标识；
> + `type` ：查询的数据**要映射的实体类的类型**；
>
> 子标签说明：
>
> +  `id` ：设置主键的映射关系；
>
> +  `result`：设置普通字段的映射关系；
> +  `association` ：设置多对一的映射关系；
> +  `collection` ：设置一对多的映射关系；
>
> 属性说明：
>
> + `property` ：设置映射关系中的**属性名**；
> + `column` ：设置映射关系中表中的**字段名**；



### 一对一映射关系

使用 `association` 元素解决一对一的映射关系，其中子元素的属性:

+ `property` ：指定映射到的Java实体类对象属性，与表外键字段对应。
+ `javaType` ：指定映射到 Java 实体类对象属性的数据类型。
+ `column`：指定数据库表中对应的字段，一般外键。
+ `select`：指定引入嵌套查询的子 SQL 语句，该属性用于关联映射中的嵌套查询
+ `fetchType` ：指定在关联查询时是否启用延迟加载，该属性有 `lazy` 和 `eager` 两个属性值。



🌰 例子：有两个一对一关联的表 `user` 表和 `idcard` 表：

::: details

+ 根据数据库表，编写持久化类 `User` 类和 `IdCard` 类，节选：

```java
public class User {
    private int id;
    private String name;
    private int age;
    private String sex;
    private String address;
    private IdCard idCard;
}	
```

```java
public class IdCard {
    private int cid;
    private int uid;
    private String code;
    User user;
}
```

+ `IdCardMapper` 映射：

```java
public interface IdCardMapper {
    List<IdCard> findAll();
    IdCard findByUid();
    IdCard findByCode(String code);
}
```

```xml
<mapper namespace="com.simon.mapper.IdCardMapper">
    <resultMap id="idCardMap" type="IdCard">
        <id property="cid" column="cid"/>
        <result property="code" column="code"/>
        <association property="user" javaType="User"
                     column="uid" select="findById"/>
    </resultMap>

    <!--List<IdCard> findAll();-->
    <select id="findAll" resultType="IdCardMap">
        SELECT *
        FROM idcard
    </select>

    <!--IdCard findByUid();-->
    <select id="findByUid" resultMap="IdCardMap">
        SELECT *
        FROM idcard
        WHERE uid = #{uid}
    </select>

    <!--IdCard findByCode(String code)-->
    <select id="findByCode" resultMap="idCardMap">
        SELECT *
        FROM idcard
        WHERE code = #{code}
    </select>
</mapper>
```

+ `UserMapper` 映射：

```java
public interface UserMapper {
    List<User> findAll();
    User findById(int id);
    List<User> findByAgeSex(int age, String sex);
}
```

```xml
<mapper namespace="com.simon.mapper.UserMapper">
    <resultMap id="UserMap" type="User">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <result property="sex" column="sex"/>
        <result property="address" column="address"/>
        <association property="idcard" javaType="IdCard"
                     column="id" select="findByUid"/>
    </resultMap>
    <!--List<User> findAll();-->
    <select id="findAll" resultMap="UserMap">
        SELECT *
        FROM user
    </select>

    <!--User findById(int id);-->
    <select id="findById">
        SELECT *
        FROM user
        WHERE id = #{id}
    </select>

    <!--List<User> findByAgeSex(int age, String sex);-->
    <select id="findByAgeSex">
        SELECT *
        FROM user
        WHERE age > #{param1}
          AND sex = #{param2}
    </select>
</mapper>
```

+ `UserMapperTest` 和 `IdCardMapperTest` 的测试：

```java
@Test
public void testFindAll() {
    List<User> userList = userMapper.findAll();
    for (User user : userList) {
        if (user != null){
            System.out.println(user);
            System.out.println(user.getIdCard());
        }
    }
}
```

```java
@Test
public void testFindAll() {
    List<IdCard> idCards = idCardMapper.findAll();
    for (IdCard idCard : idCards) {
        if (idCard != null){
            System.out.println(idCard);
            System.out.println(idCard.getUser());
        }
    }
}
```

+ 测试 `User` 复杂查询：年龄大于 20，性别为 M 的用户的 IdCard 数据。

```java
@Test
public void testFindUserByAgeSex(){
    List<User> userList = userMapper.findByAgeSex(20, "M");
    for (User user : userList) {
        if(user!=null) {
            System.out.println(user);
            System.out.println(user.getIdCard());
        }
    }
}
```

::: 



**MyBatis 加载关联关系对象主要通过两种方式**：

+ 通过**嵌套查询方法**：通过执行另一条 SQL 映射语句来返回预期的复杂类型。
  + 查询 SQL 中嵌入一个子查询 SQL
  + 会执行多条 SQL 语句
  + 语句编写较为简单
+ 通过**嵌套结果方式**：是使用嵌套结果映射来处理重复的联合结果的子集：
  + 一个嵌套的多表查询 SQL 
  + 只会执行一条复杂的 SQL 语句
  + 语句编写的比较复杂



🌰 上面 `User` 和 `IdCard` 的例子，使用嵌套查询方式。

🌰 以下使用嵌套结果方式完成 `User` 和 `IdCard` 的关系查询：

::: details

+ `IdCardMapper` ：

```java
<mapper namespace="com.simon.mapper.IdCardMapper">
    <resultMap id="IdCardMap" type="IdCard">
        <id property="cid" column="cid"/>
        <result property="uid" column="uid"/>
        <result property="code" column="code"/>
        <association property="user" javaType="User">
            <id property="id" column="uid"/>
            <result property="name" column="name"/>
            <result property="age" column="age"/>
            <result property="sex" column="sex"/>
            <result property="address" column="address"/>
        </association>
    </resultMap>

    <!--List<IdCard> findAll();-->
    <select id="findAll" resultMap="IdCardMap">
        SELECT *
        FROM idcard,
             user
        WHERE idcard.uid = user.id
    </select>

    <!--IdCard findByUid();-->
    <select id="findByUid" resultMap="IdCardMap">
        SELECT *
        FROM idcard,
             user
        WHERE uid = #{uid}
          AND idcard.uid = user.id
    </select>

    <!--IdCard findByCode(String code)-->
    <select id="findByCode" resultMap="IdCardMap">
        SELECT *
        FROM idcard,
             user
        WHERE code = #{code}
          AND idcard.uid = user.id
    </select>
</mapper>
```

+ `UserMapper` ：

```java
<mapper namespace="com.simon.mapper.UserMapper">
    <resultMap id="UserMap" type="User">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <result property="sex" column="sex"/>
        <result property="address" column="address"/>
        <association property="idCard" javaType="IdCard">
            <id property="uid" column="id"/>
            <result property="cid" column="cid"/>
            <result property="code" column="code"/>
        </association>
    </resultMap>
    <!--List<User> findAll();-->
    <select id="findAll" resultMap="UserMap">
        SELECT *
        FROM user,
             idcard
        where user.id = idcard.uid
    </select>

    <!--User findById(int id);-->
    <select id="findById" resultMap="UserMap">
        SELECT *
        FROM user,
             idcard
        WHERE id = #{id}
          AND user.id = idcard.uid
    </select>

    <!--List<User> findByAgeSex(int age, String sex);-->
    <select id="findByAgeSex" resultMap="UserMap">
        SELECT *
        FROM user,
             idcard
        WHERE age > #{param1}
          AND sex = #{param2}
          AND user.id = idcard.uid
    </select>
</mapper>
```

::: 



### 多对一映射关系



🌰 例子：查询员工以及部门信息：

```xml
<!--Emp getEmpAndDept(@Param("eid") Integer eid);-->
<select id="getEmpAndDept" resultMap="EmpAndDeptResultMapTwo">
    select * from emp left join dept on emp.did = dept.did where emp.eid = #{eid}
</select>
```

:one: 方法一：**级联方式赋值**：

```xml
<resultMap id="EmpAndDeptResultMapOne" type="Emp">
    <id property="eid" column="eid"></id>
    <result property="empName" column="emp_name"></result>
    <result property="age" column="age"></result>
    <result property="sex" column="sex"></result>
    <result property="email" column="email"></result>
    <result property="dept.did" column="did"></result>
    <result property="dept.deptName" column="dept_name"></result>
</resultMap>
```



:two: 方法二：通过 `association` 标签实现：

```xml
<resultMap id="EmpAndDeptResultMapTwo" type="Emp">
    <id property="eid" column="eid"></id>
    <result property="empName" column="emp_name"></result>
    <result property="age" column="age"></result>
    <result property="sex" column="sex"></result>
    <result property="email" column="email"></result>
    <association property="dept" javaType="Dept">
        <id property="did" column="did"></id>
        <result property="deptName" column="dept_name"></result>
    </association>
</resultMap>
```

> `property`：需要处理多对的映射关系的属性名
>
> `javaType`： 该属性的类型



:three: :star: 分布查询：

🌰 例子：分布查询员工信息和部门信息

第一步：先查询员工信息

```xml
<!--Emp getEmpAndDeptByStepOne(@Param("eid") Integer eid);-->
<select id="getEmpAndDeptByStepOne" resultMap="getEmpAndDeptByStepResultMapOne">
    select *
    from emp
    where eid = #{eid}
</select>
```

第二步：通过 `did` 查询员工所对应的部门：

```xml
<!--Dept getEmpAndDeptByStepTwo(@Param("did") Integer did);-->
<select id="getEmpAndDeptByStepTwo" resultType="Dept">
    select * from dept where did = #{did}
</select>
```

第一步中用到的 `resultMap` ：

```xml
<resultMap id="getEmpAndDeptByStepResultMapOne" type="Emp">
    <id property="eid" column="eid"></id>
    <result property="empName" column="emp_name"></result>
    <result property="age" column="age"></result>
    <result property="sex" column="sex"></result>
    <result property="email" column="email"></result>
    <association property="dept" select="com.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo"
                 column="did"></association>
</resultMap>
```

> :star: `select`： 设置分布查询，查询某个属性的值的 SQL 唯一标识（ `namespace.sqlId` 或 mapper 接口的**全类名**（可以通过 「`copy reference`」获取））
>
> `colomn`：将 SQL 以及查**询结果的某个字段**设置为分布查询的条件。

可以看到，分布查询的好处是可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息 （`settings` 标签）：

+ `lazyLoadingEnabled` ：延迟加载的全局开关，当开启时，所有关联对象都会延迟加载。

+ `aggressiveLazyLoading`：开启时任何方法都会加载该对象的**所有属性**，否则会按需加载。默认为 `false`。

  ```xml
  <settings>
      <setting name="lazyLoadingEnabled" value="true"/>
  </settings>
  ```

+ 设置延迟加载后：可以按需加载，就只会执行相应的 sql。

  🌰 例子：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java 

开启延迟加载后，单独获取员工的信息和部门信息：

```java
@Test
public void testgetEmpAndDeptByStep(){
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Emp emp = mapper.getEmpAndDeptByStepOne(3);
    System.out.println(emp.getEmpName());
    System.out.println("-----------");
    System.out.println(emp.getDept());
}
```

:::

::: tab result

```sql
DEBUG 03-08 13:58:46,720 ==>  Preparing: select * from emp where eid = ? (BaseJdbcLogger.java:137) 
DEBUG 03-08 13:58:46,754 ==> Parameters: 3(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-08 13:58:46,807 <==      Total: 1 (BaseJdbcLogger.java:137) 
王五
-----------
DEBUG 03-08 13:58:46,808 ==>  Preparing: select * from dept where did = ? (BaseJdbcLogger.java:137) 
DEBUG 03-08 13:58:46,809 ==> Parameters: 3(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-08 13:58:46,810 <==      Total: 1 (BaseJdbcLogger.java:137) 
Dept{did=3, deptName='C'}
```

可以看到，需要那一部分的信息就只会运行某一部分的查询语句，而不会全部查询全部运行。

:::

::::

+ 某个查询不需要延迟加载时，在全局开启延迟加载的情况下，可以通过在 `association` 标签中设置属性 `fetchType="lazy|eager"`，默认 `lazy` 值表示需要延迟加载，`eager` 值表示为当前 `resultMap` 立即加载。

  🌰 例子，关闭延迟加载后：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java 

mapper 配置中：

```xml
<resultMap id="getEmpAndDeptByStepResultMapOne" type="Emp">
    <id property="eid" column="eid"></id>
    <result property="empName" column="emp_name"></result>
    <result property="age" column="age"></result>
    <result property="sex" column="sex"></result>
    <result property="email" column="email"></result>
    <association property="dept" select="com.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo"
                 column="did" fetchType="eager"></association>
</resultMap>
```

:::

::: tab result

运行前面例子：分别查询员工信息和部门信息时：

```sql
DEBUG 03-08 14:03:48,605 ==>  Preparing: select * from emp where eid = ? (BaseJdbcLogger.java:137) 
DEBUG 03-08 14:03:48,636 ==> Parameters: 3(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-08 14:03:48,655 ====>  Preparing: select * from dept where did = ? (BaseJdbcLogger.java:137) 
DEBUG 03-08 14:03:48,656 ====> Parameters: 3(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-08 14:03:48,660 <====      Total: 1 (BaseJdbcLogger.java:137) 
DEBUG 03-08 14:03:48,660 <==      Total: 1 (BaseJdbcLogger.java:137) 
王五
-----------
Dept{did=3, deptName='C'}
```

:::

::::



### 一对多映射关系



🌰 员工与部门的关系：

+  多对一时，对应一个对象，例如职员对应一个部门。
+ 一对多时，对应一个集合，例如部门对应多个职员。

**方法一： 集合查询 `collection` **

查询部门以及部门中所有员工的信息：

+ mapper 配置：

```xml
<!--Dept getDeptAndEmp(@Param("did") Integer did);-->
<select id="getDeptAndEmp" resultMap="DeptAndEmpResultMap">
    select * from dept left join emp on dept.did = emp.did where dept.did = #{did}
</select>
```

:star: `ResultMap` 配置：

```xml
<resultMap id="DeptAndEmpResultMap" type="Dept">
    <id property="did" column="did"></id>
    <result property="deptName" column="dept_name"></result>
    <collection property="emps" ofType="Emp">
        <id property="eid" column="eid"></id>
        <result property="empName" column="emp_name"></result>
        <result property="age" column="age"></result>
        <result property="sex" column="sex"></result>
        <result property="email" column="emalil"></result>
    </collection>
</resultMap>
```

> `collection`：处理一对多的映射关系。
>
> `ofType`：与 `javaType` 对应设置 `collection` 标签所处理的集合属性中存储数据的类型。（例如，集合类型为员工实体类型）

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java

```java
@Test
public void testGetDeptAndEmp(){
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
    Dept deptAndEmp = mapper.getDeptAndEmp(2);
    System.out.println(deptAndEmp);
}
```

:::

::: tab result

```sql
DEBUG 03-09 10:13:31,325 ==>  Preparing: select * from dept left join emp on dept.did = emp.did where dept.did = ? (BaseJdbcLogger.java:137) 
DEBUG 03-09 10:13:31,357 ==> Parameters: 2(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-09 10:13:31,386 <==      Total: 2 (BaseJdbcLogger.java:137) 
Dept{did=2, deptName='B', emps=[Emp{eid=2, empName='李四', age=18, sex='女', email='null', dept=null}, Emp{eid=5, empName='田七', age=20, sex='女', email='null', dept=null}]}
```

:::

::::

方法二：分布查询。

例子： 先查询出部门信息，在查询出部门中的员工信息。

+ 第一步：查询部门信息

```xml
<!--Dept getDeptAndEmpByStepOne(@Param("did") Integer did);-->
<select id="getDeptAndEmpByStepOne" resultMap="deptAndEmpByStepResultMap">
    select * from dept where did = #{did}
</select>
```

:star: `ResultMap` 配置：

```xml
<resultMap id="deptAndEmpByStepResultMap" type="Dept">
    <id property="did" column="did"></id>
    <result property="deptName" column="dept_name"></result>
    <collection property="emps" select="com.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo" column="did"></collection>
</resultMap>
```

> `collection` 标签配置属性与 `association` 属性类似。

+ 根据部门 `id` 获取员工信息：

```xml
<!--List<Emp> getDeptAndEmpByStepTwo(@Param("did")Integer did);-->
<select id="getDeptAndEmpByStepTwo" resultType="Emp">
    select *
    from emp
    where did = #{did}
</select>
```

+ 测试：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java

```java
@Test
public void testGetDeptAndEmpByStep(){
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
    Dept dept = mapper.getDeptAndEmpByStepOne(1);
    System.out.println(dept);
}}
```

:::

::: tab result

```sql
DEBUG 03-09 10:24:58,173 ==>  Preparing: select * from dept where did = ? (BaseJdbcLogger.java:137) 
DEBUG 03-09 10:24:58,204 ==> Parameters: 1(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-09 10:24:58,256 <==      Total: 1 (BaseJdbcLogger.java:137) 
DEBUG 03-09 10:24:58,257 ==>  Preparing: select * from emp where did = ? (BaseJdbcLogger.java:137) 
DEBUG 03-09 10:24:58,258 ==> Parameters: 1(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-09 10:24:58,262 <==      Total: 2 (BaseJdbcLogger.java:137) 
Dept{did=1, deptName='A', emps=[Emp{eid=1, empName='张三', age=20, sex='男', email='123@qq.com', dept=null}, Emp{eid=4, empName='赵六', age=18, sex='男', email='455@163.com', dept=null}]}
```

> 可以看到运行了两次查询 SQL 语句，进行了分步查询。

:::

::::



🌰 `User` 与 `PhoneCard` 的关系：一个 `User` 可以对应多个 `PhoneCrad` ：

::: details

+ `User` 类 和 `PhoneCard` 类：

```java
public class User {
    private int id;
    private String name;
    private int age;
    private String sex;
    private String address;
    private List<PhoneCard> phoneCardList;
}
```

```Java
public class PhoneCard {
    private int pid;
    private String phoneNo;
    private int uid;
    private User user;
```

**方法一：分步查询**：

+ `UserMapper` ：

```java
public interface UserMapper {
    List<User> findAll();
    User findById(int id);
}
```

```xml
<mapper namespace="com.simon.mapper.UserMapper">
    <resultMap id="UserMap" type="User">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <result property="sex" column="sex"/>
        <result property="address" column="address"/>
        <collection property="phoneCardList" ofType="PhoneCard"
                    column="id" select="com.simon.mapper.PhoneCardMapper.findByUid"/>
    </resultMap>
    <!--List<User> findAll();-->
    <select id="findAll" resultMap="UserMap">
        SELECT *
        FROM user
    </select>

    <!--User findById(int id);-->
    <select id="findById" resultMap="UserMap">
        SELECT *
        FROM user
        WHERE id = #{id}
    </select>

</mapper>
```

+ `PhoneCardMapper` ：

```java
public interface PhoneCardMapper {
    List<PhoneCard> findAll();
    List<PhoneCard> findByUid(int uid);
}
```

```xml
<mapper namespace="com.simon.mapper.PhoneCardMapper">
    <resultMap id="PhoneCardMap" type="PhoneCard">
        <id property="pid" column="pid"/>
        <result property="phoneNo" column="phone_no"/>
        <result property="uid" column="uid"/>
        <association property="user" javaType="User" column="uid"
                    select="com.simon.mapper.UserMapper.findById"/>
    </resultMap>

    <select id="findAll" resultMap="PhoneCardMap">
        SELECT *
        FROM phonecard
    </select>

    <select id="findByUid" resultMap="PhoneCardMap">
        SELECT *
        FROM phonecard
        WHERE uid = #{uid}
    </select>
</mapper>
```

:::



### 多对多映射关系



🌰 用户 / 地点 / 门票：一个用户到多个地方游玩，一个地方有多个用户来玩，有中间表 `ticket` ，所以使用 **一个 `association` ，一个 `collection` 来实现** ：

::: details

```sql
create table spot
(
    sid     int      not null,
    address char(10) not null
);

INSERT INTO spot (sid, address) VALUES (1, '故宫');
INSERT INTO spot (sid, address) VALUES (2, '秦岭');
INSERT INTO spot (sid, address) VALUES (3, '西湖');
INSERT INTO spot (sid, address) VALUES (4, '桂林');
```

```sql
create table ticket
(
    tid int not null,
    uid int not null
);

INSERT INTO ticket (uid, tid) VALUES (1, 1);
INSERT INTO ticket (uid, tid) VALUES (1, 4);
INSERT INTO ticket (uid, tid) VALUES (2, 1);
INSERT INTO ticket (uid, tid) VALUES (2, 2);
INSERT INTO ticket (uid, tid) VALUES (2, 3);
INSERT INTO ticket (uid, tid) VALUES (3, 2);
INSERT INTO ticket (uid, tid) VALUES (5, 1);
INSERT INTO ticket (uid, tid) VALUES (5, 4);
```

+ `TicketMapper` ：

```xml
<mapper namespace="com.simon.mapper.TicketMapper">
    <resultMap id="TicketMap" type="Ticket">
        <id property="tid" column="tid"/>
        <id property="uid" column="uid"/>
        <association property="user" javaType="User"
                     column="uid" select="com.simon.mapper.UserMapper.findById"/>
        <association property="spot" javaType="Spot"
                     column="tid" select="com.simon.mapper.SpotMapper.findBySid"/>
    </resultMap>

    <select id="findByUid" resultMap="TicketMap">
        SELECT * FROM ticket WHERE uid = #{uid}
    </select>

    <select id="findByTid" resultMap="TicketMap">
        SELECT * FROM ticket WHERE tid = #{tid}
    </select>
</mapper>
```

+ `UserMapper`：

```xml
<mapper namespace="com.simon.mapper.UserMapper">
    <resultMap id="UserMap" type="User">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <result property="sex" column="sex"/>
        <result property="address" column="address"/>
        <!--<association property="idCard" javaType="IdCard" column="id" select="com.simon.mapper.IdCardMapper.findByUid"/>-->
        <!--<collection property="phoneCardList" ofType="PhoneCard"
                    column="id" select="com.simon.mapper.PhoneCardMapper.findByUid"/>-->
        <collection property="ticketList" ofType="Ticket"
                    column="id" select="com.simon.mapper.TicketMapper.findByUid"/>
    </resultMap>
    <!--List<User> findAll();-->
    <select id="findAll" resultMap="UserMap">
        SELECT *
        FROM user
    </select>

    <!--User findById(int id);-->
    <select id="findById" resultMap="UserMap">
        SELECT *
        FROM user
        WHERE id = #{id}
    </select>
</mapper>
```

+ `SpotMapper`：

```xml
<mapper namespace="com.simon.mapper.SpotMapper">
    <resultMap id="SpotMap" type="Spot">
        <id property="sid" column="sid"/>
        <result property="address" column="address"/>
        <collection property="ticketList" ofType="Ticket"
                    column="sid" select="com.simon.mapper.TicketMapper.findByTid"/>
    </resultMap>

    <select id="findAll" resultMap="SpotMap">
        SELECT *
        FROM spot
    </select>

    <select id="findBySid" resultMap="SpotMap">
        SELECT *
        FROM spot
        WHERE sid = #{sid}
    </select>
</mapper>
```

+ 分别在 `UserMapperTest` 和 `SpotMapperTest` 中测试，通过 `Ticket` 中间表查询：

+ 测试由用户查所到的地点：

```java
@Test
public void testFindAll() {
    List<User> userList = userMapper.findAll();
    for (User user : userList) {
        if (user != null) {
            System.out.println(user);
            for (Ticket ticket : user.getTicketList()) {
                System.out.println(ticket);
                if (ticket != null) {
                    System.out.println(ticket.getSpot());
                }
            }
        }
    }
}
```

+ 测试由地点查询哪些用户到过：

```java
@Test
public void findAll() {
    List<Spot> spotList = spotMapper.findAll();
    for (Spot spot : spotList) {
        if (spot != null) {
            System.out.println(spot);
            for (Ticket ticket : spot.getTicketList()) {
                if(ticket!=null) {
                    System.out.println(ticket.getUser());
                }
            }
        }
    }
}
```

:::

+ 对于一些简单的查询，可以不必如同前面那样按部就班把所有映射编写， 也可以直接使用连接查询完成：
+ 🌰 查询去过某地的用户：
+  `SpotMapper` 中：

```xml
<select id="findBySpotName" resultType="User" parameterType="String">
    SELECT user.name
    FROM user,
         spot,
         ticket
    WHERE user.id = ticket.uid
    AND spot.sid = ticket.tid AND spot.address = #{spotName}
</select>
```



## 注解实现关联映射



🌰 使用注解实现 用户 与 电话卡的关联：

::: details 

> `@Many` 注解：实现 XML 配置文件中 `collection` 的功能

+ `UserMapper` ：

```java
public interface UserMapper {

    @Select("SELECT * FROM user")
    @Results(id = "UserMap", value = {
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "name", property = "name"),
            @Result(column = "age", property = "age"),
            @Result(column = "sex", property = "sex"),
            @Result(column = "address", property = "address"),
            @Result(column = "id", property = "phoneCardList",
                many = @Many(select = "com.simon.mapper.PhoneCardMapper.findByUid",
                fetchType = FetchType.EAGER))
    })
    List<User> findAll();

    @Select("SELECT * FROM user WHERE id = #{id}")
    @ResultMap("UserMap")
    User findById(int id);
}
```



> `@One` 注解：实现 XML 配置文件中的 `association` 的功能。

+ `PhoneCardMapper` ：

```java
public interface PhoneCardMapper {
    @Select("SELECT * FROM phonecard")
    @Results(id = "PhoneCardMap", value = {
            @Result(id = true, column = "pid", property = "pid"),
            @Result(column = "phone_no", property = "phoneNo"),
            @Result(column = "uid", property = "uid"),
            @Result(column = "uid", property = "user", one = @One(
                    select = "com.simon.mapper.UserMapper.findById",
                    fetchType = FetchType.EAGER
            ))
    })
    List<PhoneCard> findAll();

    @Select("SELECT * FROM phonecard WHERE uid = #{uid}")
    @ResultMap("PhoneCardMap")
    List<PhoneCard> findByUid(int uid);
}
```

:::