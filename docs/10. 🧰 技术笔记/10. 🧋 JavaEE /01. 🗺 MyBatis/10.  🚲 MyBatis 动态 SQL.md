---
0title: 🚲 MyBatis 动态 SQL
date: 2022-03-21 09:27:22
permalink: /pages/a1647a/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🗺 MyBatis
tags: 
  - null
title: 🚲 MyBatis 动态 SQL
author: 
  name: Simon
  link: https://github.com/simon1uo
---
MyBatis 框架的动态 SQL 技术是一种根据**特定条件**动态拼装 SQL 语句的功能，它存在的意义是为了**解决拼接 SQL 语句字符串时的痛点问题**。

## 映射文件实现动态 SQL

### `if` 标签

`if` 标签可以通过 `test` 属性的表达式进行判断，如果表达式的结果为 `true` ，则标签中的内容会执行，**反之标签中的内容不会执行**。

🌰 例子：根据员工信息条件查询员工信息：

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
    select *
    from emp
    where 1 = 1
    <if test="empName != null and empName != ''">
        emp_name = #{empName}
    </if>
    <if test="age != null and age != ''">
        and age = #{age}
    </if>
    <if test="sex != null and sex != ''">
        and sex = #{sex}
    </if>
    <if test="email != null and email != ''">
        and email = #{email}
    </if>
</select>
```

> 注意 `where 1=1` 条件的使用：**使得where条件语句永远为真**。本质上就是虽然加了where条件，但实际上永远为真，也就相当于没有加任何约束条件。
>
> 🔗 相关阅读：[不要再使用 where 1=1 了，有更好的写法](https://segmentfault.com/a/1190000041474982)



### `where` 标签

通常与 `if` 标签结合使用：

+ 当 `where` 标签中的 `if` 条件都不满足时，则 `where` 标签中没有任何功能，即不会添加 `where`  关键字到 SQL 语句中。
+ 若 `where` 标签中的 `if` 条件满足，则 `where` 标签会自动添加 `where` 关键字，并**将条件最前方多余的 `and` 或者 `or`去掉**。（no more `where 1=1` ）
  + ⚠️ 注意：`where` 标签不能去掉**条件最后**多余的 `and`。所以最好写在条件前。

🌰 例子：用 `where` 标签条件查询员工信息：
:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab code

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
    select *
    from emp
    <where>
        <if test="empName != null and empName != ''">
            emp_name = #{empName}
        </if>
        <if test="age != null and age != ''">
            or age = #{age}
        </if>
        <if test="sex != null and sex != ''">
            and sex = #{sex}
        </if>
        <if test="email != null and email != ''">
            and email = #{email}
        </if>
    </where>
</select>
```

```java
@Test
public void getEmpByCondition(){
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);
    List<Emp> empByCondition = mapper.getEmpByCondition(new Emp(null, null, null, "", ""));
    empByCondition.forEach(emp -> System.out.println(emp));
}
```

:::

::: tab result

```sql
DEBUG 03-09 12:27:32,409 ==>  Preparing: select * from emp (BaseJdbcLogger.java:137) 
DEBUG 03-09 12:27:32,445 ==> Parameters:  (BaseJdbcLogger.java:137) 
DEBUG 03-09 12:27:32,471 <==      Total: 5 (BaseJdbcLogger.java:137) 
Emp{eid=1, empName='张三', age=20, sex='男', email='123@qq.com', dept=null}
Emp{eid=2, empName='李四', age=18, sex='女', email='455@163.com', dept=null}
Emp{eid=3, empName='王五', age=18, sex='女', email='455@163.com', dept=null}
Emp{eid=4, empName='赵六', age=18, sex='男', email='455@163.com', dept=null}
Emp{eid=5, empName='田七', age=20, sex='女', email='455@163.com', dept=null}
```

:::

::::



### `trim` 标签

常用于**去掉或者添加标签中的内容**，常用属性：

> + `prefix` ：在 `trim` 标签中的内容**前面添加**某些内容。
> + `prefixOverriders`：在 `trim` 标签中的内容**前面去掉**某些内容。
> + `suffix` ：在 `trim` 标签中的内容**后面添加**某些内容。
> + `suffixOverrides` ：在 `trim` 标签中的内容**后面去掉**某些内容。

若标签中没有内容时，`trim` 标签中没有效果。

🌰 例子：

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
    select *
    from emp
    <trim prefix="where" suffixOverrides="and|or">
        <if test="empName != null and empName != ''">
            emp_name = #{empName}
        </if>
        <if test="age != null and age != ''">
            and age = #{age}
        </if>
        <if test="sex != null and sex != ''">
            sex = #{sex} and
        </if>
        <if test="email != null and email != ''">
            email = #{email} and
        </if>
    </trim>
</select>
```



### `choose` / `when` / `otherwise` 

相当于 Java 中的 `if ... else ... if ... else ` 。只要其中一个 `when` 标签符合，不符合则执行 `otherwise` 中的内容。其中 `when` 标签至少有一个，`otherwise` 最多只能有一个。

🌰 例子：条件查询员工信息：

```xml
<!--List<Emp> getEmpByChoose(Emp emp);-->
<select id="getEmpByChoose" resultType="Emp">
    select * from emp
    <where>
        <choose>
            <when test="empName != null and empName != ''">
                emp_name = #{empName}
            </when>
            <when test="age != null and age != ''">
                age = #{age}
            </when>
            <when test="sex != null and sex != ''">
                sex = #{sex}
            </when>
            <when test="email != null and email != ''">
                email = #{email}
            </when>
            <otherwise>
                did = 1
            </otherwise>
        </choose>
    </where>
</select>
```



🌰 例子：查询用户信息（互斥选项）

::: details

+ `UserMapper`：

```xml
<!--List<User> findByChoose(User user);-->
<select id="findByChoose" parameterType="User" resultType="User">
    SELECT * FROM user WHERE 1 = 1
    <choose>
        <when test="name!=null">
            AND name LIKE #{name}
        </when>
        <otherwise>
            AND sex = #{sex}
        </otherwise>
    </choose>
</select>
```

+ 测试类：

```java
@Test
public void testFindByChoose() {
    User user = new User();
    // user.setName("%李%");
    user.setSex("F");
    List<User> users = userMapper.findByChoose(user);
    users.forEach(userout -> System.out.println(userout));
}
```

:::





### `foreach` 

`foreach` 元素是一个循环语句，**它的作用是遍历集合**，它能够很好地支持数组和 `List`、`Set` 接口的集合，对此提供遍历功能。它往往用于 SQL 中的 `in` 关键字。

`foreach` 标签下的属性：

+ `collection` ：设置要循环的数组 `Array` 或者集合 `List` 、`Map` 或者 `Collection` 。注意要在 mapper 接口中编写方法时用**注解法注解参数名称**，否则只能使用 MyBatis 预设参数名称读取数组或集合。
+ `item` ：表示**集合或数组**中的每一数据。
+ `sparator`：设置循环体之间的分隔符号。（MyBatis 会自动在前后添加空格）（例如，在 `in (..., ...)` 中的 `,`；`or`）
+ `open`：设置 `foreach` 标签中的内容的**开始符号**；
+ `close` ：设置 `foreach` 标签中的内容的**结束符号**；



🌰 例子：批量查询用户信息：

+ `UserMapper` ：

```xml
<!--List<User> findByIds(List<Integer> ids);-->
<select id="findByIds" resultType="User">
    SELECT * FROM user WHERE id IN
    <foreach collection="list" index="index" item="id" open="(" close=")" separator=",">#{id}</foreach>
</select>
```

+ 测试：

```java
@Test
public void testFindByIds(){
    ArrayList<Integer> ids = new ArrayList<>();
    ids.add(1);
    ids.add(2);
    List<User> userList = userMapper.findByIds(ids);
    userList.forEach(user -> System.out.println(user));
}
```



🌰 例子：批量删除员工信息：

方法一：使用 `in (…, …, …)`：

```xml
<!--int deleteMoreByArray(@Param("eids") Integer[] eids);-->
<delete id="deleteMoreByArray">
    delete from emp where eid in
        <foreach collection="eids" item="eid" separator="," open="(" close=")">
        #{eid}
        </foreach>
</delete>
```

方法二：使用 `or` ：

```xml
<delete id="deleteMoreByArray">
    delete from emp where
    <foreach collection="eids" item="eid" separator="or">
       eid = #{eid}
    </foreach>
</delete>
```



🌰 例子：批量添加员工信息：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab code

+ `EmpMapper` 

```xml
<!--int insertMoreByList(@Param("emps") List<Emp> emps);-->
<insert id="insertMoreByList">
    insert into emp
    values
    <foreach collection="emps" item="emp" separator=",">
        (null, #{emp.empName}, #{emp.age},#{emp.sex}, #{emp.email},null)
    </foreach>
</insert>
```

+ 测试：

```java
@Test
public void testInsertByMoreByList() {
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);
    Emp emp1 = new Emp(null, "a1", 23, "男", "123@qq.com");
    Emp emp2 = new Emp(null, "a2", 23, "男", "123@qq.com");
    Emp emp3 = new Emp(null, "a3", 23, "男", "123@qq.com");
    List<Emp> emps = Arrays.asList(emp1, emp2, emp3);
    int result = mapper.insertMoreByList(emps);
    System.out.println(result);
}
```

:::

::: tab result

```sql
DEBUG 03-09 13:15:35,443 ==>  Preparing: insert into emp values (null, ?, ?,?, ?,null) , (null, ?, ?,?, ?,null) , (null, ?, ?,?, ?,null) (BaseJdbcLogger.java:137) 
DEBUG 03-09 13:15:35,483 ==> Parameters: a1(String), 23(Integer), 男(String), 123@qq.com(String), a2(String), 23(Integer), 男(String), 123@qq.com(String), a3(String), 23(Integer), 男(String), 123@qq.com(String) (BaseJdbcLogger.java:137) 
DEBUG 03-09 13:15:35,494 <==    Updates: 3 (BaseJdbcLogger.java:137) 
3
```

:::

::::



### `set` 标签

可以使用 `set` 元素避免将要在修改某个对象的某个字段时时，发送所有的字段给持久化对象的问题。**只把主键和要更新的字段的值传递给 SQL 去更新**。

🌰 例子：

+ `UserMapper`：

```xml
<!--int updateBySet(User user);-->
<update id="updateBySet" parameterType="User">
    UPDATE user
    <set>
        <if test="name!=null">
            name = #{name},
        </if>
        <if test="sex!=null">
            sex = #{sex}
        </if>
    </set>
    WHERE id = #{id}
</update>
```

+ 测试：

```java
@Test
public void testUpdateBySet(){
    User user = new User();
    user.setId(5);
    // user.setName("老赵");
    user.setSex("F");
    userMapper.updateBySet(user);
}
```



### `bind` 标签

`bind` 元素可以从 OGNL 表达式中创建一个自定义变量，这样更方便使用。

`bind` 元素中的属性说明：

+ `name` ：自定义的变量名。
+ `value` ：变量的表达式。

+ `_parameter` ：指传入的参数。



🌰 例子：模糊查询用户

+ `UserMapper` 中定义模糊查询变量的表达式：

```xml
<!--List<User> findByName(String name);-->
<select id="findByName" parameterType="String" resultType="User">
    <bind name="pattern" value="'%'+_parameter+'%'"/>
    SELECT * FROM user WHERE name LIKE #{pattern}
</select>
```

+ 测试：

```java
@Test
public void testFindByName(){
    List<User> userList = userMapper.findByName("张");
    userList.forEach(user -> System.out.println(user));
}
```



## 注解实现动态 SQL

使用 XML 能够完成的也可以使用注解方式完成，而且更为便捷。

在 MyBatis 使用注解 `@InsertProvider`、`@UpdateProvider`、`@DeleteProvider`、`@SelectProvider` 来帮助构建动态SQL语句。

注解中的参数：

+ `type` 参数：指定类的 `class` 属性，该类必须要通过无参的构造函数来进行初始化，
+ `method` 参数：指定的方法，该方法必须是 `public` 属性的，而且返回值必须为 `String` ，可以为非 `static` 或者 `static`。



🌰 例子：通过注解 `SelectProvider` 实现动态 SQL：

+ 创建类 `UserProvider` ，方法 `selectAllUser()` ：

```java
public class UserProvider {
    public String selectAllUser(){
        return "select * from user";
    }
}
```

+ `UserMapper` 接口：

```java
@SelectProvider(type = UserProvider.class, method = "selectAllUser")
List<User> findAllUser();
```



🌰 例子：通过 `SelectByProvider` 实现条件动态 SQL 查询：

+ 延续上述例子中的，在 `UserProvider` 类中创建方法 `SelectByIf` ：

```java
public String selectByIf(User user) {
    String sql = "select * from user where 1 = 1";
    if(user.getName() != null) {
        sql += "and name like '%" + user.getName() +"%'";
    } 
    if(user.getSex() != null) {
        sql += "and sex ='" + user.getSex() + "'";
    }
    return sql;
}
```

+ `UserMapper` 接口：

```java
@SelectProvider(type = UserProvider.class, method = "selectByIf")
List<User> findByIf(User user);
```



使用字符串拼接 SQL 的方法有时也比较麻烦，MyBatis 提供了一个 SQL 工具类，可以使用给类提供的方法来构造SQL语句。常见的方法有： 

+ `INSERT_INTO(String)`
+ `VALUES(String, String)`
+ `UPDATE(String)`
+ `SET (String)`
+ `WHERE(String)`
+ `DELETE_FROM (String)`
+ `SELECT(String)`
+ `FROM (String)`
+ `GROUP BY (String)`
+ `ORDER_ BY (String)`


### `@InsertProvider` 注解

使用  `@InsertProvider` 的映射文件以及使用 `INSERT_INTO`、`VALUES` 方法的 `Provider` 类完成动态 SQL 添加记录：

格式：

+ `INSERT_INTO(表名)`
+ `VALUES(属性名, 属性值)` 



🌰 例子：在 `user` 表中 `id` 为逐渐可自动添加值，但是 `name` 不可以为空并且没有默认值，这是如果 `name` 没有设值添加记录就不会成功。可以使用 动态 SQL 解决这个问题。

+ 在 `UserProvider` 类中添加方法 `insertBySQLCls`：

```java
public String insertBySQLCls(final User user) {
    return new SQL(){
        {
            INSERT_INTO("user");
            if (user.getName() != null) {
                VALUES("name", "#{name}");
            } else {
                VALUES("name", "'anonymous'");
            }
            VALUES("age", "#{age}");
            VALUES("sex", "#{sex}");
            VALUES("address", "#{address}");
        }
    }.toString();
}
```

+ `UserMapper` 接口：

```java
@InsertProvider(type = UserProvider.class, method = "insertBySQLCls")
int addBySQLCls(User user);
```



### `@UpdateProvider` 注解

使用 `@UpdateProvider` 的映射文件及使用 `UPDATE`、`SET`、`WHERE` 方法的 `Provider` 类完成动态 SQL 修改记录。

格式：

+ `UPDATE( 表名）`
+ `SET（ 属性名=属性值）`
+ `WHERE(条件）`



🌰 例子：在 `user` 表中修改 无名氏的信息，可能修改姓名，可能修改年龄，在修改哪个属性不确定的情况，可以使用动态 SQL 解决这个问题。

+ 在 `UserProvider` 类中添加方法 `updateBySQLCls`：

```java
public String updateBySQLCls(@Param("puser") final User user,
                             @Param("pcondi") final String condi) {
    return new SQL() {
        {
            UPDATE("user");
            if(user.getName() != null)
                SET("name=#{puser.name}");
            if(user.getAge() != 0)
                SET("age=#{puser.age}");
            if(user.getSex() != null)
                SET("sex=#{puser.sex}");
            if(user.getAddress() != null)
                SET("address=#{puser.address}");
            WHERE("name=#{pcondi}");
        }
    }.toString();

}
```

+ `UserMapper` 接口：

```java
@UpdateProvider(type = UserProvider.class, method = "updateBySQLCls")
int alterBySQLCls(@Param("puser") User user, @Param("pcondi") String condi);
```

+ 测试：

```java
@Test
public void testAlterBySQLCls(){
    User user = new User();
    user.setAge(60);
    user.setSex("F");
    user.setAddress("深圳");
    String str = "anonymous";
    System.out.println(userMapper.alterBySQLCls(user, str));
}
```



### `@DeleteProvider` 注解

使用 `@DeleteProvider` 的映射文件及使用 `DELETE FROM` 、`WHERE` 方法的 `Provider` 类完成动态 SQL 删除记录。

格式：

+ DELETE_ FROM( 表名）
+ WHERE（条件）



🌰 例子：在 `use` r表中删除年龄为 `60` ，同时 性別为 `F` 的记录（即无名
氏的记录），可以使用动态 SQL 解决：

+ 在 `UserProvider` 类中添加方法 `deleteBySQLCls`：

```java
public String deleteBySQLCls(@Param("page") int age, @Param("psex") String sex) {
    return new SQL(){
        {
            DELETE_FROM("user");
            WHERE("sex={psex} AND age={page}");
        }
    }.toString();
}
```

+ `UserMapper` 接口：

```java
@DeleteProvider(type = UserProvider.class, method = "deleteBySQLCls")
int removeBySQLCls(@Param("page") int age, @Param("psex") String sex);
```

+ 测试：

```java
@Test
public void testRemoveBySQLCls(){
    int age = 60;
    String sex = "F";
    System.out.println(userMapper.removeBySQLCls(age, sex));
}
```



### `@SelectProvider` 注解

使用 `@SelectProvider` 的映射文件及使用 `SELECT FROM`、
`WHERE`、 `GROUP_ BY`、 `ORDER_BY` 方法的 `Provider` 类完成动态 SQL 查找记录。

格式：

+ `SELECT(属性)`
+ `FROM(表名)`
+ `WHERE(条件)`
+ `GROUP_BY(属性)`
+ `ORDER_ BY(属性)`



🌰 例子：在 `user` 表中查找年龄为 `18` 岁以上的用户信息，并按照
年龄排序后输出。可以使用动态SQL完成。

+ 在 `UserProvider` 类中添加方法 `selectBySQLCls`：

```java
public String selectBySQLCls(final int age, final String ord){
    return new SQL(){
        {
            SELECT("*");
            FROM("user");
            WHERE("age>#{param1}");
            ORDER_BY(ord);
        }
    }.toString();
}
```

+ `UserMapper` 接口：

```java
@SelectProvider(type = UserProvider.class, method = "selectBySQLCls")
List<User> findBySQLCls(int age, String ord);
```

+ 测试：

```java
@Test
public void testFindBySQLCls() {
    List<User> userList = userMapper.findBySQLCls(18, "age");
    userList.forEach(user -> System.out.println(user));
}
```



🌰 例子：按照城市 `address` 进行分组聚集查询：

+ 在 `UserProvider` 类中添加方法 `selectBySQLCls`：

```java
public String selectByGroupSQLCls(){
    return new SQL(){
        {
            SELECT("count(*), address");
            FROM("user");
            GROUP_BY("address");
        }
    }.toString();
}
```

+ `UserMapper` 接口：

```java
@SelectProvider(type = UserProvider.class, method = "selectByGroupSQLCls")
List<Map> findByGroupSQLCls();
```

+ 测试：

```java
@Test
public void testFindByGroupSQLCls(){
    List<Map> mapList = userMapper.findByGroupSQLCls();
    for (Map map : mapList) {
        System.out.println(map.get("address") + ":" + map.get("count(*)"));
    }
}
```



