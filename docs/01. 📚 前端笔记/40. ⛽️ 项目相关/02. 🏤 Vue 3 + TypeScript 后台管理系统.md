---
title:  🏤 Vue 3 + TypeScript 后台管理系统
date: 2022-04-29 13:32:54
permalink: /pages/3027d6/
categories:
  -  📚 前端笔记
  -  ⛽️ 项目相关
tags:
  - 
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## 登录功能实现

### 登录组件相关

+ 实现判断当前的 Tab 是 「账号登录」还是手机登录，使用 Element-Plus 提供的属性：

  + 在 `<el-tabs>` 标签上添加 `v-model` 属性，双向绑定一个保存当前 Tabs 信息的值：
    ```vue
    <el-tabs type="border-card" class="login-tabs" stretch v-model="currentTab">
    ```

    ```typescript
    // 获取当前tab, 注意要设置默认值
    const currentTab = ref<string>('phone')
    ```

  + 在两个 tab 的 `<el-tab-pane>` 标签下添加一个 `name` 属性用作标识，是 `currentTab` 保存的值：

    ```vue
    <el-tab-pane name="account">
    ```

    ```vue
    <el-tab-pane name="phone">
    ```

​	以此实现后续点击登录时，用判断区别开「账号登录」与「手机登录」不同的登录逻辑。

### 登录逻辑

<img src="https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/74rHji.png" alt="image-20220429133516420" style="zoom:33%;" />

为了方便区分 「账号登录」 或者 「手机登录」，真正的登录逻辑应该放进响应的面板组件当中，而外面的 LoginPanel 组件的登录按钮调用相应的「真正登录逻辑」。

+ `LoginPanel` 组件使用 `ref` 调用子组件中的登录逻辑：

 ```typescript
 // 获取该组件的Ref并且对组件的类型要获取
     const accountRef = ref<InstanceType<typeof LoginAccount>>()
 ```

> 如果不给对应的 `ref()` 添加相应的泛型类型（当前应该是 `LoginAccount` 该组件的类型，使用 `typeof` 获取），`ref()` 默认生成的对象类型为 `any` 。TypeScript 识别该对象为 `any` 后，这个对象要使用时便会不安全，不会报出详细的错误。
>
> 但是类型不能直接写「组件名称」，「组件名称」只是一个组件描述（组件实例），**要使用 `InstanceType<typeof >` 拿到该组件拥有构造函数的实例**，才能确定这个组件的类型。 [TypeScript: Documentation - Utility Types (typescriptlang.org - InstanceType<T>)](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)

+ :star: 在调用 `LoginAccount` 组件处添加绑定`ref` 属性：

```vue
<LoginAccount ref="accountRef" />
```

> 将 `LoginAccount` 组件 `defineComponent` 返回的「对象」看做成一个「组件的描述」——类。而在 `LoginPanel` 中（不是直接使用返回的对象）而是根据对象描述创建出来一个真正的组件实例（要使用时创建，所以多个）。

+ 随后在点击「立即登录」绑定事件：

```typescript
const handleLoginClick = () => {
  console.log('立即登录')
  accountRef.value?.loginAction()
}
```



### 记住密码功能

要存储数据就要考虑，是缓存到「浏览器本地缓存」，还是「会话」、「服务器数据库」。要缓存数据就要封装一个与缓存相关的「类」，可以调用其实例的方法实现缓存、清除等功能。

+ 封装 `@/utils/cache.ts` ：

```typescript
class LocalCache {
  setCache(key: string, value: any) {
    window.localStorage.setItem(key, JSON.stringify(value))
  }

  getCache(key: string) {
    const value = window.localStorage.getItem(key)
    if (value) {
      return JSON.parse(value)
    }
  }

  deleteCache(key: string) {
    const value = window.localStorage.getItem(key)
    if (value) {
      window.localStorage.removeItem(key)
    }
  }

  clearCache() {
    window.localStorage.clear()
  }
}

export default new LocalCache()
```

> 注意 `key` 、`value` 的类型；注意存储数据要使用 `JSON.stringfy()` 转换为 JSON 字符串，读取数据要使用 `JSON.parse()` 转换为对象。



+ 在点击登录时添加相应的保存登录数据到缓存逻辑，并且要在初始化数据时从缓存中读取之前有「记住密码」时的数据：

```typescript
const loginAction = () => {
  accountFormRef.value?.validate((valid, filed) => {
    if (valid) {
      console.log('验证通过')
      if (isKeepPassword.value) {
        localCache.setCache('name', account.name)
        localCache.setCache('password', account.password)
      } else {
        // 不记住密码则清除缓存
        localCache.deleteCache('name')
        localCache.deleteCache('password')
      }
    } else {
      console.log('验证失败', filed)
    }
  })
}
```

```typescript
const account = reactive({
  name: localCache.getCache('name') ?? '',
  password: localCache.getCache('password') ?? ''
})
```



### 请求登录

> + 请求登录后，获取登录的信息
>   + 确定要获取的数据 `token` 、`userInfo`、`userMenu` 
> + 把登录的数据保存
> + 请求用户的信息
> + 请求用户的菜单信息
> + 跳转路由到首页
>
> 使用 Vuex 实现。



+ Vuex Login 模块：

  注意点：

  + 要确定 `LoginModule` 的类型是 `Module`，并且 `Module` 必须传入两个泛型（规范其中 store 中 state 的类型）：

    ```typescript
    const LoginModule: Module<ILoginState, IRootSate> = {
    	state() {
        return {
          ...
        }
      },
      getters: {},
      mutations: {},
      actions: {},
    }
    ```

    > `ILoginState` 应当包含 `state` 中的数据的相关类型，如下：
    >
    > ```js
    > export interface ILoginState {
    >   token: string
    >   userInfo: any
    >   userMenu: any
    > }
    > ```

  

  + 创建完模块以后，要在 store 总文件 `createStore` 中引入登录模块的 store，使用 `modules`：

    ```typescript
    const store = createStore<IRootSate>({
      modules: {
        login
      }
    })
    ```



+ 开发阶段要解决跨域访问，配置 `webpack` 代理服务器 `devServer`：（`vue.config.js` ）

  ```js
  devServer: {
    proxy: {
      '/api': {
        target: '****',
        pathRewrite: {
          '^api': ''
        },
        changeOrigin: true
      }
    }
  },
  ```

+ 登录请求相关：

  + 定义请求接受的结果的类型接口：

  ```js
  export interface IAccount {
    name: string
    password: string
  }
  
  export interface ILoginResult {
    id: number
    name: string
    token: string
  }
  
  // data的类型不能确定，有可能是是登录结果、登录菜单
  export interface IDataType<T = any> {
    code: number
    data: T
  }
  ```

  + 处理登录请求的方法：

  ```typescript
  // 枚举登录相关的api URL
  enum LoginAPI {
    accountLogin = '/login',
    LoginUserInfo = '/users/', // users/1 通过id
    UserMenus = '/role/' // /role/menu
  }
  
  // 请求登录
  // 传入参数，类型要规范 IAccount
  // 返回类型可以推导
  export function requestAccountLogin(account: IAccount) {
    return axRequest.post<IDataType<ILoginResult>>({
      url: LoginAPI.accountLogin,
      data: account
    })
  }
  
  // 根据id请求用户信息
  export function requestUserInfoById(id: number) {
    return axRequest.get<IDataType>({
      url: LoginAPI.LoginUserInfo + id,
      showLoading: false // 登录涉及多个请求方法，避免多次加载动画
    })
  }
  
  // 获取用户菜单
  export function requestUserMenuByRoleId(id: number) {
    return axRequest.get<IDataType>({
      url: LoginAPI.UserMenus + id + '/menu',
      showLoading: false
    })
  ```

  > 注意处理 `axRequest.get/post` 后的类型



+ Login 的 store 中的相关 `mutations `、 `actions` 照常从请求中异步获取数据后，保存到 `state` 中（同时通过缓存的 `utils` 保存到浏览器本地存储中）。 

+ 最后使用 `router` 跳转路由。



### 未登录的路由处理

在路由配置中，设置 `/` 根路径为 `/main` ，但是未登录时要跳转到 `/login` 进行登录。

```js
router.beforeEach((to) => {
  if (to.path !== '/login') {
    // 只要不是跳转到登录页面，跳转之前都要检验一下是否有登录
    const token = localCache.getCache('token')
    if (!token) {
      return '/login'
    }
  }
})
```



### 、时保留Vuex中的数据

登录后跳转路由会内存中会保留 Vuex 中的数据。但是如果用户在页面中跳转，或者直接通过路由器输入路径进入页面，Vuex 的数据会消失。

+ 封装一个在每次初始化 Vue 时，加载浏览器本地存储中登录信息的函数：

  ```js
  export function setUpStore() {
    store.dispatch('login/loadLocalLoginInfo')
  }
  ```

+ 在登录 store 的 actioins 中，添加加载数据的方法：

  ```js
  // 加载浏览器存储中获取登录信息
    loadLocalLoginInfo({ commit }) {
      const token = localCache.getCache('token')
      if (token) {
        commit('CHANGE_TOKEN', token)
      }
  
      const userInfo = localCache.getCache('userInfo')
      if (userInfo) {
        commit('CHANGE_USER_INFO', userInfo)
      }
  
      const userMenu = localCache.getCache('userInfo')
      if (userMenu) {
        commit('CHANGE_USER_MENU', userMenu)
      }
    }
  }
  ```

 

## 首页管理面板

   

### Vuex 中取数据的类型限制技巧

如果直接使用 Vux 提供的 `useStore` 方法读取 store，没有数据类型检测。

+ 在 store 主文件中封装一个 `useStore` 方法：

  ```typescript
  export function useStore(): Store<IStoreType> {
    return useVuexStore()
  }
  ```

+ `IStoreType` 类型：

  ```js
  import { ILoginState } from '@/store/login/type'
  
  export interface IRootSate {
    name: string
    age: number
  }
  
  export interface IRootWithModule {
    login: ILoginState
  }
  
  export type IStoreType = IRootSate & IRootWithModule
  ```

+ 使用自定义封装的 `useStore` ：

  ```typescript
  setup() {
    const store = useStore() // 自定义封装的useStore
    const userMenu = computed(() => store.state.login.userMenu)
  
    return {
      userMenu
    }
  }
  ```



### 实现导航菜单数据展示

### 实现导航菜单折叠效果





### 动态路由

根据用户角色的动态展示菜单

（权限控制的前后端设计）

由于不同的角色有不同的菜单数据，路由的映射关系不能写死，并且没有相应权限的角色不应该拥有某个路由映射关系。有多种思路：

+ 全部情况都完全注册，但是存在安全隐患。
+ 将不同的角色注册不同的路由（根据后端已经配置好的角色信息），从后端获取到的不同角色的动态路由数据，加载到路由的配置中。存在弊端：一旦新增角色，要重新部署对于新角色的路由。

+ :star: 根据菜单动态生成路由映射（菜单 –> 路由映射），后台传送的菜单数据中已经有包含路由路径的信息，直接根据菜单的数据加载动态路由的映射关系即可。
  + 在菜单数据中就有加载组件的名称（字段），要保证组件名称与路径与后台数据必须要一致
  + :star: 在菜单数据根据路径 `url` 动态加载前端中写好的路由映射关系，生成后的映射关系再加载到路由中。（更加灵活）





+ 使用 `coderwhy` 工具生成路由组件页面+路由映射：[coderwhy - npm (npmjs.com)](https://www.npmjs.com/package/coderwhy)

  ![image-20220430133945918](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/cCK7Oy.png)

+ 在获取到 `userMenu`  用户菜单信息（来自后端或者浏览器本地存储中）后，才将该菜单信息存入到 state 中的同时，将 `userMenu` 路由映射信息添加到路由中：

  + 封装一个处理后端菜单信息的方法：

    ```js
    export function mapMenusToRoutes(userMenu: any[]): RouteRecordRaw[] {
      const routes: RouteRecordRaw[] = []
    
      // 加载默认所有的routes
      const allRoutes: RouteRecordRaw[] = []
      // 加载文件路径
      const routeFiles = require.context('../router/main', true, /\.ts/)
      routeFiles.keys().forEach((key) => {
        const route = require('../router/main' + key.split('.')[1])
        allRoutes.push(route.default)
      })
    
      // 根据菜单获取需要添加的 routes
      const _recurseGetRoute = (menus: any[]) => {
        for (const menu of menus) {
          if (menu.type === 2) {
            const route = allRoutes.find((route) => route.path === menu.url)
            if (route) {
              routes.push(route)
            }
          } else {
            _recurseGetRoute(menu.children)
          }
        }
      }
    
      _recurseGetRoute(userMenu)
      return routes
    }
    ```

  + 在 mutations 中调用该方法：

    ```typescript
    CHANGE_USER_MENU(state, userMenu: any) {
          state.userMenu = userMenu
    
          // userMenu添加到routes
          const routes = mapMenusToRoutes(userMenu)
          routes.forEach((route) => {
            router.addRoute('main', route)
          })
        }
    }
    ```

+ 完善点击跳转路由功能：

  + 在相应位置添加路由视图。

  + 创建处理点击链接的方法事件：

    ```js
    const handleMenuItemClick = (item: any) => {
      router.push({
        path: item.url ?? '/404'
      })
    }
    ```

  + 在相应的位置绑定事件即可。



+ 解决刷新 404 问题。

  + 出现问题分析：Vue 加载路由的过程： `app.use(router)` ➡️ `install()` ➡️ 获取当前的路由路径 ➡️ `router.routes` 寻找路由映射 ➡️ 不能找到路由映射信息 ➡️ 404 ➡️ **跳转路由时，才执行路由守卫的回调函数** ➡️ useStore  … ➡️ `to()` 已经确定了是要跳转到 404 组件。

  + 将 `setupStore()`  调整到 `app.use(router)` 前。

+ 刷新后 ，导航没有实时更新为当前的 `active` 的组件，因为没有动态设置 `default-active` 的配置。

  + 获取当前的路径（路由路径）
  + 根据路径匹配 `userMenu` 数据
  + 根据 `userMenu` 数据获取 `userMenu` 对应的菜单信息 `id` （注意 `main` 的处理，要重定向，保存获取去到的第一个菜单路径，然后再在路由守卫中重定向为第一个菜单路径）


## 相关页面

### 用户管理页面搜索表单

> 用户管理页面中涉及到两个部分：「表单填写」搜索功能部分和「表格展示」用户数据的部分。这两个部分的功能实际上可以封装为公共的 UI 组件，使用配置驱动，完成组件的复用。



实现表单总结：

+ 实现通过传入表单配置（例如，标题、表达规则等）到封装好的组件，完成组件的复用。
+ 要注意表单配置类型规范。

+ 要按照配置驱动表单组件，需要根据不同的数据区分不同的表单类型。所以最终只要一个输入表单的组件，根据不同的表单类型，有不同的模版。

基本结构

样式

​	响应式布局

绑定双向数据

​	注意不要修改 `props` 数据。





### 用户管理页面数据表格

### 利用动态插槽

作用域插槽

#### 表格数据

#### 时间格式化

#### Element-plus 国际化（中文）



### 用户页面进一步封装



#### 网络请求数据到底由谁请求

:star: 调用 Vuex 的 acitons 发送请求数据，并且存储到 store 的逻辑应该写在中间要处理数据的地方（例如，用户管理页面组件 -> pageContent 组件（中间）-> 展示数据表格组件） ，而用户管理页面组件只要传输一个信息到中间人即可（*思想）。

![image-20220502215254127](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/9CFCc0.png)



#### 提供页面名称（信息）找到要请求的路径

如果服务器后端开发规范，可以根据传入的名称直接拼接字符串为一个请求的路径，（*可以通过 `switch` 或者 `map` 映射，定义名称对应的请求路径 ），以实现传入一个名称，实现请求不同的数据。



#### 分层代码复用的重构思想



#### 搜索组件与搜索表单的数据双向绑定问题

+ 两种思路：

  





#### 完善搜索按钮功能

先前要展示用户的数据，请求数据的部分其实只能发送请求一次。所以应该封装为一个函数，以便之后复用请求数据。



#### 将搜索、重置封装为 hook



### 商品管理页面



#### 跨组件插槽

动态获取插槽：

`props.contentConfig.propList` -> slotName



### 菜单管理页面

#### 多级树状表格的实现

添加配置



### 按钮权限设置

服务器的数据中，菜单数据按钮的相关权限数组，封装一个 hook 方法 `usePersmisson(pageName, '相关按钮')` 判断是否有权限，然后是否展示该按钮内容。



### 按钮功能实现

请求删除、编辑、新增按钮。



+ 弹窗最好要使用「关闭时销毁 DOM」，保证下一次的数据是重新渲染的。



### 其他数据

socket 实时更新？请求全局的数据



刷新还没获取到全局请求的异步数据？使用 `computed` 的 `getter` 处理 



### 新建角色的分配权限



处理（修改）的树状数据，回显时，

+ 只处理叶子结点



### 数据可视化



最终分层：

![image-20220504134439779](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/0bnoNf.png)