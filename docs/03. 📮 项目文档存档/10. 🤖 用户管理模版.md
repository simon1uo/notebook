---
title:  🤖 用户管理模版
date: 2022-05-12 15:54:09
permalink: /pages/601e96/
categories:
  -  📮 项目文档存档
tags:
  - 
---
### 涉及配置与插件



+ MyBatisPlusX

+ apache `commons-lang3`
+ GenerateAllSetter ： 一件调用对象的所有 `set` 方法，用于初始化一个实例对象时。
+ Auto filling Java call arguments ：自动填充 Java 调用函数时参数
+ GenerateSerialVersionUID： 生成序列化 id



## 注册功能



## 登录功能

### 登录逻辑

+ 主要思路：
  1. 验证登录信息：账户、密码是否符合规则。
  2. 密码加密
  3. 查询用户是否存在
  4. 用户脱敏（将用户不敏感的信息保存到一个新的用户实例对象）
  5. 在 session 中保存用户登录状态





+ 解决 **用户如果处于被删除后的状态** 能否被查询。

  参考 MyBatisPlus 文档中 [逻辑删除 | MyBatis-Plus (baomidou.com)](https://baomidou.com/pages/6b03c5/)，默认查询没有被删除的用户。

  

  1. 在 SpringBoot 配置文件中添加上相关的配置：

     ```yml
     global-config:
         db-config:
           logic-delete-field: isDelete # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
           logic-delete-value: 1 # 逻辑已删除值(默认为 1)
           logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
     ```

  2. 在相关的实体类中的相关字段上添加 **注解 `@TableLogic`**

  3. 至此，删除后的用户在被 `isDelete` 字段受影响后不会再被查询出来。



### 登录接口



+ 如果要接收 JSON 格式的参数，最好封装一个对象记录所有的请求参数。

  1. 在 `domain` 包下创建一个新的包 `request` 处理请求参数。

  2. 以处理 **用户注册** 的参数为例，创建类 `UserRegisterRequest`，序列化实现 `Serializable` 接口。

     > 为了生成 序列化 UID：使用插件 GenerateSerialVersionUID。

  3. 编写要接收的属性，最后在类上使用 lombok 的`@Data` 注解。



### 测试接口

利用 IDEA 中的 HTTP clients 工具：
![image-20220512170321468](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/xcK0sK.png)

🌰 例子：

![image-20220512185220715](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/W9MlnB.png)



### 添加权限逻辑

必须要 **判断权限** 限制某些接口的使用仅仅只能 **管理员** 使用。

+ 在用户表中增加新的字段 `userRole` (默认值为 `0`，``0` - 普通用户，`1` - 管理员)。
+ ~~重新使用 MyBatisX 生成代码。~~
+ ~~注意原来 `isDelete` 字段在实体类处要添加注解 `@TableLogic`~~。



1. 封装 **标识用户角色相关的** 常量到接口 `UserConstant`：

   ```java
   public interface UserConstant {
       // 用户登录状态键
       String USER_LOGIN_STATE = "userLoginState";
   
       // 用户权限区分
       int DEFAULT_ROLE = 0;
   
       int ADMIN_ROLE = 1;
   }
   ```

2. 注意要在 `UserServiceImpl` 之前使用过的地方修改引入。

3. 在 `UserController` 中封装一个判断 **是否为管理员** 的方法：

   ```java
   private boolean isAdmin(HttpServletRequest request) {
       Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
       User user = (User) userObj;
       return user != null && user.getUserRole() == ADMIN_ROLE;
   }
   ```

   > 先判断用户是否登录，然后再判断是否为 **管理员**。

4. 在要判断权限的 **接口** 处，在完成相关的业务逻辑之前，先判断权限，例如 **用户搜索**：

   ```java
   @PostMapping("/search")
   public List<User> searchUsers(String username, HttpServletRequest request) {
       if (!isAdmin(request)) return new ArrayList<>();
   
       QueryWrapper<User> queryWrapper = new QueryWrapper<>();
       if (StringUtils.isNotBlank(username)) {
           queryWrapper.like("username", username);
       }
   
       return userService.list(queryWrapper);
   }
   ```



进一步限制 登录 的 session 失效时长，在 SpringBoot 配置文件中配置：
```yml
session:
    timeout: 86400
```

> 设置为一天。



### 封装信息脱敏

测试 **搜索功能** 后发现，所有的用户信息不应该完全暴露。所以最好还是在搜索返回结果之前脱敏，之前 **登录用户** 时也用到了用户信息脱敏。所以可以封装为一个方法。

```java
@Override
public User getSafetyUser(User sourceUser) {
    // 用户脱敏
    User safetyUser = new User();
    safetyUser.setId(sourceUser.getId());
    safetyUser.setUsername(sourceUser.getUsername());
    safetyUser.setUserAccount(sourceUser.getUserAccount());
    safetyUser.setAvatarUrl(sourceUser.getAvatarUrl());
    safetyUser.setGender(sourceUser.getGender());
    safetyUser.setEmail(sourceUser.getEmail());
    safetyUser.setPhone(sourceUser.getPhone());
    safetyUser.setUserStatus(sourceUser.getUserStatus());
    safetyUser.setCreateTime(sourceUser.getCreateTime());
    safetyUser.setUserRole(sourceUser.getUserRole());

    return safetyUser;
}
```





## 用户退出登录

编写 用户业务逻辑 思路：

+ 用户退出登录就要返回一个成功的表示（先设定为 `int` 类型）
+ 用户退出登录要接收什么参数。
  + 用户登录时，保存了一个 **登录状态** 到服务器的 session 中，要退出登录，就要移除这个登录状态即可。





## 接口返回信息优化

后端直接返回一个对象给前端，如果 这个数据出问题了、后端处理报错了、查不到用户，前端如果不刻意区分的话，也不知道它到底为什么报错。

比如说一个测试，它返回了一个有六项的列表，假如后台返回一个空数组，前端可能也不会意识到它是错误的，如果说后台因为一些异常，我们强制给他返回空数组，但前端可能不知道对不对，他还以为这个只是一个本来就是数据库里没有用户的一个值。

所以我们需要定义一个通用的返回对象。

> **通用返回对象**：（包括以下信息）
>
> + 数据
>
> + 自定义错误码
> + 返回类支持返回正常和错误
> + 返回信息

### 封装返回通用对象

思路：

+ 创建一个 处理返回结果 的工具类。
  + 封装为 通用返回对象。
+ 在每一个接口 返回结果之前先通过这个工具处理。





### 自定义错误码

+ 封装一个 枚举类型 的类，保存常用的错误码。
+ 在通用返回对象工具类中，完善错误相应对应的方法。
+ 处理接口出错时，响应返回错误的对象。



### 封装全局异常处理
