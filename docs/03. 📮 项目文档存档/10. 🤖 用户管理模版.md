---
title:  🤖 用户管理模版
date: 2022-05-12 15:54:09
permalink: /pages/601e96/
categories:
  -  📮 项目文档存档
tags:
  - 
---
### 涉及配置与插件



+ MyBatisPlusX

+ apache `commons-lang3`
+ GenerateAllSetter ： 一件调用对象的所有 `set` 方法，用于初始化一个实例对象时。
+ Auto filling Java call arguments ：自动填充 Java 调用函数时参数
+ GenerateSerialVersionUID： 生成序列化 id



## 注册功能



## 登录功能

### 登录逻辑

+ 主要思路：
  1. 验证登录信息：账户、密码是否符合规则。
  2. 密码加密
  3. 查询用户是否存在
  4. 用户脱敏（将用户不敏感的信息保存到一个新的用户实例对象）
  5. 在 session 中保存用户登录状态





+ 解决 **用户如果处于被删除后的状态** 能否被查询。

  参考 MyBatisPlus 文档中 [逻辑删除 | MyBatis-Plus (baomidou.com)](https://baomidou.com/pages/6b03c5/)，默认查询没有被删除的用户。

  

  1. 在 SpringBoot 配置文件中添加上相关的配置：

     ```yml
     global-config:
         db-config:
           logic-delete-field: isDelete # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
           logic-delete-value: 1 # 逻辑已删除值(默认为 1)
           logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
     ```

  2. 在相关的实体类中的相关字段上添加 **注解 `@TableLogic`**

  3. 至此，删除后的用户在被 `isDelete` 字段受影响后不会再被查询出来。



### 登录接口



+ 如果要接收 JSON 格式的参数，最好封装一个对象记录所有的请求参数。

  1. 在 `domain` 包下创建一个新的包 `request` 处理请求参数。

  2. 以处理 **用户注册** 的参数为例，创建类 `UserRegisterRequest`，序列化实现 `Serializable` 接口。

     > 为了生成 序列化 UID：使用插件 GenerateSerialVersionUID。

  3. 编写要接收的属性，最后在类上使用 lombok 的`@Data` 注解。



### 测试接口

利用 IDEA 中的 HTTP clients 工具：
![image-20220512170321468](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/xcK0sK.png)

🌰 例子：

![image-20220512185220715](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/W9MlnB.png)



### 添加权限逻辑

必须要 **判断权限** 限制某些接口的使用仅仅只能 **管理员** 使用。

+ 在用户表中增加新的字段 `userRole` (默认值为 `0`，``0` - 普通用户，`1` - 管理员)。
+ ~~重新使用 MyBatisX 生成代码。~~
+ ~~注意原来 `isDelete` 字段在实体类处要添加注解 `@TableLogic`~~。



1. 封装 **标识用户角色相关的** 常量到接口 `UserConstant`：

   ```java
   public interface UserConstant {
       // 用户登录状态键
       String USER_LOGIN_STATE = "userLoginState";
   
       // 用户权限区分
       int DEFAULT_ROLE = 0;
   
       int ADMIN_ROLE = 1;
   }
   ```

2. 注意要在 `UserServiceImpl` 之前使用过的地方修改引入。

3. 在 `UserController` 中封装一个判断 **是否为管理员** 的方法：

   ```java
   private boolean isAdmin(HttpServletRequest request) {
       Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
       User user = (User) userObj;
       return user != null && user.getUserRole() == ADMIN_ROLE;
   }
   ```

   > 先判断用户是否登录，然后再判断是否为 **管理员**。

4. 在要判断权限的 **接口** 处，在完成相关的业务逻辑之前，先判断权限，例如 **用户搜索**：

   ```java
   @PostMapping("/search")
   public List<User> searchUsers(String username, HttpServletRequest request) {
       if (!isAdmin(request)) return new ArrayList<>();
   
       QueryWrapper<User> queryWrapper = new QueryWrapper<>();
       if (StringUtils.isNotBlank(username)) {
           queryWrapper.like("username", username);
       }
   
       return userService.list(queryWrapper);
   }
   ```



进一步限制 登录 的 session 失效时长，在 SpringBoot 配置文件中配置：
```yml
session:
    timeout: 86400
```

> 设置为一天。



### 封装信息脱敏

测试 **搜索功能** 后发现，所有的用户信息不应该完全暴露。所以最好还是在搜索返回结果之前脱敏，之前 **登录用户** 时也用到了用户信息脱敏。所以可以封装为一个方法。

```java
@Override
public User getSafetyUser(User sourceUser) {
    // 用户脱敏
    User safetyUser = new User();
    safetyUser.setId(sourceUser.getId());
    safetyUser.setUsername(sourceUser.getUsername());
    safetyUser.setUserAccount(sourceUser.getUserAccount());
    safetyUser.setAvatarUrl(sourceUser.getAvatarUrl());
    safetyUser.setGender(sourceUser.getGender());
    safetyUser.setEmail(sourceUser.getEmail());
    safetyUser.setPhone(sourceUser.getPhone());
    safetyUser.setUserStatus(sourceUser.getUserStatus());
    safetyUser.setCreateTime(sourceUser.getCreateTime());
    safetyUser.setUserRole(sourceUser.getUserRole());

    return safetyUser;
}
```



