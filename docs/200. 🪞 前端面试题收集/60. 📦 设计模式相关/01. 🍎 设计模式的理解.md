> 相关问题：
>
> + 对设计模式的理解？
> + 常见的设计模式有哪些？



## 理解

软件工程中，**设计模式是对软件设计中普遍存在的各种问题所提出的解决方案**。

+ 不直接使用来完成代码的编写，而是描述在不同情况下，要怎么解决问题的一种方案；
+ 能使不稳定依赖于相对问题、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。

+ 当遇到适合的场景，**应该想到对应符合这种场景的设计模式**。

  例如，当系统中的某个接口的结构已经无法满足现在的业务需求，但是又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。因此可以想到，使用 适配器模式 来解决这个问题。



> 设计模式来源于众多专家的经验与智慧，从许多的优秀软件系统中总结出成功的、能够实现可维护复用的设计方案，使用这些方案可以避免做重复性的工作；
>
> 设计模式提供了一套通用的设计词汇和通用的形式方便开发人员之间的沟通和交流，使得设计方案更加通俗易懂；
>
> 大部分设计模式都兼顾了系统的可用性和可拓展性，使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的设计系统，避免经常做一些重复的设计、重复的代码；
>
> 合理使用设计模式并对设计模式文档化，能够有助于更快理解系统；

## 常见的设计模式

+ 单例模式
+ 工厂模式
+ 策略模式
+ 代理模式
+ 中介者模式
+ 装饰着模式
+ …



### 单例模式

单例模式 **保证一个类仅有一个实例**，并 **提供一个访问它的全局访问点**。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类仅有一个实例。



### 工厂模式

工厂模式通常会分三个角色：

+ 工厂：负责实现创建所有实例的内部逻辑；
+ 抽象产品角色：所创建的所有对象的父类，负责描述所有实例所共有的公共接口；
+ 具体产品角色：创建目标，所有创建的对象都充当这个角色的某个具体类的实例。



### 策略模式

策略模式定义了一系列的算法，把他们封装起来，使他们可以互相替换。至少分成两部分：

+ 策略类（可变）：封装具体算法，负责具体计算过程；
+ 环境类（不变）：接受客户请求，随后将请求委托给某一个策略类；



### 代理模式

代理模式为对象提供了一个代用品或者占用符，以便控制对它的访问。

🌰 例子：实现图片懒加载，先通过一张 加载中图片占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 `img` 标签中。



### 中介者模式

中介者模式通过中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。

通过中介者模式可以解除对象与对象之间的紧耦合关系。



### 装饰着模式

装饰着模式在不改变自身的基础上，程序运行期间给对象动态添加方法。

通常运用于在原有方法维持不变，在原有方法上挂载其他方法来满足需求。



## 参考

+ [Study-Plan/README.md at master · xietao3/Study-Plan (github.com)](https://github.com/xietao3/Study-Plan/blob/master/DesignPatterns/README.md) / 学习并理解 23 种设计模式。
+ [图解九种常见的设计模式 - SegmentFault 思否](https://segmentfault.com/a/1190000030850326)