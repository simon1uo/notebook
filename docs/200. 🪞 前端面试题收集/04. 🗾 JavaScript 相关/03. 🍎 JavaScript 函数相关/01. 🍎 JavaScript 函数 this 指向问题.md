> 相关问题：
>
> + JavaScript 中对函数 `this` 的理解？



## 概念

`this` 关键字时函数运行时自动生成的一个 **内部对象**。只能在函数内部使用，总是指向 **调用它** 的对象。

绝大多数情况下，函数的调用方式决定了 `this` 的值（调用时绑定）。同时 `this` 在函数执行的过程中，一旦被确定了就不能再更改。



> `this` 是什么：
>
> + 任何函数本质上都是**通过某个对象来调用的**，:star: **如果没有制定就是 `window`** 。
>
> + 所有函数内部都有一个变量 `this` ；
> + 它的值是调用函数的当前对象；



## 绑定规则

根据不同的使用场景，`this` 会有不同的值。

### 默认绑定

全局环境中定义的变量，在函数中可以通过 `this` 获取。（针对 `var` 生命的变量）

🌰 例子：

```js
var name = "Simon"
function person() {
  return this.name
}
console.log(person()) // Simon
```

> 调用 `this` 的对象是函数，而函数本身没有 `name` 这个变量，所以往外找，最终找到指向 `window`。
>
> 严格模式下，不能讲全局对象用于默认绑定， `this` 会绑定到 `undefined`。

### 隐式绑定

函数还可以作为某个对象的方法调用，此时 `this` 指向的就是这个上级对象。

🌰 例子：

```js
function test() {
  cnsole.log(this.x)
}

var obj = {}
obj.x = 1
obj.m = test
obj.m // 1
```

相当于：

```js
var obj = {
  x: 1
  m: function() {
    console.log(this.x)
  }
}
obj.m()
```



🌰 例子 / 特殊情况：

```js
var o = {
  a: 10,
  b: {
    a: 12,
    fn:function(){
      console.log(this.a); //undefined
      console.log(this); //window
    }
  }
}
var j = o.b.fn;
j();
```

> `this` 在这里指向的是 `window`。因为无论如何，`this` 永远指向最终调用它的对象，尽管 `fn` 是对象 `b` 的方法，但是 `fn` 赋值给 `j` 的时候并没有执行，所以最终指向的是 `window`。



### `new` 绑定

通过构造器 `new` 关键字生成一个实例对象，此时 `this` 指向这个实例对象。

🌰 例子：

```js
function test() {
  this.x = 1
}

var obj = new test()
obj.x // 1
```

> 之所以 `obj.x` 为 `1`，是因为 `new` 改变了 `this` 的指向。



🌰 例子 / 特殊情况：

```js
function fn() {
  this.user = 'xxx'
  return {}
}
var a = new fn()
console.log(a.user) // undefined
```

> 此时 `new` 的过程中遇到了一个 `return`，此时 `this` 指向的是返回的对象。
>
> 当返回的是一个简单类型时，`this` 指向实例对象：
>
> ```js
> function fn() {
>   this.user = 'xxx'
>   return 1
> }
> var a = new fn()
> console.log(a.user) // xxx
> ```
>
> 当返回的是 `null` 时，虽然也是对象，但是此时 `this` 指向实例对象。



### 显式修改

使用 `apply` / `call` / `bind` 方法。改变函数调用的对象，它们的第一个参数表示改变后调用这个函数的对象。因此 `this` 指向这个对象。

🌰 例子 ：

```js
var x = 0
function test() {
  console.log(this.x)
}

var obj = {}
obj.x = 1
obj.m = test
obj.m.apply(obj) // 1
```



### 绑定的优先级

+ 显示绑定  >`new` 绑定  > 隐式绑定 > 默认绑定



🌰 例子 / 隐式绑定与显式绑定比较：

```js
function foo() {
  console.log(this.a)
}

var obj1 = {
  a: 2,
  foo: foo
}

var obj2 = {
  a: 3,
  foo: foo
}

obj1.foo() // 2
obj2.foo() // 3
obj1.foo.call(obj2) // 3
obj2,foo.call(obj1) // 2
```



🌰 例子 / `new` 绑定与隐式绑定比较：

```js
function foo(something) {
  this.a = something
}

var obj1 = {
  foo: foo
}
var obj2 = {}

obj1.foo(2)
console.log(obj1.a) // 2

obj1.foo.call(obj2, 3) // 3
console.log(obj2.a) // 3

var bar = new obj1.foo(4)
console.log(obj1.a) // 2
console.log(bar.a) // 4
```



🌰 例子 / `new` 绑定与显示绑定比较：

```js
function foo(something) {
  this.a = something
}

var obj1 = {}
var bar = foo.bind(obj1)
bar(2)
console.log(obj1.a) // 2

var baz = new bar(3);
console.log(obj1.a) // 2
console.log(baz.a) // 3
```

> `bar`被绑定到obj1上，但是`new bar(3)` 并没有像我们预计的那样把`obj1.a`修改为3。但是，`new`修改了绑定调用`bar()`中的`this



## 箭头函数的 `this` 指向

ES6 中箭头函数的语法，使得可以在代码书写的时候就决定 `this` 的指向（意味着箭头函数 `this` 没有指向）

s

## 参考

+ [面试官：谈谈this对象的理解 | web前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/JavaScript/this.html#一、定义)
+ 尚硅谷 JavaScript 进阶教程