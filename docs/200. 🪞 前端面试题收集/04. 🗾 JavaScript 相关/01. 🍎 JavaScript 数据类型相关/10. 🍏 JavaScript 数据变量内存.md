---
title:  🍏 JavaScript 数据变量内存
date: 2022-06-10 15:31:47
permalink: /pages/6e10ef/
categories:
  -  🪞 前端面试题收集
  -  🗾 JavaScript 相关
  -  🍎 JavaScript 数据类型相关
tags:
  - 
---
### 数据

存储在内存中**代表特定信息**，本质上是 `0101…` 。

🌰 例子：

```js
var age = 18 // 特定信息
var a = 2 // 未知特定信息
```

+ 数据的特点：可传递、可运算。

+ 内存中的所有操作的目标为：数据。
  + 算数运算、逻辑运算、赋值、运行函数。



### 内存

内存条通电后产生的可存储数据的空间（临时的）。

+ 内存的产生和死亡：内存条 ===**通电**> 产生内存空间 ===> 存储数据 ===>  处理数据 ===**断电**> 内存空间和数据都消失。
+ 内存数据的两个数据： 内部存储的数据、地址值数据。 
+ 内存的分类：
  + 栈：全局变量 / 局部变量（包括标识对象的变量）
  + 堆：对象



### 变量

可变化的量：

+ 由**变量名、变量值**组成，每个变量都对应一块小内存。
+ 变量名用来查找对应的内存。
+ 变量值是内存中保存的数据。



### 三者关系

+ 内存是用来存储数据的空间；
+ 变量是**内存的标识**，查找内存的空间；



### 相关问题

❓ **`var a = xxx`，`a` 中保存的是什么**？

+ 当 `xxx` 是基本数据，保存的是这个数据。
+ 当 `xxx` 是对象，保存的时对象的地址值。
+ 当 `xxx` 是一个变量，保存的是 `xxx` 的内存内容（可以是基本数据也可以是地址值）。



❓**引用变量赋值问题**：

+ 当多个引用变量指向**同一个对象**，这多个变量都指向**同一个地址值**。通过一个变量修改对象的内部数据，其他所有变量看到的是修改后的数据。

```js
var obj1 = {name: 'Simon'}
var obj2 = obj1
obj1.name = 'Jack'
cosole.log(obj2.name) // 'Jack'
```

```js
function fn(obj) {
  obj.name = 'Bob'
}
fn(obj1)
console.log(obj2.name) // Bob
```

+ 两个引用变量指向相同同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象。

```js
var a = {age: 12}
var b = a
a = {name: 'Simon', age: 13}
b.age = 14
cosole.log(b.age, a.namae, b.age) // 14 Simon 13
```

+ 在函数中，要是用的参数与原来的变量指向同一个对象，但是在函数中的对象在函数执行完后，回哦成为垃圾对象，而不影响原来的变量指向的对象。

```js
function fn2 (obj){
  obj = {age: 15}
}
fn2(a)
console.log(a.age) // 13
```



❓ 在 JavaScript 调用函数传递变量参数是，是**值传递还是引用传递**问题：

+  都是值传递，分为两种情况，基本值与地址值。
+  可能是值传递，也可能是**引用传递**（地址值）。

```js
var a = 3
function fn(a) {
  a = a + 1
  console.log(a) //4
}
fn(a)
console.log(a)
```

```js
function fn2(obj) {
  console.log(obj.name)
}
var obj = {name: 'Simon'}
fn2(obj)
// 先读到obj的对象地址值，将地址值赋值给局部变量obj，然后函数內的局部变量
```



❓**JavaScript 引擎如何管理内存**：

+ **内存的生命周期**：
  + 分配小内存空间，得到它的使用权。
  + 存储数据，可以反复进行操作。
  + 释放小内存空间。（释放占用内存）

+ 内存的释放：
  + 局部变量：函数执行完后自动释放。
  + 对象：成为垃圾对象，垃圾回收器回收。

```js
var a = 3
var obj = {}
obj = null

fuction fn (){
  // var b =123
  var b = {}
}
```

