---
title: 🎈 算法框架相关前置知识
date: 2022-04-19 11:37:01
permalink: /pages/457752/
categories: 
  - 🕹 算法小记
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
:star: 算法收藏夹：

+ **fucking-algorithm** GitHub [labuladong/fucking-algorithm](https://github.com/labuladong/fucking-algorithm)

+ 🔖 [labuladong的算法小抄](https://labuladong.github.io/algo/1/3/) / 算法的本质（穷举）



算法刷题快速上手：

+ :star: 力扣官方 [剑指 Offer](https://leetcode-cn.com/study-plan/lcof)
+ 🔥 [力扣热题 TOP 100](https://leetcode-cn.com/problem-list/2cktkvj/) 
+ 🚀 [力扣精选 200 题](https://leetcode-cn.com/problem-list/qg88wci)



本篇笔记主要收集要刷算法题目之前，一些适合了解（或者复习）数据结构以及算法的相关前置知识。

## 回顾数据结构基础

### 数据结构的存储方式

数据结构的两种基本的存储方式：**数组（顺序存储方式）与链表（链式存储方式）**。这两种存储方式是结构的基础，衍生出多样化的数据结构，是在其基础上的特殊操作。

两者的优缺点：

+ 数组连续存储、可以随机访问，节约存储空间。但是因为要连续存储，内存空间要分配足够（数组扩容时需要分配更大的空间，再把数据全部复制过去，时间复杂度 O(N)）；如果要在数组中间进行插入和删除，每次操作过后的数据都要保持连续，时间复杂度 O(N)。
+ 链表元素不连续，依靠指针指向下一个元素的位置，因此不存在数组扩容（空间分配）的问题。要在链表中进行插入和删除元素，知道某一元素的前驱和后驱即可，时间复杂度 O(1)；由于元素不连续的特性，不能随机访问元素；而每个元素必须存储指向前、后元素位置的指针，消耗相比数组更多的存储空间。



在两种基本的数据结构存储方式，在特殊操作下产生的数据结构：

「队伍」、「栈」两种数据结构及可以用数组也可以用链表实现。使用数组就要处理存储空间扩容、缩容问题；使用链表不需要考虑存储空间分配，但是需要更多的内存空间存储节点指针。

「图」有两种表示方法，邻接表是链表，邻接矩阵是二维数组。邻接矩阵判断连通性迅速，并且可以进行矩阵运算解决问题，但是如果图较稀疏会耗费内存空间。邻接表比较节省内存空间，但是操作效率比不过邻接矩阵。

「散列表」就是通过散列函数把键映射到一个大数组里。对于解决散列冲突的方法，拉链法利用了链表的特性，操作简单，但是牺牲了空间；线性探查法利用了数组的特性，可以连续寻址，节省了空间，但是操作稍复杂。

**「树」常见是使用链表结构实现，不一定是完全二叉树**。在链表「树结构」基础上，又衍生出二叉搜索树、AVL 树、红黑树、B 树等树结构。「**堆」使用数组实现，是一个完全二叉树。**



### 数据结构的基本操作

操作任何的数据结构，基本的无非就是遍历数据、访问数据，增删改查。数据结构的种类有很多，它们之所以存在就是为了提高操作数据的效率，完成高效点的增删改查。

各种数据结构的遍历和访问，无非是以下的几种框架：

+ **数组遍历框架**，典型线性迭代结构：

  ```java
  void traverse(int arr) {
    for (int i = 0; i < arr.length; i++){
      // 迭代访问 arr[i]
    }
  }
  ```

+ **链表遍历框架**， 兼具迭代和递归结构：

  ```java
  // 基本的单链表节点
  class ListNode{
    int value;
    ListNode next;
  }
  
  void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {
      // 迭代访问 p.value
    }
  }
  
  void traverse(ListNode head) {
  	// 递归访问 head.value
    traverse(head.next)
  }
  ```

+ 二叉树遍历框架，典型的非线性递归遍历结构：

  ```java
  // 基本的二叉树节点
  class TreeNode {
    int value;
    TreeNode left, right;
  }
  
  // 递归遍历
  void traverse(TreeNode root){
    traverse(root.left);
    traverse(root.right)
  }
  ```

  二叉树的递归遍历结构与链表遍历结构很相似，结构也与链表结构很相似。所以其实不管 N 叉，可以拓展到与其相似的 N 叉树遍历结构。

+ 二叉树拓展为 N 叉树的遍历框架：

  ```java
  // 基本的 N 叉树节点
  class TreeNode {
    int value;
    TreeNode[] children;
  }
  
  void traverse(TreeNode root) {
    for (TreeNode chlild : root.children)
      traverse(child);
  }
  ```

  N 叉树的遍历又可以拓展为图的遍历。**图可以看作是好几 N 叉棵树的结合体。**图中有可能出现环的情况，在结构中添加布尔值类型的 `visited` 数组标记即可。







## 动态规划解题框架

**动态规划问题一般形式是求最值**。动态规划其实是运筹学的一种最优化方法，相关常见问题有求最长递增子序列，最小编辑距离等。

**动态规划问题核心思想：穷举**。要求最值，就要把所有可行的答案都找出来，然后在其中找最值。

但是动态规划问题并非穷举这么简单，动态规划的穷举有点特殊。这类问题存在「重叠子问题」，暴力穷举会导致效率低下，所以需要「备忘录」或者「DP table」优化穷举过程，避免不必要的计算；其次动态规划问题还一定会具备「最优子结构」，才能通过子问题的最值的到原问题的最值。最后动态规划问题可以千变万化，穷举所有可行解并不是一件容易的事，只有列出正确的「状态转移方程」，才能正确穷举。

上面提到的重叠子问题、最优子结构、状态转移方程就是动态规划的三要素。在实际算法问题中，写出状态转移方程是最困难的。

> 状态转移方程的辅助思维框架：
>
> 明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
>
> which means in code：
>
> ```java
> // 初始化 base case
> dp[0][0][...] = base;
> 
> // 进行状态转移
> for 状态1 in 状态1的所有取值
>   for 状态2 in 状态2的所有取值
>     for ... 
>       dp[状态1][状态2][...] = 求最值(选择1,选择2...)
> ```



动态规划问题的两个经典问题：斐波那契数列数列问题、凑零钱问题，用来解释动态规划中的三个要素的原理。

### 斐波那契数列

🔗 leetcode-cn [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

> **斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：**
>
> ```
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> ```
>
> 给定 `n`，请计算 `F(n)` 。
>
> 来源：力扣（LeetCode）
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#**常规递归解法**

使用常规的递归进行解答（如下），分析算法的复杂度，子问题个数为递归树中的节点总数 O(2^n)，乘以解决问题的时间，一个加法的操作 O(1)，最后时间复杂度为 O(2^n)。可以看出该算法低效的原因是存在大量的重复计算，这是动态规划问题的第一个性质：重叠子问题。

```java
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

> 计算递归算法的复杂度：用子问题乘以解决一个问题需要的时间。



#**带备忘录的递归解法**

可以使用「备忘录」解决「重叠子问题」（如下）。造一个「备忘录」，每次算某个子问题的答案先不急着返回，而是先记录到「备忘录」中在返回；每次遇到一个子问题先到「备忘录」中查询是否已经解决过这个问题，如果已经解决过就可以直接使用不用再计算。一般使用一个数组充当「备忘录」，亦可使用哈希表。

```java
public int fib(int N) {
  // 备忘录全初始化为0
  int[] memo = new int[N + 1];
  
  // 进行带备忘录的递归
  return helper(memo, N);
}

int helper(int[] memo, int n) {
  // base case
  if (n == 0 || n == 1) return n;
  
  // 计算过的结果直接返回
  if (memo[n] != 0) return memo[n];
  
  // 初始计算
  memo[n] = helper(memo, n-1) + helper(memo, n-2);
  return memo[n];
}
```

带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过剪枝改造成不存在冗余的递归图，减少了子问题（递归图中的节点）的个数。分析带「备忘录」的递归算法，子问题不存在冗余，数量和输入规模成正比 O(n)，解决问题的时间同上为 O(1)，所以时间复杂度为 O(n)。

至此，**带备忘录的递归算法的效率已经与迭代的动态规则解法一样了**。实际上，这种解法与常见的动态规划解法已经差不多了，只不过这种解法是「自顶向下」进行递归求解，而更常见的动态规划解法是「自底向上」进行「递解」。

「自底向上」从最底下、最简单、问题规模最小开始推导，知道得到想要的答案。这就是「递推」的思路。这是动态规划一般都脱离了递归，而是由循环迭代完成计算的原因。



#**DP 数组的迭代（递推）解法**

通过「备忘录」的启发，可以将「备忘录」独立出来成为一张表，通常叫做 DP table， 在这张表上完成「自底向上」的推算。

```java
public int fib(int N) {
  if(N==0) return 0;
  int[] dp = new int[N+1];
  
  // base case
  dp[0] = 0;
  dp[1] = 1;
  
  // dp table
  for(int i = 2; i <= N; i++){
    dp[i] = dp[i-1] + dp[i-2];
  }
  
  return dp[N];
}
```

可以看出 DP table 的写法与之前带「备忘录」的递归写法非常相似，其实是反过来算的步骤。

![fib](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/g6tLs8.png)

状态转移方程，实际上就是描述问题结构的数学形式。在上述的题中把参数 n 看作一个状态，状态 n 由 状态 n-1 和 状态 n-2 转移（相加）而来。上面不同的解法都是围绕这个状态转换的不同的表现形式。**所以状体转移方程是整个解题的核心**（暴力解法）。

但往往在动态规划问题中最困难就是找到这个暴力解，只要找到暴力解，优化方法往往就是用备忘录或者 DP table。



#**进一步优化 DP table**

在斐波那契数列的状态转移方程中，当前状态只和（与当前状态相对的）两个状态有关，其实不需要长度为 n 的 DP table，只要想办法存储之前的两个状态即可。这样可以将空间复杂度将为 O(1)。

```java
public int fib(int N) {
  // base case
  if(N == 0 || N == 1){
    return N;
  }

  int dp_i_1 = 1, dp_i_2 = 0;
  for(int i = 2; i <= N; i++){
    int dp_i = dp_i_1 + dp_i_2;
    
    // 滚动更新
    dp_i_2 = dp_i_1;
    dp_i_1 = dp_i;
  }
  
  return dp_i_1;
}
```

（最后形成了常见的斐波那契算法）

动态规划问题的最后一步优化，如果发现每次状态转移只需要 DP table 的一部分，则可以尝试缩小 DP table 的大小，只记录必要的数据，降低空间复杂度。

斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。



### 凑零钱问题

🔗 leetcode-cn [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
> 你可以认为每种硬币的数量是无限的。
>
> 来源：力扣（LeetCode）
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



#**暴力递归**

首先，这个问题是动态规划问题，因为它具有「最优子结构」的。**要符合「最优子结构」，子问题间必须互相独立**。如果子问题并不独立，最优子结构就会被破坏。

凑零钱问题中，想求 `amount=11` 时需要最少的硬币数（原问题），如果知道凑出 `amount=10` 的最少硬币数（子问题），子需要把子问题的答案加一（再选一枚面值为 1 的硬币）就能得出原问题的答案。**因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。**

**列出正确的状态转移方程的思路**：

1. **确定 `base case` 。**显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。
2. **确定「状态」。**（**原问题和子问题中会变化的变量**）由于硬币的数量无限，硬币的面额时题目会定的，只有目标金额会不断向 `base case` 靠近。所以唯一的状态是目标金额 `amount`。
3. **确定「选择」。（也就是导致「状态」产生变化的行为）**目标金额为什么变化呢，因为你在选择硬币，**你每选择一枚硬币，就相当于减少了目标金额。**所以说所有硬币的面值，就是你的「选择」。
4. **明确 `dp` 函数/数组的定义**。自顶向下的解法会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

**所以我们可以这样定义 `dp` 函数：`dp(n)` 表示，输入一个目标金额 `n`，返回凑出目标金额 `n` 所需的最少硬币数量**。



**根据思路写出伪码框架**：

```java
int coinChange(int[] coins, int amount) {
  return dp(coins, amount); // 题目要求的最终结果是 dp(amount)
}

int dp(int[] coins, int n){
  for (int coin : coins){
    res = min(res, 1 + dp(n - coin));
  }
  return res;
}
```

根据伪码，加上 `base case` 即可得出最终的答案。（目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1）

```java
int coinChange(int[] coins, int amount) {
  return dp(coins, amount); // 题目要求的最终结果是 dp(amount)
}

int dp(int[] coins, int n){
  // base case 
  if (amount == 0) return 0;
  if (amount < 0) return -1;
  
  int res = Integer.MAX_VALUE;
  for (int coin : coins){
    // 计算子问题的结果
    int subProblem = dp(coins, amount - coin);
    // 子问题无解则跳过
    if (subProblem == -1) continue;
    // 在子问题中选择最优解，然后加一
    res = Math.min(res, subProblem + 1);
  }
  return res == Integer.MAX_VALUE ? -1 : res;
}
```

以上解法明显看出无限递归，假设目标金额为 `n`，给定的硬币个数为 `k`，那么递归树最坏情况下高度为 `n`（全用面额为 1 的硬币），然后再假设这是一棵满 `k` 叉树，则节点的总数在 `k^n` 这个数量级。

接下来看每个子问题的复杂度，由于每次递归包含一个 for 循环，复杂度为 `O(k)`，相乘得到总时间复杂度为 `O(k^n)`，指数级别。因此需要消除「重叠子问题」。



状态转移方程：根据上面的暴力解法。

![coin](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/e1YhJ1.png)



#**带备忘录的递归**

在上面的暴力递归的基础上，添加上备忘录存储结果，避免重复计算（消除「重复子问题」）

```java
class Solution {
    int []memo;

    public int coinChange(int[] coins, int amount) {
        memo = new int[amount+1];

        // 备忘录初始化为一个不会取到的特殊值（*不能为-1）代表未计算
        Arrays.fill(memo, -666);    
        return dp(coins, amount);
    }

    public int dp(int[] coins, int amount){
        if(amount == 0) return 0;
        if(amount < 0) return -1;

        // 查备忘录，防止重复计算
        if(memo[amount] != -666) return memo[amount];

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            
            // 子问题无解时
            if(subProblem == -1) continue;

            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
        
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
}
```

显然使用备忘录能大大减少子问题的数目，消除子问题的冗余，所以子问题的总数不会超过金额数 `n` ，即子问题数目为 O(n) ，处理了一个子问题时间不变，仍未 O(k)，所以总时间复杂度为 O(kn)。



#**dp 数组的迭代解法**

也可使用 dp table 消除重叠子问题，（与上述的状态、选择、base case 没有区别），使用 dp 数组体现在数组索引：

dp 数组的定义，当目标金额为 `i` 时，至少需要 `dp[i]` 凑出来。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount+1); // 数组大小设置为不可能取到的值（amount+1）
    
        // base case
        dp[0] = 0;

        // 外层for循环在遍历所有状态的所有取值
        for(int i = 0; i < dp.length; i++) {
            for(int coin : coins) {
                // 子问题无解时跳过
                if(i - coin < 0) continue;
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
}
```

> dp 数组为 `amount+1` 的问题：因为凑成的 `amount` 金额的硬币数只能是 `amount`（全为 1 元硬币时），设为 `amount+1` 相当于初始化为正无穷（无法取到的值）便于后续取最小值。（设为 `Integer.MAX_VALUE` 会导致后面 `dp[i-coin]+1` 整型溢出。） 

![6](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/KNnFio.jpg)



### 动态规划问题总结

+ 斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，**并且明确了这两种方法本质上是一样的**，只是自顶向下和自底向上的不同而已。
+ 凑零钱的问题，展示了如何流程化确定「**状态转移方程**」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。



**计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举**，穷举所有可能性。算法设计无非就是先思考「**如何穷举**」，然后再追求「**如何聪明地穷举**」。列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。



## 回溯算法框架

+ 回溯算法其实就是常说的 DFS 算法，本质上就是一种**暴力穷举算法**。
+ 穷举过程就是遍历一棵多叉树的过程。（解决回溯问题实际上就是解决一个决策树的遍历过程。）
  + 在回溯树的节点上思考三个点：**路径**（已经做出的选择）；**选择列表**（当前可以做的选择）；**结束条件**（到达决策树的底层无法再做选择的条件）。
+ **回溯算法的代码框架和多叉树遍历的代码框架类似**。

```java
List<Value> result;
void backtrack(路径, 选择列表){
  if(满足结束条件) {
    result.add();
  	return;
  }
  
  for (选择:选择列表){
    做选择;
    backtrack(路径, 选择列表)
    撤销选择;
  }
}
```

**回溯算法的框架核心就是「`for` 循环内的递归」，在递归调用之前「做选择」，在递归调用之后「撤销选择」。**

> 多叉树遍历框架：
>
> ```java
> void traverse(TreeNode root) {
> 	if(root == null) {
>  	return;
> 	} 
> 	for (TreeNode child : root.children)
>  		// 前序遍历需要的操作
>     traverse(child)
>     // 后序遍历需要的操作
> }
> ```



### 全排列问题

https://leetcode-cn.com/problems/permutations/

> 给定一个**不含重复数字**的数组 `nums` ，返回其 所有可能的全排列 。你可以`按任意顺序`返回答案。
>
> 示例 1：
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> 来源：力扣（LeetCode）
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



![img](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/Amrdvo.jpg)

只要从根遍历这棵决策树，**记录路径上的数字**，就是全排列。决策树在每个节点上都在做决策（选择）。



![img](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/jXSbw1.jpg)此时的路径是 `2` （记录已经做过的选择）；`[1,3]` 是选择列表（当前可以作出的选择）；「结束条件」是选择列表为空的时候（遍历到树的底层叶子结点时)



![img](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/jESa8a.jpg)

定义的 `backtrack ` 函数就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。



![img](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/0oFes4.jpg)

在这棵树上游走即对这棵树进行遍历。**前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行**。要正确维护节点的属性，就需要在这两个节点进行选择操作。

**只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。

#**解决全排列问题**

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    
    // 主函数
    List<List<Integer>> permute(int[] nums) {
        // 记录路径链表
        LinkedList<Integer> track = new LinkedList<>();

        // 路径中元素作true标记，避免重复使用
        boolean[] used = new boolean[nums.length];

        backtrack(nums, track, used);
        return res;
    }

    // 路径记录track中
    // 选择列表：nums中不存在于track的元素（used[i]为false）
    // 结束条件：nums中的元素全都在track中出现
    void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used){
        // 触发结束条件
        if(track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }

        for(int i = 0; i < nums.length; i++){
            // 排除不合法的选择
            if(used[i]){
                // 如果nums[i]已经在track中则跳过
                continue;
            }

            // 做选择
            track.add(nums[i]);
            used[i] = true;
            //进入下一层决策树
            backtrack(nums, track, used);
            // 取消选择
            track.removeLast();
            used[i] = false;
        }
    }
}
```



> 但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高**。





### N 皇后问题

https://leetcode-cn.com/problems/n-queens/

> n 皇后问题 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后**彼此之间不能相互攻击**。
>
> 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。
>
> ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)
>
> 输入：`n = 4`
> 输出：`[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]`
> 解释：如上图所示，4 皇后问题存在两个不同的解法。
>
> 来源：力扣（LeetCode）
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

> **皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。**



N 皇后问题本质上与全排列问题相似，决策树的每一层表示棋盘上的每一行，每个节点可以作出的选择是，在该行的任意一列放置一个皇后。



![img](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/gLBLuO.jpg)



```cpp
class Solution
{
public:
    vector<vector<string>> res;
    vector<vector<string>> solveNQueens(int n)
    {
        vector<string> board(n, string(n, '.'));
        backtrack(board, 0);
        return res;
    }

    // 路径：board 中小于 row 的那些行都已经成功放置了皇后
    // 选择列表：第 row 行的所有列都是放置皇后的选择
    // 结束条件：row 超过 board 的最后一行
    void backtrack(vector<string> &board, int row)
    {
        // 触发结束条件
        if (row == board.size())
        {
            res.push_back(board);
            return;
        }

        int n = board[row].size();
        for (int col = 0; col < n; col++)
        {
            // 排除不合法选择
            if (!isValid(board, row, col))
            {
                continue;
            }
            // 做选择
            board[row][col] = 'Q';
            // 进入下一行决策
            backtrack(board, row + 1);
            // 撤销选择
            board[row][col] = '.';
        }
    }

    // 判断选择
    bool isValid(vector<string> &board, int row, int col)
    {
        int n = board.size();

        // 检查列是否有皇后互相冲突
        for (int i = 0; i < n; i++)
        {
            if (board[i][col] == 'Q')
                return false;
        }

        // 检查右上方是否由皇后互相冲突
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
        {
            if (board[i][j] == 'Q')
                return false;
        }

        // 检查左上方是否由皇后互相冲突
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
        {
            if (board[i][j] == 'Q')
                return false;
        }

        return true;
    }
};
```



> + 因为皇后是一行一行从上往下放的，所以左下方，右下方和正下方不用检查（还没放皇后）；因为一行只会放一个皇后，所以每行不用检查。**也就是最后只用检查上面，左上，右上三个方向。**
> + 函数 `backtrack` 依然像个在决策树上游走的指针，通过 `row` 和 `col` 就可以表示函数遍历到的位置，通过 `isValid` 函数可以将不符合条件的情况剪枝：



### 回溯算法总结

回溯算法就是个多叉树的遍历问题，**关键就是在前序遍历和后序遍历的位置做一些操作**，算法框架如下：

```java
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```

>**写 `backtrack` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。



## BFS 算法框架

BFS 的核心思想是**把一些问题抽象成图**，从一个点开始，向四周开始扩散。一般来说， BFS 算法都是用「**队列**」这种数据结构，**每次将一个节点周围的所有节点加入队列**。

BFS 相对 DFS 的最主要的区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多。**

### BFS 的算法框架

> 引入问题：**在一幅「图」中找到从起点 `start` 到终点 `target`的最近距离**。广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。
>
> 以上这些问题其实本质都是在一幅图中，从起点走到终点，所需的最短路径。这就是 BFS 问题的本质。

```java
// BFS 算法框架
int BFS(Node start, Node target) {
  Queue<Node> q; // 核心数据结构队列
  Set<Node> visted; // 标记避免走回头路
  
  q.offer(start); // 将起点加入队列
  visted.add(start); // 标记起点
  
 	while(q not empty) {
    int sz = q.size(); 
    // 将当前队列中的所有节点向四周扩散
    for(int i = 0; i < sz; i++){
      // *重点：判断是否到达终点
      Node cur = q.poll();
      if(cur is target)
        return step;
      // 将cur的相邻节点加入队列
      for(Node x : cur.adj()) {
        if(x not in visited) {
          q.offer(x);
          visted.add(x)
        }
      }
    }
    // *重点：更新步数
    step++;
  }
}
```

+ `cur.adj()` 泛指 `cur` **相邻的节点**。比如二维数组中，`cur` **上下左右四面**的位置就是相邻节点。
+ `visited` 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 `visited`。



### 计算二叉树的最小高度

🔗 ： [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) 

![img](https://labuladong.github.io/algo/images/BFS/title1.jpg)

> 思路：首先明确一下起点 `start` 和终点 `target` 是什么，怎么判断到达了终点。**显然起点就是 `root` 根节点，终点就是最靠近根节点的那个「叶子节点」**，叶子节点就是两个子节点都是 `null` 的节点。
>
> ```java
> if(cur.left == null && cur.right == null) // 判断到达叶子结点
> ```
>
> 显然这里不会走回头路，所以就不必用到 `visited` 标记。



#**二叉树的最小深度初步解法**：

```java
public int minDepth(TreeNode root) {
  if (root == null)
    return 0;
  Queue<TreeNode> q = new LinkedList<>();
  q.offer(root); 
  int depth = 1; // root本身就是一层,depth初始化为1
  
  while (!q.isEmpty()) {
    int sz = q.size();
    // 将当前队列中的节点向四周扩散
    for (int i = 0; i < sz; i++) {
      TreeNode cur = q.poll();
      // 判断是否达到终点
      if (cur.left == null && cur.right == null) {
        return depth;
      }
      // cur的相邻节点加入队列
      if (cur.left != null)
        q.offer(cur.left);
      if (cur.right != null)
        q.offer(cur.right);
    }
    // 增加步数
    depth++;
  }
  return depth;
}
```

+ 注意 `while` 循环和 `for` 循环的配合，**`while` 循环控制一层一层往下走，`for` 循环利用 `sz` 变量控制从左到右遍历每一层二叉树节点**。
+ 这个框架在 BFS 算法中很常见，但是对于 [Dijkstra 算法]()在加权图中不是这种框架寻找最短路径。



> 相关问题的思考，与 DFS 算法相比：
>
> + BFS 能找到最短距离，但是 DFS 最好别：
>   + BFS 的逻辑，`depth` 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。
>   + DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，**肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长**。而 BFS 借助队列做到一次一步「齐头并进」，是可以**在不遍历完整棵树的条件下找到最短距离的**。
>
> > DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。
>
> + 上面的问题就可以看出，BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低：
>
>   二叉树是满二叉树，节点数为 `N`，对于 DFS 算法来说，空间复杂度就是递归堆栈，最坏情况下顶多就是树的高度，也就是 `O(logN)`。
>
>   对于BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下**空间复杂度应该是树的最底层节点的数量**，也就是 `N/2`，用 Big O 表示的话也就是 `O(N)`。
>
>   所以总结，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。



### 解开密码锁的最少次数

 [打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/) 

> 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'`。每个拨轮可以自由旋转：例如把 `'9'` 变为 `'0'`，`'0'` 变为 `'9'` 。**每次旋转都只能旋转一个拨轮的一位数字**。
>
> 锁的初始数字为 `'0000'` ，一个代表四个拨轮的数字的字符串。
>
> 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，**这个锁将会被永久锁定**，无法再被旋转。
>
> 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/open-the-lock
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



思路：

+ 先不管 `deadends` 组合。如果只转一下锁，从 `"0000"` 开始，转一次，可以穷举出 `"1000", "9000", "0100", "0900"...` 共 8 种密码。再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能。
+ **仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点**，又让你求最短距离，这不就是典型的 BFS 嘛，框架就可以派上用场了。

#**初始 BFS 框架解法**：

```java
// 将 s[j] 向上拨动一次
String plusOne(String s, int j) {
    char[] ch = s.toCharArray();
    if (ch[j] == '9')
        ch[j] = '0';
    else
        ch[j] += 1;
    return new String(ch);
}
// 将 s[i] 向下拨动一次
String minusOne(String s, int j) {
    char[] ch = s.toCharArray();
    if (ch[j] == '0')
        ch[j] = '9';
    else
        ch[j] -= 1;
    return new String(ch);
}

void BFS(String target){
  Queue<String> q = new LinkedList<>();
  q.offer("0000");
  
  while(!q.isEmpty()){
    int sz = q.size();
    // 将当前队列中的所有节点向周围扩散
    for(int i = 0; i < sz; i++) {
      String cur = q.poll();
      // 判断是否到达终点
      System.out.println(cur);
      
      // 将一个节点的相邻节点加入队列
      for(int j = 0; j < 4; j++){
        String up = plusOne(cur, j);
        String down = minusOne(cur, j);
        q.offer(up);
        q.offer(down);
      }
    }
    
  // 增加步数
  }
  return ;
}
```

上面的初始框架还是存在问题：

+ 会走回头路。比如说我们从 `"0000"` 拨到 `"1000"`，但是等从队列拿出 `"1000"` 时，还会拨出一个 `"0000"`，这样的话会产生死循环。
+ 没有终止条件。找到 `target` 就应该结束并返回拨动的次数。
+ 没有对 `deadends` 的处理，按道理这些「死亡密码」是不能出现的。所以遇到 `deadends` 的组合应该要跳过。



#**改进后最终解法**：

```java
// 将 s[i] 向上拨动一次
String plusOne(String s, int j) {
  char[] ch = s.toCharArray();
  if (ch[j] == '9')
    ch[j] = '0';
  else
    ch[j] += 1;
  return new String(ch);
}

// 将 s[i] 向下拨动一次
String minusOne(String s, int j) {
  char[] ch = s.toCharArray();
  if (ch[j] == '0')
    ch[j] = '9';
  else
    ch[j] -= 1;
  return new String(ch);
}

public int openLock(String[] deadends, String target) {
  // 记录需要跳过的密码
  Set<String> deads = new HashSet<>();
  for (String s : deadends)
    deads.add(s);
  // 记录已经穷举过的密码防止走回头路
  Set<String> visited = new HashSet<>();

  Queue<String> q = new LinkedList<>();

  // 从起点开始启动广度优先搜索
  int step = 0;
  q.offer("0000");
  visited.add("0000");

  while (!q.isEmpty()) {
    int sz = q.size();
    // 将当前队列中的所有节点向周围扩散
    for (int i = 0; i < sz; i++) {
      String cur = q.poll();
      // 判断是否到达终点
      if (deads.contains(cur))
        continue;
      if (cur.equals(target))
        return step;

      // 将一个节点的相邻节点加入队列
      for (int j = 0; j < 4; j++) {
        String up = plusOne(cur, j);
        if (!visited.contains(up)) {
          q.offer(up);
          visited.add(up);
        }
        String down = minusOne(cur, j);
        if (!visited.contains(down)) {
          q.offer(down);
          visited.add(down);
        }
      }
    }

    // 增加步数
    step++;
  }
  // 穷举完都没找到则说明找不到
  return -1;
}
```

> 优化改进：可以不需要 `dead` 这个哈希集合，可以直接将这些元素初始化到 `visited` 集合中。



### 双向 BFS 优化

**传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止**。

![img](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/699D8P.jpeg)

如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 `target`；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。从这个例子可以直观地感受到，双向 BFS 是要比传统 BFS 高效的。

但是，**双向 BFS 也有局限，因为必须要知道终点在哪里**。比如二叉树最小高度的问题，一开始根本就不知道终点在哪里，也就无法使用双向 BFS；但是第二个密码锁的问题，是可以使用双向 BFS 算法来提高效率的。



#**使用双向 BFS 优化的解开密码锁解法**：

```java
// 将 s[i] 向上拨动一次
String plusOne(String s, int j) {
  char[] ch = s.toCharArray();
  if (ch[j] == '9')
    ch[j] = '0';
  else
    ch[j] += 1;
  return new String(ch);
}

// 将 s[i] 向下拨动一次
String minusOne(String s, int j) {
  char[] ch = s.toCharArray();
  if (ch[j] == '0')
    ch[j] = '9';
  else
    ch[j] -= 1;
  return new String(ch);
}

public int openLock(String[] deadends, String target) {
  // 记录需要跳过的密码
  Set<String> deads = new HashSet<>();
  for (String s : deadends)
    deads.add(s);
  // 记录已经穷举过的密码防止走回头路
  Set<String> visited = new HashSet<>();
  // 使用集合不用队列更能判断元素是否存在
  Set<String> q1 = new HashSet<>();
  Set<String> q2 = new HashSet<>();

  // 从起点和终点同时开始启动广度优先搜索
  int step = 0;
  q1.add("0000");
  q2.add(target);

  while (!q1.isEmpty() && !q2.isEmpty()) {
    // 哈希表在遍历的过程中不能修改，用temp存储扩散结果
    Set<String> temp = new HashSet<>();

    // 将当前队列中的所有节点向周围扩散
    for (String cur : q1) {
      // 判断是否到达终点
      if (deads.contains(cur))
        continue;
      if (q2.contains(cur))
        return step;

      visited.add(cur);

      // 将一个节点的相邻节点加入队列
      for (int j = 0; j < 4; j++) {
        String up = plusOne(cur, j);
        if (!visited.contains(up)) {
          temp.add(up);
        }
        String down = minusOne(cur, j);
        if (!visited.contains(down)) {
          temp.add(down);
        }
      }
    }

    // 增加步数
    step++;
    // 交换q1和q2
    q1 = q2;
    q2 = temp;
  }
  return -1;
}
```

+ **不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集**。
+  **while 循环的最后交换 `q1` 和 `q2` 的内容**，所以只要默认扩散 `q1` 就相当于轮流扩散 `q1` 和 `q2`。



#**另一个优化点**：

```java
while (!q1.isEmpty() && !q2.isEmpty()) {
  if (q1.size() > q2.size()) {
  // 交换 q1 和 q2
  temp = q1;
  q1 = q2;
  q2 = temp;
  //...
```

因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。

**无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的**



