---
title: 🚨 Java 反射技术
date: 2022-03-02 11:11:51
permalink: /pages/e56959/
categories: 
  - JavaEE
  - MyBatis
tags: 
  - Java
author: 
  name: Simon
  link: https://github.com/simon1uo
---
Java 反射：在运行状态中，对于任何一个类，可以知道这个类的方法和属性；对于任何一个对象，可以调用它的方法和属性。这种动态获取对象信息和调用对象方法的功能成为「反射机制」。

+ 反射其实是获取类的字节码文件，也就是 `.class` 文件，可以通过 `Class` 类的对象获取。

+ 此前在 JDBC 中，加载数据库 JDBC 驱动

  ```java
  Class.forName(“com.mysql.jdbc.Driver”)
  ```

   中就是使用了 Java 反射的机制。



`Class` 类：

+ `Class` 类的实例表示正在运行的 Java 应用程序中的**类接口**。即 JVM 中的实例每个类都有该 Class 对象（包括基本数据类型）。
+ `Class` 类没有公共构造方法。`Class` 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 `defineClass` 方法自动构造的。即不需要去处理创建，JVM 会创建。
+ **注意在运行期间，一个类只有一个 `Class` 对象产生。**

![image-20220302143034619](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/4xn0bp.png)

**反射的本质理解：得到 `Class` 对象后，反向获取该对象的各种信息。**



## 反射的三种方式

1. `Object` -> `getClass()`：使用`Object` 类中的 `getClass()` 方法， 而所有类都继承了 `Object` 类。但已经有了实例对象，没有反射的必要，所以几乎不用该方法。

   🌰 例子：

   ```java
   Student stu = new Student();
   Class stuClass1 = stu.getClass();
   ```

2. 任何的数据类型（包括基本数据类型）都有一个「静态」的 `class` 属性，所以可以据此获得。但是**需要导入类的包**，依赖太强，所以较少用。

   🌰 例子：

   ```java
   Class stuClass2 = Student.class;
   System.out.println(stuClass2);
   ```

3. :star: 通过 `Class` 类的静态方法 `forName(String)`，一般常用这种方法，参数可以为一个字符串或者配置文件。

   🌰 例子：

   ```java
   Class stuClass3 = Class.forName("Student");
   System.out.println(stuClass3);
   ```



### 获取构造方法

通过 反射获取构造方法并使用：

+ 批量获取构造方法：

  + `public Constructor[] getConstructors()` ：获取所有「**公有**」构造方法；

  + `public Constructor[] getDeclaredConstructors()` ：获取所有的构造方法（包括私有、受保护、默认、公有类型）。

🌰 例子：

```java
Constructor[] constructors = stuClass1.getConstructors();
for(Constructor c : constructors){
  System.out.println(c);
}
```

+ 获得单个制定的构造方法：
  + `public Constructor getConstructor(parameter Types)`：获取取单个的「公有」构造方法。
  + `public Constructor getDeclaredConstructor(parameterTypes)`：获取某个制定的类型的构造方法。

🌰 例子：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"
::: tab java 
```java
Constructor con1 = stuClass1.getConstructor();
Object obj1 = con1.newInstance();
System.out.println(obj1.toString());

Constructor con2 = stuClass1.getConstructor(String.class, int.class);
Object obj2 = con2.newInstance("Simon", 22);
System.out.println(obj2.toString());
```
:::
::: tab result
```
Student{name='null', age=0}
Student{name='Simon', age=22}
```
:::
::::

> `newInstance` 是 `Constructor` 类的方法（管理构造函数的类），使用此方法来创建该构造方法的声明类的新实例，并用制定的初始化参数初始化该实例。



### 获取使用成员变量

+ 获取批量/单独的成员变量：
  + `public Field[] getFields()`：获取所有**公有的**成员变量。
  + `public Field[] getDeclaredFields()`：获取所有的成员变量。
  + `public Field[] getField()`：获取成员变量。
  + `public Field[] getDeclaredField()`：获取特定成员变量。

🌰 例子：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"
::: tab java 
```java
Field[] declaredFields = stuClass1.getDeclaredFields();
for (Field declaredField : declaredFields) {
  System.out.println(declaredField);
}
```
```java
Field name = stuClass1.getDeclaredField("name");
System.out.println(name);
Object obj = stuClass1.getConstructor().newInstance();
name.setAccessible(true); // 暴力反射，接触私有限定
name.set(obj, "Simon");
System.out.println(((Student) obj).getName());
```
:::
::: tab result
```
private java.lang.String Student.name
Simon
```
:::
::::




### 获得使用成员方法

+ 获取批量/单独的成员方法：
  + `public Method[] getMethods()` ：获取所有公有方法（包含了父类的方法也包含 Object 类)
  + `public Method[] getDeclaredMethods()`：获取所有的成员方法，包括私有的（不包括继承的）
  + `public Method[] getMethods(String name, Class<?> --- parameterTypes)`：获取单个成员方法。
  + `public Method[] getDeclaredMethods(String fieldName)`：获取特定成员方法。

🌰 例子：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"
::: tab java 

```java
Method[] methods = stuClass1.getMethods();
for (Method method : methods) {
  System.out.println(method);
}
```
:::
::: tab result 
```
public java.lang.String Student.getName()
public java.lang.String Student.toString()
public void Student.setName(java.lang.String)
public int Student.getAge()
public void Student.setAge(int)
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
```
:::
::::

🌰 例子：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"

::: tab java

```java
Method setAge = stuClass1.getMethod("setAge", int.class);
System.out.println(setAge);
Object obj = stuClass1.getConstructor().newInstance();
setAge.invoke(obj, 18); // 调用方法
System.out.println(((Student) obj).toString());
```

:::

::: tab result

```
public void Student.setAge(int)
Student{name='null', age=18}
```

:::

::::

> `Object invoke(Object obj, Object .args)`：是 `Method` 类的一个方法， 第一个参数是要调用方法的对象，后面参数是调用方式所传递的实参。
