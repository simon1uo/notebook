---
title: 🖼 SpringMVC 视图
date: 2022-03-20 11:19:49
permalink: /pages/81ebd2/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🚏SpringMVC
tags: 
  - SpringMVC
author: 
  name: Simon
  link: https://github.com/simon1uo
---
SpringMVC 中的视图是 `View` 接口，视图的作用是渲染数据，将模型 `Model` 中的数据展示给用户。

SpringMVC 中的视图种类有很多，默认有**转发视图** `InternalResourceView` 和**重定向视图** `RedirectView`。

+ 当工程引入 `jstl` 的依赖时，转发视图会自动转换为 `jstlView` （一般是 JSP 中）。
+ 若使用的视图技术为 `Thymeleaf` ，在 SpringMVC 中配置了 `Thymeleaf` 的视图解析器，由此视图解析器解析之后得到的是 `ThymeleafView` 。



## `ThymeleafView` 

当控制器方法中设置的视图名称:warning:**没有任何前缀**时，此时的视图名称会被 SpringMVC 配置文件所配置的**视图解析器**解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。



🌰 例子：

```java
@RequestMapping("/testThymeleafView")
public String testThymeleafView(){
    return "success";
}
```



## 转发视图

SpringMVC 中默认的转发视图是 **InternalResourceView**。

SpringMVC 中创建转发视图的情况：

+ 当控制器方法中设置的视图名称以 `forward: ` 为前缀时，创建转发视图 InternalResourceView，**此时的视图名称不会被 SpringMVC 配置中的视图解析器解析**，而是会将前缀的 `forward: ` 去掉，剩余部分作为最终路径**通过转发的方式实现跳转**。



🌰 例子： `forward:/ ` ，`forward:/employee` ：

```java
@RequestMapping("/testForward")
public String testForward(){
    return "forward:/testThymeleafView";
}
```

## 重定向视图

SpringMVC 中默认的重定向视图为 `RedirectView`。

当控制器方法中设置的视图名称以 `redirect: ` 为前缀时，创建重定向视图 RedirectView，此时的视图名称不会被 SpringMVC 配置中的视图解析器解析，而是会将前缀的 `redirect: ` 去掉，剩余部分作为最终路径**通过重定向的方式实现跳转**。



🌰 例子：`redirect:/testHello`：

```java
@RequestMapping("/testRedirect")
public String testRedirect(){
    return "redirect:/testThymeleafView";
}
```



## 转发和重定向

转发和重定向的区别：

+ 【**发送请求次数**】转发对于浏览器来说只是**发送一次请求**（另一次请求实际上在浏览器的内部发生，只是客户端看不到）；重定向对于浏览器来说是**发送两次请求**。（所以不管是转发和重定向，在服务器中都是两次请求）
+ 【浏览器地址】转发在浏览器地址栏中呈现的是**发送请求时的地址**；重定向在浏览器地址栏中呈现的是**重定向后的地址**。
+ 【`request` 域对象】转发时 `request` 域对象是同一个；重定向时 `request` 域对象不是同一个。
+ 【访问 `WEB-INF` 资源】转发可以访问 `WEB-INF` 目录下的资源；重定向不能访问 `WEB-INF` 下的资源（`WEB-INF` 目录下的资源具有安全性、隐藏性，**只能通过服务器内部访问，不能通过服务器外部访问。**）
+ 【是否可以跨域】转发不可以跨域；重定向可以跨域（因为转发是在服务器内部发生的，所以只能访问服务器内部资源；而重定向时浏览器发送的两次请求，可以访问任意资源。例如，可以重定向到某网站，不能转发到某网站。）





## 视图控制器 `view-controller`标签

当控制器方法中，仅仅用来实现页面跳转，即只需要设置**视图名称**时（没有其他请求过程处理），可以将处理器方法使用 `view-controller` 标签进行表示。



🌰：之前通过控制器配置的控制器方法，处理 `/` 的请求：

```java
public class DemoController {
    @RequestMapping("/")
    public String index(){
        return "index";
    }
}
```

现在可以通过在 `SpringMVC.xml` SpringMVC 核心配置文件中进行配置，代替上面的控制器方法：

```xml
<mvc:view-controller path="/" view-name="index" />
```

::: warning 

当 SpringMVC 设置任何一个 `view-controller` 时，**其他控制器中的请求映射将全部失效**，此时需要在 `SpringMVC.xml` SpringMVC 核心配置文件中进行配置**开启 MVC 注解驱动的标签**：

```xml
<!--开启SpringMVC注解驱动-->
<mvc:annotation-driven/>
```

:::



::: tip

MVC 的注解驱动功能有很多，例如：

+ 如果加上了默认的 Servlet 处理静态资源（例如 CSS、JavaScript），控制器请求映射会失效，这时需要配置 MVC 的注解驱动。
+ Java 对象转换为 JSON 对象，同样需要配置 MVC 的注解驱动。

因为使用的场景很多，所以一般情况下 MVC 的注解驱动是默认需要配置的。但是要注意需要了解不同情况下 MVC 的注解驱动的功能是什么。

:::



`InternalResourceViewResolver` （仅作了解）

::: details



+ 在 SpringMVC 配置文件，这里使用`InternalResourceViewResolver`代替`ThymeleafViewResolver`：

```xml
<bean id="InternalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/templates/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

+ 控制器方法：

```java
@Controller
public class JspController {
    @RequestMapping("/success")
    public String success() {
        return "success";
    }
}
```

+ 创建一个 `JSP` 页面：

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
    <head>
        <title>Jsp</title>
    </head>
    <body>
        <a href="${pageContext.request.contextPath}/success">success.jsp</a>
    </body>
</html>
```

`success.jsp`：

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
    <head>
        <title>Success</title>
    </head>
    <body>
        <h1>Success</h1>
    </body>
</html>
```

:::