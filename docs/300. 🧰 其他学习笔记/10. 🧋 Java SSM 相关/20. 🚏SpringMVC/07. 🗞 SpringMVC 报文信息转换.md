---
title: 🗞 SpringMVC 报文信息转换
date: 2022-04-19 22:48:54
permalink: /pages/2a2032/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🚏SpringMVC
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
**报文信息转换器** （HttpMessageConverter）：**将请求报文转换为 Java 对象，将 Java 对象转换为响应报文**。

报文信息转换器提供了两个注解和两个类型（请求和响应报文相关）：`@RequestBody`、`@ResponseBody`、`RequestEntity`、`ResponseEntity`（关于相应的使用的较多）。



### `@RequestBody` 注解

可以获取请求体，需要在控制器方法**设置一个形参**，使用 `@RequestBody` 进行标识，**当前请求的请求体就会为当前注解所标识的形参赋值**。



🌰 例子：

+ 后台控制器 `HttpController` ：

```java
@Controller
public class HttpController {

    @RequestMapping("/testRequestBody")
    public String testRequestBody(@RequestBody String requestBody){
        System.out.println("requestBody: " + requestBody);
        return "success";
    }
}
```

+ 前台测试页面：

```html
<form th:action="@{/testRequestBody}" method="post">
    username: <input type="text" name="username">
    password: <input type="password" name="password">
    <input type="submit" value="提交">
</form>
```

+ 测试结果：

```
requestBody: username=123&password=123456
```



### `@RequestEntity` 注解

封装请求报文（整个）的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参。



🌰 例子：

+ 后台控制器方法 `testRequestEntity`：

```java
@RequestMapping("/testRequestEntity")
public String testRequestEntity(RequestEntity<String> requestEntity){
    // requestEntity表示整个请求报文的信息
    System.out.println("请求头requestHeader：" + requestEntity.getHeaders());
    System.out.println("请求体：" + requestEntity.getBody());
    return "success";
}
```

+ 前台测试页面：

```html
<form th:action="@{/testRequestEntity}" method="post">
    username: <input type="text" name="username">
    password: <input type="password" name="password">
    <input type="submit" value="提交">
</form>
```

+ 测试结果：

```
请求头：[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="100", "Microsoft Edge";v="100"", sec-ch-ua-mobile:"?0", sec-ch-ua-platform:""macOS"", upgrade-insecure-requests:"1", origin:"http://localhost:8080", user-agent:"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36 Edg/100.0.1185.44", ... ]
请求体：username=234&password=12314
```



### `@ResponseBody` 注解

用于**标识一个控制器方法**，可以将该方法的**返回值直接作为响应报文的响应体响应到浏览器**。



🌰 通过 Servlet API 的 `HttpServletResponse` 对象响应浏览器数据：

::: details

+ 控制器方法 `testResponse` ： 

```java
@RequestMapping("/testResponse")
public void testResponse(HttpServletResponse response) throws IOException {
    response.getWriter().print("hello, response");
}
```

> 因为不跳转页面可以将控制器方法的类型设置为 `void` 。

+ 前台测试：

```html
<a th:href="@{/testResponse}">测试通过ServletAPI的Response响应浏览器数据</a>
```

:::



🌰 SpringMVC 中 `@ResponseBody` 响应浏览器数据：

+ 控制器方法 `testResponseBody`：

```java
@RequestMapping("/testResponseBody")
@ResponseBody
public String testResponseBody(){
    return "success from responseBody";
}
```

+ 前台测试：

```html
<a th:href="@{/testResponseBody}">测试通过@ResponseBody的Response响应浏览器数据</a>
```



🌰 SpringMVC 中 `@ResponseEntity` 处理 JSON 数据（响应浏览器一个**对象**类型的数据）

+ 控制器方法：

```java
@RequestMapping("/testResponseUser")
@ResponseBody
public User testResponseUser(){
    return new User(1, "Simon", "123456", 23, "male");
}
```

+ 前台测试：

```html
<a th:href="@{/testResponseUser}">测试通过@ResponseBody的Response响应浏览器对象类型的数据</a>
```

+ 测试结果：此时响应给浏览器的数据是 Java 对象类型，并没有转换为 JSON 响应给浏览器接收（浏览器并不能接接收 Java 对象类型的数据）。

<img src="https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/MeyYQj.png" alt="image-20220419233020617" style="zoom:50%;" />



### SpringMVC 处理 JSON

要转换 Java 对象类型为 JSON 类型，以解决响应浏览器时数据转换不能出错， 在 maven 中引入依赖 `jackson` 后即可：

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.13.2</version>
</dependency>
```



> 此时 SpringMVC 完成 `@ResponseBody` 处理过程如下：
>
> + 开启 **MVC 注解驱动**
> + `HandlerAdaptor`中会自动装配一个消息转换器`MappingJackson2HttpMessageConverter`，可以将响应到浏览器的 Java 对象转换 JSON 格式的字符串。
> + 使用`@ResponseBody`注解标识控制器方法。
> + 将 Java 对象作为控制器方法的返回值返回时 ，**会自动转换为 JSON 类型的字符串**。（实体类对象、 Map 对象转换为 JSON 对象，List 对象转换为 JSON 数组）

> **回顾 MVC 注解驱动的作用**：
>
> + 解决视图控制器 `view-controller` 造成其他请求失效的问题；
> + 解决默认 Servlet 处理器 `default-servlet-handler` 造成 `DispatcherServlet` 失效的问题（静态资源问题）；
> + 解决 Java 对象转换为 JSON 对象（JSON 格式字符串）的问题。



### SpringMVC 处理 AJAX


🌰 例子：

+ 控制器方法：

```java
@RequestMapping("/testAxios")
@ResponseBody
public String testAxios(String username, String password) {
    System.out.println("username: " + username + " password: " + password);
    return "success";
}
```

+ 前台测试：

```html
<div id="app">
    <a th:href="@{/testAxios}" @click="textAxios">测试SpringMVC处理AJAX请求</a>
</div>

<script type="text/javascript" th:src="@{/static/js/vue.js}"></script>
<script type="text/javascript" th:src="@{/static/js/axios.min.js}"></script>
<script type="text/javascript" >
    new Vue({
        el: "#app",
        methods: {
            textAxios(event) {
                axios({
                    method:"post",
                    url: event.target.href,
                    params: {
                        username: "admin",
                        password: "123456"
                    }
                }).then((response)=>{
                    alert(response.data)
                });
                event.preventDefault();
            }
        }
    })
</script>
```





### `@RestController` 注解

`@RestController` 注解是 SpringMVC 提供的一个**复合注解**，标识在控制器的类上，就相当于**为类添加了 `@Controller` 注解，并且为其中的每个方法添加了 `@ResponseBody` 注解**。（较多使用）



🌰 例子：
```java
@RestController
@RequestMapping("/httpController")
public class HttpController {
    @PostMapping("/testAxios")
    public String testAxios(User user) {
        return user.getUsername() + "," + user.getPassword();
    }
}
```



### `@ResponseEntity` 注解

**用于控制器方法的返回值类型**，该控制器方法的返回值就是**响应到浏览器的响应报文**。（自定义响应报文）



🌰 实现文件下载：

+ 后台控制器方法：

```java
@Controller
public class FileUpAndDownController {

    @RequestMapping("testDownload")
    public ResponseEntity<byte[]> testResponseEntity(HttpSession httpSession) {
        ServletContext context = httpSession.getServletContext();
        // 文件位置和名称
        final String path = "/static/img/";
        String fileName = "1.png";
        // 响应体
        String realPath = context.getRealPath(path + fileName);
        byte[] bytes = readFile(realPath);
        // 响应头
        MultiValueMap<String, String> headers = new HttpHeaders();
        headers.set("Content-Disposition", "attachment;filename=" + fileName);
        // 响应状态码
        HttpStatus status = HttpStatus.OK;
        // 响应实体
        return new ResponseEntity<>(bytes, headers, status);
    }

    private byte[] readFile(String realPath) {
        System.out.println(realPath);
        final int initSize = 0;
        byte[] bytes = new byte[initSize];
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(realPath));) {
            bytes = new byte[bis.available()];
            bis.read(bytes);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return bytes;
    }
}
```

+ 前台测试：

```html
<a th:href="@{/testDownload}">下载图片</a>
```



🌰 实现文件上传：

文件上传要求 `form` 表单的请求方式必须为 `post`，并且添加属性 `enctype="multipart/form-data"`。

SpringMVC 将上传的文件封装到 `MultipartFile` 对象中，通过此对象可以获取文件相关信息。



+ 添加 Maven 依赖 ：

```xml
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>
```

+ 在 SpringMVC 配置文件中：

```xml
<!--配置文件上传解析器，将上传文件自动封装为MutilpartFile对象-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>
```

> 必须要配置 `id` 属性为 `multipartResolver` ，SpringMVC 根据 `id` 获取 bean。

+ 控制器方法：

```java
@RequestMapping("/testUpload")
public String testUpload(MultipartFile photo, HttpSession session) throws IOException {
    // 目标目录
    String photoPath = session.getServletContext().getRealPath("photo");
    File file = new File(photoPath);
    if (!file.exists()) {
        file.mkdir();
    }
    // 目标文件名
    String fileName = photo.getOriginalFilename();
    // 上传文件到服务器
    photo.transferTo(new File(photoPath + File.separator + fileName));
    return "success";
}
```



+ 前台测试：

```html
<form th:action="@{/testUpload}" method="post" enctype="multipart/form-data">
    上传头像：<input type="file" name="photo"><br>
    <input type="submit" value="上传">
</form>
```

> `enctype` 属性即`encode type`，表示编码类型，它规定了在发送到服务器之前应该如何对表单数据进行编码。
>
> 默认地，`form` 表单数据编码默认值为 `application/x-www-form-urlencoded`。除此之外，`enctype `还可以设置为`text/plain`
>
> 这三种类型是：
>
> - `application/x-www-form-urlencoded`：默认值，URL 编码
>
> - `multipart/form-data`：文件类型
>
> - `text/plain`：纯文本格式类型



+ 处理文件同名问题，使用生成一个随机的文件名以免产生冲突：

