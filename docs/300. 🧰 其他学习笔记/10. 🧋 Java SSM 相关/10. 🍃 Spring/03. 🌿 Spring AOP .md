---
title: 🌿 Spring AOP
date: 2022-03-28 20:44:14
permalink: /pages/dad650/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🍃 Spring
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## Spring AOP 概述

+ AOP 定义：Aspect Oriented Programming，**面向切面编程**（方面），通过预编译和运行时动态代理拓展程序功能。
+ AOP 作用：利用 AOP 可以对业务逻辑的各个部分隔离，降低耦合性，提高程序可重用行和开发效率。
+ 场景： 日志记录，性能统计，安全控制，事务处理，异常处理
+ 通俗描述：不修改原功能源代码的方式，**在主干功能中添加新的功能**。



🌰 例子，使用登录功能案例说明 AOP：

+ 添加权限判断功能，不通过修改主干登录功能添加新的判断权限模块。这个过程就叫做 AOP 。这个过程的好处，将功能分离出来， 此后不需要此功能时可以简易分离，降低功能耦合度。





## AOP 的底层原理

+ AOP底层原理：**动态代理**
  + **有接口情况**：JDK 动态代理。
  + **无接口情况**：CGLib 动态代理。

（参考设计模式可以了解上面两种代理方式）

由于 Spring5 中对上述代理已经做了很好的封装，只需要通过最简单的方式进行配置即可。需要对原理有一定的认识，才能做到以不变应万变。



### JDK 动态代理



🌰 例子：有接口的情况

+ 假设有接口与它的实现类：

```java
public interface UserDAO {
    void login();
}
```

```java
public class UserDAOImpl implements UserDAO {
    @Override
    public void login(){
        //登录实现过程
    }
}
```

+ 这个时候要在原始代码的基础上添加新的功能，使用 JDK 动态代理，**创建 `UserDAO` 实现类的代理对象**，通过代理对象增强功能。



### CGlib 动态代理



🌰 例子：没有接口的情况：

+ 假设有 `User` 实体类与它的方法：

```java
public class User {
    public void add(){
        //...
    }
}
```

+ 使用原始方法时：

```java
// 原始方法：通过子类继承，重写User类方法
public class Person extends User {
    @Override
    public void add(){
        super.add();
        //增强代码逻辑
    }
}
```

+ 当没有接口的情况，可以创建 `User` 类的**子类代理对象**。





## JDK 动态代理的实现

+ 实现方式：使用 `Proxy` 类中的方法创建代理对象。

> `Proxy` 类：`java.lang.Object` / `java.lang.reflect.Proxy`

+ 具体方法：`newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`

> + 返回指定接口的代理类的实例，该接口方法调用分派给指定的调用处理程序。
>
> + 三个参数：
>   + `ClassLoader loader` ：类的加载器。
>   + `Class<?>[] interfaces`：增强方法所在类实现的接口数组（表明可以多个接口）
>   + `InvocationHandler h`：实现`InvocationHandler`接口，创建代理对象，编写增强方法。



🌰 例子（原始学习例子）：

::: details

+ 创建 UserDAO 接口与其对应的实现类：

```java
public interface UserDAO {
    public int add(int a, int b);

    public String update(String id);
}
```

```java
public class UserDAOImpl implements UserDAO{
    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public String update(String id) {
        return id;
    }
}
```

+ 使用 `Proxy` 创建 `UserDAO` 的代理对象：

```java
// 创建代理对象代码
class UserDAOProxy implements InvocationHandler {

    // 把创建的是谁的代理对象，把谁传递过来
    // 通过有参构造方法进行传递
    private Object object;

    public UserDAOProxy(Object object) {
        this.object = object;
    }

    // 增强方法的逻辑
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 增强方法之前
        System.out.println("在方法之前执行，执行的方法名: " + method.getName() + ": 传递的参数" + Arrays.toString(args));

        // 被增强的方法执行
        Object res = method.invoke(object, args);

        // 增强方法之后执行
        System.out.println("方法之后执行" + object);
        return res;
    }
}
```

> 可以使用 `method.getName()` 对要增强的特定的方法进行判断，执行特定的增强代码。

```java
public class JDKProxy {
    public static void main(String[] args) {
        Class[] interfaces = {UserDAO.class};
        /*Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                return null;
            }
        });*/
        UserDAOImpl userDAO = new UserDAOImpl();

        UserDAO dao = (UserDAO) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDAOProxy(userDAO));
        int result = dao.add(1, 2);
        System.out.println("result" + result);


    }
}
```

:::

🌰 例子（改进完成度例子）：

::: details

+ 创建 UserDAO 接口与其对应的实现类：

```java
public interface UserDAO {
    public int add(int a, int b);

    public String update(String id);
}
```

```java
public class UserDAOImpl implements UserDAO{
    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public String update(String id) {
        return id;
    }
}
```

+ 创建 `UserDAO` 代理对象类 `UserDAOProxy`：

```java
public class UserDAOProxy {
    private UserDAO target;

    public UserDAOProxy(UserDAO target) {
        this.target = target;
    }

    public UserDAO newProxyInstances() {
        Class<?> targetClass = target.getClass();
        ClassLoader classLoader = targetClass.getClassLoader();
        Class<?>[] interfaces = targetClass.getInterfaces();
        return (UserDAO) Proxy.newProxyInstance(classLoader, interfaces, new UserDAOInvocationHandler());
    }

    class UserDAOInvocationHandler implements InvocationHandler {

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            // 增强方法之前
            System.out.println("before method: " + method.getName() + ", args: " + Arrays.toString(args));

            // 被增强的方法执行
            Object res = method.invoke(target, args);

            // 增强方法之后执行
            System.out.println("after method:" + target);
            return res;
        }
    }

    public static void main(String[] args) {
        UserDAO target = new UserDAOImpl();
        UserDAOProxy userDAOProxy = new UserDAOProxy(target);
        UserDAO userDAO = userDAOProxy.newProxyInstances();
        int result = userDAO.add(1, 2);
        System.out.println(result);
        userDAO.update("04191707");
    }
}
```

::: 



## AOP 术语

+ 连接点： **类中可以被增强的方法**。
+ 切入点：**类中实际被增强的方法**。
+ 通知（增强）：**实际增强的逻辑部分**。通知分为五种类型：
  + 前置通知：方法执行之前的处理。
  + 后置通知：方法执行之后的处理。
  + 环绕通知：方法执行**前后**的处理。
  + 异常通知：方法**抛出异常**的处理。
  + 最终通知：方法执行最终的处理（相当于 `try-catch-finally` 中的 `finally` 部分）。
+ 切面： 是一个动作，即把**通知应用到切入点的过程**。



🌰 理解例子：

::: details

```java
class User {
  add();
  
  update();
  
  select();
  
  delete();
}
```

+ 类中四个方法被增强，所以这四个方法可以称为连接点。

+ 如果此时 `add()` 方法被增强，这是的切入点为 `add()` 方法。

:::



## AOP 操作准备



### AspectJ 介绍

Spring 一般都是基于 `AspectJ` 实现 AOP 操作的：

- `AspectJ` 不是 Spring 的一部分，而是**一个独立的 AOP 框架**。

- 一般会把 `AspectJ `和 Spring **搭配使用，进行 AOP 操作**，因为这样更加方便。



+ 基于 AspectJ 进行 AOP 操作的两种方式：
  + 基于 XML 配置文件方式实现。
  + 基于注解方式实现。（推荐使用）



### 引入 AOP 相关依赖

![image-20220328224550819](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/ebAArl.png)

+ （在项目工程中）在 `maven` 中引入依赖：

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjrt</artifactId>
    <version>1.9.8</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.8</version>
</dependency>
```



### 切入点表达式

+ 作用：**知道对哪个类的方式进行增强**。
+ 语法结构：`execution([权限修饰符][返回类型][类全路径][方法名]([参数列表]))`



🌰 例子：

+ :one: 对 `com.simon.dao.BookDAO` 中的 `add()` 方法进行增强：

```java
execution(* com.simon.dao.bookDAO.add(..))
  // 此处*标识所有权限修饰符
```

+ :two: 对 `com.simon.dao.BookDAO` 类中的所有方法进行增强：

```java
execution(* com.simon.dao.bookDAO.* (..))
  // 此处第二*标识所有方法
```

+ :three: 对 `com.simon.dao` 包中的所有的类中的所有方法进行增强：

```java
execution(* com.simon.dao.*.*(..))
```



## 基于注解的 AOP 操作

### AspectJ 注解实现



+ 在 Spring 配置文件中，开启注解扫描：
  + 引入 `context` 和 `aop` 名称空间。
  + 配置组件扫描基础包（**开启组件注解扫描**）。
  + 开启 AspectJ 生成代理对象。

::: details

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">


    <!--开启注解扫描-->
    <context:component-scan base-package="com.simon.aopanno"/>

    <!--开启Aspect生成代理对象-->
    <aop:aspectj-autoproxy/>
</beans>
```

:::



+ **创建被增强对象和增强对象**：

🌰 使用注解创建 `User` 和 `User` 对象：

```java
@Component
public class User {
    public void add(){
        System.out.println("add... ");
    }
}
```

```java
@Component
@Aspect // 生成代理对象
public class UserProxy {
    // 前置通知
    public void before(){
        System.out.println("before");
    }
}
```

+ 添加详细的增强通知、增强类注解和切入点表达式：

::: details

```java
@Component
@Aspect // 生成代理对象
public class UserProxy {
    // 前置通知
    @Before(value = "execution(* com.simon.aopanno.User.add())")
    public void before(){
        System.out.println("before..");
    }

    // 后置通知
    @AfterReturning(value = "execution(* com.simon.aopanno.User.add())")
    public void afterReturning(){
        System.out.println("afterReturning ...");
    }

    // 最终通知
    @After(value = "execution(* com.simon.aopanno.User.add())")
    public void after(){
        System.out.println("after...");
    }

    // 异常通知
    @AfterThrowing(value = "execution(* com.simon.aopanno.User.add())")
    public void afterThrowing(){
        System.out.println("afterThrowing");
    }

    // 环绕通知
    @Around(value = "execution(* com.simon.aopanno.User.add())")
    public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println("before around");
        proceedingJoinPoint.proceed(); // 被增强的方法执行
        System.out.println("after around");
    }
}
```



::: warning 

+ ` afterReturning` 也叫返回值后通知。 
+ `after` 最终通知不管有无异常都会执行，而 `afterReturning` （后置通知或者返回通知）当有异常就不会执行。

::: 



+ 编写测试类和测试方法：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab testCode

```java
public class TestAop {

    @Test
    public void TestAop() {
        ApplicationContext context = new ClassPathXmlApplicationContext("UserProxyBean.xml");
        User user = context.getBean("user", User.class);
        user.add();
    }
}
```

:::

::: tab result

+ 运行测试结果：

```
before around
before..
add... 
afterReturning ...
after...
after around

Process finished with exit code 0
```

:::

::::

+ 为了测试 `@AfterThrowing` 作以下修改：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab testCode

+ 在 `User` 类中：

```java
@Component
public class User {
    public void add() {
        int i = 1 / 0; // 模拟异常情况
        System.out.println("add... ");
    }
}
```

:::

::: tab result

+ 运行测试结果：

```
before around
before..
afterThrowing
after...

java.lang.ArithmeticException: / by zero

	at com.simon.aopanno.User.add(User.java:8)
```

对比正常的情况，异常情况下，`@AfterReturning` 后置通知和 `@Around` 环绕后置通知的部分处理没有进行，而 `@After` 最终通知无论如何都会进行。

:::

::::



### 抽取公共切入点表达式

（重用相同的切入点表达式）

同时我们发现切入点表达式都是完全一样的，可以对这些相同的切入点表达式进行抽取，以达到重用切入点表达式定义的目的。

+ 可以将相同的切入点表达式定义为成员变量：

```java
private final String execution = "execution(* com.simon.aopanno.User.add())";
```

+ **在增强代理对象类中，使用 AspectJ 提供的 `@Pointcut` 注解。**

🌰 例子：

```java
@Pointcut(value = "execution(* com.simon.aopanno.User.add())")
public void pointDemo(){

}
```



🌰 完整例子（延续上述注解实现的例子）：

::: details 

+ 完整的 `UserProxy` 类使用公共的切入点表达式：

```java
@Component
@Aspect // 生成代理对象
public class UserProxy {
    @Pointcut(value = "execution(* com.simon.aopanno.User.add())")
    public void pointDemo(){

    }

    // 前置通知
    @Before(value = "pointDemo()")
    public void before(){
        System.out.println("before..");
    }

    // 后置通知
    @AfterReturning(value = "pointDemo()")
    public void afterReturning(){
        System.out.println("afterReturning ...");
    }

    // 最终通知
    @After(value = "pointDemo()")
    public void after(){
        System.out.println("after...");
    }

    // 异常通知
    @AfterThrowing(value = "pointDemo()")
    public void afterThrowing(){
        System.out.println("afterThrowing");
    }

    // 环绕通知
    @Around(value = "pointDemo()")
    public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println("before around");
        proceedingJoinPoint.proceed(); // 被增强的方法执行
        System.out.println("after around");
    }
}
```

:::



### 设置增强类优先级

如果有多个增强类对类中的同一个方法进行增强，可以设置**增强类的优先级**，来决定哪一个增强类优先执行，哪一个增强类后执行。

+ 使用 AspectJ 提供的 `@Order` 注解设置优先级，其中指定优先级的数字，格式为 `@Order(数字类型值)`，数字类型值遵循以下规则：

  - **数字类型值最小，优先级越高**。

  - **数字类型值越大，优先级越低。**



🌰 增强类优先级例子：

::: details

+ 创建新的一个增强类 `PersonProxy` 类，使用 `@Order` 优先级注解设置两个类的优先级，如下：

```java
@Component
@Aspect
@Order(1)
public class PersonProxy {
    //...
}
@Component
@Aspect
@Order(3)
public class UserProxy {
    //...
}
```

+ 测试结果如下：

```
Person before around
Person before..
before around
before..
add... 
afterReturning ...
after...
after around
Person afterReturning ...
Person after...
Person after around

Process finished with exit code 0
```

::: tip

可以看出：

+ `PersonProxy` 中的前置通知先于 `UserProxy` 中的前置通知执行
+ **`PersonProxy` 中的后置通知晚于 `UserProxy` 中的后置通知执行**

::: 



### 完全注解开发

要用完全注解的方式进行开发，可以使用注解配置类替代 Spring 的配置文件：
🌰 例子：

+ 创建 `AopConfig` 类：

```java
@Configuration
@ComponentScan(value = "com.simon.aopanno")
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AopConfig {
}
```

> 使用注解与配置文件中的相关对象：
>
> + `@ComponentScan` 注解进行了组件扫描，对应配置文件中的 `<context:component-scan>` 。
> + `@EnableAspectJAutoProxy` 开启 AspectJ 生成代理对象，对应配置文件中的 `<aop:aspectj-autoproxy>`。

## 基于配置文件的 AOP 操作 

（了解即可，实际运用中一般使用注解方式）

🌰 例子：
::: details

+ 创建被增强的对象（`Book` 类）和增强对象（`BookProxy` 类）：

```java
public class Book {
    public void buy(){
        System.out.println("Book.buy() ... ");
    }
}
```

```java
public class BookProxy {
    public void before(){
        System.out.println("before ... ");
    }

    public void afterReturning(){
        System.out.println("afterReturning ... ");
    }

    public void after(){
        System.out.println("after ... ");
    }

    public void afterThrowing(){
        System.out.println("afterThrowing ... ");
    }

    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("around before ...");
        joinPoint.proceed();
        System.out.println("around after ...");
    }

}
```

+ 在 Spring 配置文件中引入 `aop` 命名空间：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
```

+ 在 Spring 配置文件中创建两个类的对象：

```xml
<!--创建两个类的对象-->
<bean id="book" class="com.simon.aopxml.Book"/>
<bean id="bookProxy" class="com.simon.aopxml.BookProxy"/>
```

+ 在 Spring 配置文件中配置 `aop` 增强：

```xml
<!--配置aop增强-->
<aop:config>
    <!--配置切入点-->
    <aop:pointcut id="p" expression="execution(* com.simon.aopxml.Book.buy(..))"/>
    <!--配置切面-->
    <aop:aspect ref="bookProxy">
        <!--配置增强作用在哪个方法上-->
        <aop:before method="before" pointcut-ref="p"/>
        <!--后置通知-->
        <aop:after-returning method="afterReturning" pointcut-ref="p"/>
        <!--最终通知-->
        <aop:after method="after" pointcut-ref="p"/>
        <!--异常通知-->
        <aop:after-throwing method="afterThrowing" pointcut-ref="p"/>
        <!--环绕通知-->
        <aop:around method="around" pointcut-ref="p"/>
    </aop:aspect>
</aop:config>
```

:::
