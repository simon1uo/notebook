---
title: 🛠 MyBatis 配置文件
date: 2022-03-21 22:24:08
permalink: /pages/37eeab/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🗺 MyBatis
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
MyBatis 的持久化解决方案将用户从原始的 JDBC 访问中解放出来，用户只需要定义 SQL 语句，无需关心底层的 JDBC 操作，就可以**面向对象**的方式进行持久层操作。底层数据库连接的获取、数据访问的实现、事务控制等都无须用户关心，从而将应用层从底层的 JDBC / JTA API 中抽取出来。



## MyBatis 核心组件四个部分

+ 构造器 `SqlSessionFactoryBuilder`
+ 工厂 `SqlSessionFactory`
+ 会话`SqlSession`
  + 执行期 `Executor`
  + 参数处理器 `ParameterHandler`
  + JDBC 封装器 `StatementHandler`
  + 结果处理器 `ResultSetHandler`
+ 映射器 `SqlMapper`

<img src="https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/kYA7Fu.png" alt="image-20220307172802256" style="zoom:50%;" />

### 构造器 `SqlSessionBuilder` 

MyBatis提供了构造器SqlSessionFactoryBuilder，它会根据全局配置文件来生成SqlSessionFactory，它采用的是分步构建的建造者模式来完成工作，其中也当然会包括插件插入等。通常情况下使用它的 `build` 方法来创建 `SqlSessionFactory` 的对象。

创建` SessionFactory` 成功后它就失去作用，因此**它的实例不应该长期存在**。

在 MyBatis 中，既可以通过读取配置的 XML 文件的形式生成 `SqlSessionFactory`，也可以通过 Java代码（注解）的形式去生成 `SqlSessionFactory`。

### 工厂 SqlSessionFactory

通常每个数据库会**只对应一个** `SqlSessionFactory` 的对象（如创建多个会造成资源浪费)，它可被认为是一个数据库连接池。`SqlSessionFactory` 唯一的作用就是以工厂模式生产 `SqlSession` 的对象，通常情况下使用它的 `openSession` 方法来创建 `SqlSession`的对象。

`SqlSessionFactory` 对象是线程安全的，其生命周期通常是整个 MyBatis 的应用之中，因此一旦创建就长期保存它，直到不再使用 MyBatis。 注意`SqlSessionFactory` 是一个接口，在 MyBatis中它存在两个实现类：
`SqlSessionManager` 和 `DefaultSqlSessionFactory`。一般而言，具体是由
`DefaultSqlSessionFactory` 去实现的，而 `SqlSessionManager` 使用在多线 程的环境中，它的具体实现依靠 `DefaultSqlSessionFactory`。



### 会话 `SqlSession`

`SqlSession` 是**执行持久化操作**的，它的对象是应用程序与持久层之间执行交互操作的一个单线程对象，类似于 JDBC 中的 `Connection` 对象，代表着一个连接资源的启用。
`SqlSession` 的主要作用有：使用动态代理模式获取 `Mapper` 接口，发送 SQL 给教据库．控制教据库事务等。在 MyBatis 中，`SqlSession` 有两个实现类，`DefaultSqlSession` 和 `SqlSessionManager` 。`DefaultSqlSession` 是单线程使用的，而 `SqlSessionManager` 在多线程环境下使用。

常用方法：

+ `getMapper(Class<T> type)`：返回 `Mapper` 接口代理对象

+ `void commit()`：提交事务

+ `void rollback()`：回滾事务

+ `void clearCache()`：清除缓存

+ `void close()`：关闭 `SqlSession` 对象

  使用完后要及时关闭，通常可将其放在 `finally` 中关闭

```java
SqlSession sqlSession = sqlSessionFactory.openSession();
try {
  // 此处执行持久化操作 
} finally {
  sqlSession.close();
}
```



`SqlSession` 下的四大对象：

+ `Executor` （执行器）：`SqlSession` 会话其实是一个门面，真正干活的是执行器，它是一个真正执行 Java 和数据库交互的对象。
+ `StatementHandler` （ JDBC 封装器）：顾名思义，`StatementHandler`  （ JDBC 封装器）就是专门处理数据库会话的。
+ `ParameterHandler` （参数处理器）：MyBatis 通过 `ParameterHandler`（参教处理器）对预编译语句进行参教设置的。
+ `ResultSetHandler` （结果处理器）:MyBatis 通过 `ResultSetHandler` （结果处理器）对运回的结果集进行组装。



### 映射器 `SqlMapper` 

映射器是 MyBatis 中最重要、最复杂的组件，它由一个接口和对应的 XML 文件（或注解）组成。它的生命周期与 `SqlSession` 一致，一般来说生命周期应该等于或者小于 `SqlSession`。

映射器的主要作用就是将 SQL 查询到的结果映射为一个持久化类，或者将持久化类的数据插入到数据库中，并定义一些关于缓存等的重要内容。它可以配置以下内容：描述映射规则；提供 SQL 语句，并可以配置 SQL参数类型、返回类型、缓存刷新等信息；配置缓存；提供动态 SQL。

注意，**映射器开发只是一个接口，而不是一个实现类**。接口不能直接运行。MyBatis 运用了**动态代理技术**使得接口能运行起来。



## MyBatis 配置文件

### 配置文件结构顺序

**配置文件中的标签必须按照固定的顺序**：

> `properties` - `settings`  - `typeAliases` - `typeHandlers` - `objectFactory`  - `objectWrapperFactory` - `reflectorFactory` - `plugins` - `environments` -  `databaseIdProvider`  - `mappers`

```xml
<configuration> <!--配置-->
	<properties/> <!--属性-->
	<settings/> <!--设置-->
	<typeAliases/> <!--别名-->
	<typeHandlers/> <!--类型转换器-->
	<objectFactory/> <!--对象工厂（了解）-->
	<plugins/><!--插件（了解)-->
  <environments><!--适行环境-->
		<environment> <!--环境变量-->
			<transactionManager/><!--事务管理器-->
			<datasource/> <!--数据源-->
    </environment>
  </environments>
	<databaseldProvider/> <!--数据库厂商标识（了解)-->
	<mappers/> <!--映射器-->
</configuration>
```



### `properties` 元素

可以给系统配置一些运行参数。

+ 使用其于元素 `<property>` 的 `name` 和 `value` 属性，建立键值对。例如：

```xml
<properties>
	<property name="db.driver" value="com.mysal.jdbc.Driver" />
</properties>
<environments default="mysql">
  <environment id="mysql">
    <transactionlanager type="JDBC"></transactionlanager>
    <dataSource type="POOLED">
      <property name="driver" value="${db.driver}"/>
      <property name="ur1" value="jdbc:mysql://localhost:3306/test"/>
      <property name="username" value="root"/>
      <property nane="password" value="**"/>
  </dataSource>
  </environment>
</environments></environment>
```



### `settings` 元素

`<settings>` 可以更改 MyBatis 框架的一些默认参数，从而改变 MyBatis 运行时的行为，如自动映射、级联规则等。

🌰 例如开启自动驼峰规则（将获取到的字段名自动转换为驼峰规则命名以适应对应实体类中的属性名称）：

```xml
<configuration>
<settings>
  <setting name="mapUnderscoreToCamelCase" value="true"/>
	</settings＞
</configuration>
```

`settings` 元素的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了。



### `typeAliases` 元素

`<typeAliases>` 如果类的全名很长，又需要大量使用的时候，可以用一个简写来代替，这就是别名。MyBatis 中别名不区分大小写。

MyBatis 框架己经默认为许多常见的Java类型提供了相应的类型别名一些系统已定义的别名，如 `String` 别名 `string` 等。

因为 MyBatis 中别名不区分大小写，有一些基本数据类型和包装类型的名称一样（例如基本数据类型 `byte` 和包装类型 `java.lang.Byte` ），所以在基本的数据类型前面加了下划线来以此区分（ `byte` 别名就是 `_byte` ， `java.lang.Byte` 别名就是 `byte` ）。常见的类型对应别名如下：

详细设置：

`typeAliases` ：设置某个具体的类型的别名

🌰例子：

  ```xml
<typeAliases>
  <typeAlias type="com.mybatis.pojo.User" alias="User" />
</typeAliases>
  ```

  然后在 mapper 配置文件中就可以使用别名代表该类型全名：

  ```xml
<!--List<User> getAllUser();-->
<select id="getAllUser" resultType="User">
  select * from user
</select>
  ```

  + `type`：需要设置别名的类型的全类名。
  + `alias`：设置此类型的别名。若不设置此属性，该类型拥有默认的别名，**即类名且不区分大小写**；若设置此属性，此时该类型的别名只能使用 `alias` 所设置的值

  :star: 最常用：以包为单位，将包下所有类型设置默认的类型别名，即类名且不区分大小写。

  ```xml
<typeAliases>
  <package name="com.mybatis.pojo"/>
</typeAliases>
  ```

### `typeHandlers` 元素

`<typeHandlers>` MyBatis 根据数据类型通过类型转换适配器 `typeHandler` 来实现数据类型间的转换。

+ 一般情况下 MyBatis 会根据 `javaType` 和数据库的 `jdbcType` 来决定采用哪个 `typeHandler` 处理类型转换。MyBatis 内部已经定义了许多有用的 `typeHandler`，实现大部分情况下的自动转换。

+ 参考：表列出了 MyBatis 内置的 `typeHandler` 处理器。

+ 但有些场景下，比如数据库使用特殊类型，使用自定义枚举类型等，我们要使用自定义的 typeHandler 来处理类型之间的转换问题。 `typeHandler` 元素可以在配置文件中注册自定义的类型处理器，它的使用方式可以用它的子标签 `<typeHandler>` 注册一个类的类型处理器。

🌰 例如数据库中的 `user` 表性别为 M 或 F ，我们利用自定义类型转换器与程序中的「男」或「女」相互转换。（详细步骤已折叠）

::: details

1. 先写一个自定义的类型转换器 MyTypeHandler，这个类要实现 `TypeHandler` 接口并实现里面的四个转换方法的定义（或者继承于 `BaseTypeHandler` 基类）。

```java
public class SexTypeHandler implements TypeHandler<String> {

    /**
     * 根据Java中类型「男」或者「女」向数据库写入「M」或者「F」
     */
    @Override
    public void setParameter(PreparedStatement preparedStatement, int i, String s, JdbcType jdbcType) throws SQLException {
        if (s.equals("男"))
            preparedStatement.setString(i, "M");
        else if (s.equals("女"))
            preparedStatement.setString(i, "F");
        else
            preparedStatement.setString(i, "N");
    }

    /**
     * 根据数据库列名称s查找到的结果为「M」或者「F」，转为Java中使用的「男」或者「女」
     */
    @Override
    public String getResult(ResultSet resultSet, String s) throws SQLException {
        String result = resultSet.getString(s);
        if (result.equals("M"))
            return "男";
        else if (result.equals("F"))
            return "女";
        else
            return "未知";
    }

    /**
     * 根据数据库列序列号查找到的结果为「M」或者「F」，转为Java中使用的「男」或者「女」
     */
    @Override
    public String getResult(ResultSet resultSet, int i) throws SQLException {
        String result = resultSet.getString(i);
        if (result.equals("M"))
            return "男";
        else if (result.equals("F"))
            return "女";
        else
            return "未知";
    }

    @Override
    public String getResult(CallableStatement callableStatement, int i) throws SQLException {
        String result = callableStatement.getString(i);
        if (result.equals("M"))
            return "男";
        else if (result.equals("F"))
            return "女";
        else
            return "未知";    }
}
```

2. 在全局配置文件 `mybatis-config.xml` 中使用 `typeHandler` 子元素注册自定义类型转换器：

```xml
<typeHandlers>
    <typeHandler javaType="string" jdbcType="CHAR" handler="com.simon.typeHandler.SexTypeHandler"/>
</typeHandlers>
```

::: warning

注意特定的字段要符合特定字段的 `javaType` 、`jdbcType` 。上述配置对于数据库的所有字段起作用。

要对某个特定的字段进行自定义转换，需要配合映射器文件的相关注解（[TODO]）

:::

:::

+ 与 `<typeAliases>`类似，我们也可使用 `<typeHandlers>` 的子元素 `<package>` **导入包中所有的自定义类型处理器**来实现。
```xml
<typeHandlers>
  <package name="com.simon.typeHandler"/>
</typeHandlers>
```
但是这样没法指定 `jdbcType` 和 `javaType` 了，此时就需要在自定义的 `TypeHandler` 类上**使用注解**声明一下。
```java
@MappedTypes(String.class)
@MappedJdbcTypes(JdbcType.CHAR)
```

### `objectFactory` 元素

MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂实例来完成。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。

🌰 例如先写一个自定义的对象工厂 `MyObjectFactory` ，这个类继承了  `DefaultObjectFactory`。
::: details
```java

```
+ 然后再全局配置文件 `mybatis-config.xml` 中注册自定义工厂，并且其子元素 `<property>` 中进行对象工厂的初始值设置（下面实例属性 `prop` ）：

```xml
<objectFactory type="com.simon.objectFactory.MyObjectFactory">
    <property name="prop" value="123"/>
</objectFactory>
```

+ 运行后的结果，可以看到自定义对象工厂起作用了，有1个 users 和5个相同的user：

![image-20220322111229075](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/9t2ev3.png)

:::

### `plugins` 元素

MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用，这种拦截调用是通过插件来实现的。`<plugins>` 元素的作用就是配置用户所
开发的插件。

如果用户想要进行插件开发，必须要先了解其内部运行原理，因为在试图修改或重写己有方法的行为时，很可能会破坏 MyBatis 原有的核心模块，所以务必小心。

🌰 例子：自定义拦截器：
::: details 

+ 先写一个自定义的拦截器，这个类要继承 `Interceptor`。

```java
// 拦截器标识注解
@Intercepts(
        // 指明自定义拦截器需要拦截哪一个类型哪一个方法
        @Signature(
                type = StatementHandler.class, // 需要拦截的类
                method = "query", // 类中的方法
                args = {Statement.class, ResultHandler.class} // 因方法有重载需要指明类型
        )
)
public class MyPlugin implements Interceptor {
    private Properties properties;

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        System.out.println("拦截器参数：" + properties.get("prop"));
        Object target = invocation.getTarget(); // 被代理对象
        Method method = invocation.getMethod(); // 代理方法
        Object[] args = invocation.getArgs(); // 方法参数
        System.out.println("查询执行拦截"); // 方法拦截前执行代码块
        Object proceed = invocation.proceed();
        System.out.println("查询执行后拦截"); // 方法拦截后执行代码块
        return proceed;
    }

    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this); // 默认方法生成代理对象
    }

    @Override
    public void setProperties(Properties properties) {
        this.properties = properties; // 配置拦截器变量
    }
}
```

+ 🔗 相关链接：拦截器注解的规则 

`@Intercepts`：标识该类是一个拦截器

`@Signature`：指明自定义拦截器需要拦截哪一个类型，哪一个方法；

- `type`：对应四种类型中的一种；
- `method`：对应接口中的哪类方法（因为可能存在重载方法）；
- `args`：对应哪一个方法；

| 拦截的类         | 拦截的方法                                                   |
| ---------------- | ------------------------------------------------------------ |
| Executor         | update, query, flushStatements, commit, rollback,getTransaction, close, isClosed |
| ParameterHandler | getParameterObject, setParameters                            |
| StatementHandler | prepare, parameterize, batch, update, query                  |
| ResultSetHandler | handleResultSets, handleOutputParameters                     |

+ 然后在配置文件中注册自定义拦截器，并且可以在其子元素 `<property>` 中进行拦截器的参数设置：

```xml
<plugins>
    <plugin interceptor="com.simon.plugin.MyPlugin">
        <property name="prop" value="interceptor's parameter"/>
    </plugin>
</plugins>
```

 

+ 运行后的结果：![image-20220322113005849](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/bk540j.png)

:::

### `environments` 元素

运行环境空间，主要是配置数据库信息，空间里可以配置多个数据库，一般而言大多只需要配置一个数据库的运行环境就可以了。运行环境下面又分为两个可配置元素：事务管理器（transactionManager）和数据源（dataSource）。

其实在实际工作中，并不需要在此处配置数据库，大部分是使用 Spring 对数据源和数据库事务进行管理的。

🌰 例子：

配置多个连接数据库的环境，`defalut` 属性设置默认的环境标识：

```xml
<environments default="development">
  <environment id="development">
    <transactionManager type="JDBC"/>
    <dataSource type="POOLED">
      <property name="driver" value="com.mysql.jdbc.Driver"/>
      <property name="url" value="jdbc:mysql://localhost:3306/mybatis_demo?useUnicode=true&amp;characterEncoding=utf8"/>
      <property name="username" value="root"/>
      <property name="password" value="00000000"/> 
    </dataSource>
  </environment>
</environments>
```

+ `environment` 标签下的标签，配置某个具体的链接数据库环境，使用 `id` 唯一标识。
  + `transactionManager` 设置事务管理的方式，属性 `type=“JDBC | MANAGED”` ：`JDBC` 表示当前环境中，执行 SQL 时使用 JDBC 中的原生事务管理方式，事务的提交或者回滚需要手动处理；`MANAGED` 表示事务被管理（例如 Spring）。
  + `dataSource` 配置数据源，属性 `type="POOLED|UNPOOLED|JNDI"` 设置数据源的类型：`POOLED` 表示使用数据库连接池缓存数据库连接，`UNPOOLED` 表示不使用数据库连接池，`JNDI` 表示使用上下文中的数据源。（与 SSM 整合后，MyBatis 不再需要设置数据源）

+ `properties`：在核心配置文件头引入：

  ```xml
  <properties resource="jdbc.properties"/>
  ```

  `jdbc.properties` 文件包含 JDBC 连接信息：

  ```properties
  jdbc.driver=com.mysql.jdbc.Driver
  jdbc.url=jdbc:mysql://localhost:3306/mybatis_demo?useUnicode=true&amp;characterEncoding=utf8
  jdbc.username=root
  jdbc.password=*******
  ```

  在核心配置文件 `dataSource` 中就可以读取 `.properties` 中的信息：

  ```xml
  <dataSource type="POOLED">
    <property name="driver" value="${jdbc.driver}"/>
    <property name="url" value="${jdbc.url}" />
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
  </dataSource>
  ```




### `databasedProvider` 元素

软件公司可以同时为不同的客户提供系统，使用何种数据库情况下运行哪些语句可由客户决定。

::: details

🌰 例子：

+ 在全局配置文件 `mybatis-config.xml` 中：（其中 `name` 是數据库名称，`value` 是它的一个别名，这样我们就可以用这个别名标识一条 SQL 适用于哪一种数据库下运行。

```xml
<databaseIdProvider type="DB_VENDOR">
    <property name="MySQL" value="mysql"/>
    <property name="Oracle" value="oracle"/>
</databaseIdProvider>
```

+ 修改 Mapper 文件（以 `UserMapper.xml` 为例子），根据不同的数据库运行不同的 SQL 语句：

```xml
<select id="getAllUser" resultType="User" databaseId="mysql">
    select * from user where sex = 'M'
</select>

<select id="getAllUser" resultType="User" databaseId="oracle">
    select * from user where sex = 'F'
</select>
```

此时以使用 MySQL 数据库的机器为例子，所以只会运行第一条配置的 SQL 语句。

:::



### `mappers` 元素

MyBatis 需要开发者自己写SQL语句，mapper 映射器正是告诉 MyBatis 到哪里去找对应的映射文件，进而找到这些 SQL 语句。

有四种方法可以引入 mapper 映射文件：
```xml
<mappers>
	<!--使用类路径-->
	<mapper resource="simon/UserMapper.xml" />
	<!--使用本地文件（绝对路径）-->
	<mapper url= "/Users/Simon/*/src/main/resources/com/simon/mapper/UserMapper.xml" />
	<!--使用包名-->
	<package name= "myij" />
	<!--使用接口类-->
	<mapper class= "myj.UserMapper" />
</mappers>
```





（可以直接以包为单位引入比较方便，但要注意一致问题）

🌰 例子：以包为单位引入映射文件：

+ **要求 mapper 接口的包与映射文件所在的包一致**。

+ **mapper 接口要和映射文件的名字一致 **。

  <img src="https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/414Gec.png" alt="image-20220303160137491" style="zoom: 50%;" />

```xml
<mappers>
  <package name="com.mybatis.mapper"/>
</mappers>
```



