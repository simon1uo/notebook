---
title: 📓 重点算法框架
date: 2022-04-23 21:49:18
permalink: /pages/4042c0/
categories: 
  - 🕹 算法小记
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## 二叉树算法框架

与二叉树有关的思维模式框架：

+ 遍历：**是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。
+ 分解问题：**是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

无论哪一种思维模式，都需要思考：**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？对于其他的节点，递归会在所有的节点上完成。

### 二叉树的重要性

> 经典排序算法 [快速排序](https://labuladong.github.io/algo/2/19/42/) 和 [归并排序](https://labuladong.github.io/algo/2/19/38/)中，**快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历**。



#### 快速排序

快速排序的逻辑是，若要对 `nums[lo..hi]` 进行排序，**先找一个分界点** `p`，通过交换元素使得 `nums[lo..p-1]` 都小于等于 `nums[p]`，且 `nums[p+1..hi]` 都大于 `nums[p]`，然后递归地去 `nums[lo..p-1]` 和 `nums[p+1..hi]` 中寻找新的分界点，最后整个数组就被排序了。

快速排序的代码框架：

```java
void sort(int[] nums, int lo, int hi){
  // 前序遍历
	// 通过交换元素构建分界点p
  int p = partition(nums, lo, hi);
  
  sort(nums, lo, p - 1);
  sort(nums, p + 1, hi);
}
```

> 可以看出这与二叉树前序遍历的框架很相似。先构造分界点，然后再去左右数组构造分界点。



#### 归并排序

归并排序的逻辑是，若要对 `nums[lo..hi]` 进行排序，先对 `nums[lo..mid]` 排序，再对 `nums[mid+1..hi]` 排序，最后把这两个有序的子数组合并，整个数组就排好序了。（`mid` 是中间界点）

归并排序的代码框架：

```java
void sort(int[] nums, int lo, int hi){
  int mid = (lo + hi) / 2;
  
  // 排序 nums[lo..mid]
  sort(nums, lo, mid);
  // 排序 nums[mid+1..hi]
  sort(nums, mid + 1, hi);
  
  // 后序遍历
  // 合并nums[lo..mid] 和 nums[mid+1..hi]
  merge(nums, lo, mid, hi);
}
```

> 先对左右子数组排序，然后合并（类似合并有序链表的逻辑），与二叉树的后序遍历框架类似。



### 对前中后序的理解

> 对于数组与链表中的遍历，可以窥探处一丝前序中序后序位置的痕迹：
>
> ```java
> /* 迭代遍历数组 */
> void traverse(int[] arr) {
>     for (int i = 0; i < arr.length; i++) {
> 
>     }
> }
> 
> /* 递归遍历数组 */
> void traverse(int[] arr, int i) {
>     if (i == arr.length) {
>         return;
>     }
>     // 前序位置
>     traverse(arr, i + 1);
>     // 后序位置
> }
> 
> /* 迭代遍历单链表 */
> void traverse(ListNode head) {
>     for (ListNode p = head; p != null; p = p.next) {
> 
>     }
> }
> 
> /* 递归遍历单链表 */
> void traverse(ListNode head) {
>     if (head == null) {
>         return;
>     }
>     // 前序位置
>     traverse(head.next);
>     // 后序位置
> }
> ```
>
> 再看看二叉树的遍历框架：
>
> ```java
> void traverse(TreeNode root) {
>     if (root == null) {
>         return;
>     }
>     // 前序位置
>     traverse(root.left);
>     // 中序位置
>     traverse(root.right);
>     // 后序位置
> }
> 
> ```
>
> **二叉树这种结构无非就是二叉链表**，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。

**所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

![img](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/9VJFgL.jpeg)

例如，倒序打印链表中的元素就是一个典型的后续位置执行代码的例子：

```java
/* 递归遍历单链表，倒序打印链表元素 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    traverse(head.next);
    // 后序位置
    print(head.val);
}
```



**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

+ 前序位置的代码在刚刚进入一个二叉树节点的时候执行；

+ 后序位置的代码在将要离开一个二叉树节点的时候执行；

+ 中序位置的代码在一个二叉树节点**左子树都遍历完，即将开始遍历右子树的时候执行**。

> 为什么一直强调的是「位置」，而不是「遍历」，因为「位置」相对于遍历：可以可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事。



前中后序三个位置的二叉树标记如下：

<img src="https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/rjE3rm.jpeg" alt="img" style="zoom:33%;" />

可以看出：**每个节点都有「唯一」属于自己的前中后序位置**，所以说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。

**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。



### 二叉树两种解题思路

**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着回溯算法核心框架和 动态规划核心框架**。



#### 二叉树的最大深度

> 最大深度就是根节点到「最远」叶子节点的最长路径上的节点数。

遍二叉树历思路：显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度。

```java
// 记录最大深度
int res = 0;
// 记录遍历到的节点的深度
int depth = 0;

public int maxDepth(TreeNode root) {
  traverse(root);
  return res;
}

void traverse(TreeNode root) {
  if (root == null) {
    res = Math.max(res, depth);
    return;
  }

  // 前序位置
  depth++;
  traverse(root.left);
  traverse(root.right);
  // 后序位置
  depth--;
}
```

前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，`depth` 记录当前递归到的节点深度，把 `traverse` 理解成在二叉树上游走的一个指针，所以当然要这样维护。



分解思路：一棵二叉树的最大高度可以通过子树的最大高度推导出来：

```java
public int maxDepth(TreeNode root) {
  if (root == null) {
    return 0;
  }

  // 利用定义计算左右子树的最大深度
  int leftMax = maxDepth(root.left);
  int rightMax = maxDepth(root.right);

  // 整棵树的最大深度等于左右子树的最大深度取最大值+1（根节点）
  int res = Math.max(leftMax, rightMax) + 1;

  return res;
}
```

主要的代码逻辑放在后序位置：这个思路正确的核心在于，确实可以通过子树的最大高度推导出原树的高度，**所以要首先利用递归函数的定义算出左右子树的最大深度**，然后推出原树的最大深度，主要逻辑自然放在后序位置。



### 二叉树前中后序遍历框架

先回顾最常见的二叉树的前序遍历：

```java
List<Integer> res = new LinkedList<>();

List<Integer> preorderTraverse(TreeNode root) {
  traverse(root);
  return res;
}

void traverse(TreeNode root){
  if(root == null) return;
  
  // 前序位置
  res.add(root.val);
  
  traverse(root.left);
  traverse(root.right);
}
```

**一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果**。

#化简成为一个框架：

```java
List<Integer> preorderTraverse(TreeNode root){
  List<Integer> res = new LinkedList<>();
  
  if(root == null) return res;

  // 前序位置
	res.add(root.val);
  
  // 利用函数定义接着左子树的遍历结果
  res.addAll(preorderTraverse(root.left));
  // 利用函数定义接着右子树的前序遍历结果
  res.addAll(preorderTraverse(root.right));
  return res;
}
```

（以上遍历对于「中序」、「后序」位置的遍历也是同理的，只不过将 `add` 操作放在相应的位置而已。）

> 最后简化的算法，**这个算法的复杂度不好把控**，比较依赖语言特性。
>
> Java 的话无论 ArrayList 还是 LinkedList，`addAll` 方法的复杂度都是 O(N)，所以总体的最坏时间复杂度会达到 O(N^2)，除非你自己实现一个复杂度为 O(1) 的 `addAll` 方法，底层用链表的话并不是不可能。



### 二叉树算法综合总结

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

**3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。



### 后序位置的特殊性

> + 中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。
> + 前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。
>
> + 前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的。

「前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻」，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码**不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

例子：给一棵二叉树：

+ 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？
+ **如何打印出每个节点的左右子树各有多少节点**？

第一个问题可以在前序位置解决：
```java
void traverse(TreeNode root, int level) {
  if(root == null) return;
  
  printf("节点 %s 在第 %d 层", root, level)
  traverse(root.left, level + 1);
  traverse(root.right, level + 1);
}

// 调用
traverse(root, 1);
```

第二个问题在后置解决：

```java
void count(TreeNode) {
	if(root == null) return 0;
  
  int leftCount = count(root.left);
  int rightCount = count(root.right);
  printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点", root, leftCount, rightCount);
  
  return leftCount + rightCount + 1;
}
```

这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录；**而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚**。所以只有后序位置才能获取返回子树的信息。

**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。



例子： [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/) 

### 二叉树层级遍历

