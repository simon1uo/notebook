---
title: 🖨 数据库之事务管理
date: 2021-07-05 13:09:39
permalink: /pages/66e2f4/
categories: 
  - 数据库基础
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## :one: 事务概念

### 事务的定义

**在数据库系统中**：

+ **是一组一起执行的操作序列**；
+ **数据库系统中的逻辑工作单元**；

**在关系数据库中**：

+ **一个事务包含的操作可以是一条 SQL 语句、一组 SQL 语句或者整个程序**；



SQL中：

+ `BEGIN TRANSACTION` **表示开始事务**；
+ `COMMIT` **表示事务执行成功地结束**；数据库进入一个新的正确状态；
+ `ROLLBACK` **表示事务运行过程中发生了某种故障**，事务不能继续执行；同时撤销事务中对数据库的所有已完成的更新操作，数据库应恢复该事务到初始状态，即事务被回滚；



### 事务的 ACID 特性

**事务具有 4 个特性：原子性、一致性、隔离性、持久性；**

**原子性**：事务是原子的，**即事务对数据库的操作是一个不可分割的单元**；

+ 事务必须作为整体执行或者根本不执行。要么执行完，要么没有执行；
+ 意味着每个事务要么提交，要么因异常终止而回滚；如果没有执行完，则不能产生任何效果；
+ 通过 DBMS 的事务管理器实现，是数据库系统本身的职责；

**一致性**：**指事务执行的结果必须使数据库从一个一执性状态变到另一个一致性状态**；

**隔离性**：指一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

**持久性**：指一个事务一旦提交，它对数据库中的数据的改变是永久性的。接下来的数据操作或者故障不应该对其执行结果有任何影响，



**事务的 ACID 特性是数据库保持一致性的前提**。当数据库支持 ACID 特性时，数据库就能维持一个一致的、当前最新的现实世界的模型，并且事务一直能给用户提供正确、最新的响应；

**保证事务 ACID 特性是事务管理的重要任务**；



### 事务的管理

DBMS 中，保证事务的正确执行是事务管理器的工作；

两个主要部分：

+ 并发控制管理器；
+ 恢复管理器；



## :two: 事务的恢复

把数据库从错误状态恢复到某一已知的正确状态（一致性或者完整性状态）的功能；

通过 DBMS 的事务恢复机制实现，恢复管理器完成；

### 故障机器错误状态

+ 事务内部的故障
+ 系统故障
+ 截至故障

### 恢复技术

+ 日志 log
+ 数据转储



## :three: 并发控制

为了保证并发执行的事务能保持隔离性的整个过程称为并发控制；

DBMS 的并发控制管理器采用一定的并发控制技术实现并发控制；



### 并发控制必要性

**事务的调度**：

为了保证事务的隔离性和数据库的一致性，并发控制器需要对并发操作进行正确调度。

+ 调度
+ 串行调度



**并发事务的非串行调度带来的数据不一致的问题**：

1. **更新丢失**

2. **脏读**

   脏数据：还没有提交的事务所写的数据；

3. **不可重复读**



### 封锁技术

通过在数据对象上维护“锁”以**防止非可串行化**的行为；

+ 当一个事务在对其需要访问的数据对象进行操作之前，先向系统发出请求，**获得在它访问的数据库对象上的锁**，以防止其他事务几乎同一时间访问这些数据并因此引入非可串行化的可能。
+ 封锁技术可实现**冲突可串行化**；



**锁**

封锁模式：

+ 共享锁 S（用于读）

  若事务 T 对数据对象 A 加上共享锁，则**事务 T 可以读 A 但不能写 A**；其他事务只能对 A 加共享锁，而不能加排他锁，直到 T 释放 A 上的共享锁；**保证了其他事务可以读A，但在 T 释放 A 上的共享锁之前不能对 A 作任何更新。**

+ 排他锁 X（用于写）

  若事务 T 对数据对象加上排他锁，则**只允许 T 读和写 A**，**其他任何事务都不能再对 A 加任何类型的锁** ，直到 T 释放 A 上的排他锁。**保证了其他事务在事务 T 释放 A 上的排他锁之前不能读取和更新 A。**

**相容性矩阵**：

是描述锁管理策略的简单方法/



**两阶段封锁协议**

+ 获得锁阶段；（拓展）
+ 释放锁阶段；（收缩）



**死锁**

并发执行的事务由于竞争资源可以达到存在死锁的状态，分为两种：

+ **活死锁**（活锁）： 部分事务长期等待，但其他事务仍然能继续运行，这种长期等待状态为活锁；

  避免活锁：先来先服务；

+ **死死锁**（死锁）：循环等待资源；

  

