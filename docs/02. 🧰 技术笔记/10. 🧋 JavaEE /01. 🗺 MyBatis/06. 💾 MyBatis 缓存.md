---
title: 💾 MyBatis 缓存
date: 2022-03-22 18:07:17
permalink: /pages/4341f6/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🗺 MyBatis
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
在 MyBatis 中允许使用缓存，缓存一般都放置在可高速读/写的存储器上，比如服务器的内存，它能够有效提高系统的性能。因为数据库在大部分场景下是把存储在磁盘上的数据索引出来。

缓存就是存在于内存中的临时数据。使用缓存的目的是为了减少与数据库的交互次数，提高执行效率。

### 一级缓存

**默认开启**。一级缓存是 **`SqlSession` 级别**的，通过同一个 `SqlSession` 查询的数据会被缓存，**下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问**。

🌰 例子：在同一个 `SqlSession` 中查询员工信息多次：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab code

```xml
<!--Emp getEmpByEid(@Param("eid") Integer eid);-->
<select id="getEmpByEid" resultType="Emp">
    select * from emp where eid = #{eid}
</select>
```

测试：

```java
@Test
public void testCache(){
    SqlSession sqlSession = SqlSessionUtils.getSqlSession();
    CacheMapper mapper1 = sqlSession.getMapper(CacheMapper.class);
    Emp empByEid1 = mapper1.getEmpByEid(1);
    System.out.println(empByEid1);
    CacheMapper mapper2 = sqlSession.getMapper(CacheMapper.class);
    Emp empByEid2 = mapper2.getEmpByEid(1);
    System.out.println(empByEid2);
}
```

:::

::: tab result

```sql
DEBUG 03-09 13:37:14,984 ==>  Preparing: select * from emp where eid = ? (BaseJdbcLogger.java:137) 
DEBUG 03-09 13:37:15,009 ==> Parameters: 1(Integer) (BaseJdbcLogger.java:137) 
DEBUG 03-09 13:37:15,027 <==      Total: 1 (BaseJdbcLogger.java:137) 
Emp{eid=1, empName='张三', age=20, sex='男', email='123@qq.com', dept=null}
Emp{eid=1, empName='张三', age=20, sex='男', email='123@qq.com', dept=null}
```

:::

::::

::: warning 

**使一级缓存失效的四种情况**：

+ 不同的 `SqlSession` 对应不同的一级缓存。
+ 同一个 `SqlSession` 但是**查询条件不同**。 
+ 同一个 `SqlSession` **两次查询期间执行了任何一次增删改操作**。
+ 同一个 `SqlSession` 两次查询期间**手动清空了缓存**。例如：`sqlSession.clearCache()` 方法。

:::

### 二级缓存

需要**手动开启**。是 **`SqlSessionFactory` 级别**，通过统一个 `SqlSessionFactory` 创建的 `SqlSession` 查询的结果会被缓存；若再次执行相同的查询语句，结果会从缓存中取出。

二级缓存开启的条件：

+ 在核心配置文件中，全局配置属性 `cacheEnabled=“ture”`，默认就为 `ture` 不必设置。
+ 在 mapper 映射配置文件中设置标签：`<cache/>`。
+ 二级缓存必须在 `SqlSession` 中**关闭或提交之后**有效。
+ 查询的数据**所转换的实体类类型**必须实现**序列化的接口**。

::: warning

使二级缓存失效的情况：两次查询之间执行了任意的**增删改**，会使**一级和二级缓存**同时失效。

::: 



::: tip

**二级缓存 `cache` 标签的相关配置：**

+ `eviction` 属性：**缓存回收策略**：
  + `LRU`（Least Recently Used）： **最近最少使用**的：移除最长时间不被使用的对象。【默认值】
  + `FIFO`（First in First out） – **先进先出**：按对象进入缓存的**顺序**来移除它们。
  + `SOFT`（软引用）：移除基于垃圾回收器状态和软引用规则的对象。
  + `WEAK `（弱引用）：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
+ `flushInterval` ：刷新间隔，单位为**毫秒**。默认情况不设置，即没有间隔，**缓存仅仅调用语句（增删改语句）时刷新**。
+ `size`：引用数目，正整数。代表缓存最多存储多少个对象，太大容易导致内存溢出。
+ `readOnly` 只读属性，`true | false` `。
  + true：只读缓存；会给所有调用者返回缓存对象的**相同实例**。因此这些对象**不能被修改**。**这提供了很重要的性能优势**。
  + false：读写缓存；会返回缓存**对象的拷贝**（通过**序列化**）。这会慢一些，但是**安全**，**因此默认是false**。

:::



### 缓存查询顺序

::: tip

+ 先查询二级缓存，因为二级缓存可能会有其他程序已经查询出来的数据，**可以直接拿来用**。
+ 如果二级缓存没有命中，再查询一级缓存。
+ 如果一级缓存也没有命中，则查询数据库。

:::

::: warning

`SqlSession` 关闭之后，一级缓存的数据会写入二级缓存。

:::

