---
title: 🌵 Spring IoC
date: 2022-03-24 13:28:35
permalink: /pages/a8acd2/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🍃 Spring
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## Spring IoC 概念原理

🌰 引入例子：

::: details

+ 有一个接口类 `Person` ：

```java
public interface Person {
    void love();
    String showName();
}
```

+ 两个 `Person` 的实现类 `Man` 和 `Woman` ，均有属性 `name` 和 `Person` 类型的 `lover` ：

```java
public class Man implements Person {
    private String name;
    private Person lover;
    
  	@Override
    public void love() {
        System.out.println("He loves " + lover.showName());
    }

    @Override
    public String showName() {
        return name;
    }
}
```

```java
public class Woman implements Person {
    private String name;
    private Person lover;
  
  	@Override
    public void love() {
        System.out.println("She loves " + lover.showName());
    }

    @Override
    public String showName() {
        return name;
    }
}
```

+ 创建 Spring 配置文件 `applicationContext.xml`，完成两个实现类的实例对象的创建以及分别是互相的属性的一部分，完成依赖注入。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="man" class="com.simon.impl.Man">
        <property name="name" value="Jack"/>
        <property name="lover" ref="woman"/>
    </bean>
    <bean id="woman" class="com.simon.impl.Woman">
        <property name="name" value="Rose"/>
        <property name="lover" ref="woman"/>
    </bean>
</beans>
```

+  编写测试类，测试 `love` 方法：

```java
@Test
public void testPerson(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
    Man man = applicationContext.getBean("man", Man.class);
    System.out.println(man);
    man.love();
    Woman woman = applicationContext.getBean("woman", Woman.class);
    System.out.println(woman);
    woman.love();
}
```

例子总结：可以看出，**从来没有使用两个实现类直接创建实例对象**，他们之间也没有产生耦合关系，完全通过配置文件「软编码」，使得两个类之间已经实现了彼此的链接，这体现了 Spring 的强大。

:::

从前面的例子中贯彻的思想正是 「控制反转（IoC）」：

+ IoC （Inversion of Control）控制饭庄的概念：控制反转把创建对象的权利交给容器，**对象的实创不再由调用者来创建，而是由容器来创建，容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。**这样，控制权由应用代码转移到了**容器**，控制权发生了反转，这就是控制反转。这是 Spring 框架的核心思想之一。
+ 使用 IoC 的目的：**降低代码之间的耦合度**（解除代码中的依赖关系）。

### Spring 依赖注入

+ DI（Dependency Injection）**依赖注入**：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的（编译前不会建立，运行时建立）将某个依赖关条注入到组件之中。（与控制反转是从两个角度描述同一个概念）
+ 依赖注入的目的并非为软件条统带来更多功能，而是**为了提升组件重用的频率，并为系统搭建一个灵活、可扩拓展平台。**通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

+ 当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，传统方式有：
  + 原始做法：调用者主动创建被依赖对象，然后再调用被依赖对象的方法。（硬编码「自己制造」）
  + **简单工厂模式**：调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用依赖对象的方法。（调用组件需要主动通过工厂去获取放依赖对象，带来调用组件与被依赖对象工厂的「工厂制造」）
+ 使用 Spring 框架后，调用者无需主动荻取被依赖对象，调用者只要被动接受 Spring 容器为调用者赋予即可，由「**原来的主动获取变成了被动接受**」。



+ 依赖注入的方式：

  + 设值注入

  + 构造注入

  + 接口注入

+ 能注入的类型：
  + 基本类型和 String
  + 配置文件已经插入的 Bean 类型
  + 复杂类型 / 集合类型



### IoC 的底层实现原理

+ XML 解析
+ 工厂模式
+ 反射技术



🌰 **具体例子解释 IoC 的原理**：

+ 使用原始方法实现对象的创建和对象方法的调用，其中的代码之间的耦合度太高。

```java
class UserService{
  excute(){
    UserDAO dao = new UserDAO();  
    dao.add();
  } 
}
```

```java
class UserDAO {
	add() {
    // ...
  }
}
```



+ 工厂模式：如以下例子，在两个类中间创建一个工厂类 `UserFactory` 处理创建对象的工作，目的是减少两个类之间的耦合度最低限度（使用工厂模式仍存在耦合度，没有完全解耦）

```java
class UserService{
  excute(){
    UserDAO dao = UserFactory.getDAO();
    dao.add();
  } 
  
}
```

```java
class UserFactory {
	public static UserDAO getDAO(){
    return new UserDAO();
  }
}
```

```java
class UserDAO {
	add() {
    // ...
  }
}
```



+ 在 IoC 中，结合 XML 解析、工厂模式、反射三种技术：
  + XML 解析：配置创建的对象。
  + 反射：通过得到类的字节码文件 `.class` ，然后可以操作类中的所有内容。

🌰 例子：使用 IoC 解耦：进一步降低耦合度。

1. 第一步：XML 配置文件，配置创建的对象：

```xml
<!--配置User对象的创建-->
<bean id="user" class="com.simon.User"/>
```

2. 第二步：现有 `UserService` 类和 `UserDAO` 类，创建工厂类（运用反射技术）：

```java
class UserFactory {
  public static UserDAO getDAO(){
		String classValue = "class属性值"; // 1xml解析
    Class claszz = Class.forName(classValue);// 2 通过反射创建对象
    return (UserDAO)clazz.newInstance(); // 完成反射创建
  }
}
```



### IoC 接口

+ IoC 的思想基于 IoC 容器完成，IoC 容器底层就是对象工厂。
+ Spring 提供 IoC 容器实现两种方式（**两个接口**）
  + `BeanFactory`：IoC 容器中最基本的实现的方式，是 Spring 内部中使用的基本接口，它负责配置、创建、管理 bean，不提供开发人员进行使用。（:warning: **在加载配置文件时不会创建对象**，只有在获取对象（或者使用对象）才去创建对象。）
  + :star: `ApplicationContext` ：是 `BeanFactory` **接口的子接口**，提供更多更强大的功能，一般提供开发人员进行使用。（:warning: 加载配置文件时就会把在配置文件中的对象进行创建）

​	（要结合 Web 框架，要将耗时耗资源的工作在服务器启动过程中就创建对象，而不是在什么时候用才创建，就可以直接使用对象，所以应多使用 `ApplicationContext` ）



+ `BeanFactory` 接口中的子接口和实现类：

  ![image-20220324204226340](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/ErWDXc.png)

  `ConfigurableApplicationContext`：包含一些相关的拓展功能。

  

+ `Application` 接口中的子接口和实现类：
  ![image-20220324203635894](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/7ZUFYA.png)
  
  + `ClassPathXmlApplicationContext`  ：XML 配置文件在项目中 `src` 目录下的相对路径（内部路径）
  + `FileSystemXmlApplicationContext `：XML 文件的完整的绝对路径 



## Bean 管理

Spring 可以把「**一切 Java 对象**」当成容器里的 bean，不管是程序员自己编写的，第三方框架提供的，还是JDK提供的，如 `<bean id= "data" class="java.util.Date"/>` 这种 JDK 里的类，在 Spring 看来依然是一个的 bean 。

Spring 配置 bean 时，`class` 属性的值必须是 bean 实现类的**完整类名**（必须带包名），而且不能是接口，**除非特殊配载否则也不能是抽象类**。

Bean 管理指 IoC 的具体操作，指的是两个操作：

+ Spring **创建对象**
+ Spring **注入属性**



如果把 Spring 看做一个大型工厂，则 Spring 容器中的 bean 对象就是该工厂的产品。要想使用这个工厂生产和管理 bean 对象，就需要在配置文件中告诉它需要哪些 bean 对象，以及需要使用何种方式将这些 bean 对象裝配到一起。

**Bean 管理配置有两种实现方式**：

+ 基于 XML 配置文件方式实现
+ 基于注解方式实现



### 基于 XML 的 Bean 管理

#### 配置说明

Spring 全局配置 XML 文件相关配置说明：

![image-20220411170642184](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/yo46d5.png)

+ `<beans>` 元素是 Spring 配置文件的根元素，它有以下属性：

  + `default-autowired` ：所有 bean 默认的自动裝配行为。
  + `default-init-method` ：所有 bean 默认的初始化方法。
  + `default-destroy-method`：所有 bean 默认的回收方法。

  这些属性可以设置对所有bean起作用的默认值。

+ `<description>` 元素是 `<beans>` 元素的一个可选的子元素，就是对象当期中所配置的 `javabean` 的描述信息。

+ `<import>` 元素是 `<beans>` 元素的一个可选的子元素。在实际的项目开发中，往往会分为很多不同的包，如果遇见为**不同的包都写在一个总的配置文件**中，难免会造成配置文件内容臃肿，不易阅读的情况。为了方便管理应用配置文件，可以使用 `import` 来规划配置文件，**把配置文件分散到各个模块中**，然后在总的配置文件中通过 `import` 元素引入这些配置文件，它有以下属性：

  + `resource`：引入的配置文件的路径。

  ```xml
  <import resource="subconf.xml"/>
  ```

  > Spring 中提供了三种前缀标记辅助查找配置文件：
  >
  > + `[classpath:]`：表示从 `classpath` 开始寻找后面的资源文件，例如：`<import resource="classpath:test/subconf.xml"/>`。
  > + `[classpath*:]`： 表示不仅会在 `classpath` 路径中去查找文件，还会在相应的 `jar` 中去查找文件。
  > + `file` ：表示使用文件系统的方式寻找后面的资源文件。例如：`<import resource= "file:test/subconf.xml"/>`

+ `<alias>` 元素是 `<beans>` 元素的子元素，可以为已有的 bean **指定别名**，有以下属性：

  + `name`：属性指定一个bean实例的标识名，表明为该 bean 实例指定别名。
  + `alias`：指定的别名。

  如下例子，为 `p` 指定两个别名：

  ```xml
  <bean id="p" class= "myj.Person"/>
  <alias name="p" alias="jack"/>
  <alias name="jack" alias="jackee"/>
  ```

  

#### 创建对象

基于 XML **创建对象**（在一个 Spring 配置文件中（以 `bean1.xml` 为例））：使用 `<bean>` 标签，在标签中**添加对应的属性**就可以实现对象的创建，每个 bean 对应 Spring 容器中一个 Java 实例。

```xml
<!--配置User对象的创建-->
<bean id="user" class="com.simon.User"/>
```

`<bean>` **标签中常用的属性**：

+ `id` 属性：给创建的对象创建唯一的标识。

+ `class` 属性：类全限定名（**类全路径**）。

+ `name` 属性（了解）：（与 `id` 的作用一样），早期为 `Struts` 框架服务，现在少用。



+ 在创建对象时，默认执行**无参构造方法**，如果类中没有定义无参构造方法（或者仅仅存在有参构造方法）时，运行创建对象会报错（初始化对象失败，因为没有找到默认构造 `NoSuchMethodException` ）。



**注入属性的方法**，基于 XML **注入属性**：

+ `DI` ：依赖注入，就是注入属性（**需要在创建对象的基础上进行**）。
+ `IoC` 与 `DI` 的区别：`DI` 是 `IoC` 的一种具体表现。

**有两种注入方法**：

+ **`Setter` 方法**
+ **有参构造方法**



🌰 :one: 使用两种**原始 Java 方法**注入属性的例子（引入例子）：

::: details

+ 第一种注入方式：使用`set` 方法注入属性：

```java
public class Book {
    private String title;

    public void setTitle(String title) {
        this.title = title;
    }

    public static void main(String[] args) {
        Book book = new Book();
        book.setTitle("BookTitle");
    }
}
```

+ 第二种注入方法：使用**有参构造方法**注入属性：

```java
public class Book {
    private String title;

    public Book(String title) {
        this.title = title;
    }

    public static void main(String[] args) {
        Book book = new Book("BookTitle");
    }
}
```

:::



#### 设值注入属性

设值注入通过 `<bean>` 的元素  `<property>` 元素完成该 bean 的属性注入，有以下属性：

+ `name` ：类里面的属性的名称。

+ `value` ：向属性注入的值。



🌰 **设值注入属性的例子**：

第一步：创建类和定义属性属性和属性对应的`set` 方法：

```java
public class Book {
    
    private String title;
    private String author;

    public void setTitle(String title) {
        this.title = title;
    }

    public void setAuthor(String author) {
        this.author = author;
    }
}
```

第二步：在 Spring 配置文件中（以 `bean1.xml` 为例），使用 `bean` 标签完成属性注入：

```xml
<bean id="book" class="com.simon.Book">
    <property name="author" value="bookAuthor"/>
    <property name="title" value="bookTitle"/>
</bean>
```



第三步：创建一个测试类 `BookTest` 进行测试：

```java
public class BookTest {
    @Test
    public void testBook(){
      // 第一步：加载Spring配置文件
      ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
      // 第二步：获取配置创建的对象（已经注入属性后的对象）
      Book book = context.getBean("book", Book.class);
      System.out.println(book);
      book.testBook(); // 为了测试创建的一个方法
    }
}
```



#### 有参构造注入属性

有参构造注入属性通过 `<bean>` 元素的子元素 `<constructor-arg>` 实现，为该 bean 完成构造注入，其中的属性用法与 `<property>` 元素类似。

🌰 **有参构造注入属性例子**：

第一步：创建类和定义属性，创建属性对应有参数的构造方法：

```java
public class Orders {
    private String oName;
    private String oAddress;

    public Orders(String oName, String oAddress) {
        this.oName = oName;
        this.oAddress = oAddress;
    }
}
```

第二步：在 Spring 配置文件中（以 `bean1.xml` 为例），使用 `bean` 标签完成属性注入：

```xml
<bean id="orders" class="com.simon.Orders">
    <constructor-arg name="oName" value="orderName"/>
    <constructor-arg name="oAddress" value="orderAddress"/>
</bean>
```

> 使用 `constructor-arg` 完成属性注入：
>
> + `name` ：类里面的属性的名称（有参构造方法的参数名称）。
>
> + `value` ：向属性注入的值。
> + 或者通过 `index` 属性索引有参构造方法的参数。

第三步：创建一个测试类 `BookTest` 进行测试：

```java
@Test
public void testOrders() {
    // 第一步：加载Spring配置文件
    ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
    // 第二步：获取配置创建的对象
    Orders orders = context.getBean("orders", Orders.class);
    System.out.println(orders);
    orders.testOrders();
}
```



::: tip

设值注入方法 与 构造注入方法 对比：

+ 通过设值注入方法设定的依赖关系更加直观，**对于复杂的依赖关系**，建议采用设置注入。**对于在某些属性可选的情况下**，采用设值更加合适。
+ **构造注入适合依赖关系无需变化的注入情况**，其他依赖关系的注入应该考虑采用设值注入的方式。

:::



#### p 名称空间注入属性

🌰 :four: `p` 名称空间注入属性，简化基于 XML 配置方式（`set` 方法的简化 ）（了解即可，比较少用）：

::: details

+ 第一步：添加 `p` 名称空间在配置文件中的引入：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
```

+ 注入属性：

```xml
<bean id="book" class="com.simon.Book" p:author="authorName" p:title="bookTitle" />
```

:::



#### 注入其他类型属性

设置某个属性为字面量 （固定值）时：

+ `null`
+ **属性值包含特殊符号**



🌰 **设置某个属性为 `null` 值例子**：

::: details

+ 在之前使用 `set` 方法注入属性的基础上，添加一个新的 `address` 属性。
+ 在 Spring 配置文件中：

```xml
<!--set方法注入属性-->
<bean id="book" class="com.simon.Book">
    <property name="author" value="bookAuthor"/>
    <property name="title" value="bookTitle"/>
    <!--设置某个属性为null值的方法-->
    <property name="address">
        <null/>
    </property>
</bean>
```

:::

🌰 注入设置的属性值包含**特殊符号**：

在设置注入属性或者构造注入属性的 `value` 属性中不可以加入特殊符号，如果要设置可以利用 `<property>` 的子元素 `<value>`：

+ 将特殊符号转义
+ 把带特殊符号的内容写到 `CDATA` ：

```xml
<!--设置某个属性包含特殊符号的方法-->
<property name="address">
    <value><![CDATA[<<南京>>]]></value>
</property>
```





#### 注入外部 Bean

注入外部 bean 通过 `<property>` 或者 `<constructor-arg>` 元素的子元素 `ref` 或者属性，为该 bean 注入外部 bean 的值（引用）。  



🌰 例子：（实际运用上面的注入属性的方法）

::: details

+ 创建 `service` 类和 `DAO` 类（包括 `DAOImpl` 类）：

```java
public interface UserDAO {
    public void update();
}
```

```java
public class UserDAOImpl implements UserDAO{
    @Override
    public void update() {
        System.out.println("UserDAO Update()...");
    }
}
```

```java
public class UserService {

    public void add(){
        System.out.println("UserService Add() ...");
    }
}
```

+ 在 `service` 类调用 `DAO` 里面的方法：

1.  ~~使用原始方法创建对象并且调用（方法一）~~：

```java
public void add(){
    System.out.println("UserService Add() ...");
    // 使用原始方式创建对象并且调用UserDAO中的方法
    UserDAOImpl userDAO = new UserDAOImpl();
    userDAO.update();
}
```

2. 在 Spring 配置文件中进行配置，完成外部 `bean` 的注入：

```xml
<!--创建Service和DAO的对象-->
<bean id="userService" class="com.simon.service.UserService">
    <!--注入userDAO对象
        *name 属性值：类里面的属性名称
        *ref 属性值：下面创建的userDAO对象bean标签的id值（引入外部bean）
    -->
    <property name="userDAO" ref="userDAO"/>
</bean>

<bean id="userDAO" class="com.simon.dao.UserDAOImpl"/>
```

> 另一种写法：
> ```xml
> <property name="userDAO">
> 	<ref bean="userDAO"/>
> </property>
> ```

3. 编写测试类和测试方法：`testAdd()` ：

```java
public class UserServiceTest {
    @Test
    public void testAdd(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean2/UserServiceBean.xml");

        UserService userService = context.getBean("userService", UserService.class);
        userService.add();
    }
}
```

:::



#### 内部 Bean 和级联赋值

`<bean>` 元素可以作为 `<property>` 元素或者 `<constructor-arg>` 元素的子元素，即在之中嵌套实用。嵌套的内部 bean 不能被容器获取，所以嵌套的内部 bean 不需要 `id` 属性。  

🌰 ：内部 Bean （应用于数据库的关系），以一对多关系为例：部门和员工（一个部门对应多个员工）：

::: details

+ 创建部门类和员工类，员工使用对象表示所属的部门：

```java
public class Dept {
    private String deptName;

    public void setDeptName(String deptName) {
        this.deptName = deptName;
    }
}
```

```java
public class Emp {
    private String empName;
    private String empGender;
    private Dept dept; // 员工属于某个部门，使用对象形式表示

    public void setDept(Dept dept) {
        this.dept = dept;
    }

    public void setEmpName(String empName) {
        this.empName = empName;
    }

    public void setEmpGender(String empGender) {
        this.empGender = empGender;
    }
}
```

+ 在 Spring 配置文件中进行配置内部 bean 注入：

```xml
<bean id="emp" class="com.simon.bean.Emp">
    <!--设置两个普通属性-->
    <property name="empName" value="Simon"/>
    <property name="empGender" value="M"/>

    <!--设置对象类型属性-->
    <property name="dept">
        <bean id="dept" class="com.simon.bean.Dept">
            <property name="deptName" value="IT"/>
        </bean>
    </property>
</bean>
```

+ 编写测试类和测试方法：

```java
public class DeptAndEmpTest {

    @Test
    public void testDeptAndEmp() {
        ApplicationContext context = new ClassPathXmlApplicationContext("bean2/DeptAndEmpBean.xml");

        Emp emp = context.getBean("emp", Emp.class);
        emp.print();
    }
}
```

:::



🌰 **级联赋值例子**（延续上面部门与员工的例子）：

::: details

+ 在 Spring 配置文件中进行配置实现级联赋值：

第一种写法：

```xml
<bean id="emp" class="com.simon.bean.Emp">
    <!--设置两个普通的属性-->
    <property name="empName" value="Simon"/>
    <property name="empGender" value="M"/>
    <!--级联赋值-->
    <property name="dept" ref="dept"/>
</bean>

<bean id="dept" class="com.simon.bean.Dept">
    <property name="deptName" value="财务"/>
</bean>
```



第二种写法：

```xml
<bean id="emp2" class="com.simon.bean.Emp">
    <!--设置两个普通的属性-->
    <property name="empName" value="Simon"/>
    <property name="empGender" value="M"/>
    <!--级联赋值-->
    <property name="dept" ref="dept"/>
    <property name="dept.deptName" value="技术"/>
</bean>

<bean id="dept" class="com.simon.bean.Dept">
    <property name="deptName" value="财务"/>
</bean>
```

:warning: **第二种写法中要确保实体类的属性 `dept` （要关联的属性）的 `getter` 方法生成**。

:::



#### 注入集合属性

🌰 四种集合类型（数组、`List`、`Map`、`Set`）例子：

::: details

+ 在 Spring 配置文件中进行配置实现集合类型的注入：

```xml
<!--集合类型属性注入-->
<bean id="stu" class="com.simon.bean.Stu">
    <!--数组类型属性注入-->
    <property name="courses">
        <array>
            <value>Java课程</value>
            <value>数据库课程</value>
        </array>
    </property>

    <!--List集合类型属性注入-->
    <property name="list">
        <list>
            <value>listValue1</value>
            <value>listValue2</value>
        </list>
    </property>

    <!--Map类型属性注入
           注意 map的键值要用entry标签
    -->
    <property name="maps">
        <map>
            <entry key="mapKey1" value="mapValue1"/>
            <entry key="mapKey2" value="mapValue2"/>
        </map>
    </property>

    <!--Set类型属性注入-->
    <property name="sets">
        <set>
            <value>setValue1</value>
            <value>setValue2</value>
            <value>setValue3</value>
        </set>
    </property>
</bean>
```

+ 编写测试类和测试方法：

```java
public class StuTest {

    @Test
    public void TestStuBean(){
        ApplicationContext context = new ClassPathXmlApplicationContext("StuBean.xml");
        Stu stu = context.getBean("stu", Stu.class);
        stu.print();
    }
}
```

:::

::: tip 

**注入集合类型的细节问题**：

+ 当集合中设置的对象类型值：

🌰 例子：学生学习多门的课程作为学生的属性，`List` 集合的值为 `Course` 类中的对象：

::: details 

+ 创建新的 `Course` 类：

```java
public class Course {
    // 课程名称
    private String courseName;

    public void setCourseName(String courseName) {
        this.courseName = courseName;
    }
}
```

+ 在学生类 `Stu` 中添加属性 `CourseList` ：

```java
public class Stu{
  private List<Course> courseList;
  
  public void setCourseList(List<Course> courseList) {   
    this.courseList = courseList;
  }
}
```

+ 在 Spring 配置文件中进行配置注入：

```xml
<bean id="stu" class="com.simon.bean.Stu">
  <!-- 注入List的集合类型，值是对象-->
  <property name="courseList">
    <list>
      <ref bean="course1"/>
      <ref bean="course2"/>
    </list>
  </property>
</bean>
```

要设置 `List` 集合中的值是对象，可以创建下面的对象：

```xml
<!--创建多个course对象-->
<bean id="course1" class="com.simon.bean.Course">
    <property name="courseName" value="Spring5"/>
</bean>

<bean id="course2" class="com.simon.bean.Course">
    <property name="courseName" value="MyBatis"/>
</bean>
```

:::



+ 把**集合注入部分**提取出来**作为公共部分**：

🌰 例子：

+ 创建新的类 `Book` ：

```java
public class Book {

    private List<String> bookList;

    public void setBookList(List<String> bookList) {
        this.bookList = bookList;
    }

    public void print(){
        System.out.println(bookList);
    }
}
```

+ 在 Spring 配置文件中引入名称空间 `util`：（添加 `xmlns:util` 以及在 `xsi:schemaLocation` 相关内容）：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
```

+ 在 Spring 配置文件中提取属性注入：

```xml
<!--提取List集合类型属性注入-->
<util:list id="bookList">
    <value>SpringBoot</value>
    <value>SpringMVC</value>
    <value>MyBatis</value>
    <!--<ref>可以是对象</ref>-->
</util:list>

<bean id="book" class="com.simon.bean.Book">
    <property name="bookList" ref="bookList"/>
</bean>
```

+ 编写测试类和测试方法：

```java
public class BookTest {
    @Test
    public void TestBookBean(){
        ApplicationContext context = new ClassPathXmlApplicationContext("BookBean.xml");
        Book book = context.getBean("book", Book.class);
        book.print();
    }
}
```

:::



####  自动装配

+ 自动装配（自动完成属性注入）：根据指定的装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入。

+ 在 `bean` 标签属性 `autowire` 中配置自动装配，常用属性值有：
  + `byName` ：根据**属性名称**注入，特点：要注入值 `bean` 的 `id` 值要与类属性名称一样。
  + `byType`：根据**属性类型**注入。:warning: 要注意相同类型的 `bean` 不能创建多个，否则 `bean` 无法识别，此时最好使用根据名称注入。

（自动装配一般通过注解方法实现）

🌰 自动装配的过程例子：
::: details

+ 有两个类 `Emp` 和 `Dept` ，对应的关系如下：

```java
public class Emp {
    private Dept dept;

    public Dept getDept() {
        return dept;
    }

    public void setDept(Dept dept) {
        this.dept = dept;
    }
}
```

```java
public class Dept {
    @Override
    public String toString() {
        return "Dept{}";
    }
}
```

+ 根据属性名称自动装配：

```xml
<bean id="emp" class="com.simon.autowire.Emp" autowire="byName"/>

<bean id="dept" class="com.simon.autowire.Dept"/>
```

+ 根据属性类型自动装配：

```xml
<bean id="emp" class="com.simon.autowire.Emp" autowire="byType"/>

<bean id="dept" class="com.simon.autowire.Dept"/>
```

::: 



#### 引入外部属性文件

应用场景：**以配置数据库信息为例**：（当一个 bean 中的属性与值有很多）

🌰 例子：**通过引入外部属性文件配置数据库连接池**：

::: details

+ 创建外部属性文件 `properties` 格式的文件（以 `jdbc.properties` 为例），写入数据库的相关信息：

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/javaeeTest?useUnicode=true&characterEncoding=utf8
jdbc.username=root
jdbc.password=root
```

+ 把外部 `properties` 属性文件引入到 Spring 配置文件：引入 `context` 名称空间：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd">
```

+ 在 Spring 配置文件中引入外部属性文件：

```xml
<context:property-placeholder location="jdbc.properties"/>

<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```

:::





### FactoryBean

+ 在 Spring 中有两种类型的 Bean，一种为普通 Bean（迄今提到的例子），另一种为工厂 Bean （FactoryBean）。
  + 普通 Bean 的特点：在 Bean 中定义的 `bean` 的 `class` 类型返回的就是此类型。
  + 工厂 Bean 的特点：在 Bean 中定义的 `bean` 的类型和返回的类型可以是不一样的。



🌰 例子：（工厂 Bean 的概念实例）：

::: details

+ 创建一个类，让这个类称为工厂 Bean，要实现接口 `FactoryBean` ，实现 `FactoryBean` 接口里面的方法，在实现的方法中定义返回的 Bean 类型。

```java
public class MyBean implements FactoryBean<Course> {

    // 定义返回bean的类型
    @Override
    public Course getObject() throws Exception {
        Course course = new Course();
        course.setCourseName("MyBatis");
        return course;
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        return FactoryBean.super.isSingleton();
    }

}
```

+ 在 Spring 的配置：

```xml
<bean id="myBean" class="com.simon.factorybean.MyBean">
</bean>
```

+ 编写测试类和测试方法：

```java
public class MyBeanTest {
    @Test
    public void TestMyBean(){
        ApplicationContext context = new ClassPathXmlApplicationContext("MyBean.xml");
        Course myBean = context.getBean("myBean", Course.class); // 此处返回的类型为Course
        System.out.println(myBean);
    }
}
```

::: 



### Bean 的作用域

从本质上来看，Spring 容器就是一个超级大工厂，Spring 容器中的 bean 的实例就是该工厂的产品，这些实例可以分成单例对象和多例对象：

+ 单例对象：当容器创建时对象出生，只要容器在对象就一直存活着，容器销毁时对象消亡。
+ 多例对象：使用对象时产生，对象在使用过程中就一直存活着，当对象长期不用并且也没有其它对象引用时，将由Java垃圾回收器回收。

Bean 的作用域 `scope` ：

+ 在 Spring 中，创建的 Bean 实例**可以是单实例或者是多实例。**
+ 在 Spring 中，**默认创建的 Bean 实例是单实例对象**。



🌰 单实例对象例子：

::: details

+ 可以通过比较通过 Bean 创建的对象的哈希值（或者地址值），看是否创建的是同一个对象。说明此时创建的 Bean 实例是单实例对象。

```java
public class BookTest {
    @Test
    public void TestBookBean(){
        ApplicationContext context = new ClassPathXmlApplicationContext("BookBean.xml");
        Book book1 = context.getBean("book", Book.class);

        Book book2 = context.getBean("book", Book.class);
        System.out.println(book1.hashCode());
        System.out.println(book2.hashCode());
    }
}
```

:::



🌰 如何设置单实例还是多实例：

+ 在 Spring 配置文件中的 `<bean>` 标签中添加 `scope` 属性：

> `scope` 属性的相关属性值：
>
> + `singleton` ：表示设置是单实例对象（默认）。
> + `prototype` ：表示设置是多实例对象。
>
> ***
>
> + 还有两个属性值 `request` 和 `session` 。

::: details

```xml
<bean id="book" class="com.simon.bean.Book" scope="prototype">
    <property name="bookList" ref="bookList"/>
</bean>
```

再次运行先前的单实例测试例子，可以发现两次创建的对象的哈希值不相同，**说明此时创建的 Bean 实例是多实例对象**。

:::

::: warning

:warning: **单实例与多实例的区别**：
+ 当 `scope` 的值是 `singleton` 的时候，**加载 Spring 配置文件的时候**就会创建单实例对象。
+ 当 `scope` 的值是 `prototype`  的时候，不是加载在 Spring 配置文件时创建实例对象，而是在调用 `getBean()` 方法时创建多实例对象。

:::



关于 `<lookup-method>` 元素：当单例模式的 bean A 需要多例模式的 bean B 注入进来，为了每次引用时都能拿到最新的 bean B，通过 `<lookup-method>` 从而能在运行时通过 `getBean(String beanName)` 获取**最新的 bean B 实例**。

🌰 例如，将多例模式的 `PrototypeBean` 注入到单例模式的 `SingletonBean` 中：

```java
public class SingletonBean {
  public PrototypeBean getPrototypeBean(){
    return new PrototypeBean();
  }
 
  public void show(){
    System.out.println("SingletonBean's hashCode:" + this.hashCode());
    System.out.println("PrototypeBean's hashCode:" + getPrototypeBean().hashCode());
  }
}
```

相应的配置文件：

```xml
<bean id="prototypeBean" class="com.simon.PrototypeBean" scope="prototype"/>
<bean id="singletonBean" class="com.simon.singletonBean">
	<lookup-method name="getPrototypeBean" bean="prototypeBean"/> 
</bean>
```

测试类：

```java
@Test
public void testLookup(){
  SingletonBean singletonBean1 = (SingletonBean) context.getBean("singletonBean");
  SingletonBean singletonBean2 = (SingletonBean) context.getBean("singletonBean");
  singletonBean1.show();
  singletonBean2.show();
}
```



关于 `<replaced-method>` 元素：当想替换掉 bean 中的某个方法时，可以使用 `<replaced-method>`：

🌰 例如：

```java
public class MyMethod{
  public void show() { System.out.println("my method");}
}
```

```java
public class MyMethodRepalcer implements MethodReplacer {
  public Object reimplement(Object o, Method method, Object[] objects) throws Throwable {
		System.out.println("new method");
    return null;
  }
}
```

在配置文件中进行方法替换：

```xml
<bean id="mymethod2" class="com.simon.MyMethodRepalcer">
	<bean id="mymethod1" class="com.simon.MyMethod">
  	<replaced-method name="show" replacer="mymethod2"/>
  </bean>	
</bean>
```





### Bean 的生命周期

> 生命周期：从对象创建到对象销毁的过程。

:star: **Bean 的生命周期**：

1. 通过构造起创建 bean 的实例（无参数构造方法）
2. 为 bean 中的属性设置值或者对其他 bean 的引用（调用 `set` 方法）
3. 调用 bean 的初始化的方法（需要进行配置）。
4. bean 投入使用（获取到了对象）。
5. 当容器关闭时，调用 bean 的销毁方法（需要进行配置销毁方法）。



🌰 例子（生命周期步骤）：

::: details

+ 创建 `Orders` 类：*（包含无参构造方法（Bean 创建时使用），初始化执行的方法和销毁时执行的方法）

```java
public class Orders {

    private String orderName;


    public Orders() {
        System.out.println("第一步：执行无参数构造创建bean实例");
    }

    public void setOrderName(String orderName) {
        System.out.println("第二步：调用set方法设置属性值");
        this.orderName = orderName;

    }

    // 创建执行的初始化的方法
    public void initMethod(){
        System.out.println("第三步：执行初始化的方法");
    }

    // 创建执行的销毁的方法
    public void destroyMethod(){
        System.out.println("第五步：执行销毁的方法的方法");
    }

    @Override
    public String toString() {
        return "Orders{" +
                "orderName='" + orderName + '\'' +
                '}';
    }
}
```

+ Spring 中的配置，包括要配置初始化方法和销毁方法。

```xml
<bean id="order" class="com.simon.bean.Orders" init-method="initMethod" destroy-method="destroyMethod">
    <property name="orderName" value="phone"/>
</bean>
```

+ 编写测试类和测试方法：

```java
public class OrderTest {

    @Test
    public void TestOrderBean() {
        // ApplicationContext context = new ClassPathXmlApplicationContext("OrderBean.xml"); // 由于Application中没有close方法，所以使用它子接口中的类型中的方法
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("OrderBean.xml");
        Orders order = context.getBean("order", Orders.class);
        System.out.println("第四部：获取创建的bean对象");
        System.out.println(order);

        // 手动让bean实例销毁
        context.close();
    }
}
```

:::



**bean 的后置处理器**：

> 加上后置处理器后，**生命周期变为七个步骤**：
>
> 1. 通过构造起创建 bean 的实例（无参数构造方法）
> 2. 为 bean 中的属性设置值或者对其他 bean 的引用（调用 `set` 方法）
> 3. **把 bean 的实例传递 bean 后置处理器的方法 `postProcessBeforeInitialization`  。**
> 4. 调用 bean 的初始化的方法（需要进行配置）。
> 5. **把 bean 实例传递 bean 后置处理器的方法 `postProcessAfterInitialization`。**
> 6. bean 投入使用（获取到了对象）。
> 7. 当容器关闭时，调用 bean 的销毁方法（需要进行配置销毁方法）。

🌰 添加后置处理器后的例子：

::: details

+ 创建后置处理器类，实现接口 `BeanPostProcessor`中的方法：

```java
public class MyBeanPost implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("在初始化之前执行的方法");
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("在初始化之后执行的方法");
        return bean;
    }
}
```

+ 在 Spring 配置文件中配置后置处理器，当配置文件被加载时，创建的 bean 对象实例都会被添加后置处理器：

```xml
<!--配置后置处理器-->
<!--再加载本配置文件时，创建上面的bean时，为上面所有的bean都添加后置处理器-->
<bean id="myBeanPost" class="com.simon.bean.MyBeanPost"/>
```

:::



### 基于注解方式的 Bean 管理

> 注解：是代码特殊标记，格式： `@注解名称(属性名称=属性值, 属性名称=属性值 ...)`。
>
> 注解使用的位置：注解作用在类上面、方法上面、属性上面。
>
> 注解使用的目的：减少 XML 配置量。



#### 创建对象

Spring 针对 Bean 管理中创建对象提供的注解有：

+ `@Conponent`：**普通注解** 
+ `@Service`：业务逻辑组件类，业务层
+ `@Controller`：控制器组件类，表现层
+ `@Repository`  ：DAO 组件类，持久化层

**（上面的四个注解功能是一样的，都可以用来创建 Bean 的实例）**

🌰 基于注解方式创建对象：

::: details 

+ 除了在基于 XML 中使用到的 Spring 依赖，还需要添加额外的依赖：

![image-20220328155231274](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/OToRxI.png)

+ **开启组件扫描**：

  （要扫描多个包使用`,` 隔开，或者直接扫描包的上层目录）

```xml
<!--开启组件扫描-->
<!--<context:component-scan base-package="com.simon.dao, com.simon.service"/>-->
<context:component-scan base-package="com.simon"/>
```

+ 创建类，在类上面添加对象注解：

相当于` <bean id="userService" class="...">`，如**果注解中的值省略不写，默认值为首字母小写的类名称（如下）**。

```java
@Service(value = "userService") 
public class UserService {
    
    public void add(){
        System.out.println("UserService add() ...");
    }
}
```

+ 编写测试类和测试方法：

```java
@Test
public void testAdd(){
    ApplicationContext context = new ClassPathXmlApplicationContext("UserBean.xml");
    UserService userService = context.getBean("userService", UserService.class);
    System.out.println(userService);
    userService.add();
}
```

:::



#### 组件扫描配置

🌰 例子：设置只扫描的组件：

> 相关的标签和属性值：
>
> - `use-defalut-filters="false"` ：表示现在不使用默认 `filter`，自己配置 `filter`。
>
> - `include-filter` 标签中设置扫描哪些内容。下面的配置表示只扫描 `@Controller` 的注解。

```xml
<context:component-scan base-package="com.simon" use-default-filters="false">
    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
</context:component-scan>
```



🌰 例子：设置不扫描的组件：

> - `exclude-filter` 标签中设置不扫描哪些内容。下面的配置表示不扫描 `@Controller` 的注解。

```xml
<context:component-scan base-package="com.simon">
    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
</context:component-scan>
```



#### 注入属性

在 Spring 中与属性注入相关的注解：

- `@Autowired` ：根据属性类型进行**自动装配**。

- `@Qualifier`：根据属性名称进行注入，需要和 `@Autowired` 一起使用。

- `@Resource`：可以**根据类型或者名称**注入属性。

- `@Value`：根据普通类型（字符串）注入属性。



 `@Autowired` **自动装配**：自动按照类型注入。（这种情况下 `set` 方法可以省略，因为实质上是在容器里完成装配的）只要 IoC 容器中有唯一的一个 bean 对象和要注入的变量类型匹配，就可以注入成功。

🌰 例子：

::: details

+ 使用注解法创建 `UserService` 和 `UserDAO` 类的对象：

```java
public interface UserDao {
    void add();
}
```

```java
@Repository
public class UserDAOImpl implements UserDAO{
    @Override
    public void add() {
        System.out.println("UserDAO add() ... ");
    }
}
```

+ 在 `UserService` 中添加 `UserDAO` 类型的属性，在属性上使用注解注入 `UserDAO`  对象，注意属性不需要编写 `set` 方法

```java
@Service(value = "userService") // 相当于 <bean id="userService" class="...">
public class UserService {
    @Autowired // 根据类型注入
    private UserDAO userDAO; // 不需要添加set方法

    public void add(){
        System.out.println("UserService add() ...");
        userDAO.add();
    }
```

> 此时 `@Autowired` 自动装配是根据属性的类型进行注入的，如果 `UserDAO` 的实现类不止一个，比如新增一个 `UserDAOImpl2` ：
>
> ```java
> @Repository
> public class UserDAOImpl2 implements UserDAO{
>     @Override
>     public void add() {
>         System.out.println("UserDAO2 add() ... ");
>     }
> }
> ```
>
> 再进行测试时，程序会报错：`UnsatisfiedDependencyException`即*不满足依赖异常*，嵌套异常是`NoUniqueBeanDefinitionException`即*Bean定义不唯一异常*，预期匹配单个 Bean 但是找到了两个 Bean。要向指定装配某一个实现类，就需要用到 `@Qualifier` 注解。

:::



 `@Qualifier` ：

根据名称注入，想要从多个实现类中装配具体某一个实现类，可以使用 `@Qulifier`：

+ 属性 `value` 值为具体的实现类上配置的注解中的 `value` 值。

🌰 例子：

::: details

+ 在 `UserService` 中的 `UserDAO` 类型属性中使用，即可将实现类指定为 `userDAOImpl`：

```java
@Service(value = "userService") 
public class UserService {
    @Autowired 
    @Qualifier(value = "userDAOImpl")
    private UserDAO userDAO;

    public void add(){
        System.out.println("UserService add() ...");
        userDAO.add();
    }
}
```



::: warning

+ `@Qulifier` 注解要跟 `@Autowired` 一起使用。

+ 在 `@Qulifier` 注解中的 `value` 值对应实现类中 `@Repository`  注解的属性值（如果没有配置则默认为首字母小写的类名），当指定名称有误，即不存在名称对应的类，则会抛出找不到对应类的异常。

:::

::: 



`@Resource` ：既可以根据类型也可以根据名称注入。

🌰 例子：
::: details 

+ 根据类型注入：

```java
@Resource
private UserDao userDao;
```

+ 根据名称注入

```java
@Resource(name = "userDaoImpl")
private UserDao userDao;
```

:::

::: tip

由于 `@Resource` 注解所在的包为 `javax.annotation` 即 Java 扩展包，所以 Spring 官方不建议使用该注解而推荐使用 `@Autowired` 和 `@Qualifier` 注解。

> 常用的注解在 `org.springframework.steotype` 包下。

:::



`@Value` 

上述提到的注解都是对**对象类型的属性**进行注入，要装配普通类型额的属性，如基本数据类型及其包装类，可以使用 `@Value` 注解：

🌰 例子：

::: details 

```java
@Value(value = "Simon")
private String name;
@Value(value = "23")
private Integer age;
@Value(value = "200.0d")
private Double length;
@Value(value = "true")
private boolean isOk;
@Value(value = "0,a,3,6,test")
private String[] arrs;
```

:::



#### 完全使用注解开发

+ 创建配置类（🌰 例如下面的 `SpringConfig`  类），替代 XML 配置文件：（使用注解 `@Configuration` 和 `@ComponentScan(…)` ）

```java
@Configuration
@ComponentScan(basePackages = "com.simon.annotation")
public class SpringConfig {
}
```

+ 测试类和测试方法：

```java
public class UserServiceTest {
    @Test
    public void testAdd(){
      // ApplicationContext context = new ClassPathXmlApplicationContext("UserBean.xml");
        ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        UserService userService = context.getBean("userService", UserService.class);
        System.out.println(userService);
        userService.add();
    }
}
```

与之前的不同点就是用 `AnnotationConfigApplicationContext` 代替了 `ClassPathXmlApplicationContext` 对象。
