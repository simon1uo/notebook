---
title: 🚖 Java 代理模式
date: 2022-03-02 17:34:16
permalink: /pages/f43979/
categories: 
  - 🧋 JavaEE
  - 💡 Java 补充
tags: 
  - Java
author: 
  name: Simon
  link: https://github.com/simon1uo
---

+ Java 代理的特征是代理类与委托类有同样的接口，代理类主要负责委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。

+ 代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。



## 代理模式

按照代理的创建时期，代理可以分为两种：

+ 静态代理：程序员创建或者特定工具自动生成的源代码，再对其编译。在程序运行前，代理类的 `.class` 文件就已经存在了。【为其他对象提供一种代理以控制对这个对象的访问】
+ 动态代理：在程序运行时，运用 [反射机制](/pages/e56959/#反射的三种方式) 创建而成。



> + 其他对象：目标对象，想要访问的对象，常被称为被委托对象或被代理对象。
> + 提供一种代理：「**一种**」代表了某一类，即代理类和被代理类必须实现同一接口，这个接口下的所有实现类都能被代理访问到，其实只是单纯的为了实现代理访问功能，代理类不实现任何接口也能完成，不过针对于面向接口的编程，**这种方式更易于维护和扩展**，代理类实现接口，不管目标对象怎么改或改成谁，代理类不需要任何修改，而且任何目标对象能使用的地方都能用代理去替换。
> + 通过代理访问目标对象：代理类需要持有目标对象的引用，这样用户可以通过代理类访问目标对象，实现了用户与目标对象的解耦。
> + 访问：说明代理对象的目的是**访问被代理类**，业务逻辑的具体执行与其无关，由被代理对象完成。
> + 为什么要通过代理来访问：
>   + **设计棋式都是为了解决某一类的问题，可能目标对象不想让该用户访问或者是该用户无法访问到目标对象，这样就需要一个第三者来建立他们的联系。**
>   + 例如如代理服务器情景，被访问的服务器设置防火墙过滤掉某些地址的访问，这时用户就可以通过一个代理服务器来访问目标，使得目标服务器不用对外暴露细节，用户也能访问到想访问的数据。
> + 代理类功能增强：代理对象能直接访问到目标对象，这样它就能在调用目标对象的某个方法之前做一个预处理，**在调用方法之后进行一些结尾工作**，**这样就对目标对象的方法进行了增强**。但是，不能说代理模式提供对象功能的增强，它的设计初衷是对代理对象施加控制，只是这种设计思路能达到功能增强的目的。



### 静态代理

🌰 例子：

+ 编写接口 `Developer`：

```java
interface Developer {
    public void writeCode();
}
```

+ 接口的实现类 `DeveloperImpl` ：

```java
class DeveloperImpl implements Developer {
    private String name;

    public DeveloperImpl(String name) {
        this.name = name;
    }

    @Override
    public void writeCode() {
        System.out.println("Developer " + name + " writes code");
    }
}
```

+ 测试：创建一个 `Developer` 的实例：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"
::: tab java 

```java
public static void main(String[] args) {
  DeveloperImpl developer = new DeveloperImpl("Simon");
  developer.writeCode();
}
```

:::
::: tab result 

```
Developer Simon writes code
```

:::
::::

+ :star: 现在想让程序员写代码前打卡上班，写代码后打卡下班，又不想修改程序员 `Developer` 类，可以使用一个**静态代理** `DeveloperProxy` ：

```java
class DeveloperProxy implements Developer{
    private Developer developer;

    public DeveloperProxy(Developer developer) {
        this.developer = developer;
    }

    @Override
    public void writeCode() {
        System.out.println("begin");
        this.developer.writeCode();
        System.out.println("end");
    }
}
```

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"
::: tab java 

```java
public static void main(String[] args) {
  Developer developer = new DeveloperImpl("Simon");
  // developer.writeCode();
  
  DeveloperProxy developerProxy = new DeveloperProxy(developer);
  developerProxy.writeCode();
}
```

:::
::: tab result 

```
begin
Developer Simon writes code
end
```

:::
::::



**静态代理模式的优点：**

+ 易于理解和实现。
+ 代理美和真实类的关系是编译期静态决定的，和动态代理比较起来，执行时没有任何额外开销。

**静态代理模式的缺点：**

+ **每一个真实类都需要一个创建新的代理类。**
  + 比如上面例子 🌰，对测试工程师 `Tester` 也提出了新的要求，让测试工程师每次测出 bug 时，也要及时计算测试的耗时。那么 采用静态代理的方式，测试工程师的实现类 `Tester` 也得创建一个对应的 `TesterProxy` 类。

+ **静态代理的每一个代理类只能为一个接口服务**。所以程序开发中必然会产生过多的代理，而且所有的代理操作除了调用的方法不一样以外，其他操作一样，此时代码有重复。

  🌰例子：加上测试工程师的部分：

  ```java
  interface Tester {
      public void doTesting();
  }
  
  class TesterImpl implements Tester {
      private String name;
  
      public TesterImpl(String name) {
          this.name = name;
      }
  
      @Override
      public void doTesting() {
          System.out.println("Tester " + name + "is testing code");
      }
  }
  
  class TesterProxy implements Tester{
      private Tester tester;
  
      public TesterProxy(Tester tester) {
          this.tester = tester;
      }
  
      @Override
      public void doTesting() {
          System.out.println("begin");
          this.tester.doTesting();
          System.out.println("end");
      }
  }
  
  ```

  :::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

  ::: tab java 

  ```java
  public static void main(String[] args) {
    Tester tester = new TesterImpl("tester");
    TesterProxy testerProxy = new TesterProxy(tester);
    testerProxy.doTesting();
  }
  ```

  ::: 

  ::: tab result 

  ```
  begin
  Tester testeris testing code
  end
  ```

  ::: 

  ::::

解决静态代理的重复问题，最好的做法是通过一个代理类完成全部的代理功能，所以必须使用**动态代理**完成：

### 动态代理

`InvocationHandler` 接口：

```java
public interface InvocationHandler{
  public Object invoke(Object proxy, Methodmethod, Object[] args) throws Throwable;
}
// proxy 被代理的对象
// Method 要调用的方法
// args 方法调用所需要的参数
```



+ 动态代理 `EngineerProxy`:

```java
class EngineerProxy implements InvocationHandler {
    private Object object;

    public Object bind(Object object) {
        this.object = object;
        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("begin");
        Object res = method.invoke(object, args);
        System.out.println("end");
        return null;
    }
}
```

+ 测试用一个动态代理完成：

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }" 

::: tab java 

```java
public static void main(String[] args) {
  Developer zhangsan = new DeveloperImpl("zhangsan");
  Developer zhangsanProxy = (Developer) new EngineerProxy().bind(zhangsan);
  zhangsanProxy.writeCode();
  
  Tester lisi = new TesterImpl("lisi");
  Tester lisiProxy = (Tester) new EngineerProxy().bind(lisi);
  lisiProxy.doTesting();
}
```

::: 

::: tab result 

```
begin
Developer zhangsan writes code
end
begin
Tester lisiis testing code
end
```

::: 

::::

