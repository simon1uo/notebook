---
title: 🏷 SpringMVC 请求参数
date: 2022-03-17 19:50:43
permalink: /pages/d57de7/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🚏SpringMVC
tags: 
  - SpringMVC
author: 
  name: Simon
  link: https://github.com/simon1uo
---


## Spring MVC 获取请求参数

### 通过 servlet API 获取（*少用）

+ 将 `HttpServletRequest` 作为控制器方法的形参，此时 `HttpServletRequest` 类型的参数表示封装了当前请求的**请求报文对象**。



🌰 例子： 使用 `HttpServletRequest` 获取参数：

```java
@RequestMapping("testServletAPI")
public String testServletAPI(HttpServletRequest request) {
    // 形参位置的request表示当前的请求
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    System.out.println("username: " + username + ", password: " + password);
    return "success";
}
```

```html
<a th:href="@{/param}">测试参数Param</a>
```



> 此处 SpringMVC 的 **IOC 容器**为我们注入了 `HttpServletRequest` 请求对象，同时 `DispatcherServlet` 为我们调用 `testServletAPI()` 方法时，自动给 `request` 参数赋了值，因此可以在方法形参的位置传入请求对象 `HttpServletRequest` ，可以直接使用其方法 `getParameter` 方法获取参数。
>
> 但是尽管 Servlet API 原生方法并没有相比下面的方法简易，所以并不常用。



### 通过控制器方法

+ 在控制器的形参位置，设置和请求参数 :warning: **同名的形参**，当浏览器发送请求匹配到请求映射时，在 `DispatcherServlet` 中就会将请求参数赋值给相应的形参：

+ 若请求参数中出现**多个同名请求参数**，可以在控制器方法的**形参位置**设置字符串类型或者字符串数组来接受此请求参数。（如下例子中的  `hobby`）

  （如果使用字符串类型的形参，最终结果为请求参数的每一个值之间使用**逗号**进行拼接。）

🌰 例子：

```java
@RequestMapping("/testParam")
public String testParam(String username, String password, String[] hobby) {
    System.out.println("username: " + username + ", password: " + password + ", hobby" +  Arrays.toString(hobby));
    return "success";
}
```

```html
<form th:action="@{/testParam}" method="get">
    用户名：<input type="text" name="username" value="admin"><br>
    密码：<input type="text" name="password" value="123456"><br>
    爱好：<input type="checkbox" name="hobby" value="a" checked>a
    <input type="checkbox" name="hobby" value="b" checked>b
    <input type="checkbox" name="hobby" value="c">c
    <input type="submit" value="测试使用控制器的形参获取请求参数">
</form>
```



> 注意：同名形参相关问题：
> 在 `@RequestMapping` 注解的路径占位符相关内容中，要使用 `@PathVariable` 才能获取参数，而不能使用同名形参视图获取占位符的值。 



### `RequestParam`

+ 将请求参数和控制器方法的形参创建映射关系。

+ 包含三个属性：

  + `value` ：制定为形参赋值的请求参数的参数名。
  + `required` ：设置是否必须传输此请求参数，默认值 `true`。（当此请求参数为必须要求获取时，并且没有设置 `defaultValue` 属性，则报错 `400:Required String parameter 'xxx' is not present` ），当设置为 `false` 时没有传输参数，则注解所标识的形参值为 `null`。
  + `defaultValue`：不管 `required` 值为 `true | false` ，当 `value` 所制定的请求参数没有传输时，则使用默认值为形参赋值。

  

🌰 例子：

```java
@RequestMapping("/testParam")
public String testParam(
        @RequestParam(value = "username", required = false, defaultValue = "defaultUsername") String username,
        String password,
        String[] hobby) {
    System.out.println("username: " + username + ", password: " + password + ", hobby" + Arrays.toString(hobby));
    return "success";
}
```



> 当前台 `name=username` 修改为 `name=user_name` 时，后台并不能获取前台传输过来的参数数据。
>
> 这里侧面证明一件事，SpringMVC 中对请求参数的赋值是根据是否同名来决定的，而不会根据参数在方法上的第几个位置决定，也就是说 SpringMVC 没有考虑将*请求参数个数、类型与顺序*与*控制器方法形参个数、类型与顺序*进行绑定。如果我们来设计 SpringMVC，应该考虑这种方案么？
>
> 个人觉得，这种方案虽然可以实现与 Java 重载方法的一一绑定关系，但实际操作起来有一定难度：
>
> - 比如数字类型可以当作 String 处理，也可以当作 Integer 处理，不好区分
>
> - 退一步来讲，如果考虑重载方法，SpringMVC 底层势必要对类中所有重载方法进行循环，判断是否满足个数、类型和顺序的要求，性能上一定有所影响
>
> 而限制请求路径和请求方式不能完全相同的话，就没有这种苦恼了。即使是重载方法，通过不同请求路径或请求方法来界定到底访问哪个方法就可以了。



### `@RequestHeader`

+ 将请求头信息和控制器方法的形参创建映射关系；
+ 包含三个属性：`value`、`required`、`defaultValue`，用法同 `@RequestParam` 。



🌰 例子：

```java
@RequestMapping("/testParam")
public String testParam(
        @RequestParam(value = "user_name", required = false, defaultValue = "defaultUsername") String username,
        String password,
        String[] hobby,
        @RequestHeader(value = "HeaderTest", required = true, defaultValue = "headerTest") String HeaderTest
        ) {
    System.out.println("username: " + username + ", password: " + password + ", hobby" + Arrays.toString(hobby));
    System.out.println(HeaderTest);
    return "success";
}
```



### `@CookieValue`

+ 将 cookie 数据值和控制器方法的形参创建映射关系。
+ 包含三个属性：`value`、`required`、`defaultValue`，用法同 `@RequestParam` 。



🌰 例子：

首先创建新的 `session`，以获取 cookie 值：
```java
@RequestMapping("/testServletAPI")
public String testServletAPI(HttpServletRequest request) {
    HttpSession session = request.getSession();
    // ...
}
```

后面每次发送请求，`JSESSIONID`的`Cookie`将会放在*请求报文*信息。

```java
@RequestMapping("/testCookie")
public String testCookie(
    @CookieValue(value = "JSESSIONID") String jSessionId,
    @CookieValue(value = "Test", required = false, defaultValue = "CookieValue") String test) {
    System.out.println("jSessionId=" + jSessionId + ", test=" + test);
    return "success";
}
```



>🔗 `JSESSIONID` 相关：
>
>- 在 JavaWeb 中，`Session`依赖于`Cookie`，`Session`是服务器端的会话技术，`Cookie`是客户端的会话技术。
>
>- 会话技术默认的生命周期是浏览器开启和浏览器关闭，只要浏览器不关闭，`Cookie`将一直存在。
>
>- 调用`getSession()`方法时，首先会检测请求报文中是否有携带`JSESSIONID`的`Cookie`。如果没有，说明当前会话是第一次创建`Session`对象，则 
>
>- - 在服务端创建一个`Cookie`，以键值对形式存储。键是固定的`JSESSIONID`，值是一个 UUID 随机序列
>
>- - 在服务端创建一个`HttpSession`对象，并放在服务器所维护的 Map 集合中。Map 的键是`JSESSIONID`的值，值就是`HttpSession`对象
>
>- - 最后把`Cookie`相应给浏览器客户端，此时`JSESSIONID`的`Cookie`存在于响应报文中。每次浏览器向服务器发送请求都会携带`Cookie`，此后`JSESSIONID`的`Cookie`将存在于请求报文中

### 通过实体类获取请求参数

可以在控制器的形参位置设置一个**实体类型的的形参**，此时若浏览器传输的请求参数的参数名和实体类中的属性名**一致**，那么请求参数就会为此属性赋值。



🌰 例子：

```java
@RequestMapping("/testPOJO")
public String testPOJO(User user){
    System.out.println(user);
    return "success";
}
```

```html
<form th:action="@{/testPOJO}" method="get">
    用户名：<input type="text" name="username" value="admin"><br>
    密码：<input type="text" name="password" value="123456"><br>
    性别： <input type="radio" name="sex" value="男">男
    <input type="radio" name="sex" value="女">女<br>
    年龄：<input type="text" name="age"><br>
    邮箱：<input type="text" name="email"><br>
    <input type="submit" value="测试通过实体类获取请求参数">
</form>
```



### 解决获取请求参数的乱码问题

如上例子通过实体类获取请求参数，当前台使用 `POST` 方法相应请求时，返回的中文字符会出现字符。

> 要处理乱码问题有两种思路：
>
> + 发送请求之后，手动解码编码。
> + 发送请求之前，`Servlet` 处理请求之前处理乱码。
>
> JavaWeb 服务器中三大组件：监听器、过滤器、`Servlet`。很显然，监听器和过滤器都在`Servlet`之前
>
> - `ServletContextListener`监听器：只是来监听`ServletContext`的创建和销毁，都是只执行一次
>
> - `Filter`过滤器：只要设置了过滤路径，只要当前所访问的请求地址满足过滤路径，那么都会被过滤器过滤
>
> 很显然，用过滤器就可以做到在发送请求之前“做手脚”，这样所有请求都要经过过滤器的处理，再交给`DispatherServlet`处理。
>
> 但是，这个过滤不需要我们写，SpringMVC 已为我们准备好了，只要再`web.xml`中进行配置即可，



解决获取请求参数的乱码问题可以使用 SpringMVC 提供的**编码过滤器 `CharacterEncodingFilter`** ，但是必须要在 `web.xml` 配置文件中注册：

配置 `UTF-8`：

```xml
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceResponseEncoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

