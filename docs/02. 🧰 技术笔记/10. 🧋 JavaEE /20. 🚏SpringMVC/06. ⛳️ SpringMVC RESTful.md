---
title: ⛳️ SpringMVC RESTful
date: 2022-04-01 15:00:45
permalink: /pages/226cf2/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🚏SpringMVC
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## RESTful 简介

+ REST：Representational State Transfer，表现层的**资源状态转移**。
+ 表现层：前端的视图页面到后端的控制层为「表现层」。
+ **资源**： （一种看待服务器的方式，将服务看作是由很多离散的资源组成）Web 工程部署到服务器上，Web工程上中的内容在服务器上称资源。一个资源可以有多个 URI 标识，URI 既是资源的名称，也是资源在 Web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 进行交互。
+ 状态：资源的表现形式，可以有多种格式，例如 HTML/JSP 页面、CSS/JavaScript 文件、图片/音频/视频，皆是资源的状态。
+ 资源表述：是一段对于资源在某个特定时刻的状态的描述，可以在 客户端——服务端之间转移（交换）。资源的表述可以有多种格式，例如 HTML / XML / JSON / 纯文本 / 图片 / 视频 / 音频。资源的表述格式可以通过协商机制来确定，请求—响应方向的表述通常使用不同的格式。
+ **状态转移**：和客户端和服务器端之间的**转移**代表着资源状态的表述。浏览器发送请求到服务器，服务端将请求的资源「转移」到客户端。通过转移和操作资源的表述，来**间接实现操作资源的目的**。

***

+ RESTful：基于 REST 构建的 API 就是 RESTful 风格。



## RESTful 实现

+ 实现具体说的就是 HTTP 协议里面，四个标识**操作方式的动词**，以及分别对应的四种基本操作：

  + `GET` 用来获取资源。

  + `POST` 用来新建资源。

  + `PUT` 用来更新资源。

  + `DELETE` 用来删除资源

+ :star: REST 风格提倡 URI 地址不使用问号 `?` 对方式携带请求参数，提倡使用统一的风格设计，**从前到后各个单词使用斜杠分开**，将要发送给服务器的数据作为地址的一部分，以保证整体风格的一致性 URL。

::: tip 

以往访问资源的方式五花八问。例如，

- 获取用户信息通过`getUserById`/`selectUserById`/`findUserById`/等

- 删除用户信息通过`deleteUserById`/`removeUserById`等

- 更新用户信息通过`updateUser`/`modifyUser`/`saveUser`等

- 新增用户信息通过`addUser`/`createUser`/`insertUser`等

上述操作的资源都是用户信息。按照`RESTful`思想，**既然操作的资源一样，那么请求路径就应该一样**。

🌰 传统方式与 REST 风格对用户的操作的 URL 地址区别

| 操作 | 传统方式              | REST 风格               |
| ---- | --------------------- | ----------------------- |
| 查询 | `getUserById?id=1`    | `user/1` ，`GET` 请求   |
| 保存 | `saveUser`            | `user`，`POST` 请求     |
| 删除 | `deleteUserById?id=1` | `user/1`，`DELETE` 请求 |
| 更新 | `updateUser`          | `user`，`PUT` 请求      |

:::



🌰 例子：使用 RESTful 模拟操作用户资源：

**查询、添加部分（发送 `GET` 、`POST` 请求）**：

+ 创建控制器 `UserController` ，编写控制器方法：

```java
@Controller
public class UserController {

    @RequestMapping(value = "/user", method = RequestMethod.GET)
    public String getAllUser() {
        System.out.println("查询所有用户信息");
        return "success";
    }

    @RequestMapping(value = "/user/{id}", method = RequestMethod.GET)
    public String getUserById() {
        System.out.println("根据用户id查询用户信息");
        return "success";
    }

    @RequestMapping(value = "/user", method = RequestMethod.POST)
    public String insertUser(String username, String password) {
        System.out.println("添加用户信息" + username + password);
        return "success";
    }
}
```

+ 测试页面 `test_restful.html` ：

```html
<a th:href="@{/user}">查询所有用户信息</a><br>
<a th:href="@{/user/1}">根据用户id查询用户信息</a><br>
<form th:action="@{/user}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    <input type="submit" value="提交">
</form>
```

+ 在 Spring 配置文件中配置 `test_rest` 的视图：

```xml
<mvc:view-controller path="/test_restful" view-name="test_restful"/>
```



修改、删除部分（发送 `PUT`、`DELETE` 请求）：

::: tip 

由于在 [SpringMVC 请求映射](/pages/4cd331/) 以提到，**目前浏览器只支持 `GET` 和 `POST` 两种请求方式**，若使用其他的请求方式，**则按照默认的请求方式 `GET` 处理**。（若要发送 `PUT` 或者 `DELETE` 请求，则需要通过 Spring 提供的**过滤器** `HiddenHttpMethodFilter`）

当然，也可以使用 `AJAX` 发送 `PUT` 和 `DELETE` 请求，但是需要注意 `PUT` 和 `DELETE` **仅部分浏览器支持**。

:::

+ 在 `web.xml` 配置文件中配置 `HiddenHttpMethodFilter` 过滤器：

```xml
<filter>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

+ 编写控制器方法：

```java
@RequestMapping(value = "/user", method = RequestMethod.PUT)
public String updateUser(String username, String password) {
    System.out.println("修改用户信息" + username + password);
    return "success";
}

@RequestMapping(value = "/user", method = RequestMethod.DELETE)
public String deleteUser(String username, String password) {
    System.out.println("删除用户信息" + username + password);
    return "success";
}
```

+ 测试页面 `test_restful.html`：

```html
修改用户信息
<form th:action="@{/user}" method="post">
    <input type="hidden" name="_method" value="put">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    <input type="submit" value="修改">
</form>
删除用户信息
<form th:action="@{/user}" method="post">
    <input type="hidden" name="_method" value="delete">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    <input type="submit" value="修改">
</form>
```

> +  使用隐藏的 `input` 类型 `<input type="hidden" name="_method" value="put">` 向后台传输请求方式。
> + 实际上，在删除某条用户信息时应使用一个超链接删除某一行数据，或是通过选中表单的数据批量删除数据，所以应该是通过 `id` 信息进行删除，这里仅作测试请求方法使用。



::: tip 

关于 `web.xml` 中过滤器的配置顺序问题：

通过对 `HiddenHttpMethodFilter` 源码的剖析，它会获得 `_method` 这个请求参数，这就导致执行到 `CharacterEncodingFilter` 过滤器时，已经是获取请求参数之后了，所以会导致中文乱码问题。

因此，必须要将 `CharacterEncodingFilter`  编码处理过滤器尽量配置在其他过滤器之前。这样就能保证在任何过滤器获取请求之前，获得的失已经处理过编码格式的请求参数了。

:::



## RESTful 案例

要实现一个员工列表的增删改查：

### 功能清单

| 功能               | URL路径       | :star:请求方式 |
| ------------------ | ------------- | -------------- |
| 访问首页           | `/`           | `GET`          |
| 查询所有员工       | `/employee`   | `GET`          |
| 删除员工           | `/employee/1` | `DELETE`       |
| 跳转到添加员工页面 | `/toAdd`      | `GET`          |
| 添加员工           | `/employee`   | `POST`         |
| 跳转到修改员工页面 | `/employee/2` | `GET`          |
| 修改员工           | `/employee`   | `PUT`          |



### 项目配置

+ 创建 Maven 项目，引入相关依赖：

```xml
<packaging>war</packaging>

<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.3.18</version>
    </dependency>
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.11</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.thymeleaf</groupId>
        <artifactId>thymeleaf-spring5</artifactId>
        <version>3.0.15.RELEASE</version>
    </dependency>
</dependencies>
```

+ 配置 Web Modules （注意路径设置为 `src/main/webapp` ），配置 `web.xml` 文件，添加两个过滤器和 Spring MVC 前端控制器：

::: details 

```xml
<!--配置编码过滤器-->
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceResponseEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

<!--配置处理 PUT 和 DELETE 的请求过滤器-->
<filter>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

<!--配置 SpringMVC 前端控制器-->
<servlet>
    <servlet-name>DispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:springMVC.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>DispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

:::

+ Spring MVC 配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!--扫描组件-->
    <context:component-scan base-package="com.simon.rest"/>

    <!--配置Thymeleaf视图解析器-->
    <bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
        <property name="order" value="1"/>
        <property name="characterEncoding" value="UTF-8"/>
        <property name="templateEngine">
            <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
                <property name="templateResolver">
                    <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
                        <!--视图前缀-->
                        <property name="prefix" value="/WEB-INF/templates/"/>
                        <!--视图后缀-->
                        <property name="suffix" value=".html"/>
                        <property name="templateMode" value="HTML5"/>
                        <property name="characterEncoding" value="UTF-8"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>

    <!--配置视图控制器-->
    <mvc:view-controller path="/" view-name="index"/>
    <mvc:view-controller path="/toAdd" view-name="employee_add"/>

    <!--开放对静态资源的访问-->
    <mvc:default-servlet-handler/>

    <!--开启SpringMVC注解驱动-->
    <mvc:annotation-driven/>
</beans>
```



### Bean / DAO / Controller

+ 创建员工持久化类 `Employee`：

::: details

```java
public class Employee {
    private Integer id;
    private String lastName;
    private String email;
    private Integer gender;

    public Employee() {
    }

    public Employee(Integer id, String lastName, String email, Integer gender) {
        this.id = id;
        this.lastName = lastName;
        this.email = email;
        this.gender = gender;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Integer getGender() {
        return gender;
    }

    public void setGender(Integer gender) {
        this.gender = gender;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", gender=" + gender +
                '}';
    }
}
```

:::

+ 处理操作员工增删改查的 DAO：

```java
public interface EmployeeDAO {
    /**
     * 增加员工信息
     * @param employee
     */
    void save(Employee employee);

    /**
     * 删除员工信息
     * @param id
     */
    void deleteById(Integer id);

    /**
     * 获取所有员工信息
     * @return
     */
    List<Employee> getAll();

    /**
     * 根据员工id获取员工信息
     * @param id
     * @return
     */
    Employee getById(Integer id);
}
```

```java
@Repository
public class EmployeeDAOImpl implements EmployeeDAO {
    private static Map<Integer, Employee> employeeMap;
    private static Integer initId = 1000;

    static {
        employeeMap = new HashMap<>();
        employeeMap.put(++initId, new Employee(initId, "张三", "zhangsan@qq.com", 1));
        employeeMap.put(++initId, new Employee(initId, "李四", "lisi@qq.com", 0));
        employeeMap.put(++initId, new Employee(initId, "王五", "wangwu@qq.com", 0));
        employeeMap.put(++initId, new Employee(initId, "赵六", "zhaoliu@qq.com", 1));
    }

    @Override
    public void save(Employee employee) {
        if (employee.getId() == null) {
            employee.setId(++initId);
        }
        employeeMap.put(employee.getId(), employee);
    }

    @Override
    public void deleteById(Integer id) {
        employeeMap.remove(id);
    }

    @Override
    public List<Employee> getAll() {
        return new ArrayList<>(employeeMap.values());
    }

    @Override
    public Employee getById(Integer id) {
        return employeeMap.get(id);
    }
}
```

+ 创建处理请求的控制器类 `EmployeeController` ：

```java
@Controller
@RequestMapping("/employeeController")
public class EmployeeController {
    @Autowired
    private EmployeeDAO employeeDAO;
	
  // ... 
}
```





### 增删改查

创建首页静态页面 `templates/index.html`：

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Index | SpringMVC RESTful Example</title>
</head>
<body>
<h1>INDEX</h1>
<a th:href="@{/employeeController/employee}">查看员工信息</a>
</body>
</html>
```



#### **实现获取员工列表**

+ 在 `EmployeeController` 中处理获取员工列表的请求，请求方法为 `GET` ：

```java
@RequestMapping(value = "/employee", method = RequestMethod.GET)
public String getAllEmployee(Model model) {
    List<Employee> employeeList = employeeDAO.getAll();
    model.addAttribute("employeeList", employeeList);
    return "employee_list";
}
```

+ 创建展示员工列表的静态页面：`templates/employee_list.html`：

```html
<h1>员工信息</h1>
<table id="dataTable" border="1" cellpadding="0" cellspacing="0" style="text-align: center;">
    <tr>
        <th colspan="5">EmployeeInfo</th>
    </tr>
    <tr>
        <th>id</th>
        <th>姓名</th>
        <th>邮箱</th>
        <th>性别</th>
        <th>操作 </th>
    </tr>
    <tr th:each="employee : ${employeeList}">
        <td th:text="${employee.id}"/>
        <td th:text="${employee.lastName}"/>
        <td th:text="${employee.email}"/>
        <td th:text="${employee.gender == 1 ? '男' : '女'}"/>
        <td>
					修改
          删除
        </td>
    </tr>
</table>
```



#### 添加员工信息功能

+ 在展示员工信息列表页面添加一个超链接「添加」请求路径为 `toAdd`：

```html
<th>操作 <a th:href="@{/toAdd}">添加</a> </th>
```

+ 在 SpringMVC 配置文件中配置该请求路径跳转到添加员工信息页面：

```xml
<mvc:view-controller path="/toAdd" view-name="employee_add"/>
```

静态页面 `employee_add.html`，此时提交表达的请求方法为 `POST` ：

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Add Employee</title>
</head>
<body>
<form th:action="@{/employeeController/employee}" method="post">
    lastName: <input type="text" name="lastName"><br>
    email: <input type="text" name="email"><br>
    gender: <input type="radio" name="gender" value="1">male <input type="radio" name="gender" value="0">female <br>
    <input type="submit" value="add">
</form>
</body>
</html>
```

+ 在 `EmployeeController` 中处理添加员工信息的请求，请求方法为 `POST`：

```java
@RequestMapping(value = "/employee", method = RequestMethod.POST)
public String addEmployee(Employee employee) {
    employeeDAO.save(employee);
    return "redirect:/employeeController/employee";
}
```



#### 修改员工信息功能

+ 在操作一列下添加超链接「修改」，路径为：

```html
<a th:href="@{'/employeeController/employee/'+${employee.id}}">update</a>
```

该请求路径意为通过 `id` 获取员工信息，然后再跳转到修改员工信息的页面。

+ 在 `EmployeeController` 中处理通过 `id` 获取员工信息的请求，请求方法为 `GET` ：

```java
@RequestMapping(value = "/employee/{id}",method = RequestMethod.GET)
public String getEmployeeById(@PathVariable("id")Integer id,Model model){
    Employee employee = employeeDAO.getById(id);
    model.addAttribute("employee", employee);
    return "employee_update";
}
```

+ 创建更新员工信息的静态页面 `employee_update.html` ：
  + 在表单中有一个隐藏域用于传递请求的方法。
  + 此处有使用 `th:filed` 处理性别的展示到单选框的方法。

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Update Employee</title>
</head>
<body>
<form th:action="@{/employeeController/employee}" method="post">
    <input type="hidden" name="_method" value="put">
    <input type="hidden" name="id" th:value="${employee.id}">
    lastName: <input type="text" name="lastName" th:value="${employee.lastName}"><br>
    email: <input type="text" name="email" th:value="${employee.email}"><br>
    gender: <input type="radio" name="gender" value="1" th:field="${employee.gender}">male <input type="radio" name="gender" value="0" th:field="${employee.gender}">female <br>
    <input type="submit" value="update">
</form>
</body>
</html>
```

+ 在 `EmployeeController` 中处理修改员工信息请求，请求方法为 `PUT` ：

```java
@RequestMapping(value = "/employee", method = RequestMethod.PUT)
public String updateEmployee(Employee employee){
    employeeDAO.save(employee);
    return "redirect:/employeeController/employee";
}
```



#### 删除员工信息

在展示员工信息列表的静态页面 `employee_list` 中添加系列的操作：

+ 首先创建一个表单的隐藏域用于请求方法 `DELETE` ：

```html
<form method="post" id="deleteForm">
    <input type="hidden" name="_method" value="delete">
</form>
```

+ 引入 `vue.js` 处理点击删除超链接时，请求的路径和请求的方法：

（要引入静态资源需要在 Spring MVC 中配置开放资源访问，并且在创建 `static` 目录，放入相关的静态资源后，需要重新 Maven 项目的生命周期 `Lifecycle` 中重新打包 `package`  ，否则服务器找不到该静态资源）

```html
<script type="text/javascript" th:src="@{/static/js/vue.js}"></script>
<script type="text/javascript">
    const vue = new Vue({
        el: '#dataTable',
        methods: {
            deleteEmployee(event) {
                if (confirm('确认删除吗？')) {
                    var deleteForm = document.getElementById("deleteForm") // 根据id获取表单元素
                    deleteForm.action = event.target.href // 获取触发点击事件的超链接
                    deleteForm.submit() // 提交表单
                }
                event.preventDefault() // 取消超链接默认行为
            }
        }
    })
</script>
```

+ 在表格操作处添加「删除」超链接：

```html
<a @click="deleteEmployee" th:href="@{'/employeeController/employee/'+${employee.id}}">delete</a>
```

+ 在 `EmployeeController` 中处理删除员工信息，请求方法为 `DELETE` ：

```java
@RequestMapping(value = "/employee/{id}", method = RequestMethod.DELETE)
public String deleteEmployee(@PathVariable("id") Integer id) {
    employeeDAO.deleteById(id);
    return "redirect:/employeeController/employee";
}
```



::: tip

+ 几处处理员工信息后跳转回员工信息列表展示页面，均使用了 `redirect` 重定向到原来的页面。

:::

### 处理静态资源问题

在上述引入 `vue.js` 静态资源时，在 SpringMVC 配置文件中添加了开放静态资源访问的配置 `<mvc:default-servlet-handler/>`。

再总结其中三个 `mvc` 配置的作用：

```xml
<!--配置视图控制器-->
<mvc:view-controller path="/" view-name="index"/>
<mvc:view-controller path="/toAdd" view-name="employee_add"/>


<!--开放静态资源访问-->
<mvc:default-servlet-handler/>

<!--配置MVC注解驱动-->
<mvc:annotation-driven/>
```

+ `view-controller` ：配置视图控制器，实现简化页面跳转。
+ `default-servlet-handler` ：开放静态资源的访问。
+ `annotation-driven` ：MVC 注解驱动：
  + 解决因配置**视图控制器** `view-controller` 导致其他请求失效的问题。
  + 解决因配置静态资源访问导致其他请求失效的问题。



::: warning

+ `annotation-driven` 需要与 `view-controller`、`default-servlet-handler` 配合使用。
+ `annotation-driven` 与 `view-controller` 的关系：
  + 配置了 `view-controller` 视图控制器而不配置 `annotation-driven` 注解驱动，此时除了视图控制器配置路径的请求，其他控制器方法中的请求会失效（其他请求失效）。
  + 两者同时配置则可以实现所有请求能正常访问。
+ `annotation-driven` 与 `default-servlet-handler` 的关系：
  + 配置了 `default-servlet-handler` 而不配置 `annotation-driven` ，那么所有请求都交给 `DefaultServlet` 处理，`DispatcherServlet ` 将失效。
  + 两者同时配置，么所有请求将先交给 `DispatcherServlet` 处理，处理不了再交给 `DefaultServlet` 处理（静态资源处理）。

:::

