---
title: 🍴 SpringMVC 拦截器和异常处理
date: 2022-04-20 09:45:10
permalink: /pages/765ceb/
categories: 
  - _pages
  - 🧋 JavaEE
  - 🚏SpringMVC
tags: 
  - null
author: 
  name: Simon
  link: https://github.com/simon1uo
---
## 拦截器

### 拦截器的配置

SpringMVC 中的拦截器用于**拦截控制器方法的执行**，需要实现 `HandlerInterceptor` 类，并在 SpringMVC 的配置文件中进行配置。



🌰 例子：

+ 创建拦截器类，实现 `HandlerInterceptor` ：

```java
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyInterceptor==>preHandle");
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("MyInterceptor==>postHandle");
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("MyInterceptor==>afterCompletion");
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

> 也可以使用 `@Component` 注解方法创建 `MyInterceptor`  Bean，然后再在 SpringMVC 配置文件中 `ref` 配置 `mvc:interceptor`。

+ 在 SpringMVC 配置文件中配置拦截器：

```xml
<mvc:interceptors>
    <bean id="myInterceptor" class="com.simon.interceptor.MyInterceptor"/>
</mvc:interceptors>
```



此时访问任何的请求路径，都会被配置的拦截器所拦截。



另外 ，在 SpringMVC 配置文件中，还可以指定请求的路径配置拦截器。

+ 在 SpringMVC 配置文件中：

```xml
<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/**"/>
        <mvc:exclude-mapping path="/"/>
        <ref bean="myInterceptor"></ref>
    </mvc:interceptor>
</mvc:interceptors>
```

> `mvc:mapping` 表示要拦截匹配的请求路径。 `/**` 表示任意层路径，符合 `Ant` 风格的路径。与 `web.xml` 中 `url-pattern` 的 `/*` 匹配效果一致，但是写法不相同。
>
> `mvc:exclude-mapping` 表示不拦截（排除）的请求路径。



### 拦截器的三个抽象方法

- `preHandle`：控制器方法执行之前执行 `preHandle()`，其 `boolean `类型的返回值表示**是否拦截或放行** ：

- - 返回 `true` 表示放行，即调用控制器方法。

- - 返回 `false` 表示拦截，**即不调用控制器方法**。

- `postHandle`：**控制器方法执行之后**执行 `postHandle()`。

- `afterCompletion`：处理完视图和模型数据，**渲染视图完毕之后**执行 `afterCompletion()`。



### 拦截器的执行顺序

当 SpringMVC 中配置了多个拦截器，分为以下几种情况：

+ 若每个拦截器的 `preHandle()` 方法都返回 `true`。此时多个拦截器的执行顺序和拦截器在 SpringMVC 的配置文件的配置顺序有关：

> `preHandle()` 会按照配置的**顺序**执行，而 `postHandle()` 和 `afterComplation()` 会按照配置的**反序**执行。



🌰 例子：

+ 在 SpringMVC 中拦截器的配置顺序如下：

```xml
<mvc:interceptors>
    <ref bean="myInterceptor"></ref>
    <ref bean="myInterceptor2"></ref>
</mvc:interceptors>
```

+ 拦截器运行日志如下：

```
MyInterceptor==>preHandle
MyInterceptor2==>preHandle
MyInterceptor2==>postHandle
MyInterceptor==>postHandle
MyInterceptor2==>afterCompletion
MyInterceptor==>afterCompletion
```



+ 若某个拦截器的 `preHandle()` 返回了 `false` 。`preHandle()` 返回  `false` 和它之前的拦截器的 `preHandle()` 都会执行，`postHandle()` 都不执行，返回 `false` 的拦截器之前的拦截器的 `afterComplation()`会执行。



🌰 例子：

+ 当拦截器方法中：

```java
@Component
public class MyInterceptor2 implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyInterceptor2==>preHandle");
        return false;
    }
    // ...
}
```

+ 拦截器顺序同上例子。

+ 拦截器运行日志如下：

```
MyInterceptor==>preHandle
MyInterceptor2==>preHandle
MyInterceptor==>afterCompletion
```



## 异常处理

### 基于配置的异常处理

SpringMVC 提供了一个处理控制器方法执行过程中所出现异常的接口：`HandlerExceptionResolver`，其中包含以下常用的实现类：

+ `DefaultHandlerExceptionResolver`
+ `SimpleMappingExceptionResolver` SpringMVC 提供的自定义异常处理器。



🌰 配置异常处理例子：

+ 在 SpringMVC 配置文件中：

```xml
<!--异常处理-->
<bean id="simpleMappingExceptionResolver"
      class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <property name="exceptionMappings">
        <props>
            <!--
                properties的键表示处理器方法执行过程中出现的异常
                properties的值表示若出现指定异常，设置一个新的视图名称，跳转到指定页面
            -->
            <prop key="java.lang.ArithmeticException">error</prop>
        </props>
    </property>
    <!--设置一个属性名，将出现的异常信息共享在请求域中-->
    <property name="exceptionAttribute" value="ex"/>
</bean>
```

+ 创建一个测试的控制器方法：

```java
@RequestMapping("/testException")
public String testException() {
    int i = 1 / 0;
    return "success";
}
```



### 基于注解方式的异常处理

- `@ControllerAdvice`标识当前类为异常处理的组件

- `@ExceptionHandler`设置所标识方法处理的异常



🌰 同上例子：

+ 在控制器方法中添加注解：

```java
// ControllerAdvice 标识当前类为异常处理的组件
@ControllerAdvice
public class ExceptionController {
    // ExceptionHandler 设置所标识方法处理的异常
    @ExceptionHandler(value = {ArithmeticException.class, NullPointerException.class})
    // ex 表示当前请求处理过程中出现的异常对象
    public String testException(Exception ex, Model model) {
        model.addAttribute("ex", ex);
        return "error";
    }
}
```

