---
title:  🥦 SpringBoot 依赖、启动类等分析
date: 2022-04-27 17:21:28
permalink: /pages/f914c6/
categories:
  -  🧰 技术笔记
  -  🧋 JavaEE 
  -  🤖 SpringBoot
tags:
  - 
author: 
  name: Simon
  link: https://github.com/simon1uo
---


## Maven `pom.xml` 依赖分析

SpringBoot Maven 项目中的依赖：

+ 父依赖：主要是依赖一个父项目，主要是管理项目的资源过滤及插件。

  ```xml
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>2.6.7</version>
      <relativePath/> <!-- lookup parent from repository -->
  </parent>
  ```

  再深一层，还有一个父依赖：这里才是真正管理 SpringBoot 应用里面所有依赖版本的地方，**SpringBoot 的版本控制中心**：

  ```xml
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-dependencies</artifactId>
      <version>2.6.7.RELEASE</version>
      <relativePath>../../spring-boot-dependencies</relativePath>
  </parent>
  ```

  

  

+ 启动器 `spring-boot-starter` 相关依赖：

  **`springboot-boot-starter-*`**：就是 SpringBoot 的场景启动器。以 `spring-boot-starter-web` 为例，导入了web模块正常运行所依赖的组件。

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  ```

  SpringBoot 将所有的功能场景都抽取出来，做成一个个的 starter （启动器），只需要在项目中引入这些 starter 即可，所有相关的依赖都会导入进来 ， **要用什么功能就导入什么样的场景启动器即可** ；未来也可以自定义 starter。

​	

## SpringBoot 主启动类 `SpringBootApplication`

```java
// @SpringBootApplication 来标注一个主程序类
// 说明这是一个SpringBoot应用
@SpringBootApplication
public class SpringbootApplication {
   public static void main(String[] args) {
     // 启动了一个服务
      SpringApplication.run(SpringbootApplication.class, args);
   }

}
```



### **注解相关分析**

+ `@SpringBootApplication` 注解作用：标注在某个类上说明这个类是 SpringBoot 的主配置类 ， SpringBoot 就应该运行这个类的 main 方法来启动 SpringBoot 应用；

  进入 `@SpringBootApplication` 中查看：有相关的其他注解：

  ```java
  @SpringBootConfiguration
  @EnableAutoConfiguration
  @ComponentScan(
      excludeFilters = {@Filter(
      type = FilterType.CUSTOM,
      classes = {TypeExcludeFilter.class}
  ), @Filter(
      type = FilterType.CUSTOM,
      classes = {AutoConfigurationExcludeFilter.class}
  )}
  )
  public @interface SpringBootApplication {
      // ......
  }
  ```

  + `@ComponentScan`：自动扫描并加载符合条件的组件或者 bean， 将这个 bean 定义加载到 IoC 容器中。

  + `@SpringBootConfiguration` ：SpringBoot 的配置类 ，标注在某个类上 ， 表示这是一个 SpringBoot 的配置类；进入 `SpringBootConfiguration` 下查看：

    ```java
    @Configuration
    public @interface SpringBootConfiguration {}
    
    @Component
    public @interface Configuration {}
    ```

    这里就是 Spring 中已经很熟悉的 Spring 注解配置类的相关注解了。

    + `@Configuration` ： 说明这是一个配置类 ，配置类就是对应 Spring 的 xml 配置文件；
    + `@Component` ：**说明启动类本身也是 Spring 中的一个组件而已，负责启动应用**。

  + `@EnableAutoConfiguration`：**开启自动配置功能**。以前需要自己配置的东西，而现在 SpringBoot 可以自动帮我们配置； `@EnableAutoConfiguration` 告诉 SpringBoot 开启自动配置功能，这样自动配置才能生效；

    + 进入其中发现配置 `@AutoConfigurationPackage`，**自动配置包**：

      ```java
      @Import({Registrar.class})
      public @interface AutoConfigurationPackage {
      }
      ```

      `@import` ：Spring 底层注解， 给容器中导入一个组件。`Registrar.class` 作用：**将主启动类的所在包及包下面所有子包里面的所有组件扫描到 Spring 容器** ；

    + `@Import({AutoConfigurationImportSelector.class})` ：给容器导入组件，`AutoConfigurationImportSelector` ：自动配置导入选择器，进入该类查看源码，发现一下类：

      ```java
      // 获得候选的配置
      protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
          //这里的getSpringFactoriesLoaderFactoryClass（）方法
          //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration
          List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
          Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
          return configurations;
      }
      ```

      这个方法又调用了  `SpringFactoriesLoader` 类的静态方法，进入 `SpringFactoriesLoader` 类 `loadFactoryNames()`  方法：

      ```java
      public static List<String> loadFactoryNames(Class<?> factoryClass, @Nullable ClassLoader classLoader) {
          String factoryClassName = factoryClass.getName();
          //这里它又调用了 loadSpringFactories 方法
          return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
      }
      ```

      继续进入查看 `loadSpringFactories` 方法：

      … 

      发现一个多次出现的文件 `spring.factories` 。全局搜索该文件并打开大。其中发现了许多熟悉的 JavaConfig  配置类，并且注入了 Bean。



:star: 总结：

+ 自动配置真正实现是从 `classpath` 中搜寻所有的 `META-INF/spring.factories` 配置文件 ，并将其中对应的  `org.springframework.boot.autoconfigure` 包下的配置项，通过反射实例化为对应标注了 `@Configuration` 的 JavaConfig 形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到 IoC 容器中；
+ 将这些值作为自动配置类导入容器， 自动配置类就生效 ， SpringBoot 进行自动配置工作；
+ 整个 J2EE 的整体解决方案和自动配置都在 `springboot-autoconfigure` 的 `jar` 包中，它给容器中导入非常多的自动配置类 （`xxxAutoConfiguration`）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；
+ 有了自动配置类 ， 免去了手动编写配置注入功能组件等的工作；



### `SpringApplication.run` 分析

+ 该方法主要分两部分，一部分是 SpringApplication 的实例化，二是 run方法的执行；

+ `SpringApplication` 类的分析：

  1. 推断应用的类型是普通的项目还是 Web 项目；

  2. 查找并加载所有可用初始化器 ， 设置到 initializers 属性中；

  3. 找出所有的应用程序监听器，设置到 listeners 属性中；

  4. 推断并设置 main 方法的定义类，找到运行的主类；

+ `SpringApplication` 构造器分析：

  ```java
  public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
      // ......
      this.webApplicationType = WebApplicationType.deduceFromClasspath();
     this.setInitializers(this.getSpringFactoriesInstances();    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
      this.mainApplicationClass = this.deduceMainApplicationClass();
  }
  ```



+ `run` 方法流程分析： …



## `application.properties` 配置文件分析

> 根据不同的文件格式语法有所不同：
>
> - `application.properties`：
>
> - - 语法结构 ：key=value
>
> - `application.yml`：
>
> - - 语法结构 ：key：空格 value

**配置文件的作用**：修改 SpringBoot 自动配置的默认值，因为 SpringBoot 在底层已经自动配置好。



### yaml 相关语法

这种语言以数据作为中心，而不是以标记语言为重点。对比 xml 抛弃了标签的用法。

+ 基础语法：**语法要求严格**！

  + **空格不能省略**。
  + **以缩进来控制层级关系**，只要是左边对齐的一列数据都是同一个层级的。
  + **属性和值的大小写都是十分敏感的**。

+ 字面量（**普通的值：数字，布尔值，字符串**）：直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号。

  ```yaml
  key: value
  ```

  注意：

  + `“ ”` 双引号，**不会转义字符串里面的特殊字符** ， 特殊字符会作为本身想表示的意思；比如 ：`name: "kuang \n shen" ` 输出 ：`kuang  换行  shen`。
  + `''` 单引号，**会转义特殊字符** ， 特殊字符最终会变成和普通字符一样输出。比如 ：`name: ‘kuang \n shen’`  输出 ：`kuang  \n  shen`。

+ 对象、Map （键值对）：

  ```yaml
  student:
      name: qinjiang
      age: 3
  ```

  注意缩进以确定键与值的关系。

  行内写法：

  ```yaml
  student: {name: qinjiang,age: 3}
  ```

+ 数组（ List、set ）：使用 `-` 表示一个元素：

  ```yaml
  pets:
   - cat
   - dog
   - pig
  ```

  行内写法： `pets: [cat,dog,pig]`。



#### yaml 注入配置文件

🌰 编写一个复杂的实体类：
```java
@Component //注册bean到容器中
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;
    
    // ... 有参无参构造、get、set方法、toString()方法  
}
```

使用 yaml 配置的方式注入属性：

```yaml
person:
  name: qinjiang
  age: 3
  happy: false
  birth: 2000/01/01
  maps: {k1: v1,k2: v2}
  lists:
   - code
   - girl
   - music
  dog:
    name: 旺财
    age: 1
```

在实体类上添加一个注解 `@ConfigurationProperties(prefix = "person")` ：

+ 作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置**进行绑定**参数 `prefix = “person”` ：将配置文件中的 `person`下面的所有属性一一对应。

+ 在此之前需要在 Maven 添加配置注解处理器的依赖：

  ```xml
  <!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
  </dependency>
  ```

  

#### 加载指定的配置文件

`@PropertySource` ：**加载指定的配置文件**；

`@configurationProperties`：默认从**全局配置文件**中获取值；



🌰 例如，上述的例子指定注入的配置文件：

+ 在 resources 目录下新建一个 `person.properties` 文件。

+ 在原来的实体类中使用 `@PropertySource` 注解：

  ```java
  @PropertySource(value = "classpath:person.properties")
  @Component //注册bean
  public class Person {
  
      @Value("${name}")
      private String name;
  
      ......  
  }
  ```

  



#### yaml 配置文件占位符

在配置文件中可以编写占位符生成随机数

```yaml
person:
    name: qinjiang${random.uuid} # 随机uuid
    age: ${random.int}  # 随机int
```



### properties 配置相关

为了防止 `.properties` 相关的文件因为其中有中文而引起乱码，在 IDEA 的 File Encoding 中配置格式：

![image-20220427211929698](https://cdn.jsdelivr.net/gh/simon1uo/image-flow@master/image/1eNYk3.png)



#### properties 注入配置文件

在此前 Spring 中使用完全注解开发中，JDBC 连接数据库使用过读取配置文件的数据，同理。

+ 实体类 `User`：

  ```java
  @Component //注册bean
  public class User {
      private String name;
      private int age;
      private String sex;
  }
  ```

+ 配置文件 `user.properties` ：

  ```properties
  user1.name=kuangshen
  user1.age=18
  user1.sex=男
  ```

+ 在 `User` 中使用 `@Value` 完成属性注入：

  ```java
  @Component //注册bean
  @PropertySource(value = "classpath:user.properties")
  public class User {
      //直接使用@value
      @Value("${user.name}") //从配置文件中取值
      private String name;
      @Value("#{9*2}")  // #{SPEL} Spring表达式
      private int age;
      @Value("男")  // 字面量
      private String sex;
  }
  ```

+ `@SpringBootTest` 测试：

  ```java
  @SpringBootTest
  class DemoApplicationTests {
  
      @Autowired
      User user;
  
      @Test
      public void contextLoads() {
          System.out.println(user);
      }
  
  }
  ```

  



### 总结

+ yaml 与 properties 两种注入方式对比，使用 `@ConfigurationProperties` 只需要写一次即可 ， `@Value` 则需要每个字段都添加。
+ yaml 中遵循松散绑定。例如 yml 中写的 `last-name`，与 `lastName` 等价， `-` **后面跟着的字母默认是大写的**。
+ JSR303 数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性。
+ 复杂类型封装，yml 中可以封装对象 ， 使用 properties 的 `@value` 注入就不支持。



所以，yaml 与 properties 对比，yaml 可以自动一一映射属性，优选 yaml。



## 数据校验

SpringBoot 中可以使用 `@validated` 校验数据，**如果数据异常则会统一抛出异常，方便异常中心统一处理。**我们这里来写个注解让我们的 `name` 只能支持 Email 格式：

```java
@Component //注册bean
@ConfigurationProperties(prefix = "person")
@Validated  //数据校验
public class Person {

    @Email(message="邮箱格式错误") //name必须是邮箱格式
    private String eamil;
}
```



数据校验的常用参数：

🌰：

```java
@NotNull(message="名字不能为空")
private String userName;
@Max(value=120,message="年龄最大不能查过120")
private int age;
@Email(message="邮箱格式错误")
private String email;
```



```java
// 空检查
@Null       // 验证对象是否为null
@NotNull    // 验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank   // 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty   // 检查约束元素是否为NULL或者是EMPTY.
    
// Booelan检查
@AssertTrue     // 验证 Boolean 对象是否为 true  
@AssertFalse    // 验证 Boolean 对象是否为 false  
    
长度检查
@Size(min=, max=) // 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  
@Length(min=, max=) // 验证字符串长度是否在给定的范围之类

日期检查
@Past       // 验证 Date 和 Calendar 对象是否在当前时间之前  
@Future     // 验证 Date 和 Calendar 对象是否在当前时间之后  
@Pattern    // 验证 String 对象是否符合正则表达式的规则
```



## 多环境切换

`profile` 是 Spring **对不同环境提供不同配置功能的支持**，可以通过激活不同的环境版本，实现快速切换环境；

### 多配置文件

在主配置文件编写的时候，文件名可以是 `application-{profile}.properties/yml` ，**用来指定多个环境版本**；

🌰 **例如：**

+ `application-test.properties` 代表**测试环境配置**。

+ `application-dev.properties` 代表**开发环境配置**。

但是 Springboot 并不会直接启动这些配置文件，它**默认使用 `application.properties` 主配置文件**；所以需要通过一个配置来选择需要激活的环境：

🌰 使用 `properties` 配置的例子：在配置文件中指定使用 **dev** 环境，可以通过设置不同的端口号进行测试；启动 SpringBoot，就可以看到已经切换到 **dev**下的配置了；

```properties
spring.profiles.active=dev
```

🌰 使用 `yml` 配置文件的例子：可以不用切换多个文件，直接在一个文件中切换开发环境：

```yml
server:
  port: 8081

spring:
  profiles:
    active: prod #选择要激活那个环境块

---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: prod  #配置环境的名称
```



⚠️ **注意：如果 yml 和 properties 同时都配置了端口，并且没有激活其他环境 ， 默认会使用 properties 配置文件的！**



### 外部加载配置文件

**外部加载配置文件的方式十分多，选择最常用的即可，在开发的资源文件中进行配置！**

SpringBoot 启动会扫描以下位置的 `application.properties`或者`application.yml` 文件作为 SpringBoot 的默认配置文件。

扫描配置文件的优先级，由高到低，高优先级的配置会覆盖低优先级的配置：**SpringBoot会从这四个位置全部加载主配置文件，互补配置。**

+ 优先级1：项目路径下的 config 文件夹配置文件
+ 优先级2：项目路径下配置文件
+ 优先级3：资源路径下的 config 文件夹配置文件
+ 优先级4：**资源路径下配置文件**

### 运维技巧

项目打包好以后，可以使用命令行参数的形式，**启动项目的时候来指定配置文件的新位置**；这种情况，一般是后期运维做的多，相同配置，**外部指定的配置文件优先级最高**。



🌰 例如：
```
java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
```



## 自动配置原理

